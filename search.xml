<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Canal</title>
    <url>/2022/06/11/Canal/</url>
    <content><![CDATA[<h2 id="什么是Canal"><a href="#什么是Canal" class="headerlink" title="什么是Canal"></a>什么是Canal</h2><p>canal译意为水道&#x2F;管道&#x2F;沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。<br>从这句话理解到了什么？<br>基于MySQL，并且通过MySQL日志进行的增量解析，这也就意味着对原有的业务代码完全是无侵入性的。</p>
<span id="more"></span>
<p><strong>工作原理</strong>：解析MySQL的binlog日志，提供增量数据。</p>
<h2 id="Canal能做什么"><a href="#Canal能做什么" class="headerlink" title="Canal能做什么"></a>Canal能做什么</h2><p>基于日志增量订阅和消费的业务包括</p>
<ul>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护(拆分异构索引、倒排索引等)</li>
<li>业务 cache 刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ul>
<p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。<br>官方文档：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h2 id="Canal数据如何传输？"><a href="#Canal数据如何传输？" class="headerlink" title="Canal数据如何传输？"></a>Canal数据如何传输？</h2><p>先来一张官方图：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650355686553-164622a0-3c7c-4356-82f8-3778ee9975a6.png#averageHue=%23f3f2f2&clientId=ub5d898f2-92c2-4&from=paste&id=ub5e1132e&originHeight=569&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua4319a32-b052-48db-a60d-bc7965ab4c2&title="><br>Canal分为服务端和客户端，这也是阿里常用的套路：</p>
<ul>
<li>服务端：负责解析MySQL的binlog日志，传递增量数据给客户端或者消息中间件</li>
<li>客户端：负责解析服务端传过来的数据，然后定制自己的业务处理。</li>
</ul>
<p>目前为止支持的消息中间件很全面了，比如Kafka、RocketMQ，RabbitMQ。</p>
<h2 id="数据同步还有其他中间件吗？"><a href="#数据同步还有其他中间件吗？" class="headerlink" title="数据同步还有其他中间件吗？"></a>数据同步还有其他中间件吗？</h2><p>有，当然有，还有一些开源的中间件也是相当不错的，比如Bifrost。<br>常见的几款中间件的区别如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/jpeg/25873401/1650355699488-47931f43-dbf5-4368-94c1-4c0df391ca21.jpeg#averageHue=%23e78379&clientId=ub5d898f2-92c2-4&from=paste&id=u0c2ffed1&originHeight=265&originWidth=640&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4e2a647e-3eb9-4b25-ac5c-8ed1645131d&title="><br>当然要我选择的话，首选阿里的中间件Canal。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Canal的实战，集成到SpringBoot"><a href="#Canal的实战，集成到SpringBoot" class="headerlink" title="Canal的实战，集成到SpringBoot"></a>Canal的实战，集成到SpringBoot</h2><h3 id="Canal服务端安装"><a href="#Canal服务端安装" class="headerlink" title="Canal服务端安装"></a>Canal服务端安装</h3><p>服务端需要下载压缩包，下载地址：<a href="https://github.com/alibaba/canal/releases">https://github.com/alibaba/canal/releases</a><br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356266972-8003453b-8323-4e12-85a7-4af4f9de6e64.png#averageHue=%23fefdfd&clientId=ub5d898f2-92c2-4&from=paste&height=858&id=uc284655e&name=image.png&originHeight=858&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87200&status=done&style=none&taskId=u56ed93ae-9eb9-4a89-a9d3-10c32925cfe&title=&width=867" alt="image.png"><br>下载稳定版本v1.1.5<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356447084-372caebe-0c97-466d-820b-e231d9421234.png#averageHue=%23fefaf9&clientId=ub5d898f2-92c2-4&from=paste&height=326&id=u7de74c62&name=image.png&originHeight=326&originWidth=863&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26771&status=done&style=none&taskId=ub0e23bb0-04b7-4b3c-bc70-ae83c9bc074&title=&width=863" alt="image.png"><br>下载完成解压，目录如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356460373-1b23ca59-a31d-4651-8c65-6457e88c3399.png#averageHue=%23fefdfd&clientId=ub5d898f2-92c2-4&from=paste&id=ubfec025c&originHeight=223&originWidth=985&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8473ca90-4285-446d-8011-ee8cb593e37&title="><br>本文使用<strong>Canal+RabbitMQ</strong>进行数据的同步，因此下面步骤完全按照这个base进行。</p>
<h3 id="打开MySQL的binlog日志"><a href="#打开MySQL的binlog日志" class="headerlink" title="打开MySQL的binlog日志"></a>打开MySQL的binlog日志</h3><p>请参考<a href="https://www.yuque.com/u25495771/yqh657/cv1548">https://www.yuque.com/u25495771/yqh657/cv1548</a></p>
<h3 id="设置MySQL的配置"><a href="#设置MySQL的配置" class="headerlink" title="设置MySQL的配置"></a>设置MySQL的配置</h3><p>需要设置服务端配置文件中的MySQL配置，这样Canal才能知道需要监听哪个库、哪个表的日志文件。<br>一个 Server 可以配置多个实例监听 ，Canal 功能默认自带的有个 example 实例，本篇就用 example 实例 。如果增加实例，复制 example 文件夹内容到同级目录下，然后在 canal.properties 指定添加实例的名称。<br>修改canal.deployer-1.1.5\conf\example\instance.properties配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># url</span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line"># username/password</span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=root</span><br><span class="line"># 监听的数据库</span><br><span class="line">canal.instance.defaultDatabaseName=test</span><br><span class="line"></span><br><span class="line"># 监听的表，可以指定，多个用逗号分割，这里正则是监听所有</span><br><span class="line">canal.instance.filter.regex=.*\\..*</span><br></pre></td></tr></table></figure>
<h3 id="设置RabbitMQ的配置"><a href="#设置RabbitMQ的配置" class="headerlink" title="设置RabbitMQ的配置"></a>设置RabbitMQ的配置</h3><p>服务端默认的传输方式是tcp，需要在配置文件中设置MQ的相关信息。<br>这里需要修改两处配置文件，如下；</p>
<ol>
<li>canal.deployer-1.1.5\conf\canal.properties</li>
</ol>
<p>这个配置文件主要是设置MQ相关的配置，比如URL，用户名、密码…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 传输方式：tcp, kafka, rocketMQ, rabbitMQ</span><br><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line">##################################################</span><br><span class="line">######### 		RabbitMQ	 #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host = 127.0.0.1</span><br><span class="line">rabbitmq.virtual.host =/</span><br><span class="line"># exchange</span><br><span class="line">rabbitmq.exchange =canal.exchange</span><br><span class="line"># 用户名、密码</span><br><span class="line">rabbitmq.username =guest</span><br><span class="line">rabbitmq.password =guest</span><br><span class="line">## 是否持久化</span><br><span class="line">rabbitmq.deliveryMode = 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>canal.deployer-1.1.5\conf\example\instance.properties</li>
</ol>
<p>这个文件设置MQ的路由KEY，这样才能路由到指定的队列中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canal.mq.topic=canal.routing.key</span><br></pre></td></tr></table></figure>
<h3 id="RabbitMQ新建exchange和Queue"><a href="#RabbitMQ新建exchange和Queue" class="headerlink" title="RabbitMQ新建exchange和Queue"></a>RabbitMQ新建exchange和Queue</h3><p>在RabbitMQ中需要新建一个canal.exchange（必须和配置中的相同）的exchange和一个名称为 canal.queue（名称随意）的队列。<br>其中绑定的路由KEY为：canal.routing.key（必须和配置中的相同），如下图：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356683237-bd7aa4dd-0249-4367-a4f1-d18fd642b151.png#averageHue=%23f8f7f7&clientId=ue7f6981a-5aa6-4&from=paste&id=u84bc14bb&originHeight=242&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub5a2273f-91e8-454f-82f8-f436dcbfb34&title="></p>
<h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>点击bin目录下的脚本，windows直接双击startup.bat，启动成功如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356701506-8b6915b7-a13c-4bf4-b2b8-be891699bd1a.png#averageHue=%232e2c2a&clientId=ue7f6981a-5aa6-4&from=paste&id=uc58fbd70&originHeight=315&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u899d291e-03ac-4e87-9905-4a09ece2ef3&title="></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在本地数据库test中的oauth_client_details插入一条数据，如下：<br>INSERT INTO <code>oauth_client_details</code> VALUES (‘myjszl’, ‘res1’, ‘$2a$10$F1tQdeb0SEMdtjlO8X&#x2F;0wO6Gqybu6vPC&#x2F;Xg8OmP9&#x2F;TL1i4beXdK9W’, ‘all’, ‘password,refresh_token,authorization_code,client_credentials,implicit’, ‘<a href="http://www.baidu.com/">http://www.baidu.com</a>‘, NULL, 1000, 1000, NULL, ‘false’);</p>
<p>此时查看MQ中的canal.queue已经有了数据，如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356727749-58f14d0b-4d67-4390-b426-8c4f12bda6a6.png#averageHue=%23fcfcfc&clientId=ue7f6981a-5aa6-4&from=paste&id=u20a8b6dd&originHeight=164&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucc2b654f-0461-4176-96b2-09bb8aae423&title=">其实就是一串JSON数据，这个JSON如下：<br>{<br> “data”: [{<br>  “client_id”: “myjszl”,<br>  “resource_ids”: “res1”,<br>  “client_secret”: “$2a$10$F1tQdeb0SEMdtjlO8X&#x2F;0wO6Gqybu6vPC&#x2F;Xg8OmP9&#x2F;TL1i4beXdK9W”,<br>  “scope”: “all”,<br>  “authorized_grant_types”: “password,refresh_token,authorization_code,client_credentials,implicit”,<br>  “web_server_redirect_uri”: “<a href="http://www.baidu.com/">http://www.baidu.com</a>“,<br>  “authorities”: null,<br>  “access_token_validity”: “1000”,<br>  “refresh_token_validity”: “1000”,<br>  “additional_information”: null,<br>  “autoapprove”: “false”<br> }],<br> “database”: “test”,<br> “es”: 1640337532000,<br> “id”: 7,<br> “isDdl”: false,<br> “mysqlType”: {<br>  “client_id”: “varchar(48)”,<br>  “resource_ids”: “varchar(256)”,<br>  “client_secret”: “varchar(256)”,<br>  “scope”: “varchar(256)”,<br>  “authorized_grant_types”: “varchar(256)”,<br>  “web_server_redirect_uri”: “varchar(256)”,<br>  “authorities”: “varchar(256)”,<br>  “access_token_validity”: “int(11)”,<br>  “refresh_token_validity”: “int(11)”,<br>  “additional_information”: “varchar(4096)”,<br>  “autoapprove”: “varchar(256)”<br> },<br> “old”: null,<br> “pkNames”: [“client_id”],<br> “sql”: “”,<br> “sqlType”: {<br>  “client_id”: 12,<br>  “resource_ids”: 12,<br>  “client_secret”: 12,<br>  “scope”: 12,<br>  “authorized_grant_types”: 12,<br>  “web_server_redirect_uri”: 12,<br>  “authorities”: 12,<br>  “access_token_validity”: 4,<br>  “refresh_token_validity”: 4,<br>  “additional_information”: 12,<br>  “autoapprove”: 12<br> },<br> “table”: “oauth_client_details”,<br> “ts”: 1640337532520,<br> “type”: “INSERT”<br>}</p>
<p>每个字段的意思已经很清楚了，有表名称、方法、参数、参数类型、参数值…..<br>客户端要做的就是监听MQ获取JSON数据，然后将其解析出来，处理自己的业务逻辑。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>打开IDEA创建项目canal-toos<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650357369053-2135bca0-7417-422d-a9ae-23ced9f4a203.png#averageHue=%233d4143&clientId=ue7f6981a-5aa6-4&from=paste&height=779&id=u1ae9689a&name=image.png&originHeight=779&originWidth=818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63356&status=done&style=none&taskId=uea85711c-4dbe-4e2d-9f1a-6889877ef0a&title=&width=818" alt="image.png"><br>引用POM文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!-- Mybatis plus代码生产插件 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- Mybatisplus代码生成模板 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- Mybatis基础依赖 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--mybatisplus 依赖插件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--mysql依赖插件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.38&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">   &lt;!-- rabbitmq 服务调用依赖 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- jackosn基础依赖 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.9&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="创建消息实体类"><a href="#创建消息实体类" class="headerlink" title="创建消息实体类"></a>创建消息实体类</h3><p>MQ传递过来的是JSON数据，当然要创建个实体类接收数据，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Canal消息接收实体类</span><br><span class="line"> */</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class CanalMessage&lt;T&gt; &#123;</span><br><span class="line">    @JsonProperty(&quot;type&quot;)</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;table&quot;)</span><br><span class="line">    private String table;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;data&quot;)</span><br><span class="line">    private List&lt;T&gt; data;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;database&quot;)</span><br><span class="line">    private String database;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;es&quot;)</span><br><span class="line">    private Long es;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;id&quot;)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;isDdl&quot;)</span><br><span class="line">    private Boolean isDdl;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;old&quot;)</span><br><span class="line">    private List&lt;T&gt; old;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;pkNames&quot;)</span><br><span class="line">    private List&lt;String&gt; pkNames;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;sql&quot;)</span><br><span class="line">    private String sql;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;ts&quot;)</span><br><span class="line">    private Long ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加RabbitMQ消费端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cn.hutool.json.JSONUtil;</span><br><span class="line">import cn.myjszl.middle.ware.canal.mq.rabbit.model.CanalMessage;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 监听MQ获取Canal增量的数据消息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class CanalRabbitMQListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings = &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value = @Queue(value = &quot;canal.queue&quot;, durable = &quot;true&quot;),</span><br><span class="line">                    exchange = @Exchange(value = &quot;canal.exchange&quot;),</span><br><span class="line">                    key = &quot;canal.routing.key&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void handleDataChange(String message) &#123;</span><br><span class="line">        //将message转换为CanalMessage</span><br><span class="line">        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class);</span><br><span class="line">        String tableName = canalMessage.getTable();</span><br><span class="line">        log.info(&quot;Canal 监听 &#123;&#125; 发生变化；明细：&#123;&#125;&quot;, tableName, message);</span><br><span class="line">        String tableName =canalMessage.getTable();</span><br><span class="line">        if (canalMessage.getData()!=null)&#123;</span><br><span class="line">                for (int i=0;i&lt;canalMessage.getData().size();i++ ) &#123;</span><br><span class="line">                Map&lt;String,Object&gt; map= mapper.readValue(canalMessage.getData().get(i).toString(),Map.class);</span><br><span class="line"></span><br><span class="line">                if (canalMessage.getType().contains(&quot;INSERT&quot;))&#123;</span><br><span class="line">                    sava(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (canalMessage.getType().contains(&quot;UPDATE&quot;))&#123;</span><br><span class="line">                    update(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (canalMessage.getType().contains(&quot;DELETE&quot;))&#123;</span><br><span class="line">                    delect(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public  String underlineToHump(String str) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(str))&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //正则匹配下划线及后一个字符，删除下划线并将匹配的字符转成大写</span><br><span class="line">        Matcher matcher = UNDERLINE_PATTERN.matcher(str);</span><br><span class="line">        StringBuffer sb = new StringBuffer(str);</span><br><span class="line">        if (matcher.find()) &#123;</span><br><span class="line">            sb = new StringBuffer();</span><br><span class="line">            //将当前匹配的子串替换成指定字符串，并且将替换后的子串及之前到上次匹配的子串之后的字符串添加到StringBuffer对象中</span><br><span class="line">            //正则之前的字符和被替换的字符</span><br><span class="line">            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());</span><br><span class="line">            //把之后的字符串也添加到StringBuffer对象中</span><br><span class="line">            matcher.appendTail(sb);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //去除除字母之外的前面带的下划线</span><br><span class="line">            return sb.toString().replaceAll(&quot;_&quot;, &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return underlineToHump(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    public void sava(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line">        Object tableObjet = tableClass.newInstance();</span><br><span class="line">        for (String key :oldTable.keySet())&#123;</span><br><span class="line">            Method[] methods =  tableObjet.getClass().getMethods();</span><br><span class="line">            Object mapValue=oldTable.get(key);</span><br><span class="line"></span><br><span class="line">            String methodName = underlineToHump(&quot;set&quot;+upperFirstCase(key.toLowerCase()));</span><br><span class="line">            for (Method method:methods)&#123;</span><br><span class="line">                if (method.getName().equals(methodName))&#123;</span><br><span class="line">                    if (method.getParameterTypes()[0].equals(String.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            mapValue =&quot; &quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, mapValue.toString());</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Date.class)|| method.getParameterTypes()[0].equals(LocalDateTime.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                        method.invoke(tableObjet, LocalDateTime.parse(mapValue.toString(),formatter));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Integer.class)||method.getParameterTypes()[0].equals(int.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Integer.parseInt(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Long.class)||method.getParameterTypes()[0].equals(long.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Long.parseLong(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Double.class)||method.getParameterTypes()[0].equals(double.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Double.parseDouble(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Boolean.class)||method.getParameterTypes()[0].equals(boolean.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Boolean.parseBoolean(mapValue.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Object pojo = mapper.readValue(mapper.writeValueAsString(oldTable), tableClass.getClass());</span><br><span class="line"></span><br><span class="line">        String newTable= lowerFirstCase(tableName+&quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line"></span><br><span class="line">        service.save(tableObjet);</span><br><span class="line">    &#125;</span><br><span class="line">        public void update(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, IOException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException &#123;</span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line">        Object tableObjet = tableClass.newInstance();</span><br><span class="line">        for (String key :oldTable.keySet()) &#123;</span><br><span class="line">            Method[] methods = tableObjet.getClass().getMethods();</span><br><span class="line">            Object mapValue = oldTable.get(key);</span><br><span class="line">            if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String methodName = underlineToHump(&quot;set&quot; + upperFirstCase(key.toLowerCase()));</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                if (method.getName().equals(methodName)) &#123;</span><br><span class="line">                    if (method.getParameterTypes()[0].equals(String.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, mapValue.toString());</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Date.class) || method.getParameterTypes()[0].equals(LocalDateTime.class)) &#123;</span><br><span class="line">                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                        method.invoke(tableObjet, LocalDateTime.parse(mapValue.toString(), formatter));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Integer.class) || method.getParameterTypes()[0].equals(int.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Integer.parseInt(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Long.class) || method.getParameterTypes()[0].equals(long.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Long.parseLong(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Double.class) || method.getParameterTypes()[0].equals(double.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Double.parseDouble(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Boolean.class) || method.getParameterTypes()[0].equals(boolean.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Boolean.parseBoolean(mapValue.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    //method.invoke(tableObjet,oldTable.get(key));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newTable = lowerFirstCase(tableName + &quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line">        service.updateById(tableObjet);</span><br><span class="line">    &#125;</span><br><span class="line">    public void delect(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, IOException &#123;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line"></span><br><span class="line">        QueryWrapper wrapper = new QueryWrapper();</span><br><span class="line">        wrapper.eq(&quot;ID&quot;,oldTable.get(&quot;ID&quot;));</span><br><span class="line">        String newTable= lowerFirstCase(tableName+&quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line">        service.remove(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>springboot</tag>
        <tag>canal</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>安装RabbitMQ</title>
    <url>/2022/01/11/%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h2 id="参照官网："><a href="#参照官网：" class="headerlink" title="参照官网："></a>参照官网：</h2><p><a href="https://www.rabbitmq.com/install-rpm.html#package-cloud">https://www.rabbitmq.com/install-rpm.html#package-cloud</a></p>
<span id="more"></span>
<h2 id="添加yum存储库信息"><a href="#添加yum存储库信息" class="headerlink" title="添加yum存储库信息"></a>添加yum存储库信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">touch rabbitmq.repo</span><br><span class="line">vi rabbitmq.repo</span><br></pre></td></tr></table></figure>
<p>rabbitmq.repo中添加文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#In /etc/yum.repos.d/rabbitmq.repo</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## Zero dependency Erlang</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq_erlang</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[rabbitmq_server]</span><br><span class="line">name=rabbitmq_server</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h2><p>使用命令：yum install rabbitmq-server</p>
<p>最后修改一直选y<br>将会自动下载安装对应的<a href="https://so.csdn.net/so/search?q=erlang&spm=1001.2101.3001.7020">erlang</a>版本、rabbitmq版本、keys等。<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644656259455-3fe11f75-b3a3-40b7-92ae-521df1e6b76c.png#clientId=u99af809c-8097-4&from=paste&height=529&id=ubb7d3f11&name=image.png&originHeight=529&originWidth=1887&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73715&status=done&style=none&taskId=u5df5f38f-98fd-4151-826f-39030d372c6&title=&width=1887" alt="image.png"></p>
<h2 id="修改登录拦截"><a href="#修改登录拦截" class="headerlink" title="修改登录拦截"></a>修改登录拦截</h2><p>rabbitmq 3.3.0开始禁用除localhost外的地址采取guest登录，所以此处需要将拦截去除。<br>找到安装目录<br>vi rabbit.app<br>将其中loopback_users, [&lt;&lt;”guest”&gt;&gt;]字段中的数据修改成下列方式：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659808980-04bf71e4-c7ae-4346-8be6-47d62ebd8a85.png#clientId=u99af809c-8097-4&from=paste&id=ub3d16f82&name=image.png&originHeight=563&originWidth=501&originalType=url&ratio=1&rotation=0&showTitle=false&size=46996&status=done&style=none&taskId=u28d72f30-d720-4c4c-a149-eb0933f0eaa&title=" alt="image.png"></p>
<h2 id="启动rabbitmq"><a href="#启动rabbitmq" class="headerlink" title="启动rabbitmq"></a>启动rabbitmq</h2><p>service rabbitmq-server start</p>
<h2 id="开启图形化"><a href="#开启图形化" class="headerlink" title="开启图形化"></a>开启图形化</h2><p>rabbitmq-plugins enable rabbitmq_management<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659826635-8d068b00-e708-46c4-bd51-2e4b9f9e86dd.png#clientId=u99af809c-8097-4&from=paste&id=u225e2c08&name=image.png&originHeight=186&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&size=19642&status=done&style=none&taskId=u9402a1a4-793f-49ae-8461-428aa7895c5&title=" alt="image.png"></p>
<h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><p>rabbitmqctl status</p>
<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><p>使用命令rabbitmqctl add_user username password进行添加新用户。<br>rabbitmqctl add_user xiangjiao bunana<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659924599-bc6befcb-314f-48c0-aaf1-12ede71381d9.png#clientId=u99af809c-8097-4&from=paste&id=ub67c24ee&name=image.png&originHeight=45&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&size=8623&status=done&style=none&taskId=uc663062d-0c58-4570-ad64-e364a76c652&title=" alt="image.png"></p>
<h2 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h2><p>使用命令rabbitmqctl set_user_tags username administrator设置用户tag。<br>rabbitmqctl set_user_tags xiangjiao administrator<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659930697-fc18293d-a7cb-42b9-86a0-9f001f700899.png#clientId=u99af809c-8097-4&from=paste&id=u9bac882c&name=image.png&originHeight=27&originWidth=669&originalType=url&ratio=1&rotation=0&showTitle=false&size=4718&status=done&style=none&taskId=u396a0295-cbf2-4cc0-92a4-f1308d063cb&title=" alt="image.png"></p>
<h1 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659937730-5b420d6a-2d54-4b74-a5d8-1714df1188f0.png#clientId=u99af809c-8097-4&from=paste&id=u26e58c6c&name=image.png&originHeight=253&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&size=16836&status=done&style=none&taskId=u93fc0373-469d-436c-a3ea-67a98f50a61&title=" alt="image.png"></p>
<p> <img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659947739-f1582562-2b4e-48ce-8ee5-e63aa60ddba1.png#clientId=u99af809c-8097-4&from=paste&id=u90593ccb&name=image.png&originHeight=740&originWidth=1457&originalType=url&ratio=1&rotation=0&showTitle=false&size=67428&status=done&style=none&taskId=uc63ffb4a-3243-4c60-9c35-1f499430c7f&title=" alt="image.png"></p>
<h1 id="命令拓展"><a href="#命令拓展" class="headerlink" title="命令拓展"></a>命令拓展</h1><h2 id="卸载rabbitmq"><a href="#卸载rabbitmq" class="headerlink" title="卸载rabbitmq"></a>卸载rabbitmq</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–卸载</span><br><span class="line">–停止服务</span><br><span class="line">rabbitmqctl app_stop</span><br><span class="line">yum list | grep rabbitmq</span><br><span class="line">yum -y remove rabbitmq-server.noarch</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="卸载erlang支持"><a href="#卸载erlang支持" class="headerlink" title="卸载erlang支持"></a>卸载erlang支持</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list | grep erlang</span><br><span class="line">yum -y remove erlang-*</span><br><span class="line">yum remove erlang.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig rabbitmq-server on # 添加开机启动RabbitMQ服务</span><br><span class="line">/sbin/service rabbitmq-server start # 启动服务</span><br><span class="line">/sbin/service rabbitmq-server status # 查看服务状态</span><br><span class="line">/sbin/service rabbitmq-server stop # 停止服务</span><br><span class="line">rabbitmqctl list_users #查看用户列表信息和权限信息</span><br><span class="line">rabbitmqctl list_user_permissions xxxxx #查看指定用户的权限信息</span><br><span class="line">rabbitmqctl delete_user guest #删除guest用户</span><br><span class="line">rabbitmqctl add_user username password #添加新用户</span><br><span class="line">rabbitmqctl set_user_tags username administrator #设置用户tag</span><br><span class="line">rabbitmqctl set_permissions -p / username “.&quot; &quot;.” “.*” #赋予用户默认vhost的全部操作权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义用户信息</title>
    <url>/2024/03/11/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在集成Oauth2.1认证中心，采用默认的数据结构实现了认证，但是大部分时候默认的用户结构并不能满足生产的需要，所以接下来以RBAC权限设计来实现用户</p>
<span id="more"></span>
<h2 id="基于RBAC的权限设计"><a href="#基于RBAC的权限设计" class="headerlink" title="基于RBAC的权限设计"></a>基于RBAC的权限设计</h2><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE system_user(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36)    COMMENT &#x27;租户号&#x27; ,</span><br><span class="line">    USER_ID VARCHAR(36) NOT NULL   COMMENT &#x27;用户编号&#x27; ,</span><br><span class="line">    DEPT_ID VARCHAR(36)    COMMENT &#x27;部门编号&#x27; ,</span><br><span class="line">    USER_NAME VARCHAR(100) NOT NULL   COMMENT &#x27;用户账号&#x27; ,</span><br><span class="line">    NICK_NAME VARCHAR(100)    COMMENT &#x27;用户昵称&#x27; ,</span><br><span class="line">    EMAIL VARCHAR(100)    COMMENT &#x27;用户邮箱&#x27; ,</span><br><span class="line">    PHONE_NUMBER VARCHAR(100)    COMMENT &#x27;用户手机号&#x27; ,</span><br><span class="line">    SEX INT    COMMENT &#x27;性别&#x27; ,</span><br><span class="line">    AVATAR VARCHAR(100)    COMMENT &#x27;头像地址&#x27; ,</span><br><span class="line">    PASSWORD VARCHAR(100) NOT NULL   COMMENT &#x27;密码&#x27; ,</span><br><span class="line">    STATUS INT NOT NULL   COMMENT &#x27;用户状态&#x27; ,</span><br><span class="line">    DEL_FLAG INT NOT NULL   COMMENT &#x27;删除标志（0代表存在 2代表删除）&#x27; ,</span><br><span class="line">    REVISION INT NOT NULL  COMMENT &#x27;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(100)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(100)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户表&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE system_role(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36)    COMMENT &#x27;角色编号;角色编号&#x27; ,</span><br><span class="line">    ROLE_NAME VARCHAR(100)    COMMENT &#x27;角色名称;角色名称&#x27; ,</span><br><span class="line">    ROLE_KEY VARCHAR(100)    COMMENT &#x27;角色权限字符串;角色权限字符串&#x27; ,</span><br><span class="line">    ROLE_SORT INT    COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    DATA_SCOPE VARCHAR(100)    COMMENT &#x27;数据范围;数据范围（1：全部数据权限 2：自定数据权限 3：本部门数据权限 4：本部门及以下数据权限）&#x27; ,</span><br><span class="line">    MENU_CHECK_STRICTLY VARCHAR(1)    COMMENT &#x27;菜单树选择项是否关联显示;菜单树选择项是否关联显示&#x27; ,</span><br><span class="line">    DEPT_CHECK_STRICTLY VARCHAR(1)    COMMENT &#x27;部门树选择项是否关联显示;部门树选择项是否关联显示&#x27; ,</span><br><span class="line">    STATUS VARCHAR(1)    COMMENT &#x27;角色状态（0正常 1停用）;角色状态（0正常 1停用）&#x27; ,</span><br><span class="line">    DEL_FLAG VARCHAR(1)    COMMENT &#x27;删除标志（0代表存在 2代表删除）;删除标志（0代表存在 2代表删除）&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36)    COMMENT &#x27;租户号;租户号&#x27; ,</span><br><span class="line">    REVISION INT  NOT NULL    COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(36)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(36)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_menu(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID&#x27; ,</span><br><span class="line">    MENU_ID VARCHAR(36) NOT NULL   COMMENT &#x27;菜单编号;菜单编号&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36) NOT NULL   COMMENT &#x27;租户号;租户号&#x27; ,</span><br><span class="line">    MENU_NAME VARCHAR(100) NOT NULL   COMMENT &#x27;菜单名称;菜单名称&#x27; ,</span><br><span class="line">    PARENT_ID VARCHAR(36)    COMMENT &#x27;父菜单ID;父菜单ID&#x27; ,</span><br><span class="line">    ORDER_NUM INT    COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    PATH VARCHAR(100)    COMMENT &#x27;路由地址;路由地址&#x27; ,</span><br><span class="line">    COMPONENT VARCHAR(100)    COMMENT &#x27;组件路径;组件路径&#x27; ,</span><br><span class="line">    QUERY VARCHAR(100)    COMMENT &#x27;路由参数;路由参数&#x27; ,</span><br><span class="line">    IS_FRAME VARCHAR(1)    COMMENT &#x27;是否为外链（0是 1否）;是否为外链（0是 1否）&#x27; ,</span><br><span class="line">    IS_CACHE VARCHAR(1)    COMMENT &#x27;是否缓存（0缓存 1不缓存）;是否缓存（0缓存 1不缓存）&#x27; ,</span><br><span class="line">    MENU_TYPE VARCHAR(32)    COMMENT &#x27;菜单类型（M目录 C菜单 F按钮）;菜单类型（M目录 C菜单 F按钮）&#x27; ,</span><br><span class="line">    VISIBLE VARCHAR(100)    COMMENT &#x27;菜单状态（0显示 1隐藏）;菜单状态（0显示 1隐藏）&#x27; ,</span><br><span class="line">    STATUS VARCHAR(100)    COMMENT &#x27;菜单状态（0正常 1停用）;菜单状态（0正常 1停用）&#x27; ,</span><br><span class="line">    PERMS VARCHAR(100)    COMMENT &#x27;权限标识;权限标识&#x27; ,</span><br><span class="line">    ICON VARCHAR(100)    COMMENT &#x27;菜单图标;菜单图标&#x27; ,</span><br><span class="line">    REVISION INT NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(100)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(100)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID,MENU_ID)</span><br><span class="line">)  COMMENT = &#x27;菜单权限表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_user_role(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    USER_ID VARCHAR(36) NOT NULL   COMMENT &#x27;用户ID;用户ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36) NOT NULL   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色关联表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_role_menu(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36) NOT NULL   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    MENU_ID VARCHAR(36) NOT NULL   COMMENT &#x27;菜单ID;菜单ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;角色权限菜单表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自定义用户实现"><a href="#自定义用户实现" class="headerlink" title="自定义用户实现"></a><font style="color:rgb(0, 0, 0);">自定义用户实现</font></h3><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>改造网关实现授权</title>
    <url>/2024/03/14/%E6%94%B9%E9%80%A0%E7%BD%91%E5%85%B3%E5%AE%9E%E7%8E%B0%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>先看下认证授权的过程，认证客户端的认证是最先被认证的，只有先认证客户端可会进行token的认证，而我们不应该把客户端的信息暴漏在外面所以客户端的信息只能通过网关转发的时候注入到请求中</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/27343190/1667726854430-5c1f32f8-d71b-4c75-815c-c75de9cac331.png"></p>
<span id="more"></span>

<h2 id="直接请求认证服务器的流程"><a href="#直接请求认证服务器的流程" class="headerlink" title="直接请求认证服务器的流程"></a>直接请求认证服务器的流程</h2><p>请求<font style="color:rgb(33, 33, 33);">&#x2F;oauth2&#x2F;token 输入表单信息</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132164269-3335ac9d-d4a6-4464-81aa-b9753aae6360.png"></p>
<p><font style="color:rgb(107, 107, 107);"> </font>Authorization设置为Basic Auth</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132230680-00619d4b-b0be-436a-8431-cf863ddfb67c.png"></p>
<p>获得结果</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132311409-b4aac947-0f53-4d41-a529-549fadb993b5.png"></p>
<p>使用网关转发请求和注入服务的时候，当客户端不能直接提供客户端信息的时候，需要在网关转发时注入</p>
<h2 id="改造网关"><a href="#改造网关" class="headerlink" title="改造网关"></a>改造网关</h2><h3 id="增加局部过滤器"><a href="#增加局部过滤器" class="headerlink" title="增加局部过滤器"></a>增加局部过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoginFilter extends AbstractGatewayFilterFactory&lt;LoginFilter.Config&gt; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private  ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientProperties clientProperties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LoginFilter() &#123;</span><br><span class="line">        super(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Token URL 标识</span><br><span class="line">     */</span><br><span class="line">    private static final String TOKEN_URL_IDENTIFY = &quot;oauth2/token&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public GatewayFilter apply(Config config) &#123;</span><br><span class="line">        return (exchange, chain) -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">                //判断是否是请求token</span><br><span class="line">                String path = request.getURI().getPath();</span><br><span class="line">                if (!StrUtil.containsIgnoreCase(path, TOKEN_URL_IDENTIFY)) &#123;</span><br><span class="line">                    return chain.filter(exchange);</span><br><span class="line">                &#125;</span><br><span class="line">                //TODO:后续可以增加验证码验证</span><br><span class="line">                //注入客户端信息</span><br><span class="line">                ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">                String clientStr =String.format(&quot;%s:%s&quot;,clientProperties.getClientId(),clientProperties.getClientSecret());</span><br><span class="line">                String base = Base64.encode(clientStr);</span><br><span class="line">                addHeader(mutate,&quot;Authorization&quot;,String.format(&quot;Basic %s&quot;,base));</span><br><span class="line">            &#125;catch (UnauthorizedException ex)&#123;</span><br><span class="line">                getErrResponse(exchange, AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED,ex.getMessage()));</span><br><span class="line">            &#125;catch (Exception e) &#123;</span><br><span class="line">                return getErrResponse(exchange, AjaxResult.error(ResponseStatusEnum.SYS_ERROR, e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class Config &#123;</span><br><span class="line">        // 在这里可以定义配置属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addHeader(ServerHttpRequest.Builder mutate, String name, Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueStr = value.toString();</span><br><span class="line">        String valueEncode = valueStr;</span><br><span class="line">        mutate.header(name, valueEncode);</span><br><span class="line">    &#125;</span><br><span class="line">    private Mono&lt;Void&gt; getErrResponse(ServerWebExchange exchange, Object errInfo) &#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">        return response.writeWith(Mono.create(monoSink -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] bytes = objectMapper.writeValueAsBytes(errInfo);</span><br><span class="line">                DataBuffer dataBuffer = response.bufferFactory().wrap(bytes);</span><br><span class="line">                monoSink.success(dataBuffer);</span><br><span class="line">            &#125; catch (JsonProcessingException jsonProcessingException) &#123;</span><br><span class="line">                log.error(jsonProcessingException.getMessage());</span><br><span class="line">                monoSink.error(jsonProcessingException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置客户端信息"><a href="#配置客户端信息" class="headerlink" title="配置客户端信息"></a>配置客户端信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RefreshScope</span><br><span class="line">@ConfigurationProperties(prefix = &quot;security.client&quot;)</span><br><span class="line">public class ClientProperties &#123;</span><br><span class="line">    private String clientId;</span><br><span class="line">    private String clientSecret;</span><br><span class="line"></span><br><span class="line">    public String getClientId() &#123;</span><br><span class="line">        return clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClientId(String clientId) &#123;</span><br><span class="line">        this.clientId = clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getClientSecret() &#123;</span><br><span class="line">        return clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClientSecret(String clientSecret) &#123;</span><br><span class="line">        this.clientSecret = clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">  client:</span><br><span class="line">    clientId: messaging-client</span><br><span class="line">    clientSecret: secret</span><br></pre></td></tr></table></figure>

<h3 id="路由中添加过滤器"><a href="#路由中添加过滤器" class="headerlink" title="路由中添加过滤器"></a>路由中添加过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- id: luck-auth</span><br><span class="line">  uri: lb://luck-auth</span><br><span class="line">  predicates:</span><br><span class="line">    - Path=/auth/**</span><br><span class="line">  filters:</span><br><span class="line">    - StripPrefix=1</span><br><span class="line">    - CacheRequestFilter</span><br><span class="line">    - LoginFilter</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133263303-ffd2f328-09fa-4bd4-9a53-9c5ded039cf4.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133272368-1c2b04a7-f9b0-49ac-90e4-dce9298e5f8d.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133290397-da9266f6-dd79-4b06-ac87-736203474128.png"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Authorization设置为Basic Auth 的实际操作为在Header中新增一个key为Authorization value为 Basic +base64({clientId}:{clientSecret}) 。这里Basic后面是有一个空格的需要注意。</p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>资源服务器鉴权处理</title>
    <url>/2024/03/15/%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>在oauth2中授权服务器颁发过令牌后，用户就可以对资源进行访问，这时会有一个问题就是需要验证令牌，而前边文章中令牌使用的jwt格式，所以需要一个统一的资源管理器来验证令牌解析令牌</p>
<span id="more"></span>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class BearerTokenAuthenticationFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">	private final AuthenticationManagerResolver&lt;HttpServletRequest&gt; authenticationManagerResolver;</span><br><span class="line"></span><br><span class="line">	private AuthenticationEntryPoint authenticationEntryPoint = new BearerTokenAuthenticationEntryPoint();</span><br><span class="line"></span><br><span class="line">	private AuthenticationFailureHandler authenticationFailureHandler = (request, response, exception) -&gt; &#123;</span><br><span class="line">		if (exception instanceof AuthenticationServiceException) &#123;</span><br><span class="line">			throw exception;</span><br><span class="line">		&#125;</span><br><span class="line">		this.authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	private BearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();</span><br><span class="line"></span><br><span class="line">	private AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = new WebAuthenticationDetailsSource();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Construct a &#123;@code BearerTokenAuthenticationFilter&#125; using the provided parameter(s)</span><br><span class="line">	 * @param authenticationManagerResolver</span><br><span class="line">	 */</span><br><span class="line">	public BearerTokenAuthenticationFilter(</span><br><span class="line">			AuthenticationManagerResolver&lt;HttpServletRequest&gt; authenticationManagerResolver) &#123;</span><br><span class="line">		Assert.notNull(authenticationManagerResolver, &quot;authenticationManagerResolver cannot be null&quot;);</span><br><span class="line">		this.authenticationManagerResolver = authenticationManagerResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Construct a &#123;@code BearerTokenAuthenticationFilter&#125; using the provided parameter(s)</span><br><span class="line">	 * @param authenticationManager</span><br><span class="line">	 */</span><br><span class="line">	public BearerTokenAuthenticationFilter(AuthenticationManager authenticationManager) &#123;</span><br><span class="line">		Assert.notNull(authenticationManager, &quot;authenticationManager cannot be null&quot;);</span><br><span class="line">		this.authenticationManagerResolver = (request) -&gt; authenticationManager;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Extract any</span><br><span class="line">	 * &lt;a href=&quot;https://tools.ietf.org/html/rfc6750#section-1.2&quot; target=&quot;_blank&quot;&gt;Bearer</span><br><span class="line">	 * Token&lt;/a&gt; from the request and attempt an authentication.</span><br><span class="line">	 * @param request</span><br><span class="line">	 * @param response</span><br><span class="line">	 * @param filterChain</span><br><span class="line">	 * @throws ServletException</span><br><span class="line">	 * @throws IOException</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		String token;</span><br><span class="line">		try &#123;</span><br><span class="line">			token = this.bearerTokenResolver.resolve(request);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (OAuth2AuthenticationException invalid) &#123;</span><br><span class="line">			this.logger.trace(&quot;Sending to authentication entry point since failed to resolve bearer token&quot;, invalid);</span><br><span class="line">			this.authenticationEntryPoint.commence(request, response, invalid);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (token == null) &#123;</span><br><span class="line">			this.logger.trace(&quot;Did not process request since did not find bearer token&quot;);</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BearerTokenAuthenticationToken authenticationRequest = new BearerTokenAuthenticationToken(token);</span><br><span class="line">		authenticationRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			AuthenticationManager authenticationManager = this.authenticationManagerResolver.resolve(request);</span><br><span class="line">			Authentication authenticationResult = authenticationManager.authenticate(authenticationRequest);</span><br><span class="line">			SecurityContext context = SecurityContextHolder.createEmptyContext();</span><br><span class="line">			context.setAuthentication(authenticationResult);</span><br><span class="line">			SecurityContextHolder.setContext(context);</span><br><span class="line">			if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">				this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authenticationResult));</span><br><span class="line">			&#125;</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (AuthenticationException failed) &#123;</span><br><span class="line">			SecurityContextHolder.clearContext();</span><br><span class="line">			this.logger.trace(&quot;Failed to process authentication request&quot;, failed);</span><br><span class="line">			this.authenticationFailureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link BearerTokenResolver&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link DefaultBearerTokenResolver&#125;.</span><br><span class="line">	 * @param bearerTokenResolver the &#123;@code BearerTokenResolver&#125; to use</span><br><span class="line">	 */</span><br><span class="line">	public void setBearerTokenResolver(BearerTokenResolver bearerTokenResolver) &#123;</span><br><span class="line">		Assert.notNull(bearerTokenResolver, &quot;bearerTokenResolver cannot be null&quot;);</span><br><span class="line">		this.bearerTokenResolver = bearerTokenResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationEntryPoint&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link BearerTokenAuthenticationEntryPoint&#125;.</span><br><span class="line">	 * @param authenticationEntryPoint the &#123;@code AuthenticationEntryPoint&#125; to use</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationEntryPoint(final AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">		Assert.notNull(authenticationEntryPoint, &quot;authenticationEntryPoint cannot be null&quot;);</span><br><span class="line">		this.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationFailureHandler&#125; to use. Default implementation invokes</span><br><span class="line">	 * &#123;@link AuthenticationEntryPoint&#125;.</span><br><span class="line">	 * @param authenticationFailureHandler the &#123;@code AuthenticationFailureHandler&#125; to use</span><br><span class="line">	 * @since 5.2</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationFailureHandler(final AuthenticationFailureHandler authenticationFailureHandler) &#123;</span><br><span class="line">		Assert.notNull(authenticationFailureHandler, &quot;authenticationFailureHandler cannot be null&quot;);</span><br><span class="line">		this.authenticationFailureHandler = authenticationFailureHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationDetailsSource&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link WebAuthenticationDetailsSource&#125;.</span><br><span class="line">	 * @param authenticationDetailsSource the &#123;@code AuthenticationConverter&#125; to use</span><br><span class="line">	 * @since 5.5</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationDetailsSource(</span><br><span class="line">			AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource) &#123;</span><br><span class="line">		Assert.notNull(authenticationDetailsSource, &quot;authenticationDetailsSource cannot be null&quot;);</span><br><span class="line">		this.authenticationDetailsSource = authenticationDetailsSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JwtAuthenticationProvider的  jwt的主流程处理中心</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class JwtAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line"></span><br><span class="line">	private final Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">	private final JwtDecoder jwtDecoder;</span><br><span class="line"></span><br><span class="line">	private Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt; jwtAuthenticationConverter = new JwtAuthenticationConverter();</span><br><span class="line"></span><br><span class="line">	public JwtAuthenticationProvider(JwtDecoder jwtDecoder) &#123;</span><br><span class="line">		Assert.notNull(jwtDecoder, &quot;jwtDecoder cannot be null&quot;);</span><br><span class="line">		this.jwtDecoder = jwtDecoder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Decode and validate the</span><br><span class="line">	 * &lt;a href=&quot;https://tools.ietf.org/html/rfc6750#section-1.2&quot; target=&quot;_blank&quot;&gt;Bearer</span><br><span class="line">	 * Token&lt;/a&gt;.</span><br><span class="line">	 * @param authentication the authentication request object.</span><br><span class="line">	 * @return A successful authentication</span><br><span class="line">	 * @throws AuthenticationException if authentication failed for some reason</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">		BearerTokenAuthenticationToken bearer = (BearerTokenAuthenticationToken) authentication;</span><br><span class="line">		Jwt jwt = getJwt(bearer);</span><br><span class="line">		AbstractAuthenticationToken token = this.jwtAuthenticationConverter.convert(jwt);</span><br><span class="line">		token.setDetails(bearer.getDetails());</span><br><span class="line">		this.logger.debug(&quot;Authenticated token&quot;);</span><br><span class="line">		return token;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Jwt getJwt(BearerTokenAuthenticationToken bearer) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return this.jwtDecoder.decode(bearer.getToken());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BadJwtException failed) &#123;</span><br><span class="line">			this.logger.debug(&quot;Failed to authenticate since the JWT was invalid&quot;);</span><br><span class="line">			throw new InvalidBearerTokenException(failed.getMessage(), failed);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (JwtException failed) &#123;</span><br><span class="line">			throw new AuthenticationServiceException(failed.getMessage(), failed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">		return BearerTokenAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setJwtAuthenticationConverter(</span><br><span class="line">			Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt; jwtAuthenticationConverter) &#123;</span><br><span class="line">		Assert.notNull(jwtAuthenticationConverter, &quot;jwtAuthenticationConverter cannot be null&quot;);</span><br><span class="line">		this.jwtAuthenticationConverter = jwtAuthenticationConverter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析doFilterInternal方法我们可知：</p>
<ul>
<li>请求会被 BearerTokenAuthenticationFilter 拦截器拦截，通过bearerTokenResolver解析出token字符串如果没有解析出来，则由下一个过滤器处理。如果失败将被AuthenticationEntryPoint统一拦截处理</li>
<li>解析出来则构建一个BearerTokenAuthenticationToken对象。</li>
<li>将HttpServletRequest传递给AuthenticationManagerResolver对象，由它选择出AuthenticationManager对象，然后将 BearerTokenAuthenticationToken传递给AuthenticationManager对象进行认证。AuthenticationManager对象的实现，取决于我们的token对象是JWT还是opaque token</li>
<li>在AuthenticationManager由多个Provider对Authentication进行处理最终返回结果，当对象为jwt时处理对象为JwtAuthenticationProvider，在JwtAuthenticationProvider会先通过jwtDecoder解析jwt字符串，最终对JwtAuthenticationConverter将jwt字符串处理的为AbstractAuthenticationToken</li>
<li>验证失败<ul>
<li>清空 SecurityContextHolder 对象。</li>
<li>交由AuthenticationFailureHandler对象处理。</li>
</ul>
</li>
<li>验证成功<ul>
<li>将 Authentication对象设置到SecurityContextHolder中。</li>
<li>交由余下的过滤器继续处理。</li>
</ul>
</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>pom文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>ResourceServerConfiguration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableMethodSecurity</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class ResourceServerConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line"></span><br><span class="line">    private final HttpSecurity http;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityFilterChain filterChain() throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .antMatchers(&quot;/actuator/**&quot;, &quot;/v3/api-docs/**&quot;, &quot;/swagger-ui/**&quot;,</span><br><span class="line">                                &quot;/swagger-ui.html&quot;).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                .oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">                        .authenticationEntryPoint(luckAuthenticationEntryPoint())</span><br><span class="line">                        .bearerTokenResolver(new LuckBearerTokenResolver(redisService))</span><br><span class="line">                        .jwt());</span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationConverter jwtAuthenticationConverter() &#123;</span><br><span class="line">        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();</span><br><span class="line">        grantedAuthoritiesConverter.setAuthorityPrefix(&quot;&quot;);</span><br><span class="line">        grantedAuthoritiesConverter.setAuthoritiesClaimName(&quot;authorities&quot;);</span><br><span class="line"></span><br><span class="line">        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();</span><br><span class="line">        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);</span><br><span class="line">        return jwtAuthenticationConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LuckAuthenticationEntryPoint luckAuthenticationEntryPoint() &#123;</span><br><span class="line">        return new LuckAuthenticationEntryPoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return PasswordEncoderFactories.createDelegatingPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;pms&quot;)</span><br><span class="line">    public PermissionHandler permissionHandler() &#123;</span><br><span class="line">        return new PermissionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>异常定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public class LuckAuth2AuthencticationException extends OAuth2AuthenticationException &#123;</span><br><span class="line">    private final String code;</span><br><span class="line"></span><br><span class="line">    public LuckAuth2AuthencticationException(ResponseStatusEnum status) &#123;</span><br><span class="line">        super(new OAuth2Error(status.getMsg()), status.getMsg());</span><br><span class="line">        this.code = status.getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查异常处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LuckAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line">        ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);</span><br><span class="line">        AjaxResult&lt;?&gt; error;</span><br><span class="line">        if(authException instanceof InvalidBearerTokenException)&#123;</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.FAILED_DEPENDENCY);</span><br><span class="line">            error = AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, authException.getMessage());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            error = AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED, authException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpEndpointUtils.writeWithMessageConverters(error, servletServerHttpResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令牌适配器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class LuckBearerTokenResolver implements BearerTokenResolver &#123;</span><br><span class="line"></span><br><span class="line">    private final RedisService redisService;</span><br><span class="line"></span><br><span class="line">    private static final Pattern AUTHORIZATION_PATTERN = Pattern.compile(&quot;^Bearer (?&lt;token&gt;[a-zA-Z0-9-._~+/]+=*)$&quot;,</span><br><span class="line">            Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line">    private boolean allowFormEncodedBodyParameter = false;</span><br><span class="line"></span><br><span class="line">    private boolean allowUriQueryParameter = false;</span><br><span class="line"></span><br><span class="line">    private String bearerTokenHeaderName = HttpHeaders.AUTHORIZATION;</span><br><span class="line"></span><br><span class="line">//    public  LuckBearerTokenResolver(RedisService redisService)&#123;</span><br><span class="line">//        this.redisService = redisService;</span><br><span class="line">//    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String resolve(HttpServletRequest request) &#123;</span><br><span class="line">            final String authorizationHeaderToken = resolveFromAuthorizationHeader(request);</span><br><span class="line">            final String parameterToken = isParameterTokenSupportedForRequest(request)</span><br><span class="line">                    ? resolveFromRequestParameters(request) : null;</span><br><span class="line">            if (authorizationHeaderToken != null) &#123;</span><br><span class="line">                if (parameterToken != null) &#123;</span><br><span class="line">                    final BearerTokenError error = BearerTokenErrors</span><br><span class="line">                            .invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);</span><br><span class="line">                    throw new OAuth2AuthenticationException(error);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return authorizationHeaderToken;</span><br><span class="line">            &#125;</span><br><span class="line">            if (parameterToken != null &amp;&amp; isParameterTokenEnabledForRequest(request)) &#123;</span><br><span class="line">                return parameterToken;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Set if transport of access token using form-encoded body parameter is supported.</span><br><span class="line">     * Defaults to &#123;@code false&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param allowFormEncodedBodyParameter if the form-encoded body parameter is</span><br><span class="line">     *                                      supported</span><br><span class="line">     */</span><br><span class="line">    public void setAllowFormEncodedBodyParameter(boolean allowFormEncodedBodyParameter) &#123;</span><br><span class="line">        this.allowFormEncodedBodyParameter = allowFormEncodedBodyParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set if transport of access token using URI query parameter is supported. Defaults</span><br><span class="line">     * to &#123;@code false&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The spec recommends against using this mechanism for sending bearer tokens, and</span><br><span class="line">     * even goes as far as stating that it was only included for completeness.</span><br><span class="line">     *</span><br><span class="line">     * @param allowUriQueryParameter if the URI query parameter is supported</span><br><span class="line">     */</span><br><span class="line">    public void setAllowUriQueryParameter(boolean allowUriQueryParameter) &#123;</span><br><span class="line">        this.allowUriQueryParameter = allowUriQueryParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set this value to configure what header is checked when resolving a Bearer Token.</span><br><span class="line">     * This value is defaulted to &#123;@link HttpHeaders#AUTHORIZATION&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This allows other headers to be used as the Bearer Token source such as</span><br><span class="line">     * &#123;@link HttpHeaders#PROXY_AUTHORIZATION&#125;</span><br><span class="line">     *</span><br><span class="line">     * @param bearerTokenHeaderName the header to check when retrieving the Bearer Token.</span><br><span class="line">     * @since 5.4</span><br><span class="line">     */</span><br><span class="line">    public void setBearerTokenHeaderName(String bearerTokenHeaderName) &#123;</span><br><span class="line">        this.bearerTokenHeaderName = bearerTokenHeaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String resolveFromAuthorizationHeader(HttpServletRequest request) &#123;</span><br><span class="line">        String authorization = request.getHeader(this.bearerTokenHeaderName);</span><br><span class="line">        if (!StringUtils.startsWithIgnoreCase(authorization, &quot;bearer&quot;)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization);</span><br><span class="line">        if (!matcher.matches()) &#123;</span><br><span class="line">            BearerTokenError error = BearerTokenErrors.invalidToken(&quot;Bearer token is malformed&quot;);</span><br><span class="line">            throw new OAuth2AuthenticationException(error);</span><br><span class="line">        &#125;</span><br><span class="line">        return matcher.group(&quot;token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String resolveFromRequestParameters(HttpServletRequest request) &#123;</span><br><span class="line">        String[] values = request.getParameterValues(&quot;access_token&quot;);</span><br><span class="line">        if (values == null || values.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (values.length == 1) &#123;</span><br><span class="line">            return values[0];</span><br><span class="line">        &#125;</span><br><span class="line">        BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);</span><br><span class="line">        throw new OAuth2AuthenticationException(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isParameterTokenSupportedForRequest(final HttpServletRequest request) &#123;</span><br><span class="line">        return ((&quot;POST&quot;.equals(request.getMethod())</span><br><span class="line">                &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED_VALUE.equals(request.getContentType()))</span><br><span class="line">                || &quot;GET&quot;.equals(request.getMethod()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isParameterTokenEnabledForRequest(final HttpServletRequest request) &#123;</span><br><span class="line">        return ((this.allowFormEncodedBodyParameter &amp;&amp; &quot;POST&quot;.equals(request.getMethod())</span><br><span class="line">                &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED_VALUE.equals(request.getContentType()))</span><br><span class="line">                || (this.allowUriQueryParameter &amp;&amp; &quot;GET&quot;.equals(request.getMethod())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建 token key</span><br><span class="line">     * @param token token</span><br><span class="line">     * @return token key</span><br><span class="line">     */</span><br><span class="line">    private String buildKey(String token) &#123;</span><br><span class="line">        return String.format(&quot;%s:%s:%s&quot;, CacheConstants.TOKEN, OAuth2ParameterNames.ACCESS_TOKEN, token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    oauth2:</span><br><span class="line">      resourceserver:</span><br><span class="line">        jwt:</span><br><span class="line">          issuer-uri: http://192.168.1.186:1067</span><br></pre></td></tr></table></figure>



<h2 id="服务引用统一的资源服务器配置："><a href="#服务引用统一的资源服务器配置：" class="headerlink" title="服务引用统一的资源服务器配置："></a>服务引用统一的资源服务器配置：</h2><p>pom:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.luck.sugar&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;luck-common-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HomeController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;test&quot;)</span><br><span class="line">    @PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;)&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p>先到授权服务器获取token</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304403339-c483e02f-5dc0-44ee-ab67-dd137794d4f8.png"></p>
<p>然后在资源服务器中添加key为<font style="color:rgb(33, 33, 33);">Authorization的headers</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304459217-12582e36-cc83-4a25-80db-d973ec10e1c7.png">接着在token后面加数字1</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304562201-a7dc64ca-0218-438a-9a16-003074b4e014.png"></p>
<p>抛出异常An error occurred while attempting to decode the Jwt: Signed JWT rejected: Invalid signature</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在资源服务器的流程中有多个扩展点必须的扩展点为</p>
<p>jwtAuthenticationConverter  他定义了权限信息从jwt的那个Claims下取出，之前的授权服务器中将权限信息放入了authorities 所以上面的的例子定义了权限信息从authorities中获取</p>
<p>BearerTokenResolver：提取令牌</p>
<p>AuthenticationManagerResolver ：获取认证中心，一般使用默认的AuthenticationManager</p>
<p>JwtDecoder：他定义了jwt解析，可以结合jwtAuthenticationConverter 完成从缓存中获取权限信息</p>
<p>AuthenticationProvider：身份验证实现，如果身份验证有特殊处理可以增加</p>
<p>AuthenticationEntryPoint:BearerTokenResolver 获取失败的错误提示处理</p>
<p>AuthenticationFailureHandler: 授权失败错误处理</p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>集成Oauth2.1认证中心</title>
    <url>/2024/03/11/%E9%9B%86%E6%88%90Oauth2.1%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>新版本中的springcloud已经将springcloudoauth2包取消掉，oauth2新增了一个spring-authorization-server的项目，在spring-authorization-server下现在已经有3个可用版本，其中0.3.0对应的是jdk11版本， 0.4.0对应的是jdk8版本，1.0版本对应的是jdk17。以下的实例是以jdk11为例</p>
<span id="more"></span>
<h2 id="建立授权服务"><a href="#建立授权服务" class="headerlink" title="建立授权服务"></a>建立授权服务</h2><p>创建服务的过程这里不做赘述，项目需要的pom文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--jdbc--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;!--auth --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">Spring authorization Server</font><font style="color:rgb(18, 18, 18);">的建表文件在：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org/springframework/security/oauth2/server/authorization/oauth2-authorization-consent-schema.sql</span><br><span class="line"></span><br><span class="line">org/springframework/security/oauth2/server/authorization/oauth2-authorization-schema.sql</span><br><span class="line"></span><br><span class="line">org/springframework/security/oauth2/server/authorization/client/oauth2-registered-client-schema.sql</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">Spring Security</font><font style="color:rgb(18, 18, 18);">的建表语句在</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org/springframework/security/core/userdetails/jdbc/users.ddl</span><br></pre></td></tr></table></figure>

<p>总共5张表，这里放出0.3.0版本的sql其他版本需要自己找一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE oauth2_authorization_consent (</span><br><span class="line">    registered_client_id varchar(100) NOT NULL,</span><br><span class="line">    principal_name varchar(200) NOT NULL,</span><br><span class="line">    authorities varchar(1000) NOT NULL,</span><br><span class="line">    PRIMARY KEY (registered_client_id, principal_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">IMPORTANT:</span><br><span class="line">    If using PostgreSQL, update ALL columns defined with &#x27;blob&#x27; to &#x27;text&#x27;,</span><br><span class="line">    as PostgreSQL does not support the &#x27;blob&#x27; data type.</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE oauth2_authorization (</span><br><span class="line">    id varchar(100) NOT NULL,</span><br><span class="line">    registered_client_id varchar(100) NOT NULL,</span><br><span class="line">    principal_name varchar(200) NOT NULL,</span><br><span class="line">    authorization_grant_type varchar(100) NOT NULL,</span><br><span class="line">    attributes blob DEFAULT NULL,</span><br><span class="line">    state varchar(500) DEFAULT NULL,</span><br><span class="line">    authorization_code_value blob DEFAULT NULL,</span><br><span class="line">    authorization_code_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    authorization_code_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    authorization_code_metadata blob DEFAULT NULL,</span><br><span class="line">    access_token_value blob DEFAULT NULL,</span><br><span class="line">    access_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    access_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    access_token_metadata blob DEFAULT NULL,</span><br><span class="line">    access_token_type varchar(100) DEFAULT NULL,</span><br><span class="line">    access_token_scopes varchar(1000) DEFAULT NULL,</span><br><span class="line">    oidc_id_token_value blob DEFAULT NULL,</span><br><span class="line">    oidc_id_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    oidc_id_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    oidc_id_token_metadata blob DEFAULT NULL,</span><br><span class="line">    refresh_token_value blob DEFAULT NULL,</span><br><span class="line">    refresh_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    refresh_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    refresh_token_metadata blob DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE oauth2_registered_client (</span><br><span class="line">    id varchar(100) NOT NULL,</span><br><span class="line">    client_id varchar(100) NOT NULL,</span><br><span class="line">    client_id_issued_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,</span><br><span class="line">    client_secret varchar(200) DEFAULT NULL,</span><br><span class="line">    client_secret_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    client_name varchar(200) NOT NULL,</span><br><span class="line">    client_authentication_methods varchar(1000) NOT NULL,</span><br><span class="line">    authorization_grant_types varchar(1000) NOT NULL,</span><br><span class="line">    redirect_uris varchar(1000) DEFAULT NULL,</span><br><span class="line">    scopes varchar(1000) NOT NULL,</span><br><span class="line">    client_settings varchar(2000) NOT NULL,</span><br><span class="line">    token_settings varchar(2000) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    username varchar(50)  not null</span><br><span class="line">        primary key,</span><br><span class="line">    password varchar(500) not null,</span><br><span class="line">    enabled  tinyint(1)   not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table authorities</span><br><span class="line">(</span><br><span class="line">    username  varchar(50) not null,</span><br><span class="line">    authority varchar(50) not null,</span><br><span class="line">    constraint ix_auth_username</span><br><span class="line">        unique (username, authority),</span><br><span class="line">    constraint fk_authorities_users</span><br><span class="line">        foreign key (username) references users (username)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1067</span><br><span class="line">spring:</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/oauth2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure>

<h2 id="自定义授权服务器"><a href="#自定义授权服务器" class="headerlink" title="自定义授权服务器"></a>自定义授权服务器</h2><p>在springsecurity5.6以后配置文件为新建Configuration，然后覆盖Bean的形式进行配置，所以这里我们创建配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class AuthorizationServerConfig &#123;</span><br><span class="line">    @Autowired()</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Autowired()</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个Spring security 的过滤器链，默认会配置</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Introspection endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Revocation endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization Server Metadata endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * JWK Set endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 Provider Configuration endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 UserInfo endpoint</span><br><span class="line">     * 这些协议端点，只有配置了他才能够访问的到接口地址（类似mvc的controller）。</span><br><span class="line">     *</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(1)</span><br><span class="line">    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);</span><br><span class="line">        http</span><br><span class="line">                // Redirect to the login page when not authenticated from the</span><br><span class="line">                // authorization endpoint</span><br><span class="line">                .exceptionHandling((exceptions) -&gt; exceptions</span><br><span class="line">                        .authenticationEntryPoint(</span><br><span class="line">                                new LoginUrlAuthenticationEntryPoint(&quot;/login&quot;))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个也是个Spring Security的过滤器链，用于Spring Security的身份认证。</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(2)</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                // Form login handles the redirect to the login page from the</span><br><span class="line">                // authorization server filter chain</span><br><span class="line">                .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置用户信息，或者配置用户数据来源，主要用于用户的检索。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">//        UserDetails userDetails = User.withDefaultPasswordEncoder()</span><br><span class="line">//                .username(&quot;user&quot;)</span><br><span class="line">//                .password(&quot;password&quot;)</span><br><span class="line">//                .roles(&quot;USER&quot;)</span><br><span class="line">//                .build();</span><br><span class="line">//       return new InMemoryUserDetailsManager();</span><br><span class="line"></span><br><span class="line">        return new JdbcUserDetailsManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * oauth2 用于第三方认证，RegisteredClientRepository 主要用于管理第三方（每个第三方就是一个客户端）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RegisteredClientRepository registeredClientRepository() &#123;</span><br><span class="line">//        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">//                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">//                .clientSecret(&quot;&#123;noop&#125;secret&quot;)</span><br><span class="line">//                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/authorized&quot;)</span><br><span class="line">//                .scope(OidcScopes.OPENID)</span><br><span class="line">//                .scope(&quot;message.read&quot;)</span><br><span class="line">//                .scope(&quot;message.write&quot;)</span><br><span class="line">//                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">//                .build();</span><br><span class="line">//</span><br><span class="line">//        return new InMemoryRegisteredClientRepository(registeredClient);</span><br><span class="line">        return new JdbcRegisteredClientRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于给access_token签名使用。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JWKSource&lt;SecurityContext&gt; jwkSource() &#123;</span><br><span class="line">        KeyPair keyPair = generateRsaKey();</span><br><span class="line">        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        RSAKey rsaKey = new RSAKey.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        JWKSet jwkSet = new JWKSet(rsaKey);</span><br><span class="line">        return new ImmutableJWKSet&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成秘钥对，为jwkSource提供服务。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static KeyPair generateRsaKey() &#123;</span><br><span class="line">        KeyPair keyPair;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            keyPairGenerator.initialize(2048);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationService authorizationService() &#123;</span><br><span class="line">        return new JdbcOAuth2AuthorizationService(jdbcTemplate, registeredClientRepository());</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationConsentService authorizationConsentService() &#123;</span><br><span class="line">        return new JdbcOAuth2AuthorizationConsentService(jdbcTemplate, registeredClientRepository());</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 配置Authorization Server实例</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ProviderSettings providerSettings() &#123;</span><br><span class="line">        return ProviderSettings.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在spring-authorization-server中实现了jdbc模式的可以直接链接数据库进行操作</p>
<h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsManager userDetailsManager;</span><br><span class="line">  @Test</span><br><span class="line">void testSaveUser() &#123;</span><br><span class="line">        UserDetails userDetails = User.builder().passwordEncoder(s -&gt; &quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(s))</span><br><span class="line">                .username(&quot;user&quot;)</span><br><span class="line">                .password(&quot;password&quot;)</span><br><span class="line">                .roles(&quot;ADMIN&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        userDetailsManager.createUser(userDetails);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 UserDetailsManager 创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private RegisteredClientRepository registeredClientRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">    void testSaveClient() &#123;</span><br><span class="line">        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">                .clientSecret(&quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(&quot;secret&quot;))</span><br><span class="line">                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">                .redirectUri(&quot;http://127.0.0.1:1069/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">                .redirectUri(&quot;http://127.0.0.1:1069/authorized&quot;)</span><br><span class="line">                .scope(OidcScopes.OPENID).scope(&quot;message.read&quot;)</span><br><span class="line">                .scope(&quot;message.write&quot;)</span><br><span class="line">                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">                .build();</span><br><span class="line">        registeredClientRepository.save(registeredClient);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以registeredClientRepository创建客户端</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开：<a href="http://127.0.0.1:1067/oauth2/authorize?response_type=code&client_id=messaging-client&scope=message.read&redirect_uri=http://127.0.0.1:1067/authorized">http://127.0.0.1:1067/oauth2/authorize?response_type&#x3D;code&amp;client_id&#x3D;messaging-client&amp;scope&#x3D;message.read&amp;redirect_uri&#x3D;http://127.0.0.1:1067/authorized</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678243822906-ab077efe-c963-4e24-a89d-e5fc2beb53e8.png"></p>
<p>输入前面的添加的账号密码</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678243858497-5b68bed5-2d79-48fb-9209-c2e3639c258b.png"></p>
<p>报错了，不过没关系。因为在oath2中第一步是拿到code 拿到code之后才能换取token</p>
<p>我们只要拿到地址栏后面的code信息就好。复制出code信息，打开postman进行post请求</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244026029-0c3c4817-9483-481e-9899-69e8fb636d3b.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244264220-25530875-31db-4c3d-bd62-a4b910934a98.png"></p>
<p>点击访问</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244286055-479c09a7-92be-4354-9e80-831a3295a893.png"></p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义密码模式</title>
    <url>/2024/03/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679106524585-028d887a-7d9d-4e18-af56-f2bcdc192049.png"></p>
<p>在官方的说明中我们可以看到OAuth 2.1 废弃了 OAuth 2.0 中的密码模式，只提供了三种授权类型：授权码、刷新令牌、客户端凭证。</p>
<span id="more"></span>
<p>oauth2.1中授权码模式的流程为：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/jpeg/25873401/1679108178925-bf9d2710-85d2-45f0-a277-cfe3fe0595a5.jpeg" alt="画板"></p>
<p>由上图可知我们想要沿用密码模式会有两种方案</p>
<p>1.自定义密码模式   </p>
<p>2.修改授权码模式，自定义授权页面，使用授权页面自动提交获取token。</p>
<h2 id="自定义密码模式："><a href="#自定义密码模式：" class="headerlink" title="自定义密码模式："></a>自定义密码模式：</h2><p>在官网中对自定义配置的描述<img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109031954-9f6a10bf-a4a8-4c0b-9bee-229c07ae5844.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109044969-a5836447-2dc8-4a6c-b58b-dcad2c8d05f7.png"></p>
<p>这里可以看到在授权断点是可以实现自定义的，于是就有了接下来的思路：</p>
<p>直接略过前面的密码验证、用户确认， 直接自定义授权端点。在自定义的端点中处理授权信息，打开</p>
<p>7 <font style="color:rgb(25, 30, 30);">authorizationEndpoint</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109474910-3209f835-9aba-42bd-b42e-4a60b946d3b3.png"></p>
<p>这里可以看到自定义一个oauth2的授权请求需要定义一个处理器 一个主处理器，但是官方并没有给具体的例子所以需要看下其他授权端点的做法来完成自定义，以code授权的源码为例分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class OAuth2AuthorizationCodeAuthenticationConverter implements AuthenticationConverter &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	@Override</span><br><span class="line">	public Authentication convert(HttpServletRequest request) &#123;</span><br><span class="line">		// grant_type (REQUIRED)</span><br><span class="line">		String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE);</span><br><span class="line">		if (!AuthorizationGrantType.AUTHORIZATION_CODE.getValue().equals(grantType)) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">		MultiValueMap&lt;String, String&gt; parameters = OAuth2EndpointUtils.getParameters(request);</span><br><span class="line"></span><br><span class="line">		// code (REQUIRED)</span><br><span class="line">		String code = parameters.getFirst(OAuth2ParameterNames.CODE);</span><br><span class="line">		if (!StringUtils.hasText(code) ||</span><br><span class="line">				parameters.get(OAuth2ParameterNames.CODE).size() != 1) &#123;</span><br><span class="line">			OAuth2EndpointUtils.throwError(</span><br><span class="line">					OAuth2ErrorCodes.INVALID_REQUEST,</span><br><span class="line">					OAuth2ParameterNames.CODE,</span><br><span class="line">					OAuth2EndpointUtils.ACCESS_TOKEN_REQUEST_ERROR_URI);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// redirect_uri (REQUIRED)</span><br><span class="line">		// Required only if the &quot;redirect_uri&quot; parameter was included in the authorization request</span><br><span class="line">		String redirectUri = parameters.getFirst(OAuth2ParameterNames.REDIRECT_URI);</span><br><span class="line">		if (StringUtils.hasText(redirectUri) &amp;&amp;</span><br><span class="line">				parameters.get(OAuth2ParameterNames.REDIRECT_URI).size() != 1) &#123;</span><br><span class="line">			OAuth2EndpointUtils.throwError(</span><br><span class="line">					OAuth2ErrorCodes.INVALID_REQUEST,</span><br><span class="line">					OAuth2ParameterNames.REDIRECT_URI,</span><br><span class="line">					OAuth2EndpointUtils.ACCESS_TOKEN_REQUEST_ERROR_URI);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">		parameters.forEach((key, value) -&gt; &#123;</span><br><span class="line">			if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.CLIENT_ID) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.CODE) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.REDIRECT_URI)) &#123;</span><br><span class="line">				additionalParameters.put(key, value.get(0));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		return new OAuth2AuthorizationCodeAuthenticationToken(</span><br><span class="line">				code, clientPrincipal, redirectUri, additionalParameters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里可以看出Converter的主要作用是对参数整理然后生成一个新得OAuth2AuthorizationCodeAuthenticationToken 对象，接着看下OAuth2AuthorizationCodeAuthenticationToken的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2AuthorizationCodeAuthenticationToken extends OAuth2AuthorizationGrantAuthenticationToken &#123;</span><br><span class="line">	private final String code;</span><br><span class="line">	private final String redirectUri;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Constructs an &#123;@code OAuth2AuthorizationCodeAuthenticationToken&#125; using the provided parameters.</span><br><span class="line">	 *</span><br><span class="line">	 * @param code the authorization code</span><br><span class="line">	 * @param clientPrincipal the authenticated client principal</span><br><span class="line">	 * @param redirectUri the redirect uri</span><br><span class="line">	 * @param additionalParameters the additional parameters</span><br><span class="line">	 */</span><br><span class="line">	public OAuth2AuthorizationCodeAuthenticationToken(String code, Authentication clientPrincipal,</span><br><span class="line">			@Nullable String redirectUri, @Nullable Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">		super(AuthorizationGrantType.AUTHORIZATION_CODE, clientPrincipal, additionalParameters);</span><br><span class="line">		Assert.hasText(code, &quot;code cannot be empty&quot;);</span><br><span class="line">		this.code = code;</span><br><span class="line">		this.redirectUri = redirectUri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Returns the authorization code.</span><br><span class="line">	 *</span><br><span class="line">	 * @return the authorization code</span><br><span class="line">	 */</span><br><span class="line">	public String getCode() &#123;</span><br><span class="line">		return this.code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Returns the redirect uri.</span><br><span class="line">	 *</span><br><span class="line">	 * @return the redirect uri</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	public String getRedirectUri() &#123;</span><br><span class="line">		return this.redirectUri;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是保存参数对象的。</p>
<p>接着再看下主处理的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class OAuth2AuthorizationCodeAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">	private static final String ERROR_URI = &quot;https://datatracker.ietf.org/doc/html/rfc6749#section-5.2&quot;;</span><br><span class="line">	private static final OAuth2TokenType AUTHORIZATION_CODE_TOKEN_TYPE =</span><br><span class="line">			new OAuth2TokenType(OAuth2ParameterNames.CODE);</span><br><span class="line">	private static final OAuth2TokenType ID_TOKEN_TOKEN_TYPE =</span><br><span class="line">			new OAuth2TokenType(OidcParameterNames.ID_TOKEN);</span><br><span class="line">	private final OAuth2AuthorizationService authorizationService;</span><br><span class="line">	private final OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Constructs an &#123;@code OAuth2AuthorizationCodeAuthenticationProvider&#125; using the provided parameters.</span><br><span class="line">	 *</span><br><span class="line">	 * @param authorizationService the authorization service</span><br><span class="line">	 * @param tokenGenerator the token generator</span><br><span class="line">	 * @since 0.2.3</span><br><span class="line">	 */</span><br><span class="line">	public OAuth2AuthorizationCodeAuthenticationProvider(OAuth2AuthorizationService authorizationService,</span><br><span class="line">			OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator) &#123;</span><br><span class="line">		Assert.notNull(authorizationService, &quot;authorizationService cannot be null&quot;);</span><br><span class="line">		Assert.notNull(tokenGenerator, &quot;tokenGenerator cannot be null&quot;);</span><br><span class="line">		this.authorizationService = authorizationService;</span><br><span class="line">		this.tokenGenerator = tokenGenerator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">		OAuth2AuthorizationCodeAuthenticationToken authorizationCodeAuthentication =</span><br><span class="line">				(OAuth2AuthorizationCodeAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">		OAuth2ClientAuthenticationToken clientPrincipal =</span><br><span class="line">				getAuthenticatedClientElseThrowInvalidClient(authorizationCodeAuthentication);</span><br><span class="line">		RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();</span><br><span class="line"></span><br><span class="line">		OAuth2Authorization authorization = this.authorizationService.findByToken(</span><br><span class="line">				authorizationCodeAuthentication.getCode(), AUTHORIZATION_CODE_TOKEN_TYPE);</span><br><span class="line">		if (authorization == null) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line">		OAuth2Authorization.Token&lt;OAuth2AuthorizationCode&gt; authorizationCode =</span><br><span class="line">				authorization.getToken(OAuth2AuthorizationCode.class);</span><br><span class="line"></span><br><span class="line">		OAuth2AuthorizationRequest authorizationRequest = authorization.getAttribute(</span><br><span class="line">				OAuth2AuthorizationRequest.class.getName());</span><br><span class="line"></span><br><span class="line">		if (!registeredClient.getClientId().equals(authorizationRequest.getClientId())) &#123;</span><br><span class="line">			if (!authorizationCode.isInvalidated()) &#123;</span><br><span class="line">				// Invalidate the authorization code given that a different client is attempting to use it</span><br><span class="line">				authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());</span><br><span class="line">				this.authorizationService.save(authorization);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (StringUtils.hasText(authorizationRequest.getRedirectUri()) &amp;&amp;</span><br><span class="line">				!authorizationRequest.getRedirectUri().equals(authorizationCodeAuthentication.getRedirectUri())) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!authorizationCode.isActive()) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// @formatter:off</span><br><span class="line">		DefaultOAuth2TokenContext.Builder tokenContextBuilder = DefaultOAuth2TokenContext.builder()</span><br><span class="line">				.registeredClient(registeredClient)</span><br><span class="line">				.principal(authorization.getAttribute(Principal.class.getName()))</span><br><span class="line">				.providerContext(ProviderContextHolder.getProviderContext())</span><br><span class="line">				.authorization(authorization)</span><br><span class="line">				.authorizedScopes(authorization.getAttribute(OAuth2Authorization.AUTHORIZED_SCOPE_ATTRIBUTE_NAME))</span><br><span class="line">				.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">				.authorizationGrant(authorizationCodeAuthentication);</span><br><span class="line">		// @formatter:on</span><br><span class="line"></span><br><span class="line">		OAuth2Authorization.Builder authorizationBuilder = OAuth2Authorization.from(authorization);</span><br><span class="line"></span><br><span class="line">		// ----- Access token -----</span><br><span class="line">		OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();</span><br><span class="line">		OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">		if (generatedAccessToken == null) &#123;</span><br><span class="line">			OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">					&quot;The token generator failed to generate the access token.&quot;, ERROR_URI);</span><br><span class="line">			throw new OAuth2AuthenticationException(error);</span><br><span class="line">		&#125;</span><br><span class="line">		OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,</span><br><span class="line">				generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),</span><br><span class="line">				generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());</span><br><span class="line">		if (generatedAccessToken instanceof ClaimAccessor) &#123;</span><br><span class="line">			authorizationBuilder.token(accessToken, (metadata) -&gt;</span><br><span class="line">					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, ((ClaimAccessor) generatedAccessToken).getClaims()));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			authorizationBuilder.accessToken(accessToken);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// ----- Refresh token -----</span><br><span class="line">		OAuth2RefreshToken refreshToken = null;</span><br><span class="line">		if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &amp;&amp;</span><br><span class="line">				// Do not issue refresh token to public client</span><br><span class="line">				!clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) &#123;</span><br><span class="line"></span><br><span class="line">			tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();</span><br><span class="line">			OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">			if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) &#123;</span><br><span class="line">				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">						&quot;The token generator failed to generate the refresh token.&quot;, ERROR_URI);</span><br><span class="line">				throw new OAuth2AuthenticationException(error);</span><br><span class="line">			&#125;</span><br><span class="line">			refreshToken = (OAuth2RefreshToken) generatedRefreshToken;</span><br><span class="line">			authorizationBuilder.refreshToken(refreshToken);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// ----- ID token -----</span><br><span class="line">		OidcIdToken idToken;</span><br><span class="line">		if (authorizationRequest.getScopes().contains(OidcScopes.OPENID)) &#123;</span><br><span class="line">			tokenContext = tokenContextBuilder.tokenType(ID_TOKEN_TOKEN_TYPE).build();</span><br><span class="line">			OAuth2Token generatedIdToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">			if (!(generatedIdToken instanceof Jwt)) &#123;</span><br><span class="line">				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">						&quot;The token generator failed to generate the ID token.&quot;, ERROR_URI);</span><br><span class="line">				throw new OAuth2AuthenticationException(error);</span><br><span class="line">			&#125;</span><br><span class="line">			idToken = new OidcIdToken(generatedIdToken.getTokenValue(), generatedIdToken.getIssuedAt(),</span><br><span class="line">					generatedIdToken.getExpiresAt(), ((Jwt) generatedIdToken).getClaims());</span><br><span class="line">			authorizationBuilder.token(idToken, (metadata) -&gt;</span><br><span class="line">					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, idToken.getClaims()));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			idToken = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		authorization = authorizationBuilder.build();</span><br><span class="line"></span><br><span class="line">		// Invalidate the authorization code as it can only be used once</span><br><span class="line">		authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());</span><br><span class="line"></span><br><span class="line">		this.authorizationService.save(authorization);</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; additionalParameters = Collections.emptyMap();</span><br><span class="line">		if (idToken != null) &#123;</span><br><span class="line">			additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">			additionalParameters.put(OidcParameterNames.ID_TOKEN, idToken.getTokenValue());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return new OAuth2AccessTokenAuthenticationToken(</span><br><span class="line">				registeredClient, clientPrincipal, accessToken, refreshToken, additionalParameters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">		return OAuth2AuthorizationCodeAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到token的生成详细信息。</p>
<h3 id="自定义授权扩展"><a href="#自定义授权扩展" class="headerlink" title="自定义授权扩展"></a>自定义授权扩展</h3><p>以此为参展自定义一个模式总共需要三个类</p>
<p>OAuth2PasswordAuthenticationConverter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationConverter  implements AuthenticationConverter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication convert(HttpServletRequest request) &#123;</span><br><span class="line">        // grant_type (REQUIRED)</span><br><span class="line">        String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE);</span><br><span class="line">        if (!AuthorizationGrantType.PASSWORD.getValue().equals(grantType)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, String&gt; parameters = getParameters(request);</span><br><span class="line"></span><br><span class="line">        // username (REQUIRED)</span><br><span class="line">        String username = parameters.getFirst(OAuth2ParameterNames.USERNAME);</span><br><span class="line">        if (StrUtil.isEmpty(username) ||</span><br><span class="line">                parameters.get(OAuth2ParameterNames.USERNAME).size() != 1) &#123;</span><br><span class="line">            throw new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_NOT_EXIST, &quot;username cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // password (REQUIRED)</span><br><span class="line">        String password = parameters.getFirst(OAuth2ParameterNames.PASSWORD);</span><br><span class="line">        if (StrUtil.isEmpty(password) ||</span><br><span class="line">                parameters.get(OAuth2ParameterNames.PASSWORD).size() != 1) &#123;</span><br><span class="line">            throw new LuckOAuth2AuthencticationException(ResponseStatusEnum.PASSWORD_INCORRECT, &quot;password cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">        parameters.forEach((key, value) -&gt; &#123;</span><br><span class="line">            if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) &amp;&amp;</span><br><span class="line">                    !key.equals(OAuth2ParameterNames.USERNAME) &amp;&amp;</span><br><span class="line">                    !key.equals(OAuth2ParameterNames.PASSWORD)) &#123;</span><br><span class="line">                additionalParameters.put(key, value.get(0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return new OAuth2PasswordAuthenticationToken(username, password, clientPrincipal, additionalParameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MultiValueMap&lt;String, String&gt; getParameters(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; parameters = new LinkedMultiValueMap&lt;&gt;(parameterMap.size());</span><br><span class="line">        parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line">            if (values.length &gt; 0) &#123;</span><br><span class="line">                for (String value : values) &#123;</span><br><span class="line">                    parameters.add(key, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OAuth2PasswordAuthenticationToken</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationToken extends OAuth2AuthorizationGrantAuthenticationToken &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private final String username;</span><br><span class="line">    @Getter</span><br><span class="line">    private final String password;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &#123;@code OAuth2PasswordAuthenticationToken&#125; using the provided parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param username             the username</span><br><span class="line">     * @param password             the password</span><br><span class="line">     * @param clientPrincipal      the authenticated client principal</span><br><span class="line">     * @param additionalParameters the additional parameters</span><br><span class="line">     */</span><br><span class="line">    public OAuth2PasswordAuthenticationToken(String username, String password, Authentication clientPrincipal,</span><br><span class="line">                                                Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">        super(AuthorizationGrantType.PASSWORD, clientPrincipal, additionalParameters);</span><br><span class="line">        Assert.hasText(username, &quot;username cannot be empty&quot;);</span><br><span class="line">        Assert.hasText(password, &quot;password cannot be empty&quot;);</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OAuth2PasswordAuthenticationProvider</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">    private static final String ERROR_URI = &quot;https://datatracker.ietf.org/doc/html/rfc6749#section-5.2&quot;;</span><br><span class="line">    private final AuthenticationManager authenticationManager;</span><br><span class="line">    private final OAuth2AuthorizationService authorizationService;</span><br><span class="line">    private final OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &#123;@code OAuth2PasswordAuthenticationProvider&#125; using the provided parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param authorizationService the authorization service</span><br><span class="line">     * @param tokenGenerator       the token generator</span><br><span class="line">     */</span><br><span class="line">    public OAuth2PasswordAuthenticationProvider(AuthenticationManager authenticationManager,</span><br><span class="line">                                                OAuth2AuthorizationService authorizationService,</span><br><span class="line">                                                OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator) &#123;</span><br><span class="line">        Assert.notNull(authenticationManager, &quot;authenticationManager cannot be null&quot;);</span><br><span class="line">        Assert.notNull(authorizationService, &quot;authorizationService cannot be null&quot;);</span><br><span class="line">        Assert.notNull(tokenGenerator, &quot;tokenGenerator cannot be null&quot;);</span><br><span class="line">        this.authenticationManager = authenticationManager;</span><br><span class="line">        this.authorizationService = authorizationService;</span><br><span class="line">        this.tokenGenerator = tokenGenerator;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">        OAuth2PasswordAuthenticationToken passwordAuthentication = (OAuth2PasswordAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">        OAuth2ClientAuthenticationToken clientPrincipal = getAuthenticatedClientElseThrowInvalidClient(passwordAuthentication);</span><br><span class="line">        RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();</span><br><span class="line">        Assert.notNull(registeredClient, &quot;registeredClient cannot be null&quot;);</span><br><span class="line"></span><br><span class="line">        if (!registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.PASSWORD)) &#123;</span><br><span class="line">            throw new OAuth2AuthenticationException(OAuth2ErrorCodes.UNAUTHORIZED_CLIENT);</span><br><span class="line">        &#125;</span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;Retrieved registered client&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Attempts to authenticate the passwordAuthentication</span><br><span class="line">        Authentication authenticate = authenticate(passwordAuthentication);</span><br><span class="line"></span><br><span class="line">        DefaultOAuth2TokenContext.Builder tokenContextBuilder = getTokenContextBuilder(passwordAuthentication,</span><br><span class="line">                registeredClient, authenticate);</span><br><span class="line"></span><br><span class="line">        OAuth2Authorization.Builder authorizationBuilder = getAuthorizationBuilder(passwordAuthentication,</span><br><span class="line">                registeredClient);</span><br><span class="line"></span><br><span class="line">        OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();</span><br><span class="line"></span><br><span class="line">        // ----- Access token -----</span><br><span class="line">        OAuth2AccessToken accessToken = getAccessToken(authorizationBuilder, tokenContext);</span><br><span class="line"></span><br><span class="line">        // ----- Refresh token -----</span><br><span class="line">        OAuth2RefreshToken refreshToken = getRefreshToken(clientPrincipal, registeredClient, tokenContextBuilder, authorizationBuilder);</span><br><span class="line"></span><br><span class="line">        return new OAuth2AccessTokenAuthenticationToken(</span><br><span class="line">                registeredClient, clientPrincipal, accessToken, refreshToken, passwordAuthentication.getAdditionalParameters());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Authentication authenticate(OAuth2PasswordAuthenticationToken passwordAuthentication) &#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken token =</span><br><span class="line">                new UsernamePasswordAuthenticationToken(passwordAuthentication.getUsername(),</span><br><span class="line">                        passwordAuthentication.getPassword());</span><br><span class="line">        Authentication authenticate;</span><br><span class="line">        try &#123;</span><br><span class="line">            authenticate = authenticationManager.authenticate(token);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw oAuth2AuthenticationException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return authenticate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static DefaultOAuth2TokenContext.Builder getTokenContextBuilder(</span><br><span class="line">            OAuth2PasswordAuthenticationToken passwordAuthentication,</span><br><span class="line">            RegisteredClient registeredClient,</span><br><span class="line">            Authentication authenticate) &#123;</span><br><span class="line">        return DefaultOAuth2TokenContext.builder()</span><br><span class="line">                .registeredClient(registeredClient)</span><br><span class="line">                .principal(authenticate)</span><br><span class="line">                .providerContext(ProviderContextHolder.getProviderContext())</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.PASSWORD)</span><br><span class="line">                .authorizationGrant(passwordAuthentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static OAuth2Authorization.Builder getAuthorizationBuilder(</span><br><span class="line">            OAuth2PasswordAuthenticationToken passwordAuthentication,</span><br><span class="line">            RegisteredClient registeredClient) &#123;</span><br><span class="line">        return OAuth2Authorization.withRegisteredClient(registeredClient)</span><br><span class="line">                .principalName(passwordAuthentication.getName())</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OAuth2AccessToken getAccessToken(OAuth2Authorization.Builder authorizationBuilder,</span><br><span class="line">                                             OAuth2TokenContext tokenContext) &#123;</span><br><span class="line">        OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">        if (generatedAccessToken == null) &#123;</span><br><span class="line">            OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">                    &quot;The token generator failed to generate the access token.&quot;, ERROR_URI);</span><br><span class="line">            throw new OAuth2AuthenticationException(error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;Generated access token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,</span><br><span class="line">                generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),</span><br><span class="line">                generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());</span><br><span class="line">        if (generatedAccessToken instanceof ClaimAccessor) &#123;</span><br><span class="line">            authorizationBuilder.token(accessToken, (metadata) -&gt;</span><br><span class="line">                    metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME,</span><br><span class="line">                            ((ClaimAccessor) generatedAccessToken).getClaims()));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            authorizationBuilder.accessToken(accessToken);</span><br><span class="line">        &#125;</span><br><span class="line">        return accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OAuth2RefreshToken getRefreshToken(OAuth2ClientAuthenticationToken clientPrincipal,</span><br><span class="line">                                               RegisteredClient registeredClient,</span><br><span class="line">                                               DefaultOAuth2TokenContext.Builder tokenContextBuilder,</span><br><span class="line">                                               OAuth2Authorization.Builder authorizationBuilder) &#123;</span><br><span class="line">        OAuth2TokenContext tokenContext;</span><br><span class="line">        OAuth2RefreshToken refreshToken = null;</span><br><span class="line">        if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &amp;&amp;</span><br><span class="line">                // Do not issue refresh token to public client</span><br><span class="line">                !clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) &#123;</span><br><span class="line"></span><br><span class="line">            tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();</span><br><span class="line">            OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">            if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) &#123;</span><br><span class="line">                OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">                        &quot;The token generator failed to generate the refresh token.&quot;,ERROR_URI);</span><br><span class="line">                throw new OAuth2AuthenticationException(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Generated refresh token&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            refreshToken = (OAuth2RefreshToken) generatedRefreshToken;</span><br><span class="line">            authorizationBuilder.refreshToken(refreshToken);</span><br><span class="line"></span><br><span class="line">            this.authorizationService.save(authorizationBuilder.build());</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Saved authorization&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">        return OAuth2PasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * OAuth2 认证失败处理器只能处理 OAuth2AuthenticationException，故转换</span><br><span class="line">     *</span><br><span class="line">     * @param authenticationException 身份验证异常</span><br><span class="line">     * @return &#123;@link OAuth2AuthenticationException&#125;</span><br><span class="line">     */</span><br><span class="line">    private OAuth2AuthenticationException oAuth2AuthenticationException(Exception authenticationException) &#123;</span><br><span class="line">        if (authenticationException instanceof UsernameNotFoundException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof BadCredentialsException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.USERNAME_OR_PASSWORD_INCORRECT);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof LockedException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_FROZEN);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof AccountExpiredException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_EXPIRED);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof CredentialsExpiredException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.PASSWORD_EXPIRED);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof InternalAuthenticationServiceException) &#123;</span><br><span class="line">            if (authenticationException.getCause() instanceof DisabledException) &#123;</span><br><span class="line">                return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_DISABLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new LuckOAuth2AuthencticationException(ResponseStatusEnum.IDENTITY_VERIFICATION_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">    public OAuth2ClientAuthenticationToken getAuthenticatedClientElseThrowInvalidClient(Authentication authentication) &#123;</span><br><span class="line">        OAuth2ClientAuthenticationToken clientPrincipal = null;</span><br><span class="line">        if (OAuth2ClientAuthenticationToken.class.isAssignableFrom(authentication.getPrincipal().getClass())) &#123;</span><br><span class="line">            clientPrincipal = (OAuth2ClientAuthenticationToken) authentication.getPrincipal();</span><br><span class="line">        &#125;</span><br><span class="line">        if (clientPrincipal != null &amp;&amp; clientPrincipal.isAuthenticated()) &#123;</span><br><span class="line">            return clientPrincipal;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_CLIENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果需要自定义claims可以添加一个自定义OAuth2TokenCustomizer</p>
<p>这里以OAuth2TokenCustomizerImpl为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class OAuth2TokenCustomizerImpl implements OAuth2TokenCustomizer&lt;JwtEncodingContext&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void customize(JwtEncodingContext context) &#123;</span><br><span class="line">        JwtClaimsSet.Builder builder = context.getClaims();</span><br><span class="line"></span><br><span class="line">        // 客户端模式不返回具体用户信息</span><br><span class="line">        if (SecurityConstants.CLIENT_CREDENTIALS.equals(context.getAuthorizationGrantType().getValue())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User user = (User) context.getPrincipal().getPrincipal();</span><br><span class="line">        builder.claims((claims) -&gt; &#123;</span><br><span class="line">            claims.put(&quot;username&quot;, user.getUsername());</span><br><span class="line">            claims.put(&quot;authorities&quot;, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toArray());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>自定义鉴权成功或者鉴权失败代码可以参照</p>
<p>DefaultAuthenticationFailureHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAuthenticationFailureHandler implements AuthenticationFailureHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String AUTHENTICATION_METHOD = &quot;authentication_method&quot;;</span><br><span class="line">    private static final String CREDENTIALS = &quot;credentials&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123;</span><br><span class="line">        AjaxResult&lt;?&gt; error = createError(exception);</span><br><span class="line"></span><br><span class="line">            ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(error, servletServerHttpResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 创建 error</span><br><span class="line">         *</span><br><span class="line">         * @param exception /</span><br><span class="line">         * @return /</span><br><span class="line">         */</span><br><span class="line">        private AjaxResult&lt;?&gt; createError(AuthenticationException exception) &#123;</span><br><span class="line">            AjaxResult&lt;?&gt; error = null;</span><br><span class="line"></span><br><span class="line">            if (exception instanceof LuckOAuth2AuthencticationException) &#123;</span><br><span class="line">                error = AjaxResult.error(((LuckOAuth2AuthencticationException) exception).getCode(),</span><br><span class="line">                        exception.getMessage());</span><br><span class="line">            &#125; else if (exception instanceof OAuth2AuthenticationException) &#123;</span><br><span class="line">                OAuth2AuthenticationException oAuth2AuthenticationException= (OAuth2AuthenticationException) exception;</span><br><span class="line">                String errorCode = oAuth2AuthenticationException.getError().getErrorCode();</span><br><span class="line">                String description = oAuth2AuthenticationException.getError().getDescription();</span><br><span class="line">                if (OAuth2ErrorCodes.INVALID_CLIENT.equals(errorCode))&#123;</span><br><span class="line">                    if (StrUtil.isEmpty(description)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, &quot;无效的客户端&quot;);</span><br><span class="line">                    &#125; else if (description.contains(OAuth2ParameterNames.CLIENT_ID)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_NOT_EXIST);</span><br><span class="line">                    &#125; else if (description.contains(AUTHENTICATION_METHOD)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.AUTHORIZATION_DENIED);</span><br><span class="line">                    &#125; else if (description.contains(CREDENTIALS)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_PASSWORD_EMPTY);</span><br><span class="line">                    &#125; else if (description.contains(OAuth2ParameterNames.CLIENT_SECRET)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_PASSWORD_INCORRECT);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                switch (errorCode) &#123;</span><br><span class="line">                    case OAuth2ErrorCodes.UNSUPPORTED_GRANT_TYPE :</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.UNSUPPORTED_GRANT_TYPE);</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_REQUEST : &#123;</span><br><span class="line">                        if (StrUtil.isEmpty(description)) &#123;</span><br><span class="line">                            return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, &quot;无效的客户端&quot;);</span><br><span class="line">                        &#125; else if (description.contains(OAuth2ParameterNames.GRANT_TYPE)) &#123;</span><br><span class="line">                            return AjaxResult.error(ResponseStatusEnum.GRANT_TYPE_EMPTY);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_GRANT : return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT);</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_SCOPE : return AjaxResult.error(ResponseStatusEnum.INVALID_SCOPE);</span><br><span class="line">                    case OAuth2ErrorCodes.UNAUTHORIZED_CLIENT :</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED_CLIENT);</span><br><span class="line">                    default : error = AjaxResult.error(ResponseStatusEnum.USER_LOGIN_ABNORMAL.getCode(),</span><br><span class="line">                            oAuth2AuthenticationException.getError().getErrorCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error = AjaxResult.error(ResponseStatusEnum.USER_LOGIN_ABNORMAL, exception.getLocalizedMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DefaultAuthenticationSuccessHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定响应数据不使用 ResponseData 封装的参数名称</span><br><span class="line">     * Swagger 登录时可用</span><br><span class="line">     */</span><br><span class="line">    private static final String NO_RESPONSE_DATA_PARAM_NAME = &quot;no_response_data&quot;;</span><br><span class="line"></span><br><span class="line">    private final Converter&lt;OAuth2AccessTokenResponse, Map&lt;String, Object&gt;&gt; accessTokenResponseParametersConverter =</span><br><span class="line">            new DefaultOAuth2AccessTokenResponseMapConverter();</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">        OAuth2AccessTokenAuthenticationToken accessTokenAuthentication = (OAuth2AccessTokenAuthenticationToken) authentication;</span><br><span class="line">        OAuth2AccessToken accessToken = accessTokenAuthentication.getAccessToken();</span><br><span class="line">        OAuth2RefreshToken refreshToken = accessTokenAuthentication.getRefreshToken();</span><br><span class="line">        Map&lt;String, Object&gt; additionalParameters = accessTokenAuthentication.getAdditionalParameters();</span><br><span class="line">        OAuth2AccessTokenResponse.Builder builder = OAuth2AccessTokenResponse.withToken(accessToken.getTokenValue())</span><br><span class="line">                .tokenType(accessToken.getTokenType()).scopes(accessToken.getScopes());</span><br><span class="line">        if (accessToken.getIssuedAt() != null &amp;&amp; accessToken.getExpiresAt() != null) &#123;</span><br><span class="line">            builder.expiresIn(ChronoUnit.SECONDS.between(accessToken.getIssuedAt(), accessToken.getExpiresAt()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (refreshToken != null) &#123;</span><br><span class="line">            builder.refreshToken(refreshToken.getTokenValue());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!CollectionUtils.isEmpty(additionalParameters)) &#123;</span><br><span class="line">            builder.additionalParameters(additionalParameters);</span><br><span class="line">        &#125;</span><br><span class="line">        OAuth2AccessTokenResponse accessTokenResponse = builder.build();</span><br><span class="line">        Map&lt;String, Object&gt; tokenResponseParameters = this.accessTokenResponseParametersConverter.convert(accessTokenResponse);</span><br><span class="line">        ServletServerHttpResponse httpResponse = new ServletServerHttpResponse(response);</span><br><span class="line"></span><br><span class="line">        boolean noResponseData = Boolean.parseBoolean(request.getParameter(NO_RESPONSE_DATA_PARAM_NAME));</span><br><span class="line">        if (noResponseData) &#123;</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(tokenResponseParameters, httpResponse);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AjaxResult&lt;Map&lt;String, Object&gt;&gt; responseData = AjaxResult.ok(tokenResponseParameters);</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(responseData, httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然如果你需要自定义获取用户信息重写UserDetailsService，和其他版本的一致就好</p>
<h3 id="自定义配置信息"><a href="#自定义配置信息" class="headerlink" title="自定义配置信息"></a>自定义配置信息</h3><p>当代码逻辑写完之后需要增加配置让代码生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个Spring security 的过滤器链，默认会配置</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Introspection endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Revocation endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization Server Metadata endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * JWK Set endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 Provider Configuration endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 UserInfo endpoint</span><br><span class="line">     * 这些协议端点，只有配置了他才能够访问的到接口地址（类似mvc的controller）。</span><br><span class="line">     *</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(1)</span><br><span class="line">    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        OAuth2AuthorizationServerConfigurer&lt;HttpSecurity&gt; authorizationServerConfigurer =</span><br><span class="line">                new OAuth2AuthorizationServerConfigurer&lt;&gt;();</span><br><span class="line">        http.apply(authorizationServerConfigurer);</span><br><span class="line">        authorizationServerConfigurer</span><br><span class="line">                .authorizationService(authorizationService())</span><br><span class="line">                .tokenEndpoint(tokenEndpoint-&gt;tokenEndpoint</span><br><span class="line">                                .accessTokenRequestConverter(new OAuth2PasswordAuthenticationConverter())</span><br><span class="line">                                .accessTokenResponseHandler(responseDataAuthenticationSuccessHandler())</span><br><span class="line">                                .errorResponseHandler(authenticationFailureHandler()));</span><br><span class="line">        DefaultSecurityFilterChain chain = http</span><br><span class="line">                .requestMatcher(authorizationServerConfigurer.getEndpointsMatcher())</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt;</span><br><span class="line">                        authorize.anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                .csrf(CsrfConfigurer::disable)</span><br><span class="line">                .build();</span><br><span class="line">        addingAdditionalAuthenticationProvider(http);</span><br><span class="line">        return chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个也是个Spring Security的过滤器链，用于Spring Security的身份认证。</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(2)</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                // Form login handles the redirect to the login page from the</span><br><span class="line">                // authorization server filter chain</span><br><span class="line">                .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationSuccessHandler responseDataAuthenticationSuccessHandler() &#123;</span><br><span class="line">        return new DefaultAuthenticationSuccessHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationFailureHandler authenticationFailureHandler() &#123;</span><br><span class="line">        return new DefaultAuthenticationFailureHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置用户信息，或者配置用户数据来源，主要用于用户的检索。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">//        UserDetails userDetails = User.withDefaultPasswordEncoder()</span><br><span class="line">//                .username(&quot;user&quot;)</span><br><span class="line">//                .password(&quot;password&quot;)</span><br><span class="line">//                .roles(&quot;USER&quot;)</span><br><span class="line">//                .build();</span><br><span class="line">//       return new InMemoryUserDetailsManager();</span><br><span class="line"></span><br><span class="line">        return new OAuth2UserDetailsManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * oauth2 用于第三方认证，RegisteredClientRepository 主要用于管理第三方（每个第三方就是一个客户端）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RegisteredClientRepository registeredClientRepository() &#123;</span><br><span class="line">//        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">//                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">//                .clientSecret(&quot;&#123;noop&#125;secret&quot;)</span><br><span class="line">//                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/authorized&quot;)</span><br><span class="line">//                .scope(OidcScopes.OPENID)</span><br><span class="line">//                .scope(&quot;message.read&quot;)</span><br><span class="line">//                .scope(&quot;message.write&quot;)</span><br><span class="line">//                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">//                .build();</span><br><span class="line">//</span><br><span class="line">//        return new InMemoryRegisteredClientRepository(registeredClient);</span><br><span class="line">        return new JdbcRegisteredClientRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationService authorizationService()&#123;</span><br><span class="line">        return new OAuth2RedisAuthorizationService(redisService);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 用于给access_token签名使用。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JWKSource&lt;SecurityContext&gt; jwkSource() &#123;</span><br><span class="line">        KeyPair keyPair = generateRsaKey();</span><br><span class="line">        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        RSAKey rsaKey = new RSAKey.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        JWKSet jwkSet = new JWKSet(rsaKey);</span><br><span class="line">        return new ImmutableJWKSet&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成秘钥对，为jwkSource提供服务。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static KeyPair generateRsaKey() &#123;</span><br><span class="line">        KeyPair keyPair;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            keyPairGenerator.initialize(2048);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置Authorization Server实例</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ProviderSettings providerSettings() &#123;</span><br><span class="line">        return ProviderSettings.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void addingAdditionalAuthenticationProvider(HttpSecurity http) &#123;</span><br><span class="line">        AuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class);</span><br><span class="line">        OAuth2AuthorizationService authorizationService = http.getSharedObject(OAuth2AuthorizationService.class);</span><br><span class="line">        OAuth2TokenGenerator&lt;?&gt; tokenGenerator = http.getSharedObject(OAuth2TokenGenerator.class);</span><br><span class="line"></span><br><span class="line">        OAuth2PasswordAuthenticationProvider passwordAuthenticationProvider =</span><br><span class="line">                new OAuth2PasswordAuthenticationProvider(authenticationManager, authorizationService, tokenGenerator);</span><br><span class="line">        http.authenticationProvider(passwordAuthenticationProvider);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>备注：</p>
<p>registeredClientRepository 客户端信息</p>
<p>authorizationService token新增和处理</p>
<p>providerSettings  访问端点配置 默认为：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679126686151-d9dce2ff-ee10-4965-9c54-2744170deb62.png"></p>
<p>addingAdditionalAuthenticationProvider</p>
<p><code>OAuth2TokenEndpointConfigurer</code> 并没有提供批量设置 <code>AuthenticationProvider</code> 的方法，即，如果你要同时配置 authorization_code、refresh_token、client_credentials、password 的 <code>AuthenticationProvider</code> 的话，你需要调用多次 <code>accessTokenResponseHandler() </code>但是<code>HttpSecurity</code>提供了一个 <code>authenticationProvider()</code> 可以动态添加 <code>AuthenticationProvider</code></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>新版本的spring-authorization-server不同于原来的oauth2的版本，去除了密码模式，让很多简单的自定义登陆变的很麻烦，但是其中可自定义的地方有很多</p>
<p>Converter ：从访问令牌中获取参数，并格式化</p>
<p>Provider ：主处理器用于生成token以及保存token</p>
<p>AuthorizationService ：保存token信息，获取token信息</p>
<p>ResponseHandler ：返回信息处理</p>
<p>Token：格式化访问信息为Provider提供数据</p>
<p>Customizer ：自定义claims信息数据可以从context.getPrincipal().getPrincipal()中获取</p>
<p>Manager ：自定义获取用户信息逻辑</p>
<p>当然如果你不希望这么麻烦想要更简单的实现登陆，可以自定义<font style="color:rgb(25, 30, 30);">consentPage页面然后在自定义的consentPage中增加脚本自动提交表单获取令牌</font></p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudGateway详解</title>
    <url>/2024/03/25/SpringCloudGateway%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Spring-Cloud-Gateway-的核心功能："><a href="#Spring-Cloud-Gateway-的核心功能：" class="headerlink" title="Spring Cloud Gateway 的核心功能："></a><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway 的核心功能：</font></h2><p><font style="color:rgb(25, 27, 31);">断言（Predicate）：参照 Java8 的新特性Predicate，允许开发人员匹配 HTTP 请求中的任何内容，比如请求头或请求参数，最后根据匹配结果返回一个布尔值。 路由（route）：由ID、目标URI、断言集合和过滤器集合组成。如果聚合断言结果为真，则转发到该路由。 过滤器（filter）：可以在返回请求之前或之后修改请求和响应的内容。</font></p>
<span id="more"></span>
<h2 id="1、路由-Route"><a href="#1、路由-Route" class="headerlink" title="1、路由 Route"></a><font style="color:rgb(25, 27, 31);">1、路由 Route</font></h2><p><font style="color:rgb(25, 27, 31);">Route 主要由 路由id、目标uri、断言集合和过滤器集合组成，那我们简单看看这些属性到底有什么作用。 （1）id：路由标识，要求唯一，名称任意（默认值 uuid，一般不用，需要自定义） （2）uri：请求最终被转发到的目标地址 （3）order： 路由优先级，数字越小，优先级越高 （4）predicates：断言数组，即判断条件，如果返回值是boolean，则转发请求到 uri 属性指定的服务中 （5）filters：过滤器数组，在请求传递过程中，对请求做一些修改</font></p>
<h2 id="2、断言-Predicate"><a href="#2、断言-Predicate" class="headerlink" title="2、断言 Predicate"></a><font style="color:rgb(25, 27, 31);">2、断言 Predicate</font></h2><p><font style="color:rgb(25, 27, 31);">Predicate 来自于 Java8 的借口。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。 Predicate 可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。Spring Cloud Gateway 内置了许多 Predict，这些 Predict 的源码在 org.springframework.cloud.gateway.handler.predicate 包中，有兴趣可以阅读一下</font></p>
<h2 id="3、过滤器-filter"><a href="#3、过滤器-filter" class="headerlink" title="3、过滤器 filter"></a><font style="color:rgb(25, 27, 31);">3、过滤器 filter</font></h2><p><font style="color:rgb(25, 27, 31);">Gateway 过滤器的生命周期： PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。 POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。 Gateway 过滤器从作用范围可分为两种: GatewayFilter：应用到单个路由或者一个分组的路由上（需要在配置文件中配置） GlobalFilter：应用到所有的路由上（无需配置，全局生效） （1）局部过滤器 GatewayFilter： Spring Cloud Gateway 中内置了许多的局部过滤器；局部过滤器需要在指定路由配置才能生效，默认是不生效的</font></p>
<p><font style="color:rgb(25, 27, 31);">（2）自定义局部过滤器： 虽说内置的过滤器能够解决很多场景，但是难免还是有些特殊需求需要定制一个过滤器，下面就来介绍一下如何自定义局部过滤器。</font></p>
<p><font style="color:rgb(25, 27, 31);">(3) GlobalFilter 全局过滤器： 全局过滤器应用全部路由上，无需开发者配置，Spring Cloud Gateway 也内置了一些全局过滤器。GlobalFilter 的功能其实和 GatewayFilter 是相同的，只是 GlobalFilter 的作用域是所有的路由配置，而不是绑定在指定的路由配置上。多个 GlobalFilter 可以通过 @Order 或者 getOrder() 方法指定执行顺序，order值越小，执行的优先级越高。 注意，由于过滤器有 pre 和 post 两种类型，pre 类型过滤器如果 order 值越小，那么它就应该在pre过滤器链的顶层，post 类型过滤器如果 order 值越小，那么它就应该在 post 过滤器链的底层</font></p>
<p><font style="color:rgb(25, 27, 31);">(4) 过滤器规则（Filter）</font></p>
<p><font style="color:rgb(25, 27, 31);">过滤规则 实例 说明 PrefixPath - PrefixPath&#x3D;&#x2F;app 在请求路径前加上app RewritePath - RewritePath&#x3D;&#x2F;test, &#x2F;app&#x2F;test 访问localhost:9022&#x2F;test,请求会转发到localhost:8001&#x2F;app&#x2F;test SetPath SetPath&#x3D;&#x2F;app&#x2F;{path} 通过模板设置路径，转发的规则时会在路径前增加app，{path}表示原请求路径 RedirectTo 重定向 RemoveRequestHeader 去掉某个请求头信息 注：当配置多个filter时，优先定义的会被调用，剩余的filter将不会生效</font></p>
<h2 id="4、Predicate-断言条件-转发规则-介绍"><a href="#4、Predicate-断言条件-转发规则-介绍" class="headerlink" title="4、Predicate 断言条件(转发规则)介绍"></a><font style="color:rgb(25, 27, 31);">4、Predicate 断言条件(转发规则)介绍</font></h2><p><font style="color:rgb(25, 27, 31);">每一个Predicate的使用，你可以理解为：当满足这种条件后才会被转发，如果是多个，那就是都满足的情况下被转发。</font></p>
<h2 id="Path-方式匹配转发"><a href="#Path-方式匹配转发" class="headerlink" title="Path 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Path 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">通过Path转发示例，我们讲解下上面的两种配置，分别是application.yml以及RouteLocator。</font></p>
<p><font style="color:rgb(25, 27, 31);">配置文件匹配地址转发</font></p>
<p><font style="color:rgb(25, 27, 31);">我们在application.yml配置文件内添加对应的路由配置，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"></span><br><span class="line">application:</span><br><span class="line"></span><br><span class="line">name: spring-cloud-gateway-sample</span><br><span class="line"></span><br><span class="line">cloud:</span><br><span class="line"></span><br><span class="line">gateway:</span><br><span class="line"></span><br><span class="line">routes:</span><br><span class="line"></span><br><span class="line">- id: blog</span><br><span class="line"></span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line"></span><br><span class="line">predicates:</span><br><span class="line"></span><br><span class="line"># 匹配路径转发</span><br><span class="line"></span><br><span class="line">- Path=/api-boot-datasource-switch.html</span><br><span class="line"></span><br><span class="line"># 端口号</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line"></span><br><span class="line">port: 9090</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><strong><font style="color:rgb(25, 27, 31);">先来解释下route的组成部分：</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">id：路由的ID uri：匹配路由的转发地址 predicates：配置该路由的断言，通过PredicateDefinition类进行接收配置。 在上面的配置中，当访问<a href="http://localhost:9090/api-boot-datasource-switch.html%E6%97%B6%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8F%91%E5%88%B0">http://localhost:9090/api-boot-datasource-switch.html时就会被自动转发到</a></font><a href="https://link.zhihu.com/?target=http://blog.xx.com/api-boot-datasource-switch.html"><font style="color:rgb(25, 27, 31);">http://blog.xx.com/api-boot-datasource-switch.html</font></a><font style="color:rgb(25, 27, 31);">，这里要注意完全匹配Path的值时才会进行路由转发。</font></p>
<p><font style="color:rgb(25, 27, 31);">访问效果如下所示：</font></p>
<p><font style="color:rgb(25, 27, 31);">spring-cloud-gateway-path-predicate.png</font></p>
<p><font style="color:rgb(25, 27, 31);">RouteLocator 匹配路径转发</font></p>
<p><font style="color:rgb(25, 27, 31);">在上面的配置中，如果使用RouteLocator方式该怎么进行配置呢？</font></p>
<p><font style="color:rgb(25, 27, 31);">如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RouteLocator routeLocator(RouteLocatorBuilder builder) &#123;</span><br><span class="line">return builder.routes()</span><br><span class="line">.route(&quot;blog&quot;, r -&gt;</span><br><span class="line">r.path(&quot;/api-boot-datasource-switch.html&quot;).uri(&quot;http://blog.xx.com&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="Before-方式匹配转发"><a href="#Before-方式匹配转发" class="headerlink" title="Before 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Before 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">当部署有访问时间限制的接口时，我们可以通过Before Predicate来完成某一个时间点之前允许访问，过时后则不允许转发请求到具体的服务，配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Before=2019-05-01T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，我们允许2019-05-01日凌晨之前通过路由转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">，通过查看org.springframework.cloud.gateway.handler.predicate.BeforeRoutePredicateFactory源码我们发现，Spring Cloud Gateway的Before断言采用的ZonedDateTime进行匹配时间，这里要注意存在时区的问题，需要配置[Asia&#x2F;Shanghai]作为中国时区。</font></p>
<h2 id="After-方式匹配转发"><a href="#After-方式匹配转发" class="headerlink" title="After 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">After 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">After Predicate与Before配置使用一致，匹配某一个时间点之后允许路由转发，如下所示配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- After=2019-04-29T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中允许2019-04-29凌晨之后进行转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">。</font></p>
<h2 id="Between-方式匹配转发"><a href="#Between-方式匹配转发" class="headerlink" title="Between 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Between 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">那如果是一个时间段内允许请求转发，通过Before、After组合配置也可以完成，不过Spring Cloud Gateway还是提供了Between方式，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Between=2019-04-29T00:00:00+08:00[Asia/Shanghai], 2019-05-01T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，允许在2019-04-29日凌晨后 &amp; 2019-05-01凌晨之前请求转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">。</font></p>
<h2 id="Cookie-方式匹配转发"><a href="#Cookie-方式匹配转发" class="headerlink" title="Cookie 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Cookie 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway 还提供了根据Cookie值的方式匹配转发请求，如果请求中所携带的Cookie值与配置的Predicate匹配，那么就可以被允许转发到指定地址，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Cookie=hengboy, leo</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，如果客户端发送请求时携带了”hengboy&#x3D;leo”的Cookie信息，则允许请求转发。</font></p>
<p><strong><font style="color:rgb(25, 27, 31);">测试Cookie方式转发：</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">curl <a href="http://localhost:9090/">http://localhost:9090</a> –cookie “hengboy&#x3D;leo” 通过上面方式我们是可以成功转发请求的，如果我们修改Cookie的值，就会导致无法转发，出现404。</font></p>
<h2 id="Header-方式匹配转发"><a href="#Header-方式匹配转发" class="headerlink" title="Header 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Header 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以根据发送请求的Header信息进行匹配转发，加入我们可以根据X-Request-Id的值进行匹配，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，如果X-Request-Id的值为数字，那么就可以转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">，我们通过如下方式进行测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">curl <a href="http://localhost:9090/">http://localhost:9090</a> -H “X-Request-Id:123456” 如果头信息为X-Request-Id:abc时，就会转发失败，出现404。</font></p>
<h2 id="Host-方式匹配转发"><a href="#Host-方式匹配转发" class="headerlink" title="Host 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Host 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以根据Host主机名进行匹配转发，如果我们的接口只允许\.</font><a href="https://link.zhihu.com/?target=http://xx.com"><font style="color:rgb(25, 27, 31);">http://xx.com</font></a><font style="color:rgb(25, 27, 31);">域名进行访问，那么配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Host=\*\*.xx.com</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">测试如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. curl http://localhost:9090 -H &quot;Host: xx.com&quot; // 匹配</span><br><span class="line">2. curl http://localhost:9090 -H &quot;Host: api.xx.com&quot; // 匹配</span><br><span class="line">3. curl http://localhost:9090 -H &quot;Host: admin.xx.com&quot; // 匹配</span><br><span class="line">4. curl http://localhost:9090 -H &quot;Host: hengboy.com&quot; // 不匹配</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="请求方式-方式匹配转发"><a href="#请求方式-方式匹配转发" class="headerlink" title="请求方式 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">请求方式 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Rest请求风格的接口内往往会存在多种请求方式的接口，如果我们的接口只允许POST请求访问，那么配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Method=POST</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">发送GET请求测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">~ curl <a href="http://localhost:9090/">http://localhost:9090</a></font></p>
<p><font style="color:rgb(25, 27, 31);">{“timestamp”:”2019-04-29T06:27:41.121+0000”,”path”:”&#x2F;“,”status”:404,”error”:”Not Found”,”message”:null} 我们的请求并未被Spring Cloud Gateway进行转发，那么我们再来通过POST请求进行测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">curl -X POST <a href="http://localhost:9090/">http://localhost:9090</a> 是可以被转发到目标地址uri的，不过我的这个博客是OSS部署的，阿里云限制了POST访问，尽管如此我们也证明了可以转发。</font></p>
<p><font style="color:rgb(25, 27, 31);">请求参数 方式匹配转发 Spring Cloud GateWay还支持根据指定的参数进行匹配，Query方式的Predicate也有两种方式匹配情况，如下所示：</font></p>
<p><font style="color:rgb(25, 27, 31);">请求中存在xxx参数 cloud: gateway: routes: - id: blog uri: </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">predicates: - Query&#x3D;xxx 我们通过curl <a href="http://localhost:9090/?xxx%5C=123%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%88%90%E5%8A%9F%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%8C%E5%8F%AA%E8%A6%81%E5%8F%82%E6%95%B0%E5%AD%98%E5%9C%A8xxx%E5%B0%B1%E4%BC%9A%E8%A2%AB%E6%88%90%E5%8A%9F%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%90%A6%E5%88%99%E5%87%BA%E7%8E%B0404%E8%BD%AC%E5%8F%91%E5%A4%B1%E8%B4%A5%E3%80%82">http://localhost:9090\?xxx\=123是可以被成功转发的，只要参数存在xxx就会被成功转发，否则出现404转发失败。</a></font></p>
<p><font style="color:rgb(25, 27, 31);">请求中存在xxx参数且值为zzz cloud: gateway: routes: - id: blog uri: </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">predicates: - Query&#x3D;xxx, zzz 根据上面配置，我们限定了参数xxx必须为zzz时才会被成功转发，否则同样会出现404抓发失败。</font></p>
<p><font style="color:rgb(25, 27, 31);">请求路径 方式匹配转发 Spring Cloud Gateway提供了请求路径变量方式匹配转发，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Path=/article/&#123;articleId&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">在上面配置中{articleId}是一个路径变量，可以是任意值，匹配&#x2F;article&#x2F;1、&#x2F;article&#x2F;abc等，测试如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ curl http://localhost:9090/article/1 // 匹配</span><br><span class="line">~ curl http://localhost:9090/article/abc // 匹配</span><br><span class="line">~ curl http://localhost:9090/article/1/1 // 不匹配</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="请求IP-方式匹配转发"><a href="#请求IP-方式匹配转发" class="headerlink" title="请求IP 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">请求IP 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以限制允许访问接口的客户端IP地址，配置后只对指定IP地址的客户端进行请求转发，配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- RemoteAddr=192.168.1.56/24</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面我们配置了192.168.1.56&#x2F;24，其中192.168.1.56是客户端的IP地址，而24则是子网掩码。</font></p>
<h2 id="组合示例"><a href="#组合示例" class="headerlink" title="组合示例"></a><font style="color:rgb(25, 27, 31);">组合示例</font></h2><p><font style="color:rgb(25, 27, 31);">相同的Predicate也可以配置多个，请求的转发是必须满足所有的Predicate后才可以进行路由转发，组合使用示例如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Query=author, hengboy</span><br><span class="line">- Query=leo</span><br><span class="line">- Method=GET</span><br><span class="line">- Cookie=hengboy, leo</span><br><span class="line">- Header=X-Request-Id, \d+</span><br><span class="line">- RemoteAddr=192.168.1.56/24</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font style="color:rgb(25, 27, 31);">总结</font></h2><p><font style="color:rgb(25, 27, 31);">本章节讲解了Spring Cloud Gateway的相关谓词、断言基本使用方式，GateWay内部提供了很多种灵活的路由转发规则，在同一个路由内存在多个Predicate时，同时满足规则后请求才会被路由转发。</font></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot项目中引用SpringCloudGateway</title>
    <url>/2024/03/26/springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E7%94%A8SpringCloudGateway/</url>
    <content><![CDATA[<h1 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h1><p>首先我们打开官网可以看到如下的描述：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1672730319068-d939400c-0dc9-466e-ae30-1cff4d5c6783.png"></p>
<span id="more"></span>
<p>SpringCloudGateway旨在提供一种简单而有效的方式来路由到API，并为它们提供跨领域的关注点，例如：安全性、监控&#x2F;度量和弹性。</p>
<!-- more -->
<h1 id="为什么要使用网关"><a href="#为什么要使用网关" class="headerlink" title="为什么要使用网关"></a>为什么要使用网关</h1><p>当我们有多个服务的时候，前端需要访问服务的时候需要在前端维护好这几个服务的路径信息，<font style="color:rgb(0, 0, 0);">这样的架构会有如下几个典型的问题：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">每个微服务都需要配置单独的访问域名，开通外网访问权限，每新增一个服务都需要先让运维人员配置好域名映射</font></li>
<li><font style="color:rgb(1, 1, 1);">客户端需要维护所有微服务的访问地址，试想一下如果微服务有几十几百个呢？</font></li>
<li><font style="color:rgb(1, 1, 1);">当服务需要对接口进行权限控制，必须要认证用户才能调用，那么所有的权限逻辑在服务端都要重新编写一套。</font></li>
</ul>
<p><font style="color:rgb(0, 0, 0);">所以我们需要在微服务之前加一个网关服务，让所有的客户端只要访问网关，网关负责对请求进行转发；将权限校验逻辑放到网关的过滤器中，后端服务不需要再关注权限校验的代码；只需要对外提供一个可供外网访问的域名地址，新增服务后也不需要再让运维人员进行网络配置了，这样上面的架构就变成了通过网关转达到对应的服务</font></p>
<h1 id="如何在springboot项目中引用网关"><a href="#如何在springboot项目中引用网关" class="headerlink" title="如何在springboot项目中引用网关"></a>如何在springboot项目中引用网关</h1><h3 id="增加pom"><a href="#增加pom" class="headerlink" title="增加pom"></a>增加pom</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1672731071359-61f824de-4903-44e6-aba3-515a3f594da3.png"></p>
<p>我们从官网可以看到gateway需要的pom项，因为我们的服务都使用nacos所以需要加上nacos的pom项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--nacos--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(85, 86, 102);">由于springcloud2020弃用了</font><a href="https://so.csdn.net/so/search?q=Ribbon&spm=1001.2101.3001.7020">Ribbon</a><font style="color:rgb(85, 86, 102);">，因此Alibaba在2021版本nacos中删除了Ribbon的jar包，因此无法通过lb路由到指定微服务，出现了503情况。</font></p>
<p><font style="color:rgb(85, 86, 102);">所以只需要引入springcloud loadbalancer包即可</font></p>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LuckGatewayApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(LuckGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bootstap-yml"><a href="#bootstap-yml" class="headerlink" title="bootstap.yml"></a>bootstap.yml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1060</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: luck-gateway</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在nacos中建立网关的路由配置"><a href="#在nacos中建立网关的路由配置" class="headerlink" title="在nacos中建立网关的路由配置"></a><font style="color:rgb(1, 1, 1);">在nacos中建立网关的路由配置</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          lowerCaseServiceId: true</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: luck-uid</span><br><span class="line">        uri: lb://luck-uid</span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/uid/**</span><br><span class="line">        filters:</span><br><span class="line">          - StripPrefix=1</span><br></pre></td></tr></table></figure>



<h3 id="配置详解："><a href="#配置详解：" class="headerlink" title="配置详解："></a><font style="color:rgb(0, 0, 0);">配置详解：</font></h3><p><font style="color:rgb(119, 119, 119);">id: 在所有路由定义中需要唯一，不能重复</font><br><font style="color:rgb(119, 119, 119);">uri: lb:&#x2F;&#x2F;**  lb:&#x2F;&#x2F;为固定写法，表示开启负载均衡； ** 即服务在Nacos中注册的名字</font><br><font style="color:rgb(119, 119, 119);">predicates:- Path&#x3D;&#x2F;</font>uid<font style="color:rgb(119, 119, 119);">&#x2F;** 使用”Path Route Predicate Factory”，规则为&#x2F;</font>uid<font style="color:rgb(119, 119, 119);">&#x2F;** 的请求都还转发至微服务</font>luck-uid<font style="color:rgb(119, 119, 119);">中。</font></p>
<p>filters : - StripPrefix &#x3D;1 <strong><font style="color:rgb(77, 77, 77);">若有StripPrefix过滤器时，gateway会根据StripPrefix&#x3D;1所配的值（这里是1）去掉URL路径中的部分前缀</font></strong><font style="color:rgb(77, 77, 77);">（这里去掉一个前缀，即去掉lbs）</font></p>
<p><font style="color:rgb(0, 0, 0);"></font></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud项目使用nacos</title>
    <url>/2024/03/28/%E4%BD%8E%E4%BE%B5%E5%85%A5%E7%9A%84%E7%81%B0%E5%BA%A6%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="设计简介："><a href="#设计简介：" class="headerlink" title="设计简介："></a>设计简介：</h3><p>灰度平台配置的主键是以域名来做主键配置，以域名来关联规则，依托这些规则来判断哪些哪些请求需要走灰度</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/jpeg/25873401/1701237832373-b55015c3-0ea5-468c-bb8f-f849cbc5daba.jpeg" alt="画板"></p>
<span id="more"></span>
<h3 id="为什么要做这个平台"><a href="#为什么要做这个平台" class="headerlink" title="为什么要做这个平台"></a>为什么要做这个平台</h3><p>系统的稳定性，多有2方面造成</p>
<p>1.生产环境运行期间，异常造成的服务宕机，造成的系统不可用。</p>
<p>2.在更新服务时因为准备不足或者遗漏造成的更新时服务不可用。</p>
<p>在第一点上我们可以做好监控和告警，使用容器编排工具自动重启，服务集群来避免。</p>
<p>但是第二点人员干涉较多，很容易出现纰漏，所以构建一个灰度的平台，在系统上线后逐步的将系统开放出去，尽早的发现纰漏减少因为更新系统造成的宕机损失</p>
<h3 id="平台功能与使用场景"><a href="#平台功能与使用场景" class="headerlink" title="平台功能与使用场景"></a>平台功能<font style="color:rgb(47, 48, 52);">与使用场景</font></h3><p>平台包含规则域名管理、规则管理、比例管理。平台与openresty通过redis联动，规则的筛选通过lua脚本来执行。</p>
<p>域名管理：域名的增加、修改、删除、以及全量灰度修改、全量下线</p>
<p>规则灰度：主要配置请求类型，然后根据不同的请求类型获取对应的参数，通过规则类型（大于等于小于包含不等于等符号）来判断请求是否属于灰度</p>
<p>比例灰度：设置请求有多少数据进入灰度，这里需要注意：比例只能从小到大，最低到1%，最高到100%（第一次设置10%那后续只能从10%往上加）</p>
<p>使用场景：</p>
<p>服务A，B更新，创建服务A，B的灰度服务并在nacos的元空间中增加灰度版本，然后增加域名——规则灰度——ip灰度——白名单——公司IP地址；公司网络访问服务测试灰度内容，无异常后，再根据自己的需要配置参数规则匹配或者比例灰度来进行小部分的发布，当然如果对服务很有信息也可以直接更新到线上</p>
<h3 id="为了实现灰度都做了什么"><a href="#为了实现灰度都做了什么" class="headerlink" title="为了实现灰度都做了什么"></a>为了实现灰度都做了什么</h3><p><font style="color:rgb(47, 48, 52);"></font></p>
]]></content>
      <categories>
        <category>灰度平台</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>灰度</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud项目使用nacos</title>
    <url>/2024/03/27/springcloud%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8nacos/</url>
    <content><![CDATA[<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><h2 id="Nacos-融合-Spring-Cloud："><a href="#Nacos-融合-Spring-Cloud：" class="headerlink" title="Nacos 融合 Spring Cloud："></a><font style="color:rgb(36, 41, 46);">Nacos 融合 Spring Cloud：</font></h2><p><a href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html">https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html</a></p>
<span id="more"></span>
<h2 id="Java-SDK："><a href="#Java-SDK：" class="headerlink" title="Java SDK："></a><font style="color:rgb(36, 41, 46);">Java SDK：</font></h2><p><a href="https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html">https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html</a></p>
<h1 id="POM文件引用："><a href="#POM文件引用：" class="headerlink" title="POM文件引用："></a>POM文件引用：</h1><h2 id="父pom"><a href="#父pom" class="headerlink" title="父pom"></a>父pom</h2><p>springcloud，springboot，springcloudalibaba，nacos版本引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">      &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">      &lt;spring-boot.version&gt;2.6.13&lt;/spring-boot.version&gt;</span><br><span class="line">      &lt;spring-cloud.version&gt;2021.0.5&lt;/spring-cloud.version&gt;</span><br><span class="line">      &lt;spring-cloud-alibaba.version&gt;2021.0.4.0&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">      &lt;alibaba.nacos.version&gt;2.1.1&lt;/alibaba.nacos.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;!--统一版本--&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.luck.sugar&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;luck-bom&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- SpringBoot 依赖配置 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- SpringCloud 微服务 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- Alibaba Nacos 配置 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;alibaba.nacos.version&#125;&lt;/version&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- Mybatis 依赖配置 --&gt;</span><br><span class="line"></span><br><span class="line">           &lt;!-- SpringCloud Alibaba 微服务 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">       &lt;/dependencies&gt;</span><br><span class="line">   &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>因为我们使用了注册中心所以配置不能再使用application.yaml，需要优先级更高的bootstrap文件来找到nacos的配置文件，在springboot2.2以后bootstrap默认是关闭的需要打开才能默认使用bootstrap文件为配置文件，需要在pom文件中添加模块引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- bootstrap 启动器 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="子pom"><a href="#子pom" class="headerlink" title="子pom"></a>子pom</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;!--  spring web --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- spring test --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--nacos--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h1 id="配置文件修改："><a href="#配置文件修改：" class="headerlink" title="配置文件修改："></a>配置文件修改：</h1><p>上节解释了配置文件变化，以下是bootstrap.yml的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1066</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: luck-uid</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 49.235.122.65:8848</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 49.235.122.65:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="启动类注解添加："><a href="#启动类注解添加：" class="headerlink" title="启动类注解添加："></a>启动类注解添加：</h1><p><font style="color:#bbb529;">@EnableDiscoveryClient</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LuckUidApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(LuckUidApplication.class, args);</span><br><span class="line">        System.out.println(&quot;(♥◠‿◠)ﾉﾞ  ID服务启动成功   ლ(´ڡ`ლ)ﾞ  \n&quot; +</span><br><span class="line">                &quot; .-------.       .-------.          \n&quot; +</span><br><span class="line">                &quot; | i--------------------i |         \n&quot; +</span><br><span class="line">                &quot; | |                    | |         \n&quot; +</span><br><span class="line">                &quot; \\|   O       O        |/          \n&quot; +</span><br><span class="line">                &quot;   |      /\\           |           \n&quot; +</span><br><span class="line">                &quot;   |     /  \\          |           \n&quot; +</span><br><span class="line">                &quot;   |    \\__/           |           \n&quot; +</span><br><span class="line">                &quot;   |      __-- .        |           \n&quot; +</span><br><span class="line">                &quot;           `-..-&#x27;              &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1670814234495-463d58c8-b5df-4c44-9129-728a4b419988.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1670814281972-0e0c6a3b-0840-43c4-aafc-63de05ef2b20.png"></p>
<h1 id="异常备注："><a href="#异常备注：" class="headerlink" title="异常备注："></a>异常备注：</h1><h3 id="bootstrap-yml未生效：链接地址为-127-0-0-1"><a href="#bootstrap-yml未生效：链接地址为-127-0-0-1" class="headerlink" title="bootstrap.yml未生效：链接地址为 127.0.0.1"></a>bootstrap.yml未生效：链接地址为 127.0.0.1</h3><p>pom未添加spring-cloud-starter-bootstrap，</p>
<p>配置文件格式异常</p>
<h3 id="项目启动完成后没有注册到nacos中："><a href="#项目启动完成后没有注册到nacos中：" class="headerlink" title="项目启动完成后没有注册到nacos中："></a>项目启动完成后没有注册到nacos中：</h3><p>子pom中未引用：spring-cloud-starter-alibaba-nacos-discovery</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>Spring</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID总结</title>
    <url>/2024/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    <content><![CDATA[<h2 id="分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式-ID，那么我们如何设计它呢？本文将详细讲述分布式-ID-及其生成方案。"><a href="#分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式-ID，那么我们如何设计它呢？本文将详细讲述分布式-ID-及其生成方案。" class="headerlink" title="分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式 ID，那么我们如何设计它呢？本文将详细讲述分布式 ID 及其生成方案。"></a>分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式 ID，那么我们如何设计它呢？本文将详细讲述分布式 ID 及其生成方案。</h2><h1 id="为什么需要分布式-ID"><a href="#为什么需要分布式-ID" class="headerlink" title="为什么需要分布式 ID"></a>为什么需要分布式 ID</h1><p>目前大部分的系统都已是分布式系统，所以在这种场景的业务开发中，经常会需要唯一 ID 对数据进行标识，比如用户身份标识、消息标识等等。</p>
<span id="more"></span>


<p>并且在数据量达到一定规模后，大部分的系统也需要进行分库分表，这种场景下单库的自增 ID 已达不到我们的预期。所以我们需要分布式 ID 来对各种场景的数据进行唯一标识。</p>
<h1 id="分布式-ID-的特性"><a href="#分布式-ID-的特性" class="headerlink" title="分布式 ID 的特性"></a>分布式 ID 的特性</h1><p><strong>主要特性：</strong></p>
<ul>
<li>全局唯一：分布式 ID 最基本要求，必须全局唯一。</li>
<li>高可用：高并发下要保证 ID 的生成效率，避免影响系统。</li>
<li>易用性：使用简单，可快速接入。</li>
</ul>
<p><strong>除此之外根据不同场景还有：</strong></p>
<ul>
<li>有序性：数据库场景下的主键 ID，有序性可便于数据写入和排序。</li>
<li>安全性：无规则 ID，一般用于避免业务信息泄露场景，如订单量。</li>
</ul>
<h1 id="分布式-ID-常见生成方案"><a href="#分布式-ID-常见生成方案" class="headerlink" title="分布式 ID 常见生成方案"></a>分布式 ID 常见生成方案</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718614981558-bee358fe-b5f6-4890-b69e-9eb60310084d.jpeg" alt="画板"></p>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p><strong>UUID</strong>（Universally Unique Identifier），即通用唯一识别码。UUID 的目的是让分布式系统中的所有元素都能有唯一的识别信息。</p>
<p>UUID 是由128位二进制数组成，通常表示为32个十六进制字符，形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>



<p>这个字符串由五个部分组成，以连字符<code>-</code>分隔开，具体如下：</p>
<table>
<thead>
<tr>
<th align="center">部分</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">时间戳</td>
<td align="center">32 bits</td>
<td>UUID的前32位表示当前的时间戳。</td>
</tr>
<tr>
<td align="center">时钟序列和随机数</td>
<td align="center">16 bits</td>
<td>用于保证在同一时刻生成的UUID的唯一性。</td>
</tr>
<tr>
<td align="center">变体标识</td>
<td align="center">4 bits</td>
<td>标识 UUID 的变体，通常为固定值，表示是由 RFC 4122 定义。</td>
</tr>
<tr>
<td align="center">版本号</td>
<td align="center">4 bits</td>
<td>标识UUID的版本，常见版本有1、3、4和5</td>
</tr>
<tr>
<td align="center">节点</td>
<td align="center">48 bits</td>
<td>在版本 1 中，这部分包含生成 UUID 的计算机的唯一标识。</td>
</tr>
</tbody></table>
<p><strong>主要的 UUID 版本及其生成规则：</strong></p>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">场景</th>
<th>生成规则</th>
</tr>
</thead>
<tbody><tr>
<td align="center">版本 1</td>
<td align="center">基于时间和节点</td>
<td>由当前的时间戳和节点信息生成。包括时间戳、时钟序列、节点标识。</td>
</tr>
<tr>
<td align="center">版本 2</td>
<td align="center">基于DCE安全标识符</td>
<td>类似版本 1，但在时间戳部分包含 POSIX UID&#x2F;GID 信息。</td>
</tr>
<tr>
<td align="center">版本 3</td>
<td align="center">基于名字和散列值（MD5 版）</td>
<td>由命名空间和名字的MD5散列生成。</td>
</tr>
<tr>
<td align="center">版本 4</td>
<td align="center">完全随机生成</td>
<td>通过随机或伪随机生成128位数字。</td>
</tr>
<tr>
<td align="center">版本 5</td>
<td align="center">基于名字和散列值（SHA-1 版）</td>
<td>通过随机或伪随机生成128位数字。</td>
</tr>
</tbody></table>
<p><strong>Java中 UUID 对版本 4 进行了实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认版本 4</span></span><br><span class="line">    System.out.println(UUID.randomUUID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本 3，由命名空间和名字的MD5散列生成，相同命名空间结果相同</span></span><br><span class="line">    <span class="comment">// 如下，&quot;fuxing&quot;返回的UUID一直为8b9b6bc3-90c8-37ef-bbef-0ed0c552718f</span></span><br><span class="line">    System.out.println(UUID.nameUUIDFromBytes(<span class="string">&quot;fuxing&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong>本地生成，没有网络消耗，性能非常高。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>占用空间大，32 个字符串，128 位。</li>
<li>不安全：版本 1 可能会造成 mac 地址泄露。</li>
<li>无序，非自增。</li>
<li>机器时间不对，可能造成 UUID 重复。</li>
</ul>
<h2 id="数据库自增-ID"><a href="#数据库自增-ID" class="headerlink" title="数据库自增 ID"></a>数据库自增 ID</h2><p>实现简单，解释通过数据库表中的主键 ID 自增来生成唯一标识。如下，维护一个 MySQL 表来生成 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `unique_id` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `value` char(10) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当需要生成分布式 ID 时，向表中插入数据并返回主键 ID，这里 value 无含义，只是为了占位，方便插入数据。</p>
<p><strong>优点：</strong>实现简单，基本满足业务需求，且天然有序。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>那么有没有办法解决数据库自增 ID 的缺点呢？</p>
<p>通过水平拆分的方案，将表设置到不同的数据库中，设置不同的起始值和步长，这样可以有效的生成集群中的唯一 ID，也大大降低 ID 生成数据库操作的负载，示例如下。</p>
<p><code>&lt;font style=&quot;color:rgb(62, 62, 62);&quot;&gt;unique_id_1&lt;/font&gt;</code><font style="color:rgb(62, 62, 62);">配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>

<p><code>&lt;font style=&quot;color:rgb(62, 62, 62);&quot;&gt;unique_id_2&lt;/font&gt;</code><font style="color:rgb(62, 62, 62);">配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>



<p>这个还是需要根据自己的业务需求来，水平扩展的集群数量要符合自己的数据量，因为当设置的集群数量不足以满足高并发时，再次进行扩容集群会很麻烦。多台机器的起始值和步长都需要重新配置。</p>
<h2 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h2><p>号段模式是当下分布式 ID 生成器的主流实现方式之一，比如美团 Leaf-segment、滴滴 Tinyid、微信序列号等都使用的该方案，下面的大厂中间件中会展开说明。</p>
<p>号段模式也是基于数据库的自增 ID，数据库自增 ID 是一次性获取一个分布式 ID，**<font style="color:#5C8D07;">号段模式可以理解成从数据库批量获取 ID，然后将 ID 缓存在本地</font>**，以此来提高业务获取 ID 的效率。</p>
<p>例如，每次从数据库获取 ID 时，获取一个号段，如(1,1000]，这个范围表示 1000 个 ID，业务应用在请求获取 ID 时，只需要在本地从 1 开始自增并返回，而不用每次去请求数据库，一直到本地自增到 1000 时，才去数据库重新获取新的号段，后续流程循环往复。</p>
<p>表结构可进行如下设计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `id_generator` (</span><br><span class="line">  `id` int(10) NOT NULL,</span><br><span class="line">  `max_id` bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  `step` int(10) NOT NULL COMMENT &#x27;号段的步长&#x27;,</span><br><span class="line">  `version` int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  `biz_type` int(20) NOT NULL COMMENT &#x27;业务场景&#x27;,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>



<p>其中<code>max_id</code>和<code>step</code>用于获取批量的 ID，<code>version</code>是一个乐观锁，保证并发时数据的正确性。</p>
<p>比如，我们新增一条表数据如下。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">max_id</th>
<th align="center">step</th>
<th align="center">version</th>
<th align="center">biz_type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">100</td>
<td align="center">1000</td>
<td align="center">0</td>
<td align="center">001</td>
</tr>
</tbody></table>
<p>然后我们可以使用该号段批量生成的 ID，当<code>max_id = 1000</code>，则执行 update 操作生成新的号段。新的号段的 SQL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE </span><br><span class="line">id_generator </span><br><span class="line">SET </span><br><span class="line">max_id = #&#123;max_id+ step&#125;, </span><br><span class="line">version = version + 1 </span><br><span class="line">WHERE </span><br><span class="line">version = #&#123;version&#125; AND biz_type = 001;</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong>ID 有序递增、存储消耗空间小。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>缺点同样可以通过集群的方式进行优化，也可以如Tinyid 采用双缓存进行优化，下面的大厂中间件中会展开说明。</p>
<h2 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h2><p>当使用数据库来生成 ID 性能不够的时候，可以尝试使用 Redis 来生成 ID。原理则是利用 Redis 的原子操作 INCR 和 INCRBY 来实现。</p>
<p><strong>命令示例：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>INCR</strong></td>
<td>让一个整形的key自增1</td>
<td>:::tips redis&gt; <font style="color:#E8323C;">SET</font> mykey “10”<br/>“OK”<br/>redis&gt; <font style="color:#E8323C;">INCR</font> mykey<br/>(integer) 11<br/>:::</td>
</tr>
<tr>
<td align="center"><strong>INCRBY</strong></td>
<td>让一个整形的key自增并指定步长</td>
<td>:::tips redis&gt; <font style="color:#E8323C;">SET</font> mykey “10”<br/>“OK”<br/>redis&gt; <font style="color:#E8323C;">INCRBY</font> mykey 5<br/>(integer) 15<br/>:::</td>
</tr>
</tbody></table>
<p><strong>优点：</strong>不依赖于数据库，使用灵活，支持高并发。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>系统须引入 Redis 数据库。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li><font style="color:rgb(25, 27, 31);">Redis 出现单点故障问题，可能会丢数据导致 ID 重复</font>。</li>
</ul>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法（Snowflake）是 twitter 公司内部分布式项目采用的 ID 生成算法。结果是一个 long 型的 ID。Snowflake 算法将 64bit 划分为多段，分开来标识机器、时间等信息，具体组成结构如下图所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718695293290-53f569fe-4b3d-4e3b-8161-804a80c69b7a.jpeg" alt="画板"></p>
<p><strong>结构说明：</strong></p>
<table>
<thead>
<tr>
<th align="center">结构</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">符号位</td>
<td align="center">1 bit</td>
<td>0 表示正数，1 表示负数。</td>
</tr>
<tr>
<td align="center">时间戳</td>
<td align="center">41 bits</td>
<td>存储的是<code>当前时间戳 - 开始时间戳</code>，最长 69 年。</td>
</tr>
<tr>
<td align="center">机器位</td>
<td align="center">10 bits</td>
<td>前 5位 datacenterId，后 5 位 workerId ，最多表示 1024 台。</td>
</tr>
<tr>
<td align="center">序列号</td>
<td align="center">12 bits</td>
<td>毫秒内的流水号，意味着每个节点在每毫秒可以产生 4096 个 ID。</td>
</tr>
</tbody></table>
<p><strong>优点：</strong></p>
<p>稳定性高，不依赖于数据库等第三方系统。</p>
<p>使用灵活方便，可以根据业务需求的特性来调整算法中的 bit 位。</p>
<p>单机上 ID 单调自增，毫秒数在高位，自增序列在低位，整体上按照时间自增排序。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，可能导致发号重复或者服务处于不可用状态。</li>
<li>ID 可能不是全局递增，虽然 ID 在单机上是递增的。</li>
<li><font style="color:rgb(25, 27, 31);">Redis 出现单点故障问题，可能会丢数据导致 ID 重复</font>。</li>
</ul>
<p>当我们选择了雪花算法可以参考<font style="color:rgb(47, 48, 52);">shardingsphere的雪花算法，以此为例来写一个starter</font></p>
<p><font style="color:rgb(47, 48, 52);">定义接口</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultIdGenerator implements IdGenerator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long nextId() &#123;</span><br><span class="line">        Comparable&lt;?&gt; key=  IDUtils.generateKey();</span><br><span class="line">        return (Long) key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义雪花算法实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.fbb.pomelo.id.utils;</span><br><span class="line"></span><br><span class="line">import com.google.common.base.Preconditions;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import lombok.experimental.UtilityClass;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.net.NetworkInterface;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@UtilityClass</span><br><span class="line">public final class IDUtils &#123;</span><br><span class="line">    public static final long EPOCH;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_BITS = 12L;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_BITS = 10L;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_MASK = (1 &lt;&lt; SEQUENCE_BITS) - 1;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_LEFT_SHIFT_BITS = SEQUENCE_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long TIMESTAMP_LEFT_SHIFT_BITS = WORKER_ID_LEFT_SHIFT_BITS + WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_MAX_VALUE = 1L &lt;&lt; WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID = 0;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_VIBRATION_VALUE = 1;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS = 10;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    private static TimeService timeService = new TimeService();</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    private Properties properties = new Properties();</span><br><span class="line"></span><br><span class="line">    private int sequenceOffset = -1;</span><br><span class="line"></span><br><span class="line">    private long sequence;</span><br><span class="line"></span><br><span class="line">    private long lastMilliseconds;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(2016, Calendar.NOVEMBER, 1);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, 0);</span><br><span class="line">        calendar.set(Calendar.MINUTE, 0);</span><br><span class="line">        calendar.set(Calendar.SECOND, 0);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, 0);</span><br><span class="line">        EPOCH = calendar.getTimeInMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized Comparable&lt;?&gt; generateKey() &#123;</span><br><span class="line">        long currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">        if (waitTolerateTimeDifferenceIfNeed(currentMilliseconds)) &#123;</span><br><span class="line">            currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        if (lastMilliseconds == currentMilliseconds) &#123;</span><br><span class="line">            if (0L == (sequence = (sequence + 1) &amp; SEQUENCE_MASK)) &#123;</span><br><span class="line">                currentMilliseconds = waitUntilNextTime(currentMilliseconds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            vibrateSequenceOffset();</span><br><span class="line">            sequence = sequenceOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        lastMilliseconds = currentMilliseconds;</span><br><span class="line">        return ((currentMilliseconds - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (getWorkerId() &lt;&lt; WORKER_ID_LEFT_SHIFT_BITS) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    private boolean waitTolerateTimeDifferenceIfNeed(final long currentMilliseconds) &#123;</span><br><span class="line">        if (lastMilliseconds &lt;= currentMilliseconds) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeDifferenceMilliseconds = lastMilliseconds - currentMilliseconds;</span><br><span class="line">        Preconditions.checkState(timeDifferenceMilliseconds &lt; getMaxTolerateTimeDifferenceMilliseconds(),</span><br><span class="line">                &quot;Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds&quot;, lastMilliseconds, currentMilliseconds);</span><br><span class="line">        Thread.sleep(timeDifferenceMilliseconds);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getWorkerId() &#123;</span><br><span class="line">        long result = Long.valueOf(properties.getProperty(&quot;worker.id&quot;, String.valueOf(WORKER_ID)));</span><br><span class="line">        if (result &lt;= 0L)&#123;</span><br><span class="line">            result = generateWorkerId();</span><br><span class="line">        &#125;</span><br><span class="line">        Preconditions.checkArgument(result &gt;= 0L &amp;&amp; result &lt; WORKER_ID_MAX_VALUE);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxVibrationOffset() &#123;</span><br><span class="line">        int result = Integer.parseInt(properties.getProperty(&quot;max.vibration.offset&quot;, String.valueOf(DEFAULT_VIBRATION_VALUE)));</span><br><span class="line">        Preconditions.checkArgument(result &gt;= 0 &amp;&amp; result &lt;= SEQUENCE_MASK, &quot;Illegal max vibration offset&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxTolerateTimeDifferenceMilliseconds() &#123;</span><br><span class="line">        return Integer.valueOf(properties.getProperty(&quot;max.tolerate.time.difference.milliseconds&quot;, String.valueOf(MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long waitUntilNextTime(final long lastTime) &#123;</span><br><span class="line">        long result = timeService.getCurrentMillis();</span><br><span class="line">        while (result &lt;= lastTime) &#123;</span><br><span class="line">            result = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void vibrateSequenceOffset() &#123;</span><br><span class="line">        sequenceOffset = sequenceOffset &gt;= getMaxVibrationOffset() ? 0 : sequenceOffset + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long generateWorkerId() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return generateWorkerIdBaseOnMac();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return generateRandomWorkerId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * randomly generate one as workerId</span><br><span class="line">     * @return workerId</span><br><span class="line">     */</span><br><span class="line">    private long generateRandomWorkerId() &#123;</span><br><span class="line">        return new Random().nextInt((int)WORKER_ID_MAX_VALUE + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * use lowest 10 bit of available MAC as workerId</span><br><span class="line">     * @return workerId</span><br><span class="line">     * @throws Exception when there is no available mac found</span><br><span class="line">     */</span><br><span class="line">    private long generateWorkerIdBaseOnMac() throws Exception &#123;</span><br><span class="line">        Enumeration&lt;NetworkInterface&gt; all = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        while (all.hasMoreElements()) &#123;</span><br><span class="line">            NetworkInterface networkInterface = all.nextElement();</span><br><span class="line">            boolean loopBack = networkInterface.isLoopback();</span><br><span class="line">            boolean isVirtual = networkInterface.isVirtual();</span><br><span class="line">            if (loopBack || isVirtual) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] mac = networkInterface.getHardwareAddress();</span><br><span class="line">            return ((mac[4] &amp; 0B11) &lt;&lt; 8) | (mac[5] &amp; 0xFF);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(&quot;no available mac found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取随机ID</span><br><span class="line">     * @return 随机ID用以替代传统的UUID</span><br><span class="line">     */</span><br><span class="line">    public String get32UUID() &#123;</span><br><span class="line">        ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">        return (new UUID(random.nextLong(), random.nextLong())).toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TimeService &#123;</span><br><span class="line">    public long getCurrentMillis() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class IdAutoConfiguration &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 注入ID生成器实现</span><br><span class="line">     * @return see &#123;@link DefaultIdGenerator&#125;</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public IdGenerator idGenerator() &#123;</span><br><span class="line">        return new DefaultIdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>META-INF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">     com.fbb.pomelo.id.configuration.IdAutoConfiguration</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="大厂中间件"><a href="#大厂中间件" class="headerlink" title="大厂中间件"></a>大厂中间件</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718614818789-89d8afe6-37ff-4335-a746-1aea25018e23.jpeg" alt="画板"></p>
<h2 id="美团-Leaf"><a href="#美团-Leaf" class="headerlink" title="美团 Leaf"></a><font style="color:rgb(88, 90, 90);">美团 Leaf</font></h2><p><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html">Leaf 的官方文档</a>，简介和特性可访问了解，这里我将对 Leaf 的两种方案，Leaf segment 和 Leaf-snowflake 进行。</p>
<h3 id="Leaf-segment"><a href="#Leaf-segment" class="headerlink" title="Leaf segment"></a>Leaf segment</h3><p>基于数据库号段模式的 ID 生成方案，上面我们介绍到普通的号段模式有一些缺点：</p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>那么 Leaf 是如何做的呢？Leaf 采用了预分发的方式生成ID，也就是在 DB 之上挂 n 个 Leaf Server，每个Server启动时，都会去 DB 拿固定长度的 ID List。</p>
<p>这样就做到了完全基于分布式的架构，同时因为ID是由内存分发，所以也可以做到很高效，处理流程图如下：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718698426441-afdf835d-f486-4d25-b783-42521191ff2b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Leaf"></p>
<p><strong>其中：</strong></p>
<ul>
<li>Leaf Server 1：从 DB 加载号段[1，1000]。</li>
<li>Leaf Server 2：从 DB 加载号段[1001，2000]。</li>
<li>Leaf Server 3：从 DB 加载号段[2001，3000]。</li>
</ul>
<p>用户**<font style="color:#5C8D07;">通过轮询的方式</font>**调用 Leaf Server 的各个服务，所以某一个 Client 获取到的ID序列可能是：1，1001，2001，2，1002，2002。当某个 Leaf Server 号段用完之后，下一次请求就会从 DB 中加载新的号段，这样保证了每次加载的号段是递增的。</p>
<p>为了解决在更新DB号段的时出现的耗时和阻塞服务的问题，Leaf 采用了**<font style="color:#5C8D07;">异步更新</font>**的策略，同时通过双缓存的方式，保证无论何时DB出现问题，都能有一个 Buffer 的号段可以正常对外提供服务，只要 DB 在一个 Buffer 的下发的周期内恢复，就不会影响整个 Leaf 的可用性。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718698969771-dbe0fd2a-5501-44d0-8db1-2c250de2b7d9.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Leaf"></p>
<p>除此之外，Leaf 还**<font style="color:#5C8D07;">通过动态调整步长</font>**，解决由于步长固定导致的缓存中的 ID 被过快消耗问题，以及步长设置过大导致的号段 ID 跨度过大问题，具体公式可去官方文档中了解。</p>
<p>对于数据一致性问题，Leaf 目前是通过中间件 Zebra 加 MHA 做的主从切换。</p>
<h3 id="Leaf-Snowflake"><a href="#Leaf-Snowflake" class="headerlink" title="Leaf Snowflake"></a>Leaf Snowflake</h3><p>Leaf-snowflake 方案沿用 Snowflake 方案的 bit 位设计。</p>
<p>对于 workerID 的分配：当服务集群较小时，通过配置即可；服务集群较大时，基于 zookeeper 持久顺序节点的特性引入 zookeeper 组件配置 workerID。架构如下图所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/3003575/1718699670231-b390838f-2dd5-4e13-a52d-f446cb8fd6dc.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10"></p>
<h2 id="百度-UidGenerator"><a href="#百度-UidGenerator" class="headerlink" title="百度 UidGenerator"></a>百度 UidGenerator</h2><p><a href="https://github.com/baidu/uid-generator">开源地址</a></p>
<p>UidGenerator 方案是基于 Snowflake 算法的 ID 生成器，其对雪花算法的 bit 位的分配做了微调。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718700335302-7c7d4146-8057-464e-af50-6e39a5c6d527.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_25,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10"></p>
<hr>
<p><strong>结构说明（参数可在 Spring Bean 配置中进行配置）：</strong></p>
<table>
<thead>
<tr>
<th>结构</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>符号位</td>
<td align="center">1 bit</td>
<td><font style="color:rgb(37, 43, 58);">最高位始终是 0。</font></td>
</tr>
<tr>
<td>增量秒</td>
<td align="center"><font style="color:rgb(37, 43, 58);">28</font> bits</td>
<td>表示自客户纪元（2016-05-20）以来的增量秒。最大时间为 8.7 年。</td>
</tr>
<tr>
<td>工作节点</td>
<td align="center">22 bits</td>
<td>表示工作节点 ID，最大值为 4.2 百万个。</td>
</tr>
<tr>
<td>序列号</td>
<td align="center">13 bits</td>
<td>表示一秒钟内的序列，默认情况下每秒最多 8192 个。</td>
</tr>
</tbody></table>
<p>UidGenerator 方案包含两种实现方式，DefaultUidGenerator 和 CachedUidGenerator ，性能要求高的情况下推荐 CachedUidGenerator。</p>
<h2 id="滴滴-Tinyid"><a href="#滴滴-Tinyid" class="headerlink" title="滴滴 Tinyid"></a>滴滴 Tinyid</h2><p><a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">Tinyid 官方文档</a></p>
<p>Tinyid 方案是在 Leaf-segment 的算法基础上升级而来，不仅支持了数据库多主节点模式，还提供了 tinyid-client 客户端的接入方式，使用起来更加方便。</p>
<p>Tinyid 也是采用了异步加双缓存策略，首先可用号段加载到内存中，并在内存中生成 ID，可用号段在首次获取 ID 时加载，号段用到一定程度的时候，就去异步加载下一个号段，保证内存中始终有可用号段，则可避免性能波动。</p>
<p><strong>实现原理如下所示：</strong></p>
<p><img src="https://github.com/didi/tinyid/raw/master/doc/tinyid_final.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_29,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Tinyid"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文对分布式 ID 以及其场景的生成方案做了介绍，还针对一下大厂的中间件进行简单分析，中间件的接入代码本文并没有做详细介绍，但是官方文档的链接都帖子了每个子标题下，其中都有详细介绍。</p>
<p>文中还针对每个生成方案的优缺点作出了说明，具体的使用可针对优缺点加上业务需求来进行选型。</p>
<hr>
<blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/534893180">[1] 腾讯技术工程. 分布式唯一 ID 生成方案浅谈.</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2377401">[2] 孟斯特. UUID 介绍.</a></p>
<p><a href="https://blog.csdn.net/jiaomubai/article/details/124385324">[3] 文丑颜不良啊. 雪花算法（SnowFlake）.</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>ID</tag>
      </tags>
  </entry>
  <entry>
    <title>实现用户配置数据源引用切换</title>
    <url>/2024/10/03/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90%E5%BC%95%E7%94%A8%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="需求来源"><a href="#需求来源" class="headerlink" title="需求来源"></a>需求来源</h2><p>实现代码生成器的时候因为做了分库，所以在实现代码生成时就需要根据不同的配置去拉取不同的表结构，所以需要实现不同的库使用不同的数据源</p>
<span id="more"></span>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在mybatis中是以DataSource的形式来管理数据源的，在mybaitis-plus中预留了AbstractRoutingDataSource接口来实现数据源的切换与查找</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1726735329465-48b3cd5d-4d56-4e45-8b43-afdec1a7c275.png"></p>
<p>targetDataSources就是数据源的结合，如果我们需要增加数据源就需要在targetDataSources中增加新定义的数据源，并通知引用规则，实现如下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先我们要定义一个节点用于确定使用targetDataSources中的哪个数据源，定义DataSourceContextHolder，用于实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DataSourceContextHolder &#123;</span><br><span class="line">    </span><br><span class="line">    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public static void setDataSourceKey(String dataSourceKey) &#123;</span><br><span class="line">        contextHolder.set(dataSourceKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String getDataSourceKey() &#123;</span><br><span class="line">        return contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void clearDataSourceKey() &#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义DynamicDataSource继承与AbstractRoutingDataSource</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DynamicDataSource(DataSource defaultDataSource, Map&lt;Object, Object&gt; targetDataSources) &#123;</span><br><span class="line">    // 设置数据源集合</span><br><span class="line">    super.setTargetDataSources(targetDataSources);</span><br><span class="line">    super.setDefaultTargetDataSource(defaultDataSource);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">    return DataSourceContextHolder.getDataSourceKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里只做了两件事定义数据源，以及确认当前数据源的key</p>
<p>定义一个Configuration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(DataSourceProperties.class)</span><br><span class="line">public class PomeloDataSourceConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">    @Resource</span><br><span class="line">    private DataSourceProperties dataSourceProperties;</span><br><span class="line">    private DataSource defaultDataSource() &#123;</span><br><span class="line">        DataSource dataSource = DataSourceBuilder.create()</span><br><span class="line">                .url(dataSourceProperties.getUrl())</span><br><span class="line">                .username(dataSourceProperties.getUsername())</span><br><span class="line">                .password(dataSourceProperties.getPassword())</span><br><span class="line">                .driverClassName(dataSourceProperties.getDriverClassName())</span><br><span class="line">                .build();;</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public DynamicDataSource dynamicDataSource() &#123;</span><br><span class="line">        DynamicDataSource dynamicDataSource = new DynamicDataSource(defaultDataSource(), new HashMap&lt;&gt;());</span><br><span class="line">        return dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>如果我们需要使用多个数据源那需要我们获取到多个数据源，我们这里以数据库获取为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatasourceConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Resource</span><br><span class="line">    private GenDatabaseService genDatabaseService;</span><br><span class="line">    @Resource</span><br><span class="line">    private DynamicDataSource dynamicDataSource;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public DynamicDataSource dataSourceInit() &#123;</span><br><span class="line">        // 创建数据源</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;GenDatabase&gt; genDatabaseList = genDatabaseService.selectList();</span><br><span class="line">        for (GenDatabase genDatabase : genDatabaseList) &#123;</span><br><span class="line">            targetDataSources.put(genDatabase.getDatabaseId().toString(), DataSourceBuilder.create()</span><br><span class="line">                    .driverClassName(genDatabase.getDatabaseDriver())</span><br><span class="line">                    .url(genDatabase.getDatabaseUrl())</span><br><span class="line">                    .password(genDatabase.getDatabasePwd())</span><br><span class="line">                    .username(genDatabase.getDatabaseName()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        dynamicDataSource.setTargetDataSources(targetDataSources);</span><br><span class="line">        dynamicDataSource.afterPropertiesSet();</span><br><span class="line">        return dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时如果需要再不同的地方调用数据源可以根据 DataSourceContextHolder.setDataSourceKey来确认使用哪个数据源，如果有需要也可以以aop形式完成，这里不多赘述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DataSourceContextHolder.setDataSourceKey(tableQuery.getDatabaseId());</span><br><span class="line">DataSourceContextHolder.clearDataSourceKey();</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>权限模型RBAC模型</title>
    <url>/2024/10/03/%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8BRBAC%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="什么是RBAC模型"><a href="#什么是RBAC模型" class="headerlink" title="什么是RBAC模型"></a>什么是RBAC模型</h3><p>权限是需要给对应的用户的，当用户太多的时候如果一个一个用户的设定权限就会显得很复杂，这时候我们可以引入角色，<font style="color:rgb(74, 74, 74);">每个角色可以拥有多个权限，每个用户可以分配多个角色，这样用户就拥有了多个角色的多个权限</font></p>
<span id="more"></span>
<h3 id="为什么要用RBAC模型"><a href="#为什么要用RBAC模型" class="headerlink" title="为什么要用RBAC模型"></a>为什么要用RBAC模型</h3><p><font style="color:rgb(74, 74, 74);">因为有角色作为媒介，大大降低了错综复杂的交互关系，比如一家有上万人的公司，角色可能只需要几百个就搞定了，因为很多用户需要的权限是一样的，分配一样的角色就可以了。这种模型的对应关系图如下所示：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1723708654558-0d0105e6-79d2-40f7-b9c8-3e07cb75e2c5.png"></p>
<p><font style="color:rgb(74, 74, 74);">用户和角色，角色和权限都是多对多的关系，这种模型是最通用的权限管理模型，节省了很大的权限维护成本，当然这种只是通用的模式，在实际的业务是千变万化的，比如大部分公司是分层级的，层级越高权限越大这时候可以用角色继承的RBAC模型。还有很多角色是互斥的这时候可以使用带约束的RBAC。比如同一个角色有多个用户，我们可以采用在角色的前提下增加一个用户组来简化角色分配。在pomelo中我们使用了通用的RBAC模型，这里只展示通用的模型</font></p>
<h3 id="RBAC模型数据结构"><a href="#RBAC模型数据结构" class="headerlink" title="RBAC模型数据结构"></a>RBAC模型数据结构</h3><p>菜单表（权限表）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P TABLE IF EXISTS customer_menu;</span><br><span class="line">CREATE TABLE customer_menu(</span><br><span class="line">    `menu_id` varchar(32) NOT NULL  COMMENT &#x27;菜单编号;菜单编号&#x27; ,</span><br><span class="line">    `parent_id` varchar(32) NOT NULL  COMMENT &#x27;父菜单编号;父菜单编号&#x27; ,</span><br><span class="line">    `name` varchar(255) NOT NULL  COMMENT &#x27;菜单名称;菜单名称&#x27; ,</span><br><span class="line">    `another_name` varchar(255) NOT NULL  COMMENT &#x27;别称;别称&#x27; ,</span><br><span class="line">    `path` varchar(255) NOT NULL  COMMENT &#x27;菜单URL;菜单地址（目录 菜单信息为/xxx/xxx   按钮为:delete，create等）&#x27; ,</span><br><span class="line">    `order_num` int   COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    `component` varchar(255)   COMMENT &#x27;组件路径;组件路径&#x27; ,</span><br><span class="line">    `perms` varchar(255) NOT NULL  COMMENT &#x27;授权;授权(多个用逗号分隔，如：user:list,user:create);&#x27; ,</span><br><span class="line">    `type` tinyint(4) NOT NULL  COMMENT &#x27;类型;类型   0：目录   1：菜单   2：按钮;&#x27; ,</span><br><span class="line">    `icon` varchar(255) NOT NULL  COMMENT &#x27;菜单图标;菜单图标&#x27; ,</span><br><span class="line">    `is_full` tinyint(4)   COMMENT &#x27;是否跳转;是否跳转&#x27; ,</span><br><span class="line">    `is_link` varchar(255)   COMMENT &#x27;是否外链;是否外链&#x27; ,</span><br><span class="line">    `is_hide` tinyint(4)   COMMENT &#x27;是否隐藏;是否隐藏&#x27; ,</span><br><span class="line">    `is_affix` tinyint(4)   COMMENT &#x27;是否固定;是否固定&#x27; ,</span><br><span class="line">    `is_keep_alive` tinyint(4)   COMMENT &#x27;是否长连接;是否长连接&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; ,</span><br><span class="line">    PRIMARY KEY (menu_id)</span><br><span class="line">)  COMMENT = &#x27;菜单表&#x27;;</span><br></pre></td></tr></table></figure>

<p>角色表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_role;</span><br><span class="line">CREATE TABLE customer_role(</span><br><span class="line">    `role_id` varchar(32) NOT NULL  COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    `role_name` varchar(100) NOT NULL  COMMENT &#x27;角色名称;角色名称&#x27; ,</span><br><span class="line">    `role_key` varchar(32) NOT NULL  COMMENT &#x27;角色权限字符串;角色权限字符串&#x27; ,</span><br><span class="line">    `role_sort` int   COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    `data_scope` tinyint(4)   COMMENT &#x27;数据范围（1：全部数据权限 2：自定数据权限 ）;数据范围（1：全部数据权限 2：自定数据权限 ）&#x27; ,</span><br><span class="line">    `status` tinyint(4) NOT NULL  COMMENT &#x27;角色状态（0正常 1停用）;角色状态（0正常 1停用）&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; </span><br><span class="line">)  COMMENT = &#x27;角色表&#x27;;</span><br></pre></td></tr></table></figure>

<p>用户表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_user;</span><br><span class="line">CREATE TABLE customer_user(</span><br><span class="line">    `user_id` varchar(32) NOT NULL  COMMENT &#x27;用户编号;用户编号&#x27; ,</span><br><span class="line">    `user_name` varchar(30) NOT NULL  COMMENT &#x27;用户账号;用户账号&#x27; ,</span><br><span class="line">    `nick_name` varchar(30) NOT NULL  COMMENT &#x27;用户昵称;用户昵称&#x27; ,</span><br><span class="line">    `phone_number` varchar(20)   COMMENT &#x27;用户手机号;用户手机号&#x27; ,</span><br><span class="line">    `open_id` varchar(32)   COMMENT &#x27;微信Id;微信唯一标识&#x27; ,</span><br><span class="line">    `dy_id` varchar(32)   COMMENT &#x27;抖音Id;抖音唯一标识&#x27; ,</span><br><span class="line">    `sex` tinyint(4)   COMMENT &#x27;性别;性别（0男 1女 2未知）&#x27; ,</span><br><span class="line">    `avatar` varchar(100)   COMMENT &#x27;头像地址;头像地址&#x27; ,</span><br><span class="line">    `invite_code` varchar(32)   COMMENT &#x27;邀请码;邀请码&#x27; ,</span><br><span class="line">    `password` varchar(16) NOT NULL  COMMENT &#x27;密码;密码&#x27; ,</span><br><span class="line">    `salt` varchar(32) NOT NULL  COMMENT &#x27;盐;盐&#x27; ,</span><br><span class="line">    `status` tinyint(4) NOT NULL  COMMENT &#x27;用户状态;账号状态（0未验证  1已验证 2已冻结 3已过期）&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; ,</span><br><span class="line">    PRIMARY KEY (user_id)</span><br><span class="line">)  COMMENT = &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure>

<p>用户角色表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_user_role;</span><br><span class="line">CREATE TABLE customer_user_role(</span><br><span class="line">    `ID` INT AUTO_INCREMENT COMMENT &#x27;&#x27; ,</span><br><span class="line">    `user_id` varchar(32)   COMMENT &#x27;用户ID;用户ID&#x27; ,</span><br><span class="line">    `role_id` varchar(32)   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色表&#x27;;</span><br></pre></td></tr></table></figure>

<p>角色权限表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_role_menu;</span><br><span class="line">CREATE TABLE customer_role_menu(</span><br><span class="line">    `ID` INT AUTO_INCREMENT COMMENT &#x27;&#x27; ,</span><br><span class="line">    `role_id` varchar(32)   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    `menu_id` varchar(32)   COMMENT &#x27;菜单ID;菜单ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;角色菜单管理表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>构建一个通用的数据访问模块</title>
    <url>/2024/10/01/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>当构建一个通用的数据访问模块的时候，一般需要处理分页，乐观锁、以及插入或者修改时一些公共字段默认值填充，以及慢查询处理定制化（虽然mysql自带的有这方面功能但是通知的灵活性不如自定义更实用）</p>
<span id="more"></span>
<h2 id="处理分页、乐观锁"><a href="#处理分页、乐观锁" class="headerlink" title="处理分页、乐观锁"></a>处理分页、乐观锁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    //分页</span><br><span class="line">    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">    // 乐观锁</span><br><span class="line">    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</span><br><span class="line">    return interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入或者修改设置默认字段"><a href="#插入或者修改设置默认字段" class="headerlink" title="插入或者修改设置默认字段"></a>插入或者修改设置默认字段</h2><p>首先定义基类BaseEntity，这里定义了createTime，updateTime，delFlag三个默认配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@SuperBuilder</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class BaseEntity &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建时间</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改时间</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除标志</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Integer delFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MetaObjectHandler接口是mybatisPlus为我们提供的的一个扩展接口，我们可以利用这个接口在我们插入或者更新数据的时候，为一些字段指定默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DailyMartMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;delFlag&quot;, Integer.class, DelEnum.NORMAL.code());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 2023/10/28 调整</span><br><span class="line">     * Mybatis-plus的自动更新要求待更新的字段为null，否则不更新。这就导致select 后 更新时无法自动更新 updateTime</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public MetaObjectHandler strictFillStrategy(MetaObject metaObject, String fieldName, Supplier&lt;?&gt; fieldVal) &#123;</span><br><span class="line">        Object obj = fieldVal.get();</span><br><span class="line">        if (Objects.nonNull(obj)) &#123;</span><br><span class="line">            metaObject.setValue(fieldName, obj);</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>将MetaObjectHandler注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在 插入/更新 数据时自动填充默认值</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public PomeloMetaObjectHandler myMetaObjectHandler() &#123;</span><br><span class="line">    return new PomeloMetaObjectHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="慢查询处理"><a href="#慢查询处理" class="headerlink" title="慢查询处理"></a>慢查询处理</h2><p>mysql的慢查询可以通过很多地方拦截，比如数据库本身就可以通过配置来实现拦击并打印为日志，一部分开源的数据库连接池也可以实现，比如阿里的druid。这些虽然都可以实现慢查询拦截，但是这些属于第三方，不够灵活所以我们这里可以使用<font style="color:rgb(47, 48, 52);">Mybatis提供的拦截器接口Interceptor来自己实现拦截，自己是实现时可以结合消息队列来完成阀值式处理，这些为后话，我们先来进行一个简单的实现</font></p>
<p><font style="color:rgb(47, 48, 52);">定义一个配置文件实体</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;pomelo.sql.slow&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class SlowSQLProperties &#123;</span><br><span class="line"></span><br><span class="line">    private boolean enable = false;</span><br><span class="line"></span><br><span class="line">    private long cost = 1000L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(47, 48, 52);">实现Interceptor</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;),</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;),</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class SlowSqlInterceptor implements Interceptor &#123;</span><br><span class="line">    private final SlowSQLProperties slowSQLProperties;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        StatementHandler statementHandler = (StatementHandler) target;</span><br><span class="line">        try &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            long costTime = stopWatch.getTotalTimeMillis();</span><br><span class="line"></span><br><span class="line">            if (costTime &gt;= slowSQLProperties.getCost()) &#123;</span><br><span class="line">                BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line"></span><br><span class="line">                String sql = boundSql.getSql();</span><br><span class="line"></span><br><span class="line">                // 20230901 去掉sql中的换行符</span><br><span class="line">                sql = sql.replaceAll(&quot;\\n+&quot;, &quot; &quot;);</span><br><span class="line"></span><br><span class="line">                log.warn(&quot;WARN !!!,监测到慢查询SQL:[&#123;&#125;] 执行耗时 &#123;&#125; ms &quot;, sql, costTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注入mybatis插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注入mybatis插件，可以统计SQL执行耗时</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnProperty(name = &quot;pomelo.sql.slow.enable&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><br><span class="line">public ConfigurationCustomizer mybatisConfigurationCustomizer() &#123;</span><br><span class="line">    return configuration -&gt; configuration.addInterceptor(new SlowSqlInterceptor(slowSQLProperties));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换ID生成器"><a href="#替换ID生成器" class="headerlink" title="替换ID生成器"></a>替换ID生成器</h2><p>在<a href="https://www.yuque.com/u25495771/ghfr2q/zsg53g1qtc5fxxeo">分布式ID</a>一文中我们自定义了ID，这里修改一下mybatis的id的生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IdGenerator implements IdentifierGenerator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Number nextId(Object entity) &#123;</span><br><span class="line">        return (Long)IDUtils.generateKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String nextUUID(Object entity) &#123;</span><br><span class="line">        return IDUtils.get32UUID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 替换Mybatis-plus的算法生成器</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public IdGenerator identifierGenerator() &#123;</span><br><span class="line">    return new IdGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一扫描地址"><a href="#统一扫描地址" class="headerlink" title="统一扫描地址"></a><font style="color:rgb(51, 51, 51);">统一扫描地址</font></h2><p>当我们使用mybatis时需要在<font style="color:rgb(47, 48, 52);">每个服务启动类上都需要通过@MapperScan注解指定Mapper对象的包路径地址。如果各个模块的命名规则之间遵循统一的命名规范，那么我们可以在配置主类中直接设置Mapper对象的包路径地址，这样SpringBoot启动类就不再需要依赖此注解了</font></p>
<p><font style="color:rgb(47, 48, 52);"></font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>构建统一返回以及全局异常处理</title>
    <url>/2024/10/03/%E6%9E%84%E5%BB%BA%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BB%A5%E5%8F%8A%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="统一返回格式"><a href="#统一返回格式" class="headerlink" title="统一返回格式"></a>统一返回格式</h2><h3 id="为什么需要统一返回格式"><a href="#为什么需要统一返回格式" class="headerlink" title="为什么需要统一返回格式"></a>为什么需要统一返回格式</h3><p><font style="color:rgb(47, 48, 52);">接口的返回值类型众多，有的直接返回数据传输对象（DTO），甚至直接返回数据对象（DO），还有的返回Result对象。这样对外交互时对方处理起来特别的复杂，所以需要统一的返回格式。</font></p>
<span id="more"></span>
<h3 id="构建统一返回格式"><a href="#构建统一返回格式" class="headerlink" title="构建统一返回格式"></a>构建统一返回格式</h3><h4 id="构建Result对象"><a href="#构建Result对象" class="headerlink" title="构建Result对象"></a><font style="color:rgb(51, 51, 51);">构建Result对象</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ResultHelper &#123;</span><br><span class="line">    </span><br><span class="line">    // 成功的响应结果</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(Result.SUCCESS_CODE)</span><br><span class="line">                .setData(data)</span><br><span class="line">                .setMessage(Result.SUCCESS_MESSAGE)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 失败的响应结果</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(String code, String message) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(code)</span><br><span class="line">                .setMessage(message)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 失败的响应结果，使用默认的错误码</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(String message) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(ErrorCode.SERVICE_ERROR.getCode())</span><br><span class="line">                .setMessage(message)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(ErrorCode errorCode) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(errorCode.getCode())</span><br><span class="line">                .setMessage(errorCode.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问下接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public Result&lt;String&gt; test() &#123;</span><br><span class="line">        return ResultHelper.success(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723015024331-f73efb26-3859-4649-9d2d-60d30bb50bc0.png"></p>
<h2 id="统一的模板方法"><a href="#统一的模板方法" class="headerlink" title="统一的模板方法"></a>统一的模板方法</h2><h3 id="为什么需要统一的模板方法"><a href="#为什么需要统一的模板方法" class="headerlink" title="为什么需要统一的模板方法"></a>为什么需要统一的模板方法</h3><p>按照上面的示例一切都很美好，代码也很简洁，内容也如预期做了输出，但是我们考虑一个问题，如果有上百个接口的时候，需要对接口进行一些公共代码的调整，比如讲参数和输出打印出来，对参数进行验证，统计代码执行的时间。当遇到这种需求可以使用AOP做切面编程，但是切面编程的效率并不是很好，所以可以选择使用统一的模板方法来处理这些问题。既可以实现统一的管理公共代码，又可以更规范的书写代码</p>
<h3 id="构建统一的模板方法"><a href="#构建统一的模板方法" class="headerlink" title="构建统一的模板方法"></a>构建统一的模板方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public abstract class ServerTemplate&lt;T, R&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    public R Process(T request) &#123;</span><br><span class="line">        log.info(&quot;开始执行，参数：&#123;&#125;&quot;, request);</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            // 参数校验</span><br><span class="line">            validParam(request);</span><br><span class="line">            // 执行业务代码</span><br><span class="line">            R response = doProcess(request);</span><br><span class="line">            // 记录时间信息</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            log.info(&quot;执行结束，耗时:&#123;&#125;ms&quot;, stopWatch.getTotalTimeMillis());</span><br><span class="line">            return response;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;执行异常，异常信息:&#123;&#125;&quot;, Arrays.toString(e.getStackTrace()));</span><br><span class="line">            // 抛出异常 统一处理</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected abstract void validParam(T request);</span><br><span class="line">    </span><br><span class="line">    protected abstract R doProcess(T request);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="使用统一格式创建一个接口"><a href="#使用统一格式创建一个接口" class="headerlink" title="使用统一格式创建一个接口"></a>使用统一格式创建一个接口</h2><p>改造一下之前的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">  public Result&lt;String&gt; test(@RequestBody String request) &#123;</span><br><span class="line">      return ResultHelper.success((new ServerTemplate&lt;String, String&gt;()&#123;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          protected void validParam(String request) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          protected String doProcess(String request) &#123;</span><br><span class="line">              return request;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;).process(request));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>执行代码</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723017417888-cb2a2f15-b9ec-4264-be8b-6c9331e82b5f.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723017431106-aa9e0616-a24b-4b47-9848-680c7a980206.png"></p>
<h2 id="再次优化：自动包装类"><a href="#再次优化：自动包装类" class="headerlink" title="再次优化：自动包装类"></a>再次优化：自动包装类</h2><p>每次都ResultHelper.success(）还要在参数中增加Result来维护一致性总是觉着有点太浪费时间，而且如果忘记了就会出错。所以需要再进一步优化一下，springboot的<font style="color:rgb(47, 48, 52);">ResponseBodyAdvice可以实现自动包装类</font></p>
<p>:::info<br><font style="color:rgb(154, 154, 154);">提示: ResponseBodyAdvice 可以拦截控制器(Controller)方法的返回值，允许我们统一处理返回值或响应体。这对于统一返回格式、加密、签名等场景非常有用。</font></p>
<p>:::</p>
<p>集成<font style="color:rgb(47, 48, 52);">ResponseBodyAdvice接口</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalResponseBodyAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        // boolean supports = returnType.getContainingClass().getPackage().getName().startsWith(&quot;com.jianzh5.dailymart&quot;);</span><br><span class="line">        return true;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request,</span><br><span class="line">                                  ServerHttpResponse response) &#123;</span><br><span class="line">        if (body == null) &#123;</span><br><span class="line">            return JsonUtils.obj2String(ResultHelper.success(&quot;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        if (body instanceof String) &#123;</span><br><span class="line">            // 当响应体是String类型时，使用ObjectMapper转换，因为Spring默认使用StringHttpMessageConverter处理字符串，不会将字符串识别为JSON</span><br><span class="line">            // return objectMapper.writeValueAsString(ResultFactory.success(body));</span><br><span class="line">            return JsonUtils.obj2String(ResultHelper.success(body));</span><br><span class="line">        &#125;</span><br><span class="line">        if (body instanceof Result&lt;?&gt;) &#123;</span><br><span class="line">            // 已经包装过的结果无需再次包装</span><br><span class="line">            return body;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对响应体进行包装</span><br><span class="line">        return ResultHelper.success(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再修改一下之前的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public String test(@RequestBody String request) &#123;</span><br><span class="line">        return (new ServerTemplate&lt;String, String&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected void validParam(String request) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected String doProcess(String request) &#123;</span><br><span class="line">                return request;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;).process(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723024004078-4916bbdd-5b70-49a2-b0c6-29ddd9be84cd.png"></p>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>在构建系统的可靠性时容错处理是重要的考虑方便之一，想要系统更加的健壮全局就需要添加全局异常处理，springboot其实已经做了前期的工作，@RestControllerAdvice注解+@ExceptionHandler可以解决这方面的顾虑</p>
<h3 id="自定义异常的创建和使用"><a href="#自定义异常的创建和使用" class="headerlink" title="自定义异常的创建和使用"></a>自定义异常的创建和使用</h3><p>定义自定义异常基类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public abstract class AbstractException extends RuntimeException &#123;</span><br><span class="line">    </span><br><span class="line">    @Serial</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    </span><br><span class="line">    private final String code;</span><br><span class="line">    private final String message;</span><br><span class="line">    </span><br><span class="line">    public AbstractException(ErrorCode errorCode, String message, Throwable throwable) &#123;</span><br><span class="line">        super(message, throwable);</span><br><span class="line">        this.code = errorCode.getCode();</span><br><span class="line">        this.message = Optional.ofNullable(message).orElse(errorCode.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public AbstractException(String code, String message, Throwable throwable) &#123;</span><br><span class="line">        super(message, throwable);</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义自定义异常类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BusinessException extends AbstractException &#123;</span><br><span class="line"></span><br><span class="line">    public BusinessException(ErrorCode errorCode, String message, Throwable throwable) &#123;</span><br><span class="line">        super(errorCode, message, throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(String code, String message, Throwable throwable) &#123;</span><br><span class="line">        super(code, message, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局异常的定义"><a href="#全局异常的定义" class="headerlink" title="全局异常的定义"></a>全局异常的定义</h3><p>在服务端在接收到参数，通常是不受信任的，这时我们需要对参数进行验证，因为参数验证并不是业务错误所以需要进行额外的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(value = &#123;MethodArgumentNotValidException.class, BindException.class, ValidationException.class&#125;)</span><br><span class="line">    public Result&lt;Void&gt; handleValidException(HttpServletRequest request, Exception e) &#123;</span><br><span class="line">        String exceptionStr = &quot;参数校验异常&quot;;</span><br><span class="line">        if (e instanceof MethodArgumentNotValidException ex) &#123;</span><br><span class="line">            BindingResult bindingResult = ex.getBindingResult();</span><br><span class="line">            FieldError firstFieldError = CollectionUtil.getFirst(bindingResult.getFieldErrors());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstFieldError)</span><br><span class="line">                    .map(FieldError::getDefaultMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">            </span><br><span class="line">        &#125; else if (e instanceof ConstraintViolationException) &#123;</span><br><span class="line">            ConstraintViolationException ex = (ConstraintViolationException) e;</span><br><span class="line">            </span><br><span class="line">            ConstraintViolation&lt;?&gt; firstConstraintViolation = CollectionUtil.getFirst(ex.getConstraintViolations());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstConstraintViolation)</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">            </span><br><span class="line">        &#125; else if (e instanceof BindException) &#123;</span><br><span class="line">            BindException ex = (BindException) e;</span><br><span class="line">            ObjectError firstObjectError = CollectionUtil.getFirst(ex.getAllErrors());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstObjectError)</span><br><span class="line">                    .map(ObjectError::getDefaultMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;, request.getMethod(), getUrl(request), exceptionStr);</span><br><span class="line">        return ResultHelper.failure(ErrorCode.PARAMETER_VALIDATION_FAILED.getCode(), exceptionStr);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理自定义异常</span><br><span class="line">    @ExceptionHandler(value = &#123;AbstractException.class&#125;)</span><br><span class="line">    public Result&lt;Void&gt; handleAbstractException(HttpServletRequest request, AbstractException ex) &#123;</span><br><span class="line">        String requestURL = getUrl(request);</span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;, request.getMethod(), requestURL, ex.toString());</span><br><span class="line">        return ResultHelper.failure(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 兜底处理</span><br><span class="line">    @ExceptionHandler(value = Throwable.class)</span><br><span class="line">    public Result&lt;Void&gt; handleThrowable(HttpServletRequest request, Throwable throwable) &#123;</span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; &quot;, request.getMethod(), getUrl(request), throwable);</span><br><span class="line">        return ResultHelper.failure(ErrorCode.SERVICE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取浏览地址信息</span><br><span class="line">    private String getUrl(HttpServletRequest request) &#123;</span><br><span class="line">        if (StrUtil.isEmpty(request.getQueryString())) &#123;</span><br><span class="line">            return request.getRequestURL().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return request.getRequestURL().toString() + &quot;?&quot; + request.getQueryString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试全局异常的定义"><a href="#测试全局异常的定义" class="headerlink" title="测试全局异常的定义"></a>测试全局异常的定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public String test(@RequestBody String request) &#123;</span><br><span class="line">        return (new ServerTemplate&lt;String, String&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected void validParam(String request) &#123;</span><br><span class="line">                if (request == null)&#123;</span><br><span class="line">                    throw new BusinessException(ErrorCode.CLIENT_ERROR.getCode(), &quot;请求参数不能为空&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected String doProcess(String request) &#123;</span><br><span class="line">                return request;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;).process(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723025785241-71b9b63e-878a-48ae-bf8f-ebf6754ca7b1.png"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上文中实现了统一返回格式以及统一的模板方法，以及为了简化写法的自动包装类和全局异常的处理，在日常开发中每个人的写法各异，统一的写法规定可以避免错误的代码实现以及提升代码的可读性，可以提升整个系统的可靠性，我们可以借助springboot的注解来实现这些在</p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>构建通用的Redis辅助类</title>
    <url>/2024/10/03/%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8%E7%9A%84Redis%E8%BE%85%E5%8A%A9%E7%B1%BB/</url>
    <content><![CDATA[<p>Redis中常用的功能可以分为两款，第一是缓存用于提升读性能，可以根据不同的数据类型来实现月签到统计，排行榜，消息订阅等功能。第二是用于实现分布式锁，一个成熟的辅助类可以对这两项功能进行封装，并列出常用的方法</p>
<span id="more"></span>
<h2 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h2><p>这里讲的是构建通用的辅助类，主要针对的是在开发中遇到的问题的解决方案，在实际的开发中</p>
<p>1.在集群环境中所有的数据都集中在0数据页中，key如果没有清晰的标识，容易出现互相覆盖的问题</p>
<p>2.不同的系统序列化问题</p>
<p>3.散乱的引用，后续对某个功能进行修改或者扩展太过繁杂</p>
<p>架构就是为了解决问题，根绝以上的问题，在构建辅助类的时候我们可以来</p>
<p>首先需要定义配置项key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;pomelo.cache.redis&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class PomeloRedisProperties &#123;</span><br><span class="line">    /**Redis前缀**/</span><br><span class="line">    private String prefix = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**默认超时时间**/</span><br><span class="line">    private Long timeout = 30000L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间单位</span><br><span class="line">     */</span><br><span class="line">    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义统一的key序列化方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class PomeloRedisKeySerializer  implements RedisSerializer&lt;String&gt; &#123;</span><br><span class="line">    private final String keyPrefix;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(String key) throws SerializationException &#123;</span><br><span class="line">        String buildKey = keyPrefix + key;</span><br><span class="line">        return buildKey.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String deserialize(byte[] bytes) throws SerializationException &#123;</span><br><span class="line">        return new String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自动注入设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableConfigurationProperties(PomeloRedisProperties.class)</span><br><span class="line">public class PomeloRedisCacheAutoConfiguration &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 构建Redis的Key</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PomeloRedisKeySerializer redisKeySerializer() &#123;</span><br><span class="line">        String prefix = pomeloRedisProperties.getPrefix();</span><br><span class="line">        return new PomeloRedisKeySerializer(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * redisTemplate相关配置</span><br><span class="line">     * [@Role(BeanDefinition.ROLE_INFRASTRUCTURE)] 表明这个bean是完全后台模式，不需要被代理。</span><br><span class="line">     *</span><br><span class="line">     * @param factory Redis连接工厂类</span><br><span class="line">     * @return 返回配置项对象</span><br><span class="line">     */</span><br><span class="line">    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        // 配置连接工厂</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jacksonSerial = new Jackson2JsonRedisSerializer&lt;&gt;(objectMapper, Object.class);</span><br><span class="line"></span><br><span class="line">        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        // null值字段不显示</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        // 美化JSON输出</span><br><span class="line">        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span><br><span class="line">        objectMapper.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        // 值采用json序列化</span><br><span class="line">        template.setValueSerializer(jacksonSerial);</span><br><span class="line">        // 使用StringRedisSerializer来序列化和反序列化redis的key值</span><br><span class="line">        template.setKeySerializer(redisKeySerializer());</span><br><span class="line">        // 设置hash key 和value序列化模式</span><br><span class="line">        template.setHashKeySerializer(redisKeySerializer());</span><br><span class="line">        // template.setHashValueSerializer(jacksonSerial);</span><br><span class="line">        template.setHashValueSerializer(jacksonSerial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义公共的辅助类：</p>
<h4 id="key操作辅助类"><a href="#key操作辅助类" class="headerlink" title="key操作辅助类"></a>key操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    /**</span><br><span class="line">     * 删除key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     */</span><br><span class="line">    public void delete(String key) &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量删除key</span><br><span class="line">     *</span><br><span class="line">     * @param keys</span><br><span class="line">     */</span><br><span class="line">    public void delete(Collection&lt;String&gt; keys) &#123;</span><br><span class="line">        stringRedisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public byte[] dump(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.dump(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否存在key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean exists(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean expire(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param date</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean expireAt(String key, Date date) &#123;</span><br><span class="line">        return stringRedisTemplate.expireAt(key, date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查找匹配的key</span><br><span class="line">     *</span><br><span class="line">     * @param pattern</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; keys(String pattern) &#123;</span><br><span class="line">        return stringRedisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将当前数据库的 key 移动到给定的数据库 db 当中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param dbIndex</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean move(String key, int dbIndex) &#123;</span><br><span class="line">        return stringRedisTemplate.move(key, dbIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除 key 的过期时间，key 将持久保持</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean persist(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.persist(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 的剩余的过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long getExpire(String key, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.getExpire(key, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 的剩余的过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long getExpire(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.getExpire(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从当前数据库中随机返回一个 key</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String randomKey() &#123;</span><br><span class="line">        return stringRedisTemplate.randomKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改 key 的名称</span><br><span class="line">     *</span><br><span class="line">     * @param oldKey</span><br><span class="line">     * @param newKey</span><br><span class="line">     */</span><br><span class="line">    public void rename(String oldKey, String newKey) &#123;</span><br><span class="line">        stringRedisTemplate.rename(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 仅当 newkey 不存在时，将 oldKey 改名为 newkey</span><br><span class="line">     *</span><br><span class="line">     * @param oldKey</span><br><span class="line">     * @param newKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean renameIfAbsent(String oldKey, String newKey) &#123;</span><br><span class="line">        return stringRedisTemplate.renameIfAbsent(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 所储存的值的类型</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public DataType type(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.type(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="String类型操作辅助类"><a href="#String类型操作辅助类" class="headerlink" title="String类型操作辅助类"></a>String类型操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisStringUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 中字符串值的子字符</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().get(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将给定 key 的值设为 value ，并返回 key 的旧值(old value)</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getAndSet(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对 key 所储存的字符串值，获取指定偏移量上的位(bit)</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param offset</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean getBit(String key, long offset) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().getBit(key, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量获取</span><br><span class="line">     *</span><br><span class="line">     * @param keys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; multiGet(Collection&lt;String&gt; keys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().multiGet(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置ASCII码, 字符串&#x27;a&#x27;的ASCII码是97, 转为二进制是&#x27;01100001&#x27;, 此方法是将二进制第offset位值变为value</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @param value 值,true为1, false为0</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean setBit(String key, long offset, boolean value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().setBit(key, offset, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param timeout 过期时间</span><br><span class="line">     * @param unit    时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES</span><br><span class="line">     *                秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS</span><br><span class="line">     */</span><br><span class="line">    public void setEx(String key, String value, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只有在 key 不存在时设置 key 的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return 之前已经存在返回false, 不存在返回true</span><br><span class="line">     */</span><br><span class="line">    public boolean setIfAbsent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param offset 从指定位置开始覆写</span><br><span class="line">     */</span><br><span class="line">    public void setRange(String key, String value, long offset) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取字符串的长度</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long size(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量添加</span><br><span class="line">     *</span><br><span class="line">     * @param maps</span><br><span class="line">     */</span><br><span class="line">    public void multiSet(Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().multiSet(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</span><br><span class="line">     *</span><br><span class="line">     * @param maps</span><br><span class="line">     * @return 之前已经存在返回false, 不存在返回true</span><br><span class="line">     */</span><br><span class="line">    public boolean multiSetIfAbsent(Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().multiSetIfAbsent(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加(自增长), 负数则为自减</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long incrBy(String key, long increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double incrByFloat(String key, double increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 追加到末尾</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Integer append(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().append(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="List操作辅助类"><a href="#List操作辅助类" class="headerlink" title="List操作辅助类"></a>List操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisListUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过索引获取列表中的元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lIndex(String key, long index) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().index(key, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取列表指定范围内的元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start 开始位置, 0是开始位置</span><br><span class="line">     * @param end   结束位置, -1返回所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; lRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存储在list头部</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPush(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushAll(String key, String... value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushAll(String key, Collection&lt;String&gt; value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当list存在的时候才加入</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushIfPresent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果pivot存在,再pivot前面添加</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param pivot</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPush(String key, String pivot, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPush(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushAll(String key, String... value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushAll(String key, Collection&lt;String&gt; value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为已存在的列表添加值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushIfPresent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在pivot元素的右边添加值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param pivot</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPush(String key, String pivot, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过索引设置列表元素的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index 位置</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    public void lSet(String key, long index, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForList().set(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的第一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return 删除的元素</span><br><span class="line">     */</span><br><span class="line">    public String lLeftPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout 等待时间</span><br><span class="line">     * @param unit    时间单位</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBLeftPop(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除并获取列表最后一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return 删除的元素</span><br><span class="line">     */</span><br><span class="line">    public String lRightPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout 等待时间</span><br><span class="line">     * @param unit    时间单位</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBRightPop(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span><br><span class="line">     *</span><br><span class="line">     * @param sourceKey</span><br><span class="line">     * @param destinationKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lRightPopAndLeftPush(String sourceKey, String destinationKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPopAndLeftPush(sourceKey,</span><br><span class="line">                destinationKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param sourceKey</span><br><span class="line">     * @param destinationKey</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBRightPopAndLeftPush(String sourceKey, String destinationKey,</span><br><span class="line">                                        long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPopAndLeftPush(sourceKey,</span><br><span class="line">                destinationKey, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除集合中值等于value得元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index index=0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素;</span><br><span class="line">     *              index&lt;0, 从尾部开始删除第一个值等于value的元素;</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRemove(String key, long index, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().remove(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 裁剪list</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     */</span><br><span class="line">    public void lTrim(String key, long start, long end) &#123;</span><br><span class="line">        stringRedisTemplate.opsForList().trim(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取列表长度</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLen(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Set操作类型辅助类"><a href="#Set操作类型辅助类" class="headerlink" title="Set操作类型辅助类"></a>Set操作类型辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisSetUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set添加元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sAdd(String key, String... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set移除元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sRemove(String key, Object... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除并返回集合的一个随机元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String sPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().pop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将元素value从一个集合移到另一个集合</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean sMove(String key, String value, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().move(key, value, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断集合是否包含value</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean sIsMember(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sIntersect(String key, String otherKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersect(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sIntersect(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersect(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的交集存储到destKey集合中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sIntersectAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersectAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的交集存储到destKey集合中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sIntersectAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersectAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的并集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sUnion(String key, String otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的并集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sUnion(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的并集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sUnionAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的并集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sUnionAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                               String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的差集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDifference(String key, String otherKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().difference(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的差集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDifference(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().difference(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的差集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sDifference(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().differenceAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的差集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sDifference(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                            String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().differenceAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合所有元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; setMembers(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中的一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String sRandomMember(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().randomMember(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中count个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param count</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; sRandomMembers(String key, long count) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().randomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中count个元素并且去除重复的</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param count</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDistinctRandomMembers(String key, long count) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().distinctRandomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;String&gt; sScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Hash操作辅助类"><a href="#Hash操作辅助类" class="headerlink" title="Hash操作辅助类"></a>Hash操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisHashUtils &#123;</span><br><span class="line"></span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取存储在哈希表中指定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Object hGet(String key, String field) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().get(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有给定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;Object, Object&gt; hGetAll(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有给定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param fields</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; hMultiGet(String key, Collection&lt;Object&gt; fields) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().multiGet(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hPut(String key, String hashKey, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hPutAll(String key, Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(key, maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 仅当hashKey不存在时才设置</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param hashKey</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean hPutIfAbsent(String key, String hashKey, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().putIfAbsent(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个或多个哈希表字段</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param fields</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hDelete(String key, Object... fields) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().delete(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查看哈希表 key 中，指定的字段是否存在</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean hExists(String key, String field) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().hasKey(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为哈希表 key 中的指定字段的整数值加上增量 increment</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @param increment</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hIncrBy(String key, Object field, long increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().increment(key, field, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为哈希表 key 中的指定字段的整数值加上增量 increment</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @param delta</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double hIncrByFloat(String key, Object field, double delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().increment(key, field, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有哈希表中的字段</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;Object&gt; hKeys(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().keys(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取哈希表中字段的数量</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取哈希表中所有值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; hValues(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().values(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 迭代哈希表中的键值对</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; hScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ZSet操作辅助类"><a href="#ZSet操作辅助类" class="headerlink" title="ZSet操作辅助类"></a>ZSet操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisZSetUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加元素,有序集合是按照元素的score值由小到大排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param score</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean zAdd(String key, String value, double score) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().add(key, value, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zAdd(String key, Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemove(String key, Object... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long zRemove(String key, Collection&lt;String&gt; values) &#123;</span><br><span class="line">        if (values != null &amp;&amp; !values.isEmpty()) &#123;</span><br><span class="line">            Object[] objs = values.toArray(new Object[values.size()]);</span><br><span class="line">            return stringRedisTemplate.opsForZSet().remove(key, objs);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加元素的score值，并返回增加后的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param delta</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double zIncrementScore(String key, String value, double delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().incrementScore(key, value, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return 0表示第一位</span><br><span class="line">     */</span><br><span class="line">    public Long zRank(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回元素在集合的排名,按元素的score值由大到小排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zReverseRank(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从小到大排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start 开始位置</span><br><span class="line">     * @param end   结束位置, -1查询所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取zset集合的所有元素, 从小到大排序</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRangeAll(String key) &#123;</span><br><span class="line">        return zRange(key, 0, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合元素, 并且把score值也获取</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, long start,</span><br><span class="line">                                                                   long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeWithScores(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min 最小值</span><br><span class="line">     * @param max 最大值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRangeByScore(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从小到大排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min 最小值</span><br><span class="line">     * @param max 最大值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,</span><br><span class="line">                                                                          double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,</span><br><span class="line">                                                                          double min, double max, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max,</span><br><span class="line">                start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRange(key, start, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, long min, long max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从大到小排序, 并返回score值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key,</span><br><span class="line">                                                                          long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeWithScores(key, start,</span><br><span class="line">                end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, double min,</span><br><span class="line">                                            double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores(</span><br><span class="line">            String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key,</span><br><span class="line">                min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, double min,</span><br><span class="line">                                            double max, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max,</span><br><span class="line">                start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据score值获取集合元素数量</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zCount(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().count(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zZCard(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().zCard(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合中value元素的score值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double zScore(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().score(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除指定索引位置的成员</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemoveRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().removeRange(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据指定的score值的范围来移除成员</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemoveRangeByScore(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().removeRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key和otherKey的并集并存储在destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zUnionAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zUnionAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                               String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet()</span><br><span class="line">                .unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zIntersectAndStore(String key, String otherKey,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().intersectAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zIntersectAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().intersectAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="管道辅助类"><a href="#管道辅助类" class="headerlink" title="管道辅助类"></a>管道辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisPipelineUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    /**</span><br><span class="line">     * 扫描主键，建议使用</span><br><span class="line">     *</span><br><span class="line">     * @param patten</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; scan(String patten) &#123;</span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.execute((RedisCallback&lt;Set&lt;String&gt;&gt;) connection -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">            try (Cursor&lt;byte[]&gt; cursor = connection.scan( ScanOptions.scanOptions()</span><br><span class="line">                    .match(patten).count(10000).build())) &#123;</span><br><span class="line">                while (cursor.hasNext()) &#123;</span><br><span class="line">                    result.add(new String(cursor.next()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;);</span><br><span class="line">        return keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 管道技术，提高性能</span><br><span class="line">     *</span><br><span class="line">     * @param type</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; lRightPushPipeline(String type, Collection&lt;String&gt; values) &#123;</span><br><span class="line">        List&lt;Object&gt; results = stringRedisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;</span><br><span class="line">                //集合转换数组</span><br><span class="line">                String[] strings = values.toArray(new String[values.size()]);</span><br><span class="line">                //直接批量发送</span><br><span class="line">                stringRedisConn.rPush(type, strings);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public List&lt;Object&gt; refreshWithPipeline(String futureKey, String topicKey, Collection&lt;String&gt; tasks) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; result = stringRedisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Nullable</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123;</span><br><span class="line">                StringRedisConnection stringRedisConnection = (StringRedisConnection) redisConnection;</span><br><span class="line">                String[] allTask = tasks.toArray(new String[tasks.size()]);</span><br><span class="line">                stringRedisConnection.lPush(topicKey, allTask);</span><br><span class="line">                stringRedisConnection.zRem(futureKey, allTask);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自定义RedissonClient"><a href="#自定义RedissonClient" class="headerlink" title="自定义RedissonClient"></a>自定义RedissonClient</h2><p>缓存我们使用的RedisTemplate，但是布隆处理器和分布式锁我们需要使用RedissonClient，增加RedissonClient配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><br><span class="line">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><br><span class="line">public class RedissonClientAutoConfiguration &#123;</span><br><span class="line">    private RedisProperties redisProperties;</span><br><span class="line"></span><br><span class="line">    private final static String SCHEMA = &quot;redis://&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">            name = &#123;&quot;redissonClient&quot;&#125;</span><br><span class="line">    )</span><br><span class="line">    public RedissonClient redissonClient()&#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line"></span><br><span class="line">        //集群模式</span><br><span class="line">        if(redisProperties.getCluster() != null)&#123;</span><br><span class="line">            RedisProperties.Cluster cluster = redisProperties.getCluster();</span><br><span class="line">            List&lt;String&gt; nodes = cluster.getNodes();</span><br><span class="line"></span><br><span class="line">            ClusterServersConfig clusterServersConfig = config.useClusterServers()</span><br><span class="line">                    .addNodeAddress(getSchemaAddress(nodes));</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                clusterServersConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line">            //哨兵模式</span><br><span class="line">        &#125;else if (redisProperties.getSentinel() != null)&#123;</span><br><span class="line">            RedisProperties.Sentinel sentinel = redisProperties.getSentinel();</span><br><span class="line">            List&lt;String&gt; nodes = sentinel.getNodes();</span><br><span class="line"></span><br><span class="line">            SentinelServersConfig sentinelServersConfig = config.useSentinelServers()</span><br><span class="line">                    .setMasterName(sentinel.getMaster())</span><br><span class="line">                    .setConnectTimeout(50000)</span><br><span class="line">                    .addSentinelAddress(getSchemaAddress(nodes))</span><br><span class="line">                    .setMasterConnectionPoolSize(64)</span><br><span class="line">                    .setMasterConnectionMinimumIdleSize(32)</span><br><span class="line">                    .setSlaveConnectionPoolSize(64)</span><br><span class="line">                    .setSlaveConnectionMinimumIdleSize(32);</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                sentinelServersConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            SingleServerConfig singleServerConfig = config.useSingleServer()</span><br><span class="line">                    .setAddress(SCHEMA + redisProperties.getHost() + &quot;:&quot; + redisProperties.getPort())</span><br><span class="line">                    .setDatabase(redisProperties.getDatabase());</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                singleServerConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        config.setCodec(new JsonJacksonCodec());</span><br><span class="line"></span><br><span class="line">        return Redisson.create(config);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建Schema的redis连接</span><br><span class="line">     * @param nodes 节点</span><br><span class="line">     * @return schema数组</span><br><span class="line">     */</span><br><span class="line">    private String[] getSchemaAddress(List&lt;String&gt; nodes) &#123;</span><br><span class="line">        String[] sentinelAddressesWithSchema = new String[nodes.size()];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            sentinelAddressesWithSchema[i] = SCHEMA + nodes.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sentinelAddressesWithSchema;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布隆处理器"><a href="#布隆处理器" class="headerlink" title="布隆处理器"></a>布隆处理器</h2><p>布隆过滤器（Bloom filter）是一种空间效率极高的概率型数据结构，用于判断一个元素是否在一个集合中。它的原理是当一个元素被加入集合时，通过几个不同的Hash函数将元素映射成一个位数组中的多个位置，再次查询时如果位数组中的每一位都此被设置过，则肯定在集合中。如果这些位有任何一位没有被设置过，则肯定不在集合中。主要的优点是空间效率和查询时间都远超一般的算法。</p>
<p>布隆过滤器可以用来解决缓存穿透问题。在接到一个查询请求时，先用布隆过滤器检查，如果布隆过滤器判断元素不在集合中，那么就可以不用去数据库中查询了，直接返回“元素不存在”。</p>
<p>一般在使用布隆过滤器的具体操作为：</p>
<ol>
<li>先将所有可能查询的数据hash到布隆过滤器中</li>
<li>当用户查询数据的时候，首先在布隆过滤器查询数据是否存在</li>
<li>如果布隆过滤器认为数据不存在，则直接返回给用户“数据不存在”</li>
<li>如果布隆过滤器认为数据存在，那么再去数据库中查询数据</li>
<li>再将数据库查询出来的数据存入缓存</li>
</ol>
<p>定义一个简单的布隆过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class PomeloBloomFilterAutoConfiguration &#123;</span><br><span class="line">    private static final String BLOOM_KEY = &quot;pomelo_bloom_filter&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 布隆过滤器</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RBloomFilter&lt;String&gt; cacheBloomFilter(RedissonClient redissonClient) &#123;</span><br><span class="line">        RBloomFilter&lt;String&gt; rBloomFilter = redissonClient.getBloomFilter(BLOOM_KEY);</span><br><span class="line">        rBloomFilter.tryInit(50000L, 0.03D);</span><br><span class="line">        return rBloomFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义一个简单的过滤器工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisBloomFilterUtils &#123;</span><br><span class="line">    private  final RBloomFilter bloomFilter;;</span><br><span class="line">    public boolean add(String value) &#123;</span><br><span class="line">        return bloomFilter.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean contains(String value) &#123;</span><br><span class="line">        return bloomFilter.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><font style="color:rgb(77, 77, 77);">并发执行是比较场景的场景，单机情况下，我们可以利用</font><a href="https://so.csdn.net/so/search?q=%E9%94%81%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020">锁机制</a><font style="color:rgb(77, 77, 77);">来实现顺序执行。然而微服务时代，多节点运行，如何让某业务可以同一时刻只允许一个任务运行呢？</font><br><font style="color:rgb(77, 77, 77);">Redisson实现分布式锁的用法，可以很容易实现分布式锁的配置。</font></p>
<p><font style="color:rgb(77, 77, 77);">我们按照本地模式来在辅助类中实现本地锁</font></p>
<p><font style="color:rgb(77, 77, 77);">定义ILock</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ILock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 加锁，并返回锁对象</span><br><span class="line">     */</span><br><span class="line">    Lock tryLock(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放锁对象</span><br><span class="line">     */</span><br><span class="line">    void unlock(Lock lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义DistributeLock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface DistributeLock extends ILock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建锁实例</span><br><span class="line">     */</span><br><span class="line">    RLock getLock(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建公平锁实例</span><br><span class="line">     */</span><br><span class="line">    RLock getFairLock(String key);</span><br><span class="line"></span><br><span class="line">    boolean tryLock(RLock lock);</span><br><span class="line">    boolean tryLock(RLock lock, long timeout);</span><br><span class="line"></span><br><span class="line">    RLock tryLock(String key);</span><br><span class="line">    RLock tryLock(String key, long timeout) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    RLock tryLock(String key, long timeout, TimeUnit timeUnit) throws InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现DistributeLock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedissonDistributeLock implements DistributeLock&#123;</span><br><span class="line">    private final RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock getLock(String key) &#123;</span><br><span class="line">        return redissonClient.getLock(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock getFairLock(String key) &#123;</span><br><span class="line">        return redissonClient.getFairLock(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(RLock lock) &#123;</span><br><span class="line">        return lock.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(RLock lock, long timeout) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (lock.tryLock(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key) &#123;</span><br><span class="line">        RLock lock = getLock(key);</span><br><span class="line">        if (lock.tryLock()) &#123;</span><br><span class="line">            return lock; // 直接返回锁对象</span><br><span class="line">        &#125;</span><br><span class="line">        return null; // 获取锁失败，返回null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key, long timeout) &#123;</span><br><span class="line">        return tryLock(key, timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key, long timeout, TimeUnit timeUnit) &#123;</span><br><span class="line">        RLock lock = getLock(key);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (lock.tryLock(timeout, timeUnit)) &#123;</span><br><span class="line">                return lock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(Lock lock) &#123;</span><br><span class="line">        if (lock instanceof RLock) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自动配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class PomeloLockAutoConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnClass(RedissonClient.class)</span><br><span class="line">    public DistributeLock redissonDistributeLock(RedissonClient redissonClient) &#123;</span><br><span class="line">        return new RedissonDistributeLock(redissonClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>工具</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>统一返回时间格式</title>
    <url>/2024/10/06/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>在springboot中@RestController的返回会使用Jackson来将响应序列化为json格式，所以构建统一的响应中的日期格式可以定义统一的序列化参数来实现，springboot自带的时间格式定义怎么处理的</p>
<span id="more"></span>
<h3 id="1-使用-DateTimeFormat和-JsonFormat都是处理时间格式化问题的"><a href="#1-使用-DateTimeFormat和-JsonFormat都是处理时间格式化问题的" class="headerlink" title="1.使用@DateTimeFormat和@JsonFormat都是处理时间格式化问题的"></a>1.使用@DateTimeFormat和@JsonFormat都是处理时间格式化问题的</h3><table>
<thead>
<tr>
<th>区别</th>
<th>@DateTimeFormat</th>
<th>@JsonFormat</th>
</tr>
</thead>
<tbody><tr>
<td>使用方法</td>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”)</font></td>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”, timezone &#x3D; “GMT+8”)</font></td>
</tr>
<tr>
<td>使用场景</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">URL传参时，格式化前端传向后端日期类型的时间格式</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">JSON传参，格式化前端传参和后端返回给前端的时间格式，传参可能不一定是json，但是一般接口向前端返回数据，基本上都是封装的统一返回格式，然后JSON返回。所以这个注解是一定要加的！</font></td>
</tr>
<tr>
<td>使用地方</td>
<td><font style="color:rgb(79, 79, 79);">实体类日期字段上、或者字段的set方法上、或者方法入参上</font></td>
<td><font style="color:rgb(79, 79, 79);">实体类日期字段上、或者字段的set方法上、、或者方法入参上</font></td>
</tr>
<tr>
<td>来源</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">org.springframework.format.annotation</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">com.fasterxml.jackson.annotation</font></td>
</tr>
</tbody></table>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>一旦使用yyyy-MM-dd 格式，如果传时分秒就会报错，或者是使用 yyyy-MM-dd HH:mm:ss，如果传yyyy-MM-dd 也会报错。</li>
<li>假如是springboot项目的话，使用这两个注解是不用导其他的依赖包的！</li>
<li>框架当中默认他会认为 前端传的是UTC时间，然后SpringMVC在接到参数的时候，会进行转换为本地区时间，向前端返回参数的时候会转换为UTC时间！</li>
<li>这两个注解可以选择在实体类的set方法当中使用，也可以在字段上使用，效果是一样的！</li>
</ul>
<h3 id="2-在全局配置文件中设置"><a href="#2-在全局配置文件中设置" class="headerlink" title="2.在全局配置文件中设置"></a>2.在全局配置文件中设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss </span><br><span class="line">    time-zone: GMT+8</span><br></pre></td></tr></table></figure>

<h3 id="3-通过JavaBean方式配置"><a href="#3-通过JavaBean方式配置" class="headerlink" title="3.通过JavaBean方式配置"></a>3.通过JavaBean方式配置</h3><p>定义DateForamtConfiguration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DateForamtConfiguration &#123;</span><br><span class="line"></span><br><span class="line">        public static final String timeFormat = &quot;HH:mm:ss&quot;;</span><br><span class="line">        public static final String dateFormat = &quot;yyyy-MM-dd&quot;;</span><br><span class="line">        public static final String dateTimeFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 全局时间格式化</span><br><span class="line">         */</span><br><span class="line">        @Bean</span><br><span class="line">        public Jackson2ObjectMapperBuilderCustomizer customizer() &#123;</span><br><span class="line">            return builder -&gt; &#123;</span><br><span class="line">                builder.simpleDateFormat(dateTimeFormat);</span><br><span class="line">                //日期序列化</span><br><span class="line">                builder.serializers(new LocalTimeSerializer(DateTimeFormatter.ofPattern(timeFormat)));</span><br><span class="line">                builder.serializers(new LocalDateSerializer(DateTimeFormatter.ofPattern(dateFormat)));</span><br><span class="line">                builder.serializers(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(dateTimeFormat)));</span><br><span class="line">                //日期反序列化</span><br><span class="line">                builder.deserializers(new LocalTimeDeserializer(DateTimeFormatter.ofPattern(timeFormat)));</span><br><span class="line">                builder.deserializers(new LocalDateDeserializer(DateTimeFormatter.ofPattern(dateFormat)));</span><br><span class="line">                builder.deserializers(new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(dateTimeFormat)));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>格式化</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>集成Nacos+SpringCloudGateway实现配置中心以及服务发现</title>
    <url>/2024/10/03/%E9%9B%86%E6%88%90Nacos+SpringCloudGateway%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>前面已经实现了统一返回以及异常处理，也完成了通用的数据模块，我们已经可以借此来实现服务，但是在微服务中肯定不会只有一个服务，当我们有多个服务的时候，会出现多个痛点：</p>
<ol>
<li>当服务多的时候分布在不同的服务器上部署的时候，前端寻址将是困难重重，所以需要一个统一的入口，来帮助前端来访问这些服务</li>
<li>多个服务分部在不同的主机上，当我们因为某种原因需要修改多个服务的配置文件时，工作量巨大。</li>
</ol>
<p>而Nacos+SpringCloudGateway可以帮我们解决这个问题</p>
<span id="more"></span>
<h2 id="集成Nacos"><a href="#集成Nacos" class="headerlink" title="集成Nacos"></a>集成Nacos</h2><h3 id="nacos是做什么的"><a href="#nacos是做什么的" class="headerlink" title="nacos是做什么的"></a>nacos是做什么的</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723102566330-cd999175-7353-4a7c-977c-9c09184126c6.png"></p>
<p>nacos的官网关于nacos的介绍一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台，那他有什么作用呢<img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723102912210-7e6f66de-bf32-4988-aeae-aa4e993406c0.png"></p>
<p>官网的描述是这样的，总结一下有两点：服务发现和服务注册以及配置管理，那nacos能做些什么呢</p>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册:"></a>服务注册:</h4><p>服务提供者在启动时向 Nacos 注册中心注册自己的服务信息，包括服务名称、IP 地址、端口号等。</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现:"></a>服务发现:</h4><p>服务消费者从 Nacos 注册中心获取服务提供者的信息，从而能够调用服务。</p>
<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查:"></a>健康检查:</h4><p>Nacos 支持服务实例的健康检查，可以自动剔除不健康的服务实例。</p>
<h4 id="服务元数据管理"><a href="#服务元数据管理" class="headerlink" title="服务元数据管理:"></a>服务元数据管理:</h4><p>除了基本的服务信息外，还可以附加服务的元数据，如版本、权重等。</p>
<h4 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组:"></a>服务分组:</h4><p>支持服务分组，可以根据不同的业务场景将服务划分到不同的组。</p>
<h4 id="服务版本控制"><a href="#服务版本控制" class="headerlink" title="服务版本控制:"></a>服务版本控制:</h4><p>支持服务版本管理，便于灰度发布和回滚。</p>
<h4 id="配置管理："><a href="#配置管理：" class="headerlink" title="配置管理："></a>配置管理：</h4><p>动态的配置管理用于集中管理配置文件</p>
<h3 id="在user模块中集成nacos"><a href="#在user模块中集成nacos" class="headerlink" title="在user模块中集成nacos"></a>在user模块中集成nacos</h3><p>首先定义pom文件（前文中已经定义了nacos的版本）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>启动类增加@EnableDiscoveryClient</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class PomeloCustomerModulesApplication &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(PomeloCustomerModulesApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加文件bootstrap.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 5030</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: pomelo-customer</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        namespace: c3477374-9bfd-4c52-a511-8a99468d7759</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: c3477374-9bfd-4c52-a511-8a99468d7759</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>启动服务</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723189847074-be1be5fa-4d1c-4948-bd2a-95e1bbc355d7.png"></p>
<p>可以看到已经连接到nacos</p>
<h2 id="集成SpringCloudGateway"><a href="#集成SpringCloudGateway" class="headerlink" title="集成SpringCloudGateway"></a>集成SpringCloudGateway</h2><h3 id="SpringCloudGateway是做什么的"><a href="#SpringCloudGateway是做什么的" class="headerlink" title="SpringCloudGateway是做什么的"></a>SpringCloudGateway是做什么的</h3><pre><code>在微服务架构中，一个系统会被拆分为很多个微服务。那么作为客户端要如何去调用这么多的微服务呢？如果没有网关的存在，我们只能在客户端记录每个微服务的地址，然后分别去调用。这样的话会产生很多问题，例如：
</code></pre>
<ul>
<li>客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性</li>
<li>认证复杂，每个微服务都有独立认证</li>
<li>存在跨域请求，在一定场景下处理相对复杂</li>
</ul>
<p>为解决上面的问题所以引入了网关的概念：所谓的API网关，就是指系统的统一入口，提供内部服务的路由中转，为客户端提供统一服务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、路由转发等。</p>
<p><font style="color:rgb(0, 0, 0);">Spring Cloud Gateway就是api网关。官网上对Spring Cloud Gateway如下：</font></p>
<p>:::info<br><font style="color:rgb(0, 0, 0);">This project provides a libraries for building an API Gateway on top of Spring WebFlux or Spring WebMVC. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring&#x2F;metrics, and resiliency.</font></p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a><font style="color:rgb(0, 0, 0);">Features</font></h2><p><font style="color:rgb(0, 0, 0);">Spring Cloud Gateway features:</font></p>
<ul>
<li><font style="color:rgb(0, 0, 0);">Built on Spring Framework and Spring Boot</font></li>
<li><font style="color:rgb(0, 0, 0);">Able to match routes on any request attribute.</font></li>
<li><font style="color:rgb(0, 0, 0);">Predicates and filters are specific to routes.</font></li>
<li><font style="color:rgb(0, 0, 0);">Circuit Breaker integration.</font></li>
<li><font style="color:rgb(0, 0, 0);">Spring Cloud DiscoveryClient integration</font></li>
<li><font style="color:rgb(0, 0, 0);">Easy to write Predicates and Filters</font></li>
<li><font style="color:rgb(0, 0, 0);">Request Rate Limiting</font></li>
<li><font style="color:rgb(0, 0, 0);">Path Rewriting</font></li>
</ul>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring5.0+Spring Boot20和 Project Reactor等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的API路由管理方式。</font></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><font style="color:rgb(79, 79, 79);">作用</font></h4><ul>
<li><font style="color:rgb(77, 77, 77);">反向代理</font></li>
<li><font style="color:rgb(77, 77, 77);">鉴权</font></li>
<li><font style="color:rgb(77, 77, 77);">流量控制</font></li>
<li><font style="color:rgb(77, 77, 77);">熔断</font></li>
<li><font style="color:rgb(77, 77, 77);">日志监控</font></li>
</ul>
<h3 id="通过SpringCloudGateway找到user模块"><a href="#通过SpringCloudGateway找到user模块" class="headerlink" title="通过SpringCloudGateway找到user模块"></a>通过SpringCloudGateway找到user模块</h3><p>当了解过概念后我们来动手实践一下</p>
<h4 id="第一步引入pom"><a href="#第一步引入pom" class="headerlink" title="第一步引入pom"></a>第一步引入pom</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--nacos--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二步引入nacos"><a href="#第二步引入nacos" class="headerlink" title="第二步引入nacos"></a>第二步引入nacos</h4><p>按照上面nacos的步驟做一遍</p>
<h4 id="第三步配置路由"><a href="#第三步配置路由" class="headerlink" title="第三步配置路由"></a>第三步配置路由</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          lowerCaseServiceId: true</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: pomelo-user</span><br><span class="line">        uri: lb://pomelo-user</span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/user/**</span><br><span class="line">        filters:</span><br><span class="line">          - StripPrefix=1</span><br></pre></td></tr></table></figure>

<h4 id="第四步测试"><a href="#第四步测试" class="headerlink" title="第四步测试"></a>第四步测试</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723191800165-3fce78f5-7a95-4d7e-8fd5-c36b50d2b6bd.png"></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>nacos</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2024/05/03/%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>类型</th>
<th>单体</th>
<th>微服务</th>
</tr>
</thead>
<tbody><tr>
<td>部署速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>扩展能力</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>复用能力</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>复杂度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>耦合度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>调试</td>
<td>容易</td>
<td>困难</td>
</tr>
<tr>
<td>问题排查</td>
<td>容易</td>
<td>困难</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>差</td>
</tr>
</tbody></table>
<span id="more"></span>


<p>单体应用：随着时间的积累代码量越来越大构建速度会越来越慢，部署也会越来越慢，随着代码的积累各种代码的耦合度会越来越高，技术债务逐步上升代码的扩展能力持续下降，复用困难，业务为了避免各种技术债务复杂度会越来越高。因为技术债务较高当开发人员离职后，继任者需要大量的时间去熟悉系统和代码，造成经济损失。但是在开发中单体服务代码集中日志集中所以调试简单，问题排查过程简单。而且单体中不需要额外的服务调用所以性能会更好一点</p>
<p>微服务应用：通过设计将业务进行拆分，降低各个服务间的耦合，每个服务独立部署并且实现服务轻量化，所以构建迅速。因为各个服务独立与其他服务耦合度低所以复用能力和扩展能力更强，每个服务更专注自己的业务领域所以业务的复杂度更低。复杂度更低即使开发人员离职，继任者只需要了解自己需要负责的服务就可以胜任。但是微服务因为做了拆分所以数据的交换需要进行进程通讯，而且同一个请求可能经过多个服务。进程间的通讯会对性能产生影响，请求经过多个服务会使数据的事务实施困难，以及单个请求的异常因为链路太长定位问题困难。</p>
<p>针对微服务的缺点我们的弥补措施：</p>
<p>微服务之间互相调用网络请求的瓶颈：尽量的明确接口数据长度，使用缓存，减少服务间的交互，更改交互方式为rpc</p>
<p>调试和问题排查：问题排查主要是分为两部分</p>
<p>1.问题的定位问题： 引入skywalking来对全链路进行追踪</p>
<p>2.问题的上下文信息获取：引入ELK日志管理解决方案，对日志进行集中，并通过skywalking提供的唯一ID对数据进行查询分析</p>
<p>事务：事务可以根据业务情况来使用诸如两段式提交的解决方案或者使用最终一致性解决方案来解决</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>单体</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign调用时如何传递传递Token并且多线程环境也能适用</title>
    <url>/2024/10/16/OpenFeign%E8%B0%83%E7%94%A8%E6%97%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E4%BC%A0%E9%80%92Token%E5%B9%B6%E4%B8%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B9%9F%E8%83%BD%E9%80%82%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>在上一片文章中我<font style="color:rgb(47, 48, 52);">们解决了网关层认证后向后端服务传递用户信息的问题。今天我们来解决另外一个问题：如何在 OpenFeign 中传递 Token，并且保证多线程情况下也能适用。</font></p>
<span id="more"></span>
<p><font style="color:rgb(47, 48, 52);">如果我们想要在OpenFeign中获取到用户信息，我们可以通过如下步骤实现</font></p>
<h3 id="实现RequestInterceptor接口"><a href="#实现RequestInterceptor接口" class="headerlink" title="实现RequestInterceptor接口"></a><font style="color:rgb(47, 48, 52);">实现RequestInterceptor接口</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloFeignRequestInterceptor implements RequestInterceptor &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void apply(RequestTemplate requestTemplate) &#123;</span><br><span class="line">        Map&lt;String, String&gt; headerMap = RequestHeaderContextHolder.getInstance().get();</span><br><span class="line">        if (ObjectUtil.isNotEmpty(headerMap)) &#123;</span><br><span class="line">            // heders头透传</span><br><span class="line">            for (Map.Entry&lt;String, String&gt; entry : headerMap.entrySet()) &#123;</span><br><span class="line">                requestTemplate.header(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用InheritableThreadLocal保存header信息"><a href="#使用InheritableThreadLocal保存header信息" class="headerlink" title="使用InheritableThreadLocal保存header信息"></a>使用<font style="color:rgb(47, 48, 52);">InheritableThreadLocal保存header信息</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RequestHeaderContextHolder &#123;</span><br><span class="line">    </span><br><span class="line">    // 使用InheritableThreadLocal，使得共享变量可被子线程继承</span><br><span class="line">    private final ThreadLocal&lt;Map&lt;String, String&gt;&gt; REQUEST_HEADER_HOLDER;</span><br><span class="line">    private RequestHeaderContextHolder() &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER = new InheritableThreadLocal&lt;&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected Map&lt;String, String&gt; initialValue() &#123;</span><br><span class="line">                return new HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * return RequestHeaderHolder instance</span><br><span class="line">     */</span><br><span class="line">    public static RequestHeaderContextHolder getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 根据键获取请求头的值</span><br><span class="line">     * @param key 请求头的键</span><br><span class="line">     * @return 对应键的值</span><br><span class="line">     */</span><br><span class="line">    public String getValue(String key) &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取当前线程的请求头信息</span><br><span class="line">     * @return 请求头Map</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, String&gt; get() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取当前线程的用户信息</span><br><span class="line">     * @return 当前用户信息</span><br><span class="line">     */</span><br><span class="line">    public String getCurrentUser() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCurrentUserName() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 设置当前线程的用户信息</span><br><span class="line">     * @param userId 用户ID</span><br><span class="line">     */</span><br><span class="line">    public void setCurrentUser(String userId) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_ID_HEADER, userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentUser(String userId, String userName) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_ID_HEADER, userId);</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_NAME_HEADER, userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 设置请求头信息</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, String value) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类的单例模式</span><br><span class="line">     */</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        </span><br><span class="line">        private static final RequestHeaderContextHolder instance = new RequestHeaderContextHolder();</span><br><span class="line">        private SingletonHolder() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改请求拦截器"><a href="#修改请求拦截器" class="headerlink" title="修改请求拦截器"></a><font style="color:rgb(47, 48, 52);">修改请求拦截器</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserTokenHandlerInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String userId = request.getHeader(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">        String userName = request.getHeader(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">        RequestHeaderContextHolder.getInstance().setCurrentUser(userId, userName);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        RequestHeaderContextHolder.getInstance().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>通过实现requestInterceotor接口我们在每次进行feign调用时都会将header头文件进行传递。但是在异步的环境中无法获取到header头文件信息，我们通过自定义<font style="color:rgb(47, 48, 52);">InheritableThreadLocal结构体对header进行保存然后贡献的形式进行处理。这样可以在不同的场景下依然可以完成数据的保存</font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Sa-Token的微服务权限验证</title>
    <url>/2024/10/06/%E5%9F%BA%E4%BA%8ESa-Token%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p><strong><font style="color:rgb(44, 62, 80);">Sa-Token</font></strong><font style="color:rgb(52, 73, 94);"> 是一个轻量级 Java 权限认证框架主，要解决：</font><strong><font style="color:rgb(44, 62, 80);">登录认证</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">权限认证</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">单点登录</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">OAuth2.0</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">分布式Session会话</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">微服务网关鉴权</font></strong><font style="color:rgb(52, 73, 94);"> 等一系列权限相关问题。Sa-Token 旨在以简单、优雅的方式完成系统的权限认证部分。</font></p>
<p><font style="color:rgb(52, 73, 94);">官网地址：</font><a href="https://sa-token.cc/">https://sa-token.cc/</a></p>
<span id="more"></span>
<h2 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>多种登陆模式，账号密码，手机号验证码等</li>
<li>网关验证登陆是否过期，黑白名单等处理</li>
<li>可以支持角色和权限字符串鉴权验证</li>
<li>实现登出功能</li>
<li>减少数据库访问，登陆后数据详情放入redis中</li>
</ul>
<p>在pomelo中权限的验证，采用了token格式的数据，对与用户信息进行缓存的形式进行操作，并没有使用jwt，主要考虑有两种：jwt的数据保存在token字符串中，增加了前端到后段的通讯负担，敏感数据的解析一样需要从服务端中获取，所以在pomelo中，我们直接使用token来进行交互，并把用户的数据保存在redis缓存中，虽然需要承担redis缓存宕机带来的用户验证异常，但是也拥有很高的灵活性</p>
<h3 id="网关统一认证处理"><a href="#网关统一认证处理" class="headerlink" title="网关统一认证处理"></a>网关统一认证处理</h3><p>网关可以统一的来实现权限的认证，但是不够灵活，所以在网关中只对消息中是否存在token来进行判断，token消息是否过期进行处理，当消息正常时新增Header对token进行透传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class AuthFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DistributedCache distributedCache;</span><br><span class="line">    // 排除过滤的 uri 地址，nacos自行添加</span><br><span class="line">    @Autowired</span><br><span class="line">    private IgnoreWhiteProperties ignoreWhite;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthProperties authProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 连接 Token 前缀和 Token 值的字符</span><br><span class="line">     */</span><br><span class="line">    public static final String TOKEN_CONNECTOR_CHAT  = &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">        String path = exchange.getRequest().getURI().getPath();</span><br><span class="line">        // 跳过不需要验证的路径</span><br><span class="line">        if (StringUtils.matches(path, ignoreWhite.getWhites())) &#123;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        String token = getToken(request);</span><br><span class="line">        if (StrUtil.isEmpty(token)) &#123;</span><br><span class="line">            return unauthorizedResponse(exchange, ErrorCode.TOKEN_EMPTY_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        // 验证token是否过期</span><br><span class="line">        if (!distributedCache.hasKey(authProperties.getIdentifier() + &quot;:login:token:&quot; + token)) &#123;</span><br><span class="line">            return unauthorizedResponse(exchange, ErrorCode.TOKEN_EXPIRATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String prefixToken =String.format(&quot;%s%s%s&quot;, authProperties.getPrefix(),TOKEN_CONNECTOR_CHAT, token) ;</span><br><span class="line">        addHeader(mutate, authProperties.getIdentifier(), prefixToken,true);</span><br><span class="line">        String loginUserKey  = String.format(&quot;%S%S&quot;, SecurityConstants.USER_KEY, token);</span><br><span class="line">        if (distributedCache.hasKey(loginUserKey)) &#123;</span><br><span class="line">            LoginUser loginUser= distributedCache.get(loginUserKey, LoginUser.class);</span><br><span class="line">            if (loginUser != null)&#123;</span><br><span class="line">                addHeader(mutate, SecurityConstants.USER_ID_HEADER, loginUser.getUserId(),false);</span><br><span class="line">                addHeader(mutate, SecurityConstants.USER_NAME_HEADER, loginUser.getUserName(),false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addHeader(ServerHttpRequest.Builder mutate, String name, Object value,Boolean isEncode) &#123;</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueStr = value.toString();</span><br><span class="line">        if (isEncode)&#123;</span><br><span class="line">            mutate.header(name, valueStr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueEncode = ServletUtils.urlEncode(valueStr);</span><br><span class="line">        mutate.header(name, valueEncode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Mono&lt;Void&gt; unauthorizedResponse(ServerWebExchange exchange, ErrorCode errorCode) &#123;</span><br><span class="line">        log.error(&quot;[鉴权异常处理]请求路径:&#123;&#125;&quot;, exchange.getRequest().getPath());</span><br><span class="line">        return ServletUtils.webFluxResponseWriter(exchange.getResponse(), errorCode.getMessage(), errorCode.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求token</span><br><span class="line">     */</span><br><span class="line">    private String getToken(ServerHttpRequest request) &#123;</span><br><span class="line">        String token = request.getHeaders().getFirst(SecurityConstants.AUTHORIZATION_HEADER);</span><br><span class="line">        // 如果前端设置了令牌前缀，则裁剪掉前缀</span><br><span class="line">        if (StrUtil.isNotEmpty(token) &amp;&amp; token.startsWith(authProperties.getPrefix())) &#123;</span><br><span class="line">            token = token.replaceFirst(authProperties.getPrefix(), &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="登陆授权"><a href="#登陆授权" class="headerlink" title="登陆授权"></a>登陆授权</h3><p>登陆需要支持两种模式一种是短信登陆，以及账号密码登陆。短信登陆时如果账号未注册，直接注册新用户，账号密码需要提前注册后才能登陆。当用户身份验证通过后，需要将token放入redis用于处理token超时的问题，2将token与用户信息关联，为后续验证做好准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public LoginRspVo login(LoginDTO loginDTO) &#123;</span><br><span class="line">       // 预认证 验证参数</span><br><span class="line">       preAuthenticationCheck(loginDTO);</span><br><span class="line">       // 认证</span><br><span class="line">       LoginUser loginUser = authenticate(loginDTO);</span><br><span class="line">       CacheUtil.addLoginUser(loginUser);</span><br><span class="line">       // 角色获取</span><br><span class="line">       List&lt;String&gt; roles = getRoles(loginUser.getUserId());</span><br><span class="line">       if (CollectionUtil.isNotEmpty(roles))&#123;</span><br><span class="line">           CacheUtil.updateRoleCache(loginUser.getUserId(), roles);</span><br><span class="line"></span><br><span class="line">           // 权限获取</span><br><span class="line">           for (String role : roles) &#123;</span><br><span class="line">               List&lt;String&gt; permissions = getPermissions(role);</span><br><span class="line">               CacheUtil.updatePermissionCache(role, permissions);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       LoginRspVo loginRspVo = new LoginRspVo();</span><br><span class="line">       loginRspVo.setAccess_token(loginUser.getToken());</span><br><span class="line">       loginRspVo.setUserId(loginUser.getUserId());</span><br><span class="line">       loginRspVo.setUserName(loginUser.getUserName());</span><br><span class="line">       loginRspVo.setLoginTime(loginUser.getLoginTime());</span><br><span class="line">       return loginRspVo;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>实现思路：当系统用户登录完成后，将用户数据放入缓存，以及将用户的角色和权限信息放入到缓存。以供网关以及后续鉴权提供数据支持。</p>
<h3 id="服务鉴权"><a href="#服务鉴权" class="headerlink" title="服务鉴权"></a>服务鉴权</h3><p>在sa-token中提供了StpInterface借口，来对权限以及角色进行处理，处理思路：定义PomeloInterfaceImpl对用户的权限以及角色获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PomeloInterfaceImpl implements StpInterface &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public List&lt;String&gt; getPermissionList(Object loginId, String loginType) &#123;</span><br><span class="line">        // 1. 声明权限码集合</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        // 2. 遍历角色列表，查询拥有的权限码</span><br><span class="line">        for (String roleId : getRoleList(loginId, loginType)) &#123;</span><br><span class="line">            List&lt;String&gt; permissionList = (List&lt;String&gt;) SaManager.getSaTokenDao()</span><br><span class="line">                    .getObject(SaManager.getConfig().getTokenName()+&quot;:role-find-permission:&quot; + roleId);</span><br><span class="line">            if (permissionList == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            list.addAll(permissionList);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public List&lt;String&gt; getRoleList(Object loginId, String loginType) &#123;</span><br><span class="line">        List&lt;String&gt; roleList = (List&lt;String&gt;) SaManager.getSaTokenDao()</span><br><span class="line">                .getObject(SaManager.getConfig().getTokenName()+&quot;:loginId-find-role:&quot; + loginId);</span><br><span class="line">        return roleList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>权限</tag>
        <tag>sa-token</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务中的ACL与OpenFeign的绝佳配合</title>
    <url>/2024/10/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84ACL%E4%B8%8EOpenFeign%E7%9A%84%E7%BB%9D%E4%BD%B3%E9%85%8D%E5%90%88/</url>
    <content><![CDATA[<h2 id="ACL的概念"><a href="#ACL的概念" class="headerlink" title="ACL的概念"></a>ACL的概念</h2><p>在一些情况下我们需要引入第三方的接口来进行操作，但是当我们引用第三方接口的时候也会有一些隐患，第三方&#x3D;不可空，没准哪一天对方的接口参数突然就变掉了，如果我们直接在多个地方引用了第三方的接口，我们就需要在不同的地方处理接口方法，这时我们就需要引入防腐层的概念</p>
<h3 id="什么是防腐层"><a href="#什么是防腐层" class="headerlink" title="什么是防腐层"></a>什么是防腐层</h3><p>在许多情况下，我们的系统需要依赖其他系统，但被依赖的系统可能具有不合理的数据结构、API、协议或技术实现。如果我们强烈依赖外部系统，就会导致我们的系统受到<strong>“腐蚀”</strong>。在这种情况下，通过引入防腐层，可以有效地隔离外部依赖和内部逻辑，无论外部如何变化，内部代码尽可能保持不变。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737213600511-5dd8e777-8274-4482-92b6-db88a7a8179e.png"></p>
<span id="more"></span>
<p>防腐层不仅仅是一层简单的调用封装，在实际开发中，ACL可以提供更多强大的功能：</p>
<ol>
<li><strong>适配器：</strong> 很多时候外部依赖的数据、接口和协议并不符合内部规范，通过适配器模式，可以将数据转化逻辑封装到ACL内部，降低对业务代码的侵入。</li>
<li><strong>缓存：</strong> 对于频繁调用且数据变更不频繁的外部依赖，通过在ACL里嵌入缓存逻辑，能够有效的降低对于外部依赖的请求压力。同时，很多时候缓存逻辑是写在业务代码里的，通过将缓存逻辑嵌入ACL，能够降低业务代码的复杂度。</li>
<li><strong>兜底：</strong> 如果外部依赖的稳定性较差，提高系统稳定性的策略之一是通过ACL充当兜底，例如在外部依赖出问题时，返回最近一次成功的缓存或业务兜底数据。这种兜底逻辑通常复杂，如果散布在核心业务代码中，会难以维护。通过集中在ACL中，更容易进行测试和修改。</li>
<li><strong>易于测试：</strong> ACL的接口类能够很容易的实现Mock或Stub，以便于单元测试。</li>
<li><strong>功能开关：</strong> 有时候，我们希望在某些场景下启用或禁用某个接口的功能，或者让某个接口返回特定值。我们可以在ACL中配置功能开关，而不会影响真实的业务代码。</li>
</ol>
<h3 id="如何实现防腐层"><a href="#如何实现防腐层" class="headerlink" title="如何实现防腐层"></a>如何实现防腐层</h3><p><font style="color:rgb(47, 48, 52);">实现ACL防腐层的步骤如下：</font></p>
<ol>
<li><font style="color:rgb(47, 48, 52);">对于依赖的外部对象，我们提取所需的字段，并创建一个内部所需的DTO类。</font></li>
<li><font style="color:rgb(47, 48, 52);">构建一个新的Facade，在Facade中封装调用链路，将外部类转化为内部类。Facade可以参考Repository的实现模式，将接口定义在领域层，而将实现放在基础设施层。</font></li>
<li><font style="color:rgb(47, 48, 52);">在ApplicationService中依赖内部的Facade对象。</font></li>
</ol>
<p>具体的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class CustomerMenuDTO &#123;</span><br><span class="line">    // 菜单ID</span><br><span class="line">    private String menuId;</span><br><span class="line">    // 父菜单ID，一级菜单为0</span><br><span class="line">    private String parentId;</span><br><span class="line">    // 菜单名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 别称</span><br><span class="line">    private String anotherName;</span><br><span class="line">    // 组件路径</span><br><span class="line">    private String component;</span><br><span class="line">    // 菜单URL</span><br><span class="line">    private String path;</span><br><span class="line">    // 排序</span><br><span class="line">    private Integer orderNum;</span><br><span class="line">    // 菜单标题</span><br><span class="line">    private String title;</span><br><span class="line">    // 授权(多个用逗号分隔)</span><br><span class="line">    private String perms;</span><br><span class="line">    // 类型 0：目录 1：菜单 2：按钮</span><br><span class="line">    private Integer type;</span><br><span class="line">    // 菜单图标</span><br><span class="line">    private String icon;</span><br><span class="line">    // 是否跳转</span><br><span class="line">    private Boolean IsFull;</span><br><span class="line">    // 是否外链</span><br><span class="line">    private String isLink;</span><br><span class="line">    // 是否隐藏</span><br><span class="line">    private Boolean isHide;</span><br><span class="line">    // 是否固定</span><br><span class="line">    private Boolean isAffix;</span><br><span class="line">    // 是否长连接</span><br><span class="line">    private Boolean isKeepAlive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">Facade</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(name = &quot;pomelo-customer&quot;)</span><br><span class="line">public interface CustomerRemoteFacade &#123;</span><br><span class="line">    //获取用户角色</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName);</span><br><span class="line">    //获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserId/&#123;UserId&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserId(@PathVariable(&quot;UserId&quot;) String UserId);</span><br><span class="line">    //根据手机号获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber);</span><br><span class="line">    //获取用户角色信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId);</span><br><span class="line">    //获取用户权限</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在服务中应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final CustomerRemoteFacade customerRemoteFacade;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  CustomerUserDTO customerUser = customerRemoteFacade.getUserInfoByPhoneNumber(phonePasswordLoginDTO.getPhone());</span><br><span class="line">       if (customerUser ==null)&#123;</span><br><span class="line">           throw new BusinessException(ErrorCode.USERNAME_PASSWORD_INCORRECT);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这样，经过acl防腐处理，我们的服务中就不需要直接调用第三方接口了，当第三方的接口有过修改，我们只需要在acl中将逻辑更改，这样并不会影响到主体业务</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><font style="color:rgb(47, 48, 52);">在没有防腐层ACL的情况下，系统需要直接依赖外部对象和外部调用接口，调用逻辑如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737214136984-079e1779-c4fe-4ae8-b17d-eab63490e35b.png"></p>
<font style="color:rgb(47, 48, 52);">  
</font>

<p><font style="color:rgb(47, 48, 52);">而有了防腐层ACL后，系统只需要依赖内部的值类和接口，调用逻辑如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737214136953-fab41375-7967-4827-a6d7-eb95351dd551.png"></p>
<h2 id="OpenFeign的应用"><a href="#OpenFeign的应用" class="headerlink" title="OpenFeign的应用"></a>OpenFeign的应用</h2><h3 id="微服务中的远程调用"><a href="#微服务中的远程调用" class="headerlink" title="微服务中的远程调用"></a>微服务中的远程调用</h3><p>在pomelo中服务间的远程调用，我们单独的定义一个包来完成。同样我们在引用方，也可以以acl的思想来使用openFeign应用。接下来我们看一下用户登录引用用户服务的实现过程</p>
<h4 id="定义服务接口"><a href="#定义服务接口" class="headerlink" title="定义服务接口"></a>定义服务接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span><br><span class="line">public class CustomerUserInternal &#123;</span><br><span class="line">    private final CustomerUserService customerUserService;</span><br><span class="line">    private final CustomerRoleService customerRoleService;</span><br><span class="line">    private final CustomerMenuService customerMenuService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据用户名获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param UserName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    public CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName) &#123;</span><br><span class="line">        return customerUserService.selectUserByUserName(UserName);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 根据手机号获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param PhoneNumber</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    public CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber) &#123;</span><br><span class="line">        return customerUserService.selectUserByPhoneNumber(PhoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 根据id获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoById/&#123;id&#125;&quot;)</span><br><span class="line">    public CustomerUserListDTO getUserInfoById(@PathVariable(&quot;id&quot;) String id) &#123;</span><br><span class="line">        return customerUserService.selectUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    public List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId) &#123;</span><br><span class="line">        return customerRoleService.selectRoleByUserId(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据角色获取权限信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    public List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId) &#123;</span><br><span class="line">        return customerMenuService.getMenuOptionsByRoleId(roleId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acl防腐层facade实现"><a href="#acl防腐层facade实现" class="headerlink" title="acl防腐层facade实现"></a>acl防腐层facade实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(name = &quot;pomelo-customer&quot;)</span><br><span class="line">public interface CustomerRemoteFacade &#123;</span><br><span class="line">    //获取用户角色</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName);</span><br><span class="line">    //获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserId/&#123;UserId&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserId(@PathVariable(&quot;UserId&quot;) String UserId);</span><br><span class="line">    //根据手机号获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber);</span><br><span class="line">    //获取用户角色信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId);</span><br><span class="line">    //获取用户权限</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="启动服务增加注解"><a href="#启动服务增加注解" class="headerlink" title="启动服务增加注解"></a>启动服务增加注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(&quot;com.fbb.pomelo.auth.acl&quot;)</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在引用方调用接口进行参数处理</p>
<h3 id="自定义微服务解码器"><a href="#自定义微服务解码器" class="headerlink" title="自定义微服务解码器"></a>自定义微服务解码器</h3><p>我们在构建统一返回以及全局异常处理中提出过对参数的返回体进行了包装，那我们引用feign的时间就需要对之前的包装进行解码</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloFeignResponseDecoder implements Decoder &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object decode(Response response, Type type) throws IOException, DecodeException, FeignException &#123;</span><br><span class="line">        // 因为在web中定义过返回自动转换为Result，所以在使用openfeign时为了方便我们需要自定义解码将Result接触</span><br><span class="line">        Result&lt;?&gt; result = JsonUtils.inputStream2Obj(response.body().asInputStream(),Result.class);</span><br><span class="line">        if (ErrorCode.OK.getCode().equals(result.getCode())) &#123;</span><br><span class="line">            Object data = result.getData();</span><br><span class="line">            if (ObjectUtil.isEmpty(data))&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            JavaType javaType = TypeFactory.defaultInstance().constructType(type);</span><br><span class="line">            return JsonUtils.convertValue(data, javaType);</span><br><span class="line">        &#125;</span><br><span class="line">        // 异常则抛出业务异常</span><br><span class="line">        throw new RemoteException(result.getCode(), result.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="上游异常的统一处理"><a href="#上游异常的统一处理" class="headerlink" title="上游异常的统一处理"></a>上游异常的统一处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class PomeloFeignErrorDecoder implements ErrorDecoder &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Exception decode(String s, Response response) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Reader reader = response.body().asReader(Charset.defaultCharset());</span><br><span class="line">            Result&lt;?&gt; result = JsonUtils.reader2Obj(reader, Result.class);</span><br><span class="line">            return new RemoteException(result.getCode(), result.getMessage());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;Response转换异常&quot;, e);</span><br><span class="line">            throw new RemoteException(ErrorCode.FEIGN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Feign全局异常处理"><a href="#Feign全局异常处理" class="headerlink" title="Feign全局异常处理"></a>Feign全局异常处理</h3><p>feign的全局异常依然是沿用了spring的RestControllerAdvice注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">@Slf4j</span><br><span class="line">@Order(Ordered.HIGHEST_PRECEDENCE) // 优先级</span><br><span class="line">@ResponseStatus(code = HttpStatus.BAD_REQUEST) // 统一 HTTP 状态码</span><br><span class="line">public class PomeloFeignExceptionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(FeignException.class)</span><br><span class="line">    public Result&lt;?&gt; handleFeignException(FeignException e) &#123;</span><br><span class="line">        // log.error(&quot;FeignException: &quot;, e);</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(ErrorCode.REMOTE_ERROR.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(DecodeException.class)</span><br><span class="line">    public Result&lt;?&gt; handleDecodeException(DecodeException e) &#123;</span><br><span class="line">        log.error(&quot;Feign Decode Error: &quot;, e);</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        if (cause instanceof AbstractException) &#123;</span><br><span class="line">            RemoteException remoteException = (RemoteException) cause;</span><br><span class="line">            // 上游符合全局响应包装约定的再次抛出即可</span><br><span class="line">            return new Result&lt;Void&gt;()</span><br><span class="line">                    .setCode(remoteException.getCode())</span><br><span class="line">                    .setMessage(remoteException.getMessage())</span><br><span class="line">                    .setTimestamp(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        // 全部转换成RemoteException</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(ErrorCode.REMOTE_ERROR.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    @ExceptionHandler(RemoteException.class)</span><br><span class="line">    public Result&lt;?&gt; handleRemoteException(RemoteException e) &#123;</span><br><span class="line">        log.error(&quot;Feign Remote Error: &quot;, e);</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(e.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><font style="color:rgb(47, 48, 52);">我们学习了如何使用ACL来隔离外部依赖，降低系统耦合度。在微服务架构中，我们探讨了如何通过OpenFeign来实现跨服务调用，并解决了全局包装和异常处理的问题，希望本文的内容对您在软件开发项目中有所帮助。</font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2024/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><font style="color:rgb(77, 77, 77);">1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</font></p>
<p>:::info</p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.5);">Consistency（一致性）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">Availability（可用性）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">Partition tolerance （分区容错性）</font></li>
</ul>
<p>:::</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727676127141-2d6e2681-9b7a-40cc-a38f-71676129af12.png"></p>
<span id="more"></span>
<p><font style="color:rgb(77, 77, 77);">它们的第一个字母分别是 C、A、P。</font></p>
<p><font style="color:rgb(77, 77, 77);">Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</font></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><font style="color:rgb(77, 77, 77);">Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</font></p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p><font style="color:rgb(77, 77, 77);">Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</font></p>
<h3 id="分区容错"><a href="#分区容错" class="headerlink" title="分区容错"></a>分区容错</h3><p><strong><font style="color:rgb(77, 77, 77);">Partition（分区）</font></strong><font style="color:rgb(77, 77, 77);">：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">Tolerance（容错）</font></strong><font style="color:rgb(77, 77, 77);">：在集群出现分区时，整个系统也要持续对外提供服务</font></p>
<h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p><font style="color:rgb(77, 77, 77);">在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727676224018-30b6e228-e99e-4d1f-b7e9-e33ebe7f5390.png"></p>
<p>如果此时要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</p>
<p>如果此时要保证可用性，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。</p>
<p>也就是说，在P(分区情况下)一定会出现的情况下，A和C之间只能实现一个。</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li>
<li><strong>Soft State（软状态）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态。</li>
<li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li>
</ul>
<h2 id="解决分布式事务的思路"><a href="#解决分布式事务的思路" class="headerlink" title="解决分布式事务的思路"></a><font style="color:rgb(79, 79, 79);">解决分布式事务的思路</font></h2><p><font style="color:rgb(77, 77, 77);">分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：</font></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">AP模式：</font><strong><font style="color:rgb(77, 77, 77);">各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。  既最终一致性</font></strong></li>
<li><font style="color:rgb(77, 77, 77);">CP模式：</font><strong><font style="color:rgb(77, 77, 77);">各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态</font></strong><font style="color:rgb(77, 77, 77);">。既最终一致性</font></li>
</ul>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在实际应用中，</p>
<p>2PC与3PC都是使用的AP模式</p>
<p>本地事务表使用的CP模式</p>
<h3 id="2PC与3PC"><a href="#2PC与3PC" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h3><h4 id="二阶段提交（2PC）"><a href="#二阶段提交（2PC）" class="headerlink" title="二阶段提交（2PC）"></a>二阶段提交（2PC）</h4><h5 id="阶段一：准备阶段"><a href="#阶段一：准备阶段" class="headerlink" title="阶段一：准备阶段"></a>阶段一：准备阶段</h5><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727680107070-126ca8cb-a71a-4392-b599-9a044ac40c3d.png"></p>
<ol>
<li><font style="color:rgb(37, 41, 51);">协调者向所有参与者发送commit请求，询问是否可以提交事务，并等待答复。</font></li>
<li><font style="color:rgb(37, 41, 51);">各参与者开始准备执行事务，将uodo log和redo log记入事务日志中，并不提交事务。</font></li>
<li><font style="color:rgb(37, 41, 51);">如果参与者执行成功，则向协调者返回yes，否则返回no。</font></li>
</ol>
<h5 id="阶段二：提交阶段"><a href="#阶段二：提交阶段" class="headerlink" title="阶段二：提交阶段"></a>阶段二：提交阶段</h5><p><font style="color:rgb(37, 41, 51);">协调者收到各个参与者的准备信息后，根据反馈情况，通知各个参与者Commit或者Rollback。</font></p>
<h6 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a><font style="color:rgb(37, 41, 51);">事务提交</font></h6><p>当第一阶段所有参与者都反馈同意时，协调者发起正式提交事务请求，当所有的参与者都回复成功，则表明完成事务，具体流程如下：</p>
<ol>
<li><font style="color:rgb(37, 41, 51);">协调者向所有参与者发送正式提交事务请求（即：commit请求）。</font></li>
<li><font style="color:rgb(37, 41, 51);">参与者收到协调者的commit请求后，参与者正式执行事务提交操作，并释放整个事务期间占用的资源。</font></li>
<li><font style="color:rgb(37, 41, 51);">参与者完成事务提交后，向协调者发送ACK消息。</font></li>
<li><font style="color:rgb(37, 41, 51);">协调者收到所有参与者反馈的ACK消息后，完成事务。</font></li>
</ol>
<h6 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h6><p>如果任意一个参与者在第一阶段返回中止信息，或者由于超时协调者无法获取到所有参与者的信息，那么这个事务将会被回滚，具体流程如下：</p>
<ol>
<li>协调者向所有参与者发送回滚请求（即：rollback请求）。</li>
<li>参与者收到协调者发送的回滚请求后，参与者使用第一阶段中的undo log信息执行回滚操作，并释放在整个事务期间占用的资源。</li>
<li>参与者在执行完回滚操作之后，向协调者发送ACK信息。</li>
<li>协调者受到所有参与者反馈的信息后，取消事务。</li>
</ol>
<h5 id="2PC的优缺点"><a href="#2PC的优缺点" class="headerlink" title="2PC的优缺点"></a>2PC的优缺点</h5><p><strong>二阶段的确可以提供原子性操作，但是仍有如下缺点：</strong></p>
<ol>
<li>性能问题：所有参与者在提交阶段，都处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li>可靠性问题：如果协调者出现单点故障，或者出现不可用状态，参与者将一直处于锁定状态。</li>
<li>数据一致性问题：在阶段2中，如果出现协调者和参与者都挂了，有可能导致数据不一致。</li>
</ol>
<h4 id="三阶段提交（3PC）"><a href="#三阶段提交（3PC）" class="headerlink" title="三阶段提交（3PC）"></a><font style="color:rgb(37, 41, 51);">三阶段提交（3PC）</font></h4><p>与两阶段提交不同的是，三阶段提交有两个改动点：</p>
<ul>
<li>引入超时机制，在协调者与参与者中都引入了超时机制。</li>
<li>在第一阶段与第二阶段中，插入了一个<code>准备阶段</code>。保证了在最后提交阶段之前，各参与节点的状态是一致的。故3PC有CanCommit，PreCommit，DoCommit。</li>
</ul>
<p>所以3PC处理流程如下：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727680774753-2f1543a6-0c4c-4e5c-a214-d22cc31374c1.webp"></p>
<h5 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title=" CanCommit阶段"></a><font style="color:rgb(37, 41, 51);"> CanCommit阶段</font></h5><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回yes，否则返回no。</p>
<ol>
<li><strong>事务询问：</strong> 协调者向参与者发送CanCommit请求，询问是否可以执行事务提交操作，然后开始等待答复。</li>
<li><strong>响应反馈：</strong> 参与者接到CanCommit请求后，如果可以顺利执行事务，则反馈yes响应，并进入<code>预备状态</code>，否则反馈no。</li>
</ol>
<h5 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a><font style="color:rgb(37, 41, 51);">PreCommit阶段</font></h5><p><code>协调者</code>根据<code>参与者</code>的反馈情况决定是否可以继续执行事务的<code>PreCommit</code>阶段。</p>
<p>有两种反馈情况：</p>
<p>一、所有的参与者都反馈yes响应，那么就会执行事务的<code>PreCommit</code>阶段。</p>
<ol>
<li><strong>发送预提交请求：</strong> 协调者向参与者发送<code>PreCommit</code>请求，并进入Prepared阶段。</li>
<li><strong>预提交事务：</strong> 参与者收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中 <strong>（但不提交事务）</strong> 。</li>
<li><strong>响应反馈：</strong> 如果参与者都成功了执行事务操作，则返回ack响应，同时开始等待最终命令。</li>
</ol>
<p>二、加入有任何一个参与者反馈no响应，或者等待超时之后，协调者也没收到参与者的反馈，那么就执行事务中断。</p>
<ol>
<li><strong>发送中断请求：</strong> 协调者向所有参与者发送abort请求。</li>
<li><strong>中断事务：</strong> 参与者收到协调者发送的abort请求后（或者超时后，仍未收到协调者的请求），开始执行事务的中断。</li>
</ol>
<h5 id="DoCommit阶段"><a href="#DoCommit阶段" class="headerlink" title="DoCommit阶段"></a><font style="color:rgb(37, 41, 51);">DoCommit阶段</font></h5><p>该阶段进行真正的事务提交，可以分为如下两种情况：</p>
<p><strong>一、执行事务提交：协调者收到所有参与者的ack信息，开始执行提交事务。</strong></p>
<ol>
<li>发送DoCommit请求：协调者收到参与者发送的ack响应后，那么就会从<code>预提交状态</code>进入到<code>提交状态</code>，并向所有的参与者发送DoCommit请求。</li>
<li>事务提交：参与者接收到协调者发送的DoCommit请求，开始执行事务提交操作，并在完成事务操作后释放所有的事务资源。</li>
<li>响应反馈：事务提交完成后，参与者向协调者发送ack信息。</li>
<li>事务完成：协调者受到所有参与者的ack信息后，完成事务。</li>
</ol>
<p><strong>二、中断事务：协调者没能收到所有参与者的ack信息，开始执行中断事务。</strong></p>
<ol>
<li>发送中断请求：协调者性所有的参与者发送abort请求。</li>
<li>事务回滚：参与者收到abort请求后，开始利用阶段2中记录的undo log执行事务的回滚操作，并在完成回滚后，释放所有的事务资源。</li>
<li>响应反馈：参与者完成事务回滚后，向协调者发送ack信息。</li>
<li>中断事务：协调者受到所有参与者的ack信息后，执行事务中断。</li>
</ol>
<p>在进入DoCommit阶段是，如果协调者或者参与者出现问题，导致参与者无法接收到协调者发出的<code>提交事务/中断事务</code>请求，此时，参与者都会在等待超时之后，继续执行事务提交。这是基于概率来决定，当进入第三阶段时，说明第一阶段，所有的参与者都同意进行修改操作，同时在第二阶段，所有的参与者都统一同意PreCommit操作。所以，如果在第三阶段，如果出现网络问题，虽然参与者没有收到commit&#x2F;abort请求，但是它有理由相信：成功提交的几率很大。</p>
<p><font style="color:rgb(37, 41, 51);">3PC的优缺点</font></p>
<p><font style="color:rgb(37, 41, 51);">与2PC相比，3PC降低了阻塞范围，并且在等待超时后，协调者或者参与者中断事务，避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务，可能造成数据不一致。</font></p>
<p><strong><font style="color:rgb(37, 41, 51);">2PC和3PC都无法保证数据绝对的一致性，一般为预防这种问题，可以提交一个告警。</font></strong></p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a><font style="color:rgb(77, 77, 77);">TCC</font></h3><p><strong><font style="color:rgb(37, 41, 51);">TCC：</font></strong><font style="color:rgb(37, 41, 51);"> </font><font style="color:rgb(37, 41, 51);">TCC（Try Confirm Cancel）是应用层的两阶段提交，所以对业务有侵入。</font></p>
<p><strong><font style="color:rgb(37, 41, 51);">核心思想：</font></strong><font style="color:rgb(37, 41, 51);"> 针对每个操作，都要实现对应的</font><code>&lt;font style=&quot;color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);&quot;&gt;确认&lt;/font&gt;</code><font style="color:rgb(37, 41, 51);">和</font><code>&lt;font style=&quot;color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);&quot;&gt;补偿&lt;/font&gt;</code><font style="color:rgb(37, 41, 51);">操作，也就是业务逻辑的每个分支，都要实现Try、Confirm、Cancel三个操作。</font></p>
<h4 id="TCC的执行流程"><a href="#TCC的执行流程" class="headerlink" title="TCC的执行流程"></a><font style="color:rgb(37, 41, 51);">TCC的执行流程</font></h4><p>TCC的执行过程可以分成两个阶段：</p>
<ol>
<li><strong>第一阶段：</strong> Try。该阶段，通过try操作做检测并预留资源。（比如：下单，在try阶段，并不是真正的扣减库存，只是把下单的库存进行锁定。）</li>
<li><strong>第二阶段：</strong> Confirm&#x2F;Cancel。根据第一阶段的结果决定是执行confirm还是cancel。<ol>
<li>Confirm：对Try阶段锁定的资源实际扣除。</li>
<li>Cancel：对Try阶段锁定的资源进行释放。</li>
</ol>
</li>
</ol>
<h4 id="TCC是如何保证最终一致性"><a href="#TCC是如何保证最终一致性" class="headerlink" title="TCC是如何保证最终一致性"></a><font style="color:rgb(37, 41, 51);">TCC是如何保证最终一致性</font></h4><ul>
<li>TCC是以Try为中心的，Confirm操作和Cancel操作都是围绕着Try展开的。所以在Try阶段保障性是最好的，即使出现失败，也可以通过Cancel操作将其执行结果撤销。</li>
<li>在Try阶段执行成功，并进入到Confirm阶段时，默认Confirm阶段是不会出错的，也就是说只要Try成功，Confirm一定成功（TCC设计之初的定义）。</li>
<li>Confirm和Cancel如果失败，则由TCC框架进行重试补偿（定时）。</li>
<li>但仍存在极低情况下在<strong>CC</strong>阶段彻底失败，则需要人工介入。</li>
</ul>
<h4 id="TCC的注意事项"><a href="#TCC的注意事项" class="headerlink" title=" TCC的注意事项"></a><font style="color:rgb(37, 41, 51);"> TCC的注意事项</font></h4><h5 id="1-允许空回滚："><a href="#1-允许空回滚：" class="headerlink" title="(1) 允许空回滚："></a>(1) 允许空回滚：</h5><p>空回滚的原因是Try阶段超时或者丢包，导致TCC二阶段进行回滚，触发Cancel操作，此时事务参与者可能可能未收到Try操作，但是收到了Cancel操作。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727681701463-5db96149-aabe-4002-aa6b-496cb9967df8.webp"></p>
<p>所以，Cancel操作在实现的时候需要允许空回滚，即在Cancel执行时，如果没有查到对应业务的Try操作时，也是需要返回成功，让事务管理器认为已回滚。</p>
<h5 id="2-防悬挂控制："><a href="#2-防悬挂控制：" class="headerlink" title="(2) 防悬挂控制："></a>(2) 防悬挂控制：</h5><p><strong>悬挂</strong>是指二阶段的Cancel比一阶段的Try操作先执行，出现该问题的原因是Try阶段由于网络拥堵而超时，导致事务管理器生成回滚，触发Cancel操作，但之后拥堵网络的Try又被资源管理器收到了，但是Cancel操作比Try操作先到。如果按照前面允许空回滚的逻辑，回滚是会成功，事务管理器认为回滚成功，所以，此时应该<code>拒绝</code>空回滚之后的Try操作，否则会产生数据不一致。</p>
<p>因此，我们在Cancel空回滚返回成功之前，应记录该条事务xid或者业务主键，标识该记录已经回滚过，Try操作在执行前先检查这条事务xid或者业务主键是否标记为回滚成功，如果是，则不执行Try操作。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727681701424-9de15540-02c8-47b1-9359-05020686875c.webp"></p>
<h5 id="3-幂等控制"><a href="#3-幂等控制" class="headerlink" title="(3) 幂等控制"></a>(3) 幂等控制</h5><p>由于网络原因或者重试操作都有可能导致Try - Confirm - Cancel三个操作重复执行，所以使用TCC时需要注意这三个操作的幂等控制。通常针对具体业务选择对应的<code>业务幂等键</code>来做防重控制。</p>
<h4 id="TCC方案的优缺点"><a href="#TCC方案的优缺点" class="headerlink" title="TCC方案的优缺点"></a><font style="color:rgb(37, 41, 51);">TCC方案的优缺点</font></h4><h6 id="TCC事务机制相比上面的2PC3PC事务机制，有如下优点："><a href="#TCC事务机制相比上面的2PC3PC事务机制，有如下优点：" class="headerlink" title="TCC事务机制相比上面的2PC3PC事务机制，有如下优点："></a>TCC事务机制相比上面的2PC3PC事务机制，有如下优点：</h6><ol>
<li>性能提升：具体业务实现，控制资源锁的粒度变小，不会锁定整个资源。</li>
<li>数据最终一致性：基于Confirm和Cancel操作的幂等性，确保事务最终完成或者取消，保证了数据一致性。</li>
<li>可靠性：解决了XA协议的协调者单点故障问题。由主业务发起并控制整个业务活动，业务活动管理器可以变成多点，引入集群。</li>
</ol>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>TCC的Try - Confirm - Cancel操作功能需要按具体业务实现，业务耦合度高，提高了开发成功。</p>
<h3 id="本地事务表"><a href="#本地事务表" class="headerlink" title="本地事务表"></a>本地事务表</h3><h4 id="什么是本地消息表"><a href="#什么是本地消息表" class="headerlink" title="什么是本地消息表"></a><font style="color:rgb(37, 41, 51);">什么是本地消息表</font></h4><p><strong>本地事务表</strong>的核心思路是将**<code>分布式事务</code><strong>拆分</strong><code>**成本地事务**</code><strong>进行处理，该方案中主要有两个角色：</strong><code>事务主动方</code><strong>和</strong><code>事务被动方</code>**。<br>**<code>事务主动方</code><strong>需要额外新建事务消息表，并在本地事务中完成业务处理和记录事务消息，并轮训事务消息表的数据发哦那个事务消息，</strong><code>事务被动方</code>**基于消息中间件消费事务消息表中的事务。</p>
<p>这样可以避免一下两种情况导致的数据不一致性：</p>
<ul>
<li>业务处理成功，事务消息发送失败。</li>
<li>业务处理失败，事务消息发送成功。</li>
</ul>
<h4 id="本地事务表的执行流程"><a href="#本地事务表的执行流程" class="headerlink" title="本地事务表的执行流程"></a><font style="color:rgb(37, 41, 51);">本地事务表的执行流程</font></h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727682899971-9cb09696-10ea-493b-998e-11ccc9a0eecf.webp"></p>
<ul>
<li>事务主动方在同一个本地事务中处理业务和写消息表操作。</li>
<li>事务主动方通过消息中间件发送消息，通知事务被动发处理事务消息。</li>
<li>事务被动方接收到消息后，处理业务逻辑。</li>
<li>事务被动方通过消息中间件发送消息，通知事务主动方事务已处理。</li>
<li>事务主动方接收到消息后，更新消息表的状态为已处理。</li>
</ul>
<h5 id="一些必要的容错处理如下"><a href="#一些必要的容错处理如下" class="headerlink" title="一些必要的容错处理如下"></a><font style="color:rgb(37, 41, 51);">一些必要的容错处理如下</font></h5><ul>
<li>当①处理出错，由于事务还在事务主动方的本地事务中，直接回滚即可。</li>
<li>当②、④、⑤处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，通知事务被动方重新读取消息处理业务即可。</li>
<li>当③业务上处理失败，事务被动方可以发送消息给事务主动方回滚事务。</li>
</ul>
<h4 id="本地消息表优缺点"><a href="#本地消息表优缺点" class="headerlink" title="本地消息表优缺点"></a><font style="color:rgb(37, 41, 51);">本地消息表优缺点</font></h4><h5 id="1-优点："><a href="#1-优点：" class="headerlink" title="1) 优点："></a>1) 优点：</h5><ul>
<li>由于写消息表和业务数据在同一个本地事务中处理，确保了消息数据的可靠性，消息数据可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<h5 id="2-缺点："><a href="#2-缺点：" class="headerlink" title="2) 缺点："></a>2) 缺点：</h5><ul>
<li>与具体业务场景绑定，耦合性强，不可公用。</li>
<li>消息数据和业务数据同库，占用业务系统资源。</li>
<li>由于需要将消息持久化到数据库中，消息服务性能会受到一定的影响。</li>
</ul>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a><font style="color:rgb(37, 41, 51);">事务消息</font></h3><h4 id="MQ事务消息执行流程"><a href="#MQ事务消息执行流程" class="headerlink" title="MQ事务消息执行流程"></a><font style="color:rgb(37, 41, 51);">MQ事务消息执行流程</font></h4><p>通过消息的异步事务，可以保证<code>本地事务</code>和<code>消息发送</code>同时执行成功或失败，既能实现系统间的解耦，又能保证数据的最终一致性。</p>
<p><code>本地消息表</code>方案中，<code>事务主动方</code>通过在<code>同一个本地事务</code>中写<code>业务数据</code>和<code>消息数据</code>来保证数据的一致性。而事务消息相对于普通的MQ提供了<code>2PC</code>的提交接口，流程如下：</p>
<h5 id="1-正常执行情况"><a href="#1-正常执行情况" class="headerlink" title="1) 正常执行情况"></a><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727683362207-58fe821c-381b-4aca-9f6e-d05b6833fbbf.webp">1) 正常执行情况</h5><p>在事务主动方服务正常，没有发生故障的情况下，发消息流程如下：</p>
<ul>
<li>步骤①：发送Half消息</li>
<li>步骤②：Half消息发送成功</li>
<li>步骤③：开始执行本地事务</li>
<li>步骤④：根据本地事务执行结果向MQ Server发送Commit&#x2F;Rollback。</li>
<li>最终步骤：MQ Server基于Commit&#x2F;Rollback进行消息投递或者删除。</li>
</ul>
<h5 id="2-异常情况"><a href="#2-异常情况" class="headerlink" title="2) 异常情况"></a>2) 异常情况</h5><p>在断网或者应用重启情况下，图中的步骤④Commit或者Rollback未到达MQ Server，此时处理逻辑如下：</p>
<ul>
<li>步骤⑤：MQ Server未收到二次确认消息，发起消息回查。</li>
<li>步骤⑥：收到消息回查后，需要检查对应消息的本地事务执行状态。</li>
<li>步骤⑦：根据检查的本地事务执行状态，再次向MQ发送Commit&#x2F;Rollback。</li>
<li>最终步骤：MQ Server基于Commit&#x2F;Rollback进行消息投递或者删除</li>
</ul>
<h4 id="MQ事务消息的优缺点"><a href="#MQ事务消息的优缺点" class="headerlink" title="MQ事务消息的优缺点"></a>MQ事务消息的优缺点</h4><h5 id="1-优点（-相较于本地消息表-）"><a href="#1-优点（-相较于本地消息表-）" class="headerlink" title="1) 优点（ 相较于本地消息表 ）"></a>1) 优点（ 相较于本地消息表 ）</h5><ul>
<li>消息数据独立存储，降低业务系统与消息系统的耦合性。</li>
<li>吞吐量有所提升。</li>
</ul>
<h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2) 缺点"></a>2) 缺点</h5><ul>
<li>一次消息发送需要两次网络请求（Half消息+Commit&#x2F;Rollback）。</li>
<li>业务处理服务需要实现消息状态回查接口。</li>
</ul>
<h4 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h4><p>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对接口，如果事务被动方没有接收到主动方发送的消息，此时可以调用事务主动方提供的消息校对接口<code>主动获取</code>。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727683362353-4ab255e2-2fa1-4673-a0cf-aac6358c75d5.webp"> 在可靠事务消息中，事务主动方需要将消息发送出去，并且让接收方成功接收消息，这种可靠性是由事务主动方保证的。</p>
<p>但是最大努力通知，事务主动方仅仅是做到尽最大努力（重试，轮询…）将信息发送给事务被动方，所以存在事务被动方接收不到信息的情况，所以需要事务被动发通过消息校对接口主动查询获取消息并消费，这种通知的可靠性是由事务被动方保证的。</p>
<p><strong>适用场景：</strong></p>
<p>适用于业务通知类型，如支付宝&#x2F;微信交易的结果，就是通过最大努力通知方式通知商户，既有回调通知，也有交易查询接口。</p>
<h3 id="分布式事务中间件Seata"><a href="#分布式事务中间件Seata" class="headerlink" title="分布式事务中间件Seata"></a>分布式事务中间件Seata</h3><h4 id="初识Seata"><a href="#初识Seata" class="headerlink" title="初识Seata"></a><font style="color:rgb(79, 79, 79);">初识Seata</font></h4><p><font style="color:rgb(77, 77, 77);">Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的</font><a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&spm=1001.2101.3001.7020"><font style="color:rgb(77, 77, 77);">分布式事务解决方案</font></a><font style="color:rgb(77, 77, 77);">。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</font></p>
<p><font style="color:rgb(77, 77, 77);">官网地址：</font><a href="http://seata.io/">http://seata.io/</a><font style="color:rgb(77, 77, 77);">，其中的文档、播客中提供了大量的使用说明、源码分析。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727683681068-3113ed0f-ef7b-438f-8112-1e6af770a110.png"></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<h4 id="Seata的架构"><a href="#Seata的架构" class="headerlink" title="Seata的架构"></a><font style="color:rgb(79, 79, 79);">Seata的架构</font></h4><p>Seata事务管理中有三个重要的角色：</p>
<ul>
<li>TC (Transaction Coordinator) - <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li>
<li>TM (Transaction Manager) - <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li>
<li>RM (Resource Manager) - <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p>整体的架构如图：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727683745367-07fb02a0-a23e-463f-940c-cf4d4ad22024.png"></p>
<p>Seata基于上述架构提供了四种不同的分布式事务解决方案：</p>
<ul>
<li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li>
<li>TCC模式：最终一致的分阶段事务模式，有业务侵入</li>
<li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li>
<li>SAGA模式：长事务模式，有业务侵入</li>
</ul>
<p>:::info<br>无论哪种方案，都离不开TC，也就是事务的协调者。</p>
<p>:::</p>
<p>这里XA模式可以理解为2PC或者3PC</p>
<p>TCC模式：上面已经讲过 </p>
<p>SAGA模式<font style="color:rgb(77, 77, 77);">和tcc很想,但是TCC操作的是冻结的预留数据,这个是直接操作数据</font></p>
<p>但是我们主要需要学习的是AT模式</p>
<h4 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h4><p><font style="color:rgb(77, 77, 77);">AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</font></p>
<h5 id="Seata的AT模型"><a href="#Seata的AT模型" class="headerlink" title="Seata的AT模型"></a><font style="color:rgb(79, 79, 79);">Seata的AT模型</font></h5><p><font style="color:rgb(77, 77, 77);">基本流程图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685192520-38d73085-a173-4ffb-ad7d-36010bf6b7a1.png"></p>
<h6 id="阶段一RM的工作："><a href="#阶段一RM的工作：" class="headerlink" title="阶段一RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段一RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">注册分支事务</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">记录undo-log（数据快照）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">执行业务sql并提交</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">报告事务状态</font></li>
</ul>
<h6 id="阶段二提交时RM的工作："><a href="#阶段二提交时RM的工作：" class="headerlink" title="阶段二提交时RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段二提交时RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">删除undo-log即可</font></li>
</ul>
<h6 id="阶段二回滚时RM的工作："><a href="#阶段二回滚时RM的工作：" class="headerlink" title="阶段二回滚时RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段二回滚时RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">根据undo-log恢复数据到更新前</font></li>
</ul>
<p>:::info<br><font style="color:rgb(85, 86, 102);">事务执行成功 删除快照 事务执行失败 同一回复到快照</font></p>
<p>:::</p>
<h5 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a><font style="color:rgb(79, 79, 79);">流程梳理</font></h5><p><font style="color:rgb(77, 77, 77);">我们用一个真实的业务来梳理下AT模式的原理。</font></p>
<p><font style="color:rgb(77, 77, 77);">比如，现在又一个数据库表，记录用户余额：</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);">id</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);">money</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">1</font></td>
<td><font style="color:rgb(79, 79, 79);">100</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">其中一个分支业务要执行的SQL为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tb_account set money = money - 10 where id = 1</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">AT模式下，当前分支事务执行流程如下：</font></p>
<p><font style="color:rgb(77, 77, 77);">一阶段：</font></p>
<p><font style="color:rgb(77, 77, 77);">1）TM发起并注册全局事务到TC</font></p>
<p><font style="color:rgb(77, 77, 77);">2）TM调用分支事务</font></p>
<p><font style="color:rgb(77, 77, 77);">3）分支事务准备执行业务SQL</font></p>
<p><font style="color:rgb(77, 77, 77);">4）RM拦截业务SQL，根据where条件查询原始数据，形成快照。</font></p>
<p><font style="color:rgb(77, 77, 77);">5）RM执行业务SQL，提交本地事务，释放数据库锁。此时</font><font style="color:rgb(77, 77, 77);"> </font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;money = 90&lt;/font&gt;</code></p>
<p><font style="color:rgb(77, 77, 77);">6）RM报告本地事务状态给TC</font></p>
<p><font style="color:rgb(77, 77, 77);">二阶段：</font></p>
<p><font style="color:rgb(77, 77, 77);">1）TM通知TC事务结束</font></p>
<p><font style="color:rgb(77, 77, 77);">2）TC检查分支事务状态</font></p>
<p><font style="color:rgb(77, 77, 77);">a）如果都成功，则立即删除快照</font></p>
<p><font style="color:rgb(77, 77, 77);">b）如果有分支事务失败，需要回滚。读取快照数据（</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;&#123;&quot;id&quot;: 1, &quot;money&quot;: 100&#125;&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">），将快照恢复到数据库。此时数据库再次恢复为100</font></p>
<p><font style="color:rgb(77, 77, 77);">流程图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685541924-773c552b-0b8a-411f-aebd-c538347de620.png"></p>
<h5 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a><font style="color:rgb(79, 79, 79);">AT与XA的区别</font></h5><p><font style="color:rgb(77, 77, 77);">简述AT模式与XA模式最大的区别是什么？</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式强一致；AT模式最终一致 中间状态是软提交</font></li>
</ul>
<h5 id="脏写问题"><a href="#脏写问题" class="headerlink" title="脏写问题"></a><font style="color:rgb(79, 79, 79);">脏写问题</font></h5><p>在多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p>
<p>假如多个线程操作同一事务,其中一个线程先拿到数据锁执行完sql 提交事务以后释放锁,另一个线程就能拿到锁在进行一次sql执行,并且线程一刚好完at模式中有个事务失败需要回滚,这个时候数据就脏写了</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685613699-c21e200f-32a7-47e9-a759-5cc24175eaa1.png"></p>
<p>解决思路就是引入了全局锁的概念。</p>
<p>在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685625629-d0eb8311-bbe7-4762-809c-a3752dde5983.png"></p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><font style="color:rgb(79, 79, 79);">优缺点</font></h5><p><font style="color:rgb(77, 77, 77);">AT模式的优点：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">一阶段完成直接提交事务,释放数据库资源，性能比较好</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">利用全局锁实现读写隔离</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">没有代码侵入，框架自动完成回滚和提交</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">AT模式的缺点：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">两阶段之间属于软状态，属于最终一致</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">框架的快照功能会影响性能，但比XA模式要好很多</font></li>
</ul>
<p>:::info<br><font style="color:rgb(85, 86, 102);">XA事务的强一致性是通过事务等待来实现的,分支事务等待所有事务完成才能进行提交,提交后才能释放锁sql锁,对性能一致处于消耗,AT模式是直接先进性提交 然后释放sql锁,最后靠全局锁来实现防止脏数据,且回复靠快照,无序等待事务链中所有数据</font></p>
<p>:::</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>在现实的架构设计中分布式事务，我们一般会本地事务表和seata结合使用，本地事务表来实现最终一致性，用来实现可以允许一定程度的不一致，但是最终结果一致的业务，比如涉及到第三方的支付，开票，优惠结算等。seata我们一般使用AT来实现一些要求强一致性的业务，比如下单库存扣减之类的场景。在实际的开发中我们应该尽量避免使用事务，因为涉及到第三方系统的可用性隐患+1，而且数据覆写需要尽量避免掉</p>
<p><font style="color:rgb(79, 79, 79);"></font></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务中的SpringCloudGateway如何传递用户信息</title>
    <url>/2024/10/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84SpringCloudGateway%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>我们在权限验证中提到了在网关中会通过缓存取出用户数据。当我们获取到用户信息后应该怎么传递下去，有两种方案：</p>
<p>一种是通过redis对数据进行存储，在不同的服务中通过同一个redis进行调用。</p>
<p>第二种：在SpringCloudGateway中将数据取出后放入请求头，然后通过请求头进行传输</p>
<span id="more"></span>
<p>第一种方案的弊端很明显，需要多次的进行redis链接，增加了redis的负担，也增加了系统的不稳定性</p>
<p>所以我们这次的实现以第二种方法为主</p>
<p> 代码实现：</p>
<p>网关处获取到用户信息，通过定义header头信息将用户信息进行传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String loginUserKey  = String.format(&quot;%S%S&quot;, SecurityConstants.USER_KEY, token);</span><br><span class="line">      if (distributedCache.hasKey(loginUserKey)) &#123;</span><br><span class="line">          LoginUser loginUser= distributedCache.get(loginUserKey, LoginUser.class);</span><br><span class="line">          if (loginUser != null)&#123;</span><br><span class="line">              addHeader(mutate, SecurityConstants.USER_ID_HEADER, loginUser.getUserId(),false);</span><br><span class="line">              addHeader(mutate, SecurityConstants.USER_NAME_HEADER, loginUser.getUserName(),false);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>在服务中我们通过拦截器对请求进行拦截，通过拦截器来实现header头文件中的用户信息捕捉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserTokenHandlerInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String userId = request.getHeader(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">        String userName = request.getHeader(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">        RequestHeaderContextHolder.getInstance().setCurrentUser(userId, userName);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        RequestHeaderContextHolder.getInstance().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spring中注册拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WebMvcConfigurerAdaptor implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new UserTokenHandlerInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就可以在服务中获取到用户信息</p>
<p>小结：</p>
<p>本文主要讲的spingcloud gateway中实现健权后如何将用户信息进行传递，通过拦截器以及网关传递轻松的实现了用户身份的传递</p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign调用时如何传递传递Token并且多线程环境也能适用</title>
    <url>/2024/10/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="为什么要自定义负载均衡"><a href="#为什么要自定义负载均衡" class="headerlink" title="为什么要自定义负载均衡"></a>为什么要自定义负载均衡</h2><p>在实际的开发中总是会遇到如下的场景：A,B两个成员一起开发，A在开发C服务，B在开发D服务，测试环境中也部署有C服务和D服务，A和B的诉求是不互相干扰对方。但是实际中nacos中注册了服务之后默认的负载策略是根据权重来决定访问哪个服务，当权重一致时就是各50%的访问，很容易就对其他成员造成干扰，所以我们需要一个自定义负载均衡器来做一个分流。</p>
<h2 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h2><p>在springcloud的解决方案中负载均衡器使用的LoadBalancer框架，我们需要实现ReactorServiceInstanceLoadBalancer接口来完成自定义负载均衡。所以我们的思路就是在网关中进行打标，然后通过自定义负载均衡器来确定具体调用的服务。</p>
<span id="more"></span>
<h3 id="网关处理打标"><a href="#网关处理打标" class="headerlink" title="网关处理打标"></a>网关处理打标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class LoadBalancerFilter  implements GlobalFilter, Ordered &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloLoadBalancerProperties pomeloLoadBalancerProperties;</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">        //灰度标识分两种情况，1.通过header传过来，2.通过url传过来</span><br><span class="line">        String gray = request.getHeaders().getFirst(&quot;gray&quot;);</span><br><span class="line">        if (StrUtil.isNotEmpty(gray)) &#123;</span><br><span class="line">            HeaderUtils.addHeader(mutate, pomeloLoadBalancerProperties.getHeader(), gray, true);</span><br><span class="line">            return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        String grayUrl = request.getQueryParams().getFirst(&quot;gray&quot;);</span><br><span class="line">        if (StrUtil.isNotEmpty(grayUrl)) &#123;</span><br><span class="line">            HeaderUtils.addHeader(mutate, pomeloLoadBalancerProperties.getHeader(), grayUrl, true);</span><br><span class="line">            return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自定义负载均衡处理器"><a href="#自定义负载均衡处理器" class="headerlink" title="自定义负载均衡处理器"></a>自定义负载均衡处理器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloLoadBalancer implements ReactorServiceInstanceLoadBalancer &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(PomeloLoadBalancer.class);</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloLoadBalancerProperties pomeloLoadBalancerProperties;</span><br><span class="line"></span><br><span class="line">    private final ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider;</span><br><span class="line">    private final String serviceId;</span><br><span class="line"></span><br><span class="line">    private final AtomicInteger position;</span><br><span class="line"></span><br><span class="line">    public PomeloLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider</span><br><span class="line">            , String serviceId,PomeloLoadBalancerProperties pomeloLoadBalancerProperties) &#123;</span><br><span class="line">        this(serviceInstanceListSupplierProvider,serviceId,new Random().nextInt(1000),pomeloLoadBalancerProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PomeloLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider,</span><br><span class="line">                              String serviceId, int seedPosition,</span><br><span class="line">                              PomeloLoadBalancerProperties pomeloLoadBalancerProperties) &#123;</span><br><span class="line">        this.serviceId = serviceId;</span><br><span class="line">        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;</span><br><span class="line">        this.position = new AtomicInteger(seedPosition);</span><br><span class="line">        this.pomeloLoadBalancerProperties = pomeloLoadBalancerProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123;</span><br><span class="line">        ServiceInstanceListSupplier supplier = this.serviceInstanceListSupplierProvider</span><br><span class="line">                .getIfAvailable(NoopServiceInstanceListSupplier::new);</span><br><span class="line">        return supplier.get(request).next()</span><br><span class="line">                .map(serviceInstances -&gt; processInstanceResponse(serviceInstances,request));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 灰度处理</span><br><span class="line">     * @param instances</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Response&lt;ServiceInstance&gt; processInstanceResponse(List&lt;ServiceInstance&gt; instances, Request request) &#123;</span><br><span class="line">        if (instances.isEmpty()) &#123;</span><br><span class="line">            return new EmptyResponse();</span><br><span class="line">        &#125;</span><br><span class="line">        DefaultRequestContext requestContext = (DefaultRequestContext) request.getContext();</span><br><span class="line">        RequestData clientRequest = (RequestData) requestContext.getClientRequest();</span><br><span class="line">        HttpHeaders headers = clientRequest.getHeaders();</span><br><span class="line">        // get Request Header</span><br><span class="line">        String reqVersion = headers.getFirst(pomeloLoadBalancerProperties.getHeader());</span><br><span class="line"></span><br><span class="line">        List&lt;ServiceInstance&gt; normalServiceInstances = instances.stream()</span><br><span class="line">                .filter(instance -&gt; !instance.getMetadata().containsKey(pomeloLoadBalancerProperties.getHeader()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        log.debug(&quot;X-Pomelo-LoadBalancer:&#123;&#125;&quot;,reqVersion);</span><br><span class="line">        if (!StrUtil.isEmpty(reqVersion)) &#123;</span><br><span class="line">            // filter service instances</span><br><span class="line">            List&lt;ServiceInstance&gt; gsServiceInstances = instances.stream()</span><br><span class="line">                    .filter(instance -&gt; reqVersion.equals(instance.getMetadata().get(pomeloLoadBalancerProperties.getHeader())))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">            if (gsServiceInstances.size() &gt; 0) &#123;</span><br><span class="line">                return processRibbonInstanceResponse(gsServiceInstances);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return processRibbonInstanceResponse(normalServiceInstances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 负载均衡器</span><br><span class="line">     * 参考 org.springframework.cloud.loadbalancer.core.RoundRobinLoadBalancer#getInstanceResponse</span><br><span class="line">     */</span><br><span class="line">    private Response&lt;ServiceInstance&gt; processRibbonInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123;</span><br><span class="line">        int pos = Math.abs(this.position.incrementAndGet());</span><br><span class="line">        ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line">        return new DefaultResponse(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>nacos</tag>
        <tag>脚手架</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
</search>
