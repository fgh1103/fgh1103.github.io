<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Canal</title>
    <url>/2022/06/11/Canal/</url>
    <content><![CDATA[<h2 id="什么是Canal"><a href="#什么是Canal" class="headerlink" title="什么是Canal"></a>什么是Canal</h2><p>canal译意为水道&#x2F;管道&#x2F;沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。<br>从这句话理解到了什么？<br>基于MySQL，并且通过MySQL日志进行的增量解析，这也就意味着对原有的业务代码完全是无侵入性的。</p>
<span id="more"></span>
<p><strong>工作原理</strong>：解析MySQL的binlog日志，提供增量数据。</p>
<h2 id="Canal能做什么"><a href="#Canal能做什么" class="headerlink" title="Canal能做什么"></a>Canal能做什么</h2><p>基于日志增量订阅和消费的业务包括</p>
<ul>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护(拆分异构索引、倒排索引等)</li>
<li>业务 cache 刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ul>
<p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。<br>官方文档：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h2 id="Canal数据如何传输？"><a href="#Canal数据如何传输？" class="headerlink" title="Canal数据如何传输？"></a>Canal数据如何传输？</h2><p>先来一张官方图：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650355686553-164622a0-3c7c-4356-82f8-3778ee9975a6.png#averageHue=%23f3f2f2&clientId=ub5d898f2-92c2-4&from=paste&id=ub5e1132e&originHeight=569&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua4319a32-b052-48db-a60d-bc7965ab4c2&title="><br>Canal分为服务端和客户端，这也是阿里常用的套路：</p>
<ul>
<li>服务端：负责解析MySQL的binlog日志，传递增量数据给客户端或者消息中间件</li>
<li>客户端：负责解析服务端传过来的数据，然后定制自己的业务处理。</li>
</ul>
<p>目前为止支持的消息中间件很全面了，比如Kafka、RocketMQ，RabbitMQ。</p>
<h2 id="数据同步还有其他中间件吗？"><a href="#数据同步还有其他中间件吗？" class="headerlink" title="数据同步还有其他中间件吗？"></a>数据同步还有其他中间件吗？</h2><p>有，当然有，还有一些开源的中间件也是相当不错的，比如Bifrost。<br>常见的几款中间件的区别如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/jpeg/25873401/1650355699488-47931f43-dbf5-4368-94c1-4c0df391ca21.jpeg#averageHue=%23e78379&clientId=ub5d898f2-92c2-4&from=paste&id=u0c2ffed1&originHeight=265&originWidth=640&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4e2a647e-3eb9-4b25-ac5c-8ed1645131d&title="><br>当然要我选择的话，首选阿里的中间件Canal。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Canal的实战，集成到SpringBoot"><a href="#Canal的实战，集成到SpringBoot" class="headerlink" title="Canal的实战，集成到SpringBoot"></a>Canal的实战，集成到SpringBoot</h2><h3 id="Canal服务端安装"><a href="#Canal服务端安装" class="headerlink" title="Canal服务端安装"></a>Canal服务端安装</h3><p>服务端需要下载压缩包，下载地址：<a href="https://github.com/alibaba/canal/releases">https://github.com/alibaba/canal/releases</a><br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356266972-8003453b-8323-4e12-85a7-4af4f9de6e64.png#averageHue=%23fefdfd&clientId=ub5d898f2-92c2-4&from=paste&height=858&id=uc284655e&name=image.png&originHeight=858&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87200&status=done&style=none&taskId=u56ed93ae-9eb9-4a89-a9d3-10c32925cfe&title=&width=867" alt="image.png"><br>下载稳定版本v1.1.5<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356447084-372caebe-0c97-466d-820b-e231d9421234.png#averageHue=%23fefaf9&clientId=ub5d898f2-92c2-4&from=paste&height=326&id=u7de74c62&name=image.png&originHeight=326&originWidth=863&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26771&status=done&style=none&taskId=ub0e23bb0-04b7-4b3c-bc70-ae83c9bc074&title=&width=863" alt="image.png"><br>下载完成解压，目录如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356460373-1b23ca59-a31d-4651-8c65-6457e88c3399.png#averageHue=%23fefdfd&clientId=ub5d898f2-92c2-4&from=paste&id=ubfec025c&originHeight=223&originWidth=985&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8473ca90-4285-446d-8011-ee8cb593e37&title="><br>本文使用<strong>Canal+RabbitMQ</strong>进行数据的同步，因此下面步骤完全按照这个base进行。</p>
<h3 id="打开MySQL的binlog日志"><a href="#打开MySQL的binlog日志" class="headerlink" title="打开MySQL的binlog日志"></a>打开MySQL的binlog日志</h3><p>请参考<a href="https://www.yuque.com/u25495771/yqh657/cv1548">https://www.yuque.com/u25495771/yqh657/cv1548</a></p>
<h3 id="设置MySQL的配置"><a href="#设置MySQL的配置" class="headerlink" title="设置MySQL的配置"></a>设置MySQL的配置</h3><p>需要设置服务端配置文件中的MySQL配置，这样Canal才能知道需要监听哪个库、哪个表的日志文件。<br>一个 Server 可以配置多个实例监听 ，Canal 功能默认自带的有个 example 实例，本篇就用 example 实例 。如果增加实例，复制 example 文件夹内容到同级目录下，然后在 canal.properties 指定添加实例的名称。<br>修改canal.deployer-1.1.5\conf\example\instance.properties配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># url</span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line"># username/password</span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=root</span><br><span class="line"># 监听的数据库</span><br><span class="line">canal.instance.defaultDatabaseName=test</span><br><span class="line"></span><br><span class="line"># 监听的表，可以指定，多个用逗号分割，这里正则是监听所有</span><br><span class="line">canal.instance.filter.regex=.*\\..*</span><br></pre></td></tr></table></figure>
<h3 id="设置RabbitMQ的配置"><a href="#设置RabbitMQ的配置" class="headerlink" title="设置RabbitMQ的配置"></a>设置RabbitMQ的配置</h3><p>服务端默认的传输方式是tcp，需要在配置文件中设置MQ的相关信息。<br>这里需要修改两处配置文件，如下；</p>
<ol>
<li>canal.deployer-1.1.5\conf\canal.properties</li>
</ol>
<p>这个配置文件主要是设置MQ相关的配置，比如URL，用户名、密码…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 传输方式：tcp, kafka, rocketMQ, rabbitMQ</span><br><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line">##################################################</span><br><span class="line">######### 		RabbitMQ	 #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host = 127.0.0.1</span><br><span class="line">rabbitmq.virtual.host =/</span><br><span class="line"># exchange</span><br><span class="line">rabbitmq.exchange =canal.exchange</span><br><span class="line"># 用户名、密码</span><br><span class="line">rabbitmq.username =guest</span><br><span class="line">rabbitmq.password =guest</span><br><span class="line">## 是否持久化</span><br><span class="line">rabbitmq.deliveryMode = 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>canal.deployer-1.1.5\conf\example\instance.properties</li>
</ol>
<p>这个文件设置MQ的路由KEY，这样才能路由到指定的队列中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canal.mq.topic=canal.routing.key</span><br></pre></td></tr></table></figure>
<h3 id="RabbitMQ新建exchange和Queue"><a href="#RabbitMQ新建exchange和Queue" class="headerlink" title="RabbitMQ新建exchange和Queue"></a>RabbitMQ新建exchange和Queue</h3><p>在RabbitMQ中需要新建一个canal.exchange（必须和配置中的相同）的exchange和一个名称为 canal.queue（名称随意）的队列。<br>其中绑定的路由KEY为：canal.routing.key（必须和配置中的相同），如下图：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356683237-bd7aa4dd-0249-4367-a4f1-d18fd642b151.png#averageHue=%23f8f7f7&clientId=ue7f6981a-5aa6-4&from=paste&id=u84bc14bb&originHeight=242&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub5a2273f-91e8-454f-82f8-f436dcbfb34&title="></p>
<h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>点击bin目录下的脚本，windows直接双击startup.bat，启动成功如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356701506-8b6915b7-a13c-4bf4-b2b8-be891699bd1a.png#averageHue=%232e2c2a&clientId=ue7f6981a-5aa6-4&from=paste&id=uc58fbd70&originHeight=315&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u899d291e-03ac-4e87-9905-4a09ece2ef3&title="></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在本地数据库test中的oauth_client_details插入一条数据，如下：<br>INSERT INTO <code>oauth_client_details</code> VALUES (‘myjszl’, ‘res1’, ‘$2a$10$F1tQdeb0SEMdtjlO8X&#x2F;0wO6Gqybu6vPC&#x2F;Xg8OmP9&#x2F;TL1i4beXdK9W’, ‘all’, ‘password,refresh_token,authorization_code,client_credentials,implicit’, ‘<a href="http://www.baidu.com/">http://www.baidu.com</a>‘, NULL, 1000, 1000, NULL, ‘false’);</p>
<p>此时查看MQ中的canal.queue已经有了数据，如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356727749-58f14d0b-4d67-4390-b426-8c4f12bda6a6.png#averageHue=%23fcfcfc&clientId=ue7f6981a-5aa6-4&from=paste&id=u20a8b6dd&originHeight=164&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucc2b654f-0461-4176-96b2-09bb8aae423&title=">其实就是一串JSON数据，这个JSON如下：<br>{<br> “data”: [{<br>  “client_id”: “myjszl”,<br>  “resource_ids”: “res1”,<br>  “client_secret”: “$2a$10$F1tQdeb0SEMdtjlO8X&#x2F;0wO6Gqybu6vPC&#x2F;Xg8OmP9&#x2F;TL1i4beXdK9W”,<br>  “scope”: “all”,<br>  “authorized_grant_types”: “password,refresh_token,authorization_code,client_credentials,implicit”,<br>  “web_server_redirect_uri”: “<a href="http://www.baidu.com/">http://www.baidu.com</a>“,<br>  “authorities”: null,<br>  “access_token_validity”: “1000”,<br>  “refresh_token_validity”: “1000”,<br>  “additional_information”: null,<br>  “autoapprove”: “false”<br> }],<br> “database”: “test”,<br> “es”: 1640337532000,<br> “id”: 7,<br> “isDdl”: false,<br> “mysqlType”: {<br>  “client_id”: “varchar(48)”,<br>  “resource_ids”: “varchar(256)”,<br>  “client_secret”: “varchar(256)”,<br>  “scope”: “varchar(256)”,<br>  “authorized_grant_types”: “varchar(256)”,<br>  “web_server_redirect_uri”: “varchar(256)”,<br>  “authorities”: “varchar(256)”,<br>  “access_token_validity”: “int(11)”,<br>  “refresh_token_validity”: “int(11)”,<br>  “additional_information”: “varchar(4096)”,<br>  “autoapprove”: “varchar(256)”<br> },<br> “old”: null,<br> “pkNames”: [“client_id”],<br> “sql”: “”,<br> “sqlType”: {<br>  “client_id”: 12,<br>  “resource_ids”: 12,<br>  “client_secret”: 12,<br>  “scope”: 12,<br>  “authorized_grant_types”: 12,<br>  “web_server_redirect_uri”: 12,<br>  “authorities”: 12,<br>  “access_token_validity”: 4,<br>  “refresh_token_validity”: 4,<br>  “additional_information”: 12,<br>  “autoapprove”: 12<br> },<br> “table”: “oauth_client_details”,<br> “ts”: 1640337532520,<br> “type”: “INSERT”<br>}</p>
<p>每个字段的意思已经很清楚了，有表名称、方法、参数、参数类型、参数值…..<br>客户端要做的就是监听MQ获取JSON数据，然后将其解析出来，处理自己的业务逻辑。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>打开IDEA创建项目canal-toos<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650357369053-2135bca0-7417-422d-a9ae-23ced9f4a203.png#averageHue=%233d4143&clientId=ue7f6981a-5aa6-4&from=paste&height=779&id=u1ae9689a&name=image.png&originHeight=779&originWidth=818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63356&status=done&style=none&taskId=uea85711c-4dbe-4e2d-9f1a-6889877ef0a&title=&width=818" alt="image.png"><br>引用POM文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!-- Mybatis plus代码生产插件 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- Mybatisplus代码生成模板 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- Mybatis基础依赖 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--mybatisplus 依赖插件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--mysql依赖插件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.38&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">   &lt;!-- rabbitmq 服务调用依赖 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- jackosn基础依赖 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.9&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="创建消息实体类"><a href="#创建消息实体类" class="headerlink" title="创建消息实体类"></a>创建消息实体类</h3><p>MQ传递过来的是JSON数据，当然要创建个实体类接收数据，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Canal消息接收实体类</span><br><span class="line"> */</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class CanalMessage&lt;T&gt; &#123;</span><br><span class="line">    @JsonProperty(&quot;type&quot;)</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;table&quot;)</span><br><span class="line">    private String table;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;data&quot;)</span><br><span class="line">    private List&lt;T&gt; data;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;database&quot;)</span><br><span class="line">    private String database;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;es&quot;)</span><br><span class="line">    private Long es;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;id&quot;)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;isDdl&quot;)</span><br><span class="line">    private Boolean isDdl;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;old&quot;)</span><br><span class="line">    private List&lt;T&gt; old;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;pkNames&quot;)</span><br><span class="line">    private List&lt;String&gt; pkNames;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;sql&quot;)</span><br><span class="line">    private String sql;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;ts&quot;)</span><br><span class="line">    private Long ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加RabbitMQ消费端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cn.hutool.json.JSONUtil;</span><br><span class="line">import cn.myjszl.middle.ware.canal.mq.rabbit.model.CanalMessage;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 监听MQ获取Canal增量的数据消息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class CanalRabbitMQListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings = &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value = @Queue(value = &quot;canal.queue&quot;, durable = &quot;true&quot;),</span><br><span class="line">                    exchange = @Exchange(value = &quot;canal.exchange&quot;),</span><br><span class="line">                    key = &quot;canal.routing.key&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void handleDataChange(String message) &#123;</span><br><span class="line">        //将message转换为CanalMessage</span><br><span class="line">        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class);</span><br><span class="line">        String tableName = canalMessage.getTable();</span><br><span class="line">        log.info(&quot;Canal 监听 &#123;&#125; 发生变化；明细：&#123;&#125;&quot;, tableName, message);</span><br><span class="line">        String tableName =canalMessage.getTable();</span><br><span class="line">        if (canalMessage.getData()!=null)&#123;</span><br><span class="line">                for (int i=0;i&lt;canalMessage.getData().size();i++ ) &#123;</span><br><span class="line">                Map&lt;String,Object&gt; map= mapper.readValue(canalMessage.getData().get(i).toString(),Map.class);</span><br><span class="line"></span><br><span class="line">                if (canalMessage.getType().contains(&quot;INSERT&quot;))&#123;</span><br><span class="line">                    sava(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (canalMessage.getType().contains(&quot;UPDATE&quot;))&#123;</span><br><span class="line">                    update(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (canalMessage.getType().contains(&quot;DELETE&quot;))&#123;</span><br><span class="line">                    delect(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public  String underlineToHump(String str) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(str))&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //正则匹配下划线及后一个字符，删除下划线并将匹配的字符转成大写</span><br><span class="line">        Matcher matcher = UNDERLINE_PATTERN.matcher(str);</span><br><span class="line">        StringBuffer sb = new StringBuffer(str);</span><br><span class="line">        if (matcher.find()) &#123;</span><br><span class="line">            sb = new StringBuffer();</span><br><span class="line">            //将当前匹配的子串替换成指定字符串，并且将替换后的子串及之前到上次匹配的子串之后的字符串添加到StringBuffer对象中</span><br><span class="line">            //正则之前的字符和被替换的字符</span><br><span class="line">            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());</span><br><span class="line">            //把之后的字符串也添加到StringBuffer对象中</span><br><span class="line">            matcher.appendTail(sb);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //去除除字母之外的前面带的下划线</span><br><span class="line">            return sb.toString().replaceAll(&quot;_&quot;, &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return underlineToHump(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    public void sava(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line">        Object tableObjet = tableClass.newInstance();</span><br><span class="line">        for (String key :oldTable.keySet())&#123;</span><br><span class="line">            Method[] methods =  tableObjet.getClass().getMethods();</span><br><span class="line">            Object mapValue=oldTable.get(key);</span><br><span class="line"></span><br><span class="line">            String methodName = underlineToHump(&quot;set&quot;+upperFirstCase(key.toLowerCase()));</span><br><span class="line">            for (Method method:methods)&#123;</span><br><span class="line">                if (method.getName().equals(methodName))&#123;</span><br><span class="line">                    if (method.getParameterTypes()[0].equals(String.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            mapValue =&quot; &quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, mapValue.toString());</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Date.class)|| method.getParameterTypes()[0].equals(LocalDateTime.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                        method.invoke(tableObjet, LocalDateTime.parse(mapValue.toString(),formatter));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Integer.class)||method.getParameterTypes()[0].equals(int.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Integer.parseInt(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Long.class)||method.getParameterTypes()[0].equals(long.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Long.parseLong(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Double.class)||method.getParameterTypes()[0].equals(double.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Double.parseDouble(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Boolean.class)||method.getParameterTypes()[0].equals(boolean.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Boolean.parseBoolean(mapValue.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Object pojo = mapper.readValue(mapper.writeValueAsString(oldTable), tableClass.getClass());</span><br><span class="line"></span><br><span class="line">        String newTable= lowerFirstCase(tableName+&quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line"></span><br><span class="line">        service.save(tableObjet);</span><br><span class="line">    &#125;</span><br><span class="line">        public void update(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, IOException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException &#123;</span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line">        Object tableObjet = tableClass.newInstance();</span><br><span class="line">        for (String key :oldTable.keySet()) &#123;</span><br><span class="line">            Method[] methods = tableObjet.getClass().getMethods();</span><br><span class="line">            Object mapValue = oldTable.get(key);</span><br><span class="line">            if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String methodName = underlineToHump(&quot;set&quot; + upperFirstCase(key.toLowerCase()));</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                if (method.getName().equals(methodName)) &#123;</span><br><span class="line">                    if (method.getParameterTypes()[0].equals(String.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, mapValue.toString());</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Date.class) || method.getParameterTypes()[0].equals(LocalDateTime.class)) &#123;</span><br><span class="line">                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                        method.invoke(tableObjet, LocalDateTime.parse(mapValue.toString(), formatter));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Integer.class) || method.getParameterTypes()[0].equals(int.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Integer.parseInt(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Long.class) || method.getParameterTypes()[0].equals(long.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Long.parseLong(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Double.class) || method.getParameterTypes()[0].equals(double.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Double.parseDouble(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Boolean.class) || method.getParameterTypes()[0].equals(boolean.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Boolean.parseBoolean(mapValue.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    //method.invoke(tableObjet,oldTable.get(key));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newTable = lowerFirstCase(tableName + &quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line">        service.updateById(tableObjet);</span><br><span class="line">    &#125;</span><br><span class="line">    public void delect(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, IOException &#123;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line"></span><br><span class="line">        QueryWrapper wrapper = new QueryWrapper();</span><br><span class="line">        wrapper.eq(&quot;ID&quot;,oldTable.get(&quot;ID&quot;));</span><br><span class="line">        String newTable= lowerFirstCase(tableName+&quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line">        service.remove(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>springboot</tag>
        <tag>canal</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>安装RabbitMQ</title>
    <url>/2022/01/11/%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h2 id="参照官网："><a href="#参照官网：" class="headerlink" title="参照官网："></a>参照官网：</h2><p><a href="https://www.rabbitmq.com/install-rpm.html#package-cloud">https://www.rabbitmq.com/install-rpm.html#package-cloud</a></p>
<span id="more"></span>
<h2 id="添加yum存储库信息"><a href="#添加yum存储库信息" class="headerlink" title="添加yum存储库信息"></a>添加yum存储库信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">touch rabbitmq.repo</span><br><span class="line">vi rabbitmq.repo</span><br></pre></td></tr></table></figure>
<p>rabbitmq.repo中添加文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#In /etc/yum.repos.d/rabbitmq.repo</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## Zero dependency Erlang</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq_erlang</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[rabbitmq_server]</span><br><span class="line">name=rabbitmq_server</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h2><p>使用命令：yum install rabbitmq-server</p>
<p>最后修改一直选y<br>将会自动下载安装对应的<a href="https://so.csdn.net/so/search?q=erlang&spm=1001.2101.3001.7020">erlang</a>版本、rabbitmq版本、keys等。<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644656259455-3fe11f75-b3a3-40b7-92ae-521df1e6b76c.png#clientId=u99af809c-8097-4&from=paste&height=529&id=ubb7d3f11&name=image.png&originHeight=529&originWidth=1887&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73715&status=done&style=none&taskId=u5df5f38f-98fd-4151-826f-39030d372c6&title=&width=1887" alt="image.png"></p>
<h2 id="修改登录拦截"><a href="#修改登录拦截" class="headerlink" title="修改登录拦截"></a>修改登录拦截</h2><p>rabbitmq 3.3.0开始禁用除localhost外的地址采取guest登录，所以此处需要将拦截去除。<br>找到安装目录<br>vi rabbit.app<br>将其中loopback_users, [&lt;&lt;”guest”&gt;&gt;]字段中的数据修改成下列方式：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659808980-04bf71e4-c7ae-4346-8be6-47d62ebd8a85.png#clientId=u99af809c-8097-4&from=paste&id=ub3d16f82&name=image.png&originHeight=563&originWidth=501&originalType=url&ratio=1&rotation=0&showTitle=false&size=46996&status=done&style=none&taskId=u28d72f30-d720-4c4c-a149-eb0933f0eaa&title=" alt="image.png"></p>
<h2 id="启动rabbitmq"><a href="#启动rabbitmq" class="headerlink" title="启动rabbitmq"></a>启动rabbitmq</h2><p>service rabbitmq-server start</p>
<h2 id="开启图形化"><a href="#开启图形化" class="headerlink" title="开启图形化"></a>开启图形化</h2><p>rabbitmq-plugins enable rabbitmq_management<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659826635-8d068b00-e708-46c4-bd51-2e4b9f9e86dd.png#clientId=u99af809c-8097-4&from=paste&id=u225e2c08&name=image.png&originHeight=186&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&size=19642&status=done&style=none&taskId=u9402a1a4-793f-49ae-8461-428aa7895c5&title=" alt="image.png"></p>
<h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><p>rabbitmqctl status</p>
<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><p>使用命令rabbitmqctl add_user username password进行添加新用户。<br>rabbitmqctl add_user xiangjiao bunana<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659924599-bc6befcb-314f-48c0-aaf1-12ede71381d9.png#clientId=u99af809c-8097-4&from=paste&id=ub67c24ee&name=image.png&originHeight=45&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&size=8623&status=done&style=none&taskId=uc663062d-0c58-4570-ad64-e364a76c652&title=" alt="image.png"></p>
<h2 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h2><p>使用命令rabbitmqctl set_user_tags username administrator设置用户tag。<br>rabbitmqctl set_user_tags xiangjiao administrator<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659930697-fc18293d-a7cb-42b9-86a0-9f001f700899.png#clientId=u99af809c-8097-4&from=paste&id=u9bac882c&name=image.png&originHeight=27&originWidth=669&originalType=url&ratio=1&rotation=0&showTitle=false&size=4718&status=done&style=none&taskId=u396a0295-cbf2-4cc0-92a4-f1308d063cb&title=" alt="image.png"></p>
<h1 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659937730-5b420d6a-2d54-4b74-a5d8-1714df1188f0.png#clientId=u99af809c-8097-4&from=paste&id=u26e58c6c&name=image.png&originHeight=253&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&size=16836&status=done&style=none&taskId=u93fc0373-469d-436c-a3ea-67a98f50a61&title=" alt="image.png"></p>
<p> <img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659947739-f1582562-2b4e-48ce-8ee5-e63aa60ddba1.png#clientId=u99af809c-8097-4&from=paste&id=u90593ccb&name=image.png&originHeight=740&originWidth=1457&originalType=url&ratio=1&rotation=0&showTitle=false&size=67428&status=done&style=none&taskId=uc63ffb4a-3243-4c60-9c35-1f499430c7f&title=" alt="image.png"></p>
<h1 id="命令拓展"><a href="#命令拓展" class="headerlink" title="命令拓展"></a>命令拓展</h1><h2 id="卸载rabbitmq"><a href="#卸载rabbitmq" class="headerlink" title="卸载rabbitmq"></a>卸载rabbitmq</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–卸载</span><br><span class="line">–停止服务</span><br><span class="line">rabbitmqctl app_stop</span><br><span class="line">yum list | grep rabbitmq</span><br><span class="line">yum -y remove rabbitmq-server.noarch</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="卸载erlang支持"><a href="#卸载erlang支持" class="headerlink" title="卸载erlang支持"></a>卸载erlang支持</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list | grep erlang</span><br><span class="line">yum -y remove erlang-*</span><br><span class="line">yum remove erlang.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig rabbitmq-server on # 添加开机启动RabbitMQ服务</span><br><span class="line">/sbin/service rabbitmq-server start # 启动服务</span><br><span class="line">/sbin/service rabbitmq-server status # 查看服务状态</span><br><span class="line">/sbin/service rabbitmq-server stop # 停止服务</span><br><span class="line">rabbitmqctl list_users #查看用户列表信息和权限信息</span><br><span class="line">rabbitmqctl list_user_permissions xxxxx #查看指定用户的权限信息</span><br><span class="line">rabbitmqctl delete_user guest #删除guest用户</span><br><span class="line">rabbitmqctl add_user username password #添加新用户</span><br><span class="line">rabbitmqctl set_user_tags username administrator #设置用户tag</span><br><span class="line">rabbitmqctl set_permissions -p / username “.&quot; &quot;.” “.*” #赋予用户默认vhost的全部操作权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义用户信息</title>
    <url>/2024/03/11/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在集成Oauth2.1认证中心，采用默认的数据结构实现了认证，但是大部分时候默认的用户结构并不能满足生产的需要，所以接下来以RBAC权限设计来实现用户</p>
<span id="more"></span>
<h2 id="基于RBAC的权限设计"><a href="#基于RBAC的权限设计" class="headerlink" title="基于RBAC的权限设计"></a>基于RBAC的权限设计</h2><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE system_user(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36)    COMMENT &#x27;租户号&#x27; ,</span><br><span class="line">    USER_ID VARCHAR(36) NOT NULL   COMMENT &#x27;用户编号&#x27; ,</span><br><span class="line">    DEPT_ID VARCHAR(36)    COMMENT &#x27;部门编号&#x27; ,</span><br><span class="line">    USER_NAME VARCHAR(100) NOT NULL   COMMENT &#x27;用户账号&#x27; ,</span><br><span class="line">    NICK_NAME VARCHAR(100)    COMMENT &#x27;用户昵称&#x27; ,</span><br><span class="line">    EMAIL VARCHAR(100)    COMMENT &#x27;用户邮箱&#x27; ,</span><br><span class="line">    PHONE_NUMBER VARCHAR(100)    COMMENT &#x27;用户手机号&#x27; ,</span><br><span class="line">    SEX INT    COMMENT &#x27;性别&#x27; ,</span><br><span class="line">    AVATAR VARCHAR(100)    COMMENT &#x27;头像地址&#x27; ,</span><br><span class="line">    PASSWORD VARCHAR(100) NOT NULL   COMMENT &#x27;密码&#x27; ,</span><br><span class="line">    STATUS INT NOT NULL   COMMENT &#x27;用户状态&#x27; ,</span><br><span class="line">    DEL_FLAG INT NOT NULL   COMMENT &#x27;删除标志（0代表存在 2代表删除）&#x27; ,</span><br><span class="line">    REVISION INT NOT NULL  COMMENT &#x27;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(100)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(100)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户表&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE system_role(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36)    COMMENT &#x27;角色编号;角色编号&#x27; ,</span><br><span class="line">    ROLE_NAME VARCHAR(100)    COMMENT &#x27;角色名称;角色名称&#x27; ,</span><br><span class="line">    ROLE_KEY VARCHAR(100)    COMMENT &#x27;角色权限字符串;角色权限字符串&#x27; ,</span><br><span class="line">    ROLE_SORT INT    COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    DATA_SCOPE VARCHAR(100)    COMMENT &#x27;数据范围;数据范围（1：全部数据权限 2：自定数据权限 3：本部门数据权限 4：本部门及以下数据权限）&#x27; ,</span><br><span class="line">    MENU_CHECK_STRICTLY VARCHAR(1)    COMMENT &#x27;菜单树选择项是否关联显示;菜单树选择项是否关联显示&#x27; ,</span><br><span class="line">    DEPT_CHECK_STRICTLY VARCHAR(1)    COMMENT &#x27;部门树选择项是否关联显示;部门树选择项是否关联显示&#x27; ,</span><br><span class="line">    STATUS VARCHAR(1)    COMMENT &#x27;角色状态（0正常 1停用）;角色状态（0正常 1停用）&#x27; ,</span><br><span class="line">    DEL_FLAG VARCHAR(1)    COMMENT &#x27;删除标志（0代表存在 2代表删除）;删除标志（0代表存在 2代表删除）&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36)    COMMENT &#x27;租户号;租户号&#x27; ,</span><br><span class="line">    REVISION INT  NOT NULL    COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(36)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(36)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_menu(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID&#x27; ,</span><br><span class="line">    MENU_ID VARCHAR(36) NOT NULL   COMMENT &#x27;菜单编号;菜单编号&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36) NOT NULL   COMMENT &#x27;租户号;租户号&#x27; ,</span><br><span class="line">    MENU_NAME VARCHAR(100) NOT NULL   COMMENT &#x27;菜单名称;菜单名称&#x27; ,</span><br><span class="line">    PARENT_ID VARCHAR(36)    COMMENT &#x27;父菜单ID;父菜单ID&#x27; ,</span><br><span class="line">    ORDER_NUM INT    COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    PATH VARCHAR(100)    COMMENT &#x27;路由地址;路由地址&#x27; ,</span><br><span class="line">    COMPONENT VARCHAR(100)    COMMENT &#x27;组件路径;组件路径&#x27; ,</span><br><span class="line">    QUERY VARCHAR(100)    COMMENT &#x27;路由参数;路由参数&#x27; ,</span><br><span class="line">    IS_FRAME VARCHAR(1)    COMMENT &#x27;是否为外链（0是 1否）;是否为外链（0是 1否）&#x27; ,</span><br><span class="line">    IS_CACHE VARCHAR(1)    COMMENT &#x27;是否缓存（0缓存 1不缓存）;是否缓存（0缓存 1不缓存）&#x27; ,</span><br><span class="line">    MENU_TYPE VARCHAR(32)    COMMENT &#x27;菜单类型（M目录 C菜单 F按钮）;菜单类型（M目录 C菜单 F按钮）&#x27; ,</span><br><span class="line">    VISIBLE VARCHAR(100)    COMMENT &#x27;菜单状态（0显示 1隐藏）;菜单状态（0显示 1隐藏）&#x27; ,</span><br><span class="line">    STATUS VARCHAR(100)    COMMENT &#x27;菜单状态（0正常 1停用）;菜单状态（0正常 1停用）&#x27; ,</span><br><span class="line">    PERMS VARCHAR(100)    COMMENT &#x27;权限标识;权限标识&#x27; ,</span><br><span class="line">    ICON VARCHAR(100)    COMMENT &#x27;菜单图标;菜单图标&#x27; ,</span><br><span class="line">    REVISION INT NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(100)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(100)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID,MENU_ID)</span><br><span class="line">)  COMMENT = &#x27;菜单权限表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_user_role(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    USER_ID VARCHAR(36) NOT NULL   COMMENT &#x27;用户ID;用户ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36) NOT NULL   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色关联表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_role_menu(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36) NOT NULL   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    MENU_ID VARCHAR(36) NOT NULL   COMMENT &#x27;菜单ID;菜单ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;角色权限菜单表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自定义用户实现"><a href="#自定义用户实现" class="headerlink" title="自定义用户实现"></a><font style="color:rgb(0, 0, 0);">自定义用户实现</font></h3><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>改造网关实现授权</title>
    <url>/2024/03/14/%E6%94%B9%E9%80%A0%E7%BD%91%E5%85%B3%E5%AE%9E%E7%8E%B0%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>先看下认证授权的过程，认证客户端的认证是最先被认证的，只有先认证客户端可会进行token的认证，而我们不应该把客户端的信息暴漏在外面所以客户端的信息只能通过网关转发的时候注入到请求中</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/27343190/1667726854430-5c1f32f8-d71b-4c75-815c-c75de9cac331.png"></p>
<span id="more"></span>

<h2 id="直接请求认证服务器的流程"><a href="#直接请求认证服务器的流程" class="headerlink" title="直接请求认证服务器的流程"></a>直接请求认证服务器的流程</h2><p>请求<font style="color:rgb(33, 33, 33);">&#x2F;oauth2&#x2F;token 输入表单信息</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132164269-3335ac9d-d4a6-4464-81aa-b9753aae6360.png"></p>
<p><font style="color:rgb(107, 107, 107);"> </font>Authorization设置为Basic Auth</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132230680-00619d4b-b0be-436a-8431-cf863ddfb67c.png"></p>
<p>获得结果</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132311409-b4aac947-0f53-4d41-a529-549fadb993b5.png"></p>
<p>使用网关转发请求和注入服务的时候，当客户端不能直接提供客户端信息的时候，需要在网关转发时注入</p>
<h2 id="改造网关"><a href="#改造网关" class="headerlink" title="改造网关"></a>改造网关</h2><h3 id="增加局部过滤器"><a href="#增加局部过滤器" class="headerlink" title="增加局部过滤器"></a>增加局部过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoginFilter extends AbstractGatewayFilterFactory&lt;LoginFilter.Config&gt; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private  ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientProperties clientProperties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LoginFilter() &#123;</span><br><span class="line">        super(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Token URL 标识</span><br><span class="line">     */</span><br><span class="line">    private static final String TOKEN_URL_IDENTIFY = &quot;oauth2/token&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public GatewayFilter apply(Config config) &#123;</span><br><span class="line">        return (exchange, chain) -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">                //判断是否是请求token</span><br><span class="line">                String path = request.getURI().getPath();</span><br><span class="line">                if (!StrUtil.containsIgnoreCase(path, TOKEN_URL_IDENTIFY)) &#123;</span><br><span class="line">                    return chain.filter(exchange);</span><br><span class="line">                &#125;</span><br><span class="line">                //TODO:后续可以增加验证码验证</span><br><span class="line">                //注入客户端信息</span><br><span class="line">                ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">                String clientStr =String.format(&quot;%s:%s&quot;,clientProperties.getClientId(),clientProperties.getClientSecret());</span><br><span class="line">                String base = Base64.encode(clientStr);</span><br><span class="line">                addHeader(mutate,&quot;Authorization&quot;,String.format(&quot;Basic %s&quot;,base));</span><br><span class="line">            &#125;catch (UnauthorizedException ex)&#123;</span><br><span class="line">                getErrResponse(exchange, AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED,ex.getMessage()));</span><br><span class="line">            &#125;catch (Exception e) &#123;</span><br><span class="line">                return getErrResponse(exchange, AjaxResult.error(ResponseStatusEnum.SYS_ERROR, e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class Config &#123;</span><br><span class="line">        // 在这里可以定义配置属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addHeader(ServerHttpRequest.Builder mutate, String name, Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueStr = value.toString();</span><br><span class="line">        String valueEncode = valueStr;</span><br><span class="line">        mutate.header(name, valueEncode);</span><br><span class="line">    &#125;</span><br><span class="line">    private Mono&lt;Void&gt; getErrResponse(ServerWebExchange exchange, Object errInfo) &#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">        return response.writeWith(Mono.create(monoSink -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] bytes = objectMapper.writeValueAsBytes(errInfo);</span><br><span class="line">                DataBuffer dataBuffer = response.bufferFactory().wrap(bytes);</span><br><span class="line">                monoSink.success(dataBuffer);</span><br><span class="line">            &#125; catch (JsonProcessingException jsonProcessingException) &#123;</span><br><span class="line">                log.error(jsonProcessingException.getMessage());</span><br><span class="line">                monoSink.error(jsonProcessingException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置客户端信息"><a href="#配置客户端信息" class="headerlink" title="配置客户端信息"></a>配置客户端信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RefreshScope</span><br><span class="line">@ConfigurationProperties(prefix = &quot;security.client&quot;)</span><br><span class="line">public class ClientProperties &#123;</span><br><span class="line">    private String clientId;</span><br><span class="line">    private String clientSecret;</span><br><span class="line"></span><br><span class="line">    public String getClientId() &#123;</span><br><span class="line">        return clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClientId(String clientId) &#123;</span><br><span class="line">        this.clientId = clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getClientSecret() &#123;</span><br><span class="line">        return clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClientSecret(String clientSecret) &#123;</span><br><span class="line">        this.clientSecret = clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">  client:</span><br><span class="line">    clientId: messaging-client</span><br><span class="line">    clientSecret: secret</span><br></pre></td></tr></table></figure>

<h3 id="路由中添加过滤器"><a href="#路由中添加过滤器" class="headerlink" title="路由中添加过滤器"></a>路由中添加过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- id: luck-auth</span><br><span class="line">  uri: lb://luck-auth</span><br><span class="line">  predicates:</span><br><span class="line">    - Path=/auth/**</span><br><span class="line">  filters:</span><br><span class="line">    - StripPrefix=1</span><br><span class="line">    - CacheRequestFilter</span><br><span class="line">    - LoginFilter</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133263303-ffd2f328-09fa-4bd4-9a53-9c5ded039cf4.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133272368-1c2b04a7-f9b0-49ac-90e4-dce9298e5f8d.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133290397-da9266f6-dd79-4b06-ac87-736203474128.png"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Authorization设置为Basic Auth 的实际操作为在Header中新增一个key为Authorization value为 Basic +base64({clientId}:{clientSecret}) 。这里Basic后面是有一个空格的需要注意。</p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>资源服务器鉴权处理</title>
    <url>/2024/03/15/%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>在oauth2中授权服务器颁发过令牌后，用户就可以对资源进行访问，这时会有一个问题就是需要验证令牌，而前边文章中令牌使用的jwt格式，所以需要一个统一的资源管理器来验证令牌解析令牌</p>
<span id="more"></span>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class BearerTokenAuthenticationFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">	private final AuthenticationManagerResolver&lt;HttpServletRequest&gt; authenticationManagerResolver;</span><br><span class="line"></span><br><span class="line">	private AuthenticationEntryPoint authenticationEntryPoint = new BearerTokenAuthenticationEntryPoint();</span><br><span class="line"></span><br><span class="line">	private AuthenticationFailureHandler authenticationFailureHandler = (request, response, exception) -&gt; &#123;</span><br><span class="line">		if (exception instanceof AuthenticationServiceException) &#123;</span><br><span class="line">			throw exception;</span><br><span class="line">		&#125;</span><br><span class="line">		this.authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	private BearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();</span><br><span class="line"></span><br><span class="line">	private AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = new WebAuthenticationDetailsSource();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Construct a &#123;@code BearerTokenAuthenticationFilter&#125; using the provided parameter(s)</span><br><span class="line">	 * @param authenticationManagerResolver</span><br><span class="line">	 */</span><br><span class="line">	public BearerTokenAuthenticationFilter(</span><br><span class="line">			AuthenticationManagerResolver&lt;HttpServletRequest&gt; authenticationManagerResolver) &#123;</span><br><span class="line">		Assert.notNull(authenticationManagerResolver, &quot;authenticationManagerResolver cannot be null&quot;);</span><br><span class="line">		this.authenticationManagerResolver = authenticationManagerResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Construct a &#123;@code BearerTokenAuthenticationFilter&#125; using the provided parameter(s)</span><br><span class="line">	 * @param authenticationManager</span><br><span class="line">	 */</span><br><span class="line">	public BearerTokenAuthenticationFilter(AuthenticationManager authenticationManager) &#123;</span><br><span class="line">		Assert.notNull(authenticationManager, &quot;authenticationManager cannot be null&quot;);</span><br><span class="line">		this.authenticationManagerResolver = (request) -&gt; authenticationManager;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Extract any</span><br><span class="line">	 * &lt;a href=&quot;https://tools.ietf.org/html/rfc6750#section-1.2&quot; target=&quot;_blank&quot;&gt;Bearer</span><br><span class="line">	 * Token&lt;/a&gt; from the request and attempt an authentication.</span><br><span class="line">	 * @param request</span><br><span class="line">	 * @param response</span><br><span class="line">	 * @param filterChain</span><br><span class="line">	 * @throws ServletException</span><br><span class="line">	 * @throws IOException</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		String token;</span><br><span class="line">		try &#123;</span><br><span class="line">			token = this.bearerTokenResolver.resolve(request);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (OAuth2AuthenticationException invalid) &#123;</span><br><span class="line">			this.logger.trace(&quot;Sending to authentication entry point since failed to resolve bearer token&quot;, invalid);</span><br><span class="line">			this.authenticationEntryPoint.commence(request, response, invalid);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (token == null) &#123;</span><br><span class="line">			this.logger.trace(&quot;Did not process request since did not find bearer token&quot;);</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BearerTokenAuthenticationToken authenticationRequest = new BearerTokenAuthenticationToken(token);</span><br><span class="line">		authenticationRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			AuthenticationManager authenticationManager = this.authenticationManagerResolver.resolve(request);</span><br><span class="line">			Authentication authenticationResult = authenticationManager.authenticate(authenticationRequest);</span><br><span class="line">			SecurityContext context = SecurityContextHolder.createEmptyContext();</span><br><span class="line">			context.setAuthentication(authenticationResult);</span><br><span class="line">			SecurityContextHolder.setContext(context);</span><br><span class="line">			if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">				this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authenticationResult));</span><br><span class="line">			&#125;</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (AuthenticationException failed) &#123;</span><br><span class="line">			SecurityContextHolder.clearContext();</span><br><span class="line">			this.logger.trace(&quot;Failed to process authentication request&quot;, failed);</span><br><span class="line">			this.authenticationFailureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link BearerTokenResolver&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link DefaultBearerTokenResolver&#125;.</span><br><span class="line">	 * @param bearerTokenResolver the &#123;@code BearerTokenResolver&#125; to use</span><br><span class="line">	 */</span><br><span class="line">	public void setBearerTokenResolver(BearerTokenResolver bearerTokenResolver) &#123;</span><br><span class="line">		Assert.notNull(bearerTokenResolver, &quot;bearerTokenResolver cannot be null&quot;);</span><br><span class="line">		this.bearerTokenResolver = bearerTokenResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationEntryPoint&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link BearerTokenAuthenticationEntryPoint&#125;.</span><br><span class="line">	 * @param authenticationEntryPoint the &#123;@code AuthenticationEntryPoint&#125; to use</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationEntryPoint(final AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">		Assert.notNull(authenticationEntryPoint, &quot;authenticationEntryPoint cannot be null&quot;);</span><br><span class="line">		this.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationFailureHandler&#125; to use. Default implementation invokes</span><br><span class="line">	 * &#123;@link AuthenticationEntryPoint&#125;.</span><br><span class="line">	 * @param authenticationFailureHandler the &#123;@code AuthenticationFailureHandler&#125; to use</span><br><span class="line">	 * @since 5.2</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationFailureHandler(final AuthenticationFailureHandler authenticationFailureHandler) &#123;</span><br><span class="line">		Assert.notNull(authenticationFailureHandler, &quot;authenticationFailureHandler cannot be null&quot;);</span><br><span class="line">		this.authenticationFailureHandler = authenticationFailureHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationDetailsSource&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link WebAuthenticationDetailsSource&#125;.</span><br><span class="line">	 * @param authenticationDetailsSource the &#123;@code AuthenticationConverter&#125; to use</span><br><span class="line">	 * @since 5.5</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationDetailsSource(</span><br><span class="line">			AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource) &#123;</span><br><span class="line">		Assert.notNull(authenticationDetailsSource, &quot;authenticationDetailsSource cannot be null&quot;);</span><br><span class="line">		this.authenticationDetailsSource = authenticationDetailsSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JwtAuthenticationProvider的  jwt的主流程处理中心</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class JwtAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line"></span><br><span class="line">	private final Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">	private final JwtDecoder jwtDecoder;</span><br><span class="line"></span><br><span class="line">	private Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt; jwtAuthenticationConverter = new JwtAuthenticationConverter();</span><br><span class="line"></span><br><span class="line">	public JwtAuthenticationProvider(JwtDecoder jwtDecoder) &#123;</span><br><span class="line">		Assert.notNull(jwtDecoder, &quot;jwtDecoder cannot be null&quot;);</span><br><span class="line">		this.jwtDecoder = jwtDecoder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Decode and validate the</span><br><span class="line">	 * &lt;a href=&quot;https://tools.ietf.org/html/rfc6750#section-1.2&quot; target=&quot;_blank&quot;&gt;Bearer</span><br><span class="line">	 * Token&lt;/a&gt;.</span><br><span class="line">	 * @param authentication the authentication request object.</span><br><span class="line">	 * @return A successful authentication</span><br><span class="line">	 * @throws AuthenticationException if authentication failed for some reason</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">		BearerTokenAuthenticationToken bearer = (BearerTokenAuthenticationToken) authentication;</span><br><span class="line">		Jwt jwt = getJwt(bearer);</span><br><span class="line">		AbstractAuthenticationToken token = this.jwtAuthenticationConverter.convert(jwt);</span><br><span class="line">		token.setDetails(bearer.getDetails());</span><br><span class="line">		this.logger.debug(&quot;Authenticated token&quot;);</span><br><span class="line">		return token;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Jwt getJwt(BearerTokenAuthenticationToken bearer) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return this.jwtDecoder.decode(bearer.getToken());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BadJwtException failed) &#123;</span><br><span class="line">			this.logger.debug(&quot;Failed to authenticate since the JWT was invalid&quot;);</span><br><span class="line">			throw new InvalidBearerTokenException(failed.getMessage(), failed);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (JwtException failed) &#123;</span><br><span class="line">			throw new AuthenticationServiceException(failed.getMessage(), failed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">		return BearerTokenAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setJwtAuthenticationConverter(</span><br><span class="line">			Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt; jwtAuthenticationConverter) &#123;</span><br><span class="line">		Assert.notNull(jwtAuthenticationConverter, &quot;jwtAuthenticationConverter cannot be null&quot;);</span><br><span class="line">		this.jwtAuthenticationConverter = jwtAuthenticationConverter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析doFilterInternal方法我们可知：</p>
<ul>
<li>请求会被 BearerTokenAuthenticationFilter 拦截器拦截，通过bearerTokenResolver解析出token字符串如果没有解析出来，则由下一个过滤器处理。如果失败将被AuthenticationEntryPoint统一拦截处理</li>
<li>解析出来则构建一个BearerTokenAuthenticationToken对象。</li>
<li>将HttpServletRequest传递给AuthenticationManagerResolver对象，由它选择出AuthenticationManager对象，然后将 BearerTokenAuthenticationToken传递给AuthenticationManager对象进行认证。AuthenticationManager对象的实现，取决于我们的token对象是JWT还是opaque token</li>
<li>在AuthenticationManager由多个Provider对Authentication进行处理最终返回结果，当对象为jwt时处理对象为JwtAuthenticationProvider，在JwtAuthenticationProvider会先通过jwtDecoder解析jwt字符串，最终对JwtAuthenticationConverter将jwt字符串处理的为AbstractAuthenticationToken</li>
<li>验证失败<ul>
<li>清空 SecurityContextHolder 对象。</li>
<li>交由AuthenticationFailureHandler对象处理。</li>
</ul>
</li>
<li>验证成功<ul>
<li>将 Authentication对象设置到SecurityContextHolder中。</li>
<li>交由余下的过滤器继续处理。</li>
</ul>
</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>pom文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>ResourceServerConfiguration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableMethodSecurity</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class ResourceServerConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line"></span><br><span class="line">    private final HttpSecurity http;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityFilterChain filterChain() throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .antMatchers(&quot;/actuator/**&quot;, &quot;/v3/api-docs/**&quot;, &quot;/swagger-ui/**&quot;,</span><br><span class="line">                                &quot;/swagger-ui.html&quot;).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                .oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">                        .authenticationEntryPoint(luckAuthenticationEntryPoint())</span><br><span class="line">                        .bearerTokenResolver(new LuckBearerTokenResolver(redisService))</span><br><span class="line">                        .jwt());</span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationConverter jwtAuthenticationConverter() &#123;</span><br><span class="line">        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();</span><br><span class="line">        grantedAuthoritiesConverter.setAuthorityPrefix(&quot;&quot;);</span><br><span class="line">        grantedAuthoritiesConverter.setAuthoritiesClaimName(&quot;authorities&quot;);</span><br><span class="line"></span><br><span class="line">        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();</span><br><span class="line">        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);</span><br><span class="line">        return jwtAuthenticationConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LuckAuthenticationEntryPoint luckAuthenticationEntryPoint() &#123;</span><br><span class="line">        return new LuckAuthenticationEntryPoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return PasswordEncoderFactories.createDelegatingPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;pms&quot;)</span><br><span class="line">    public PermissionHandler permissionHandler() &#123;</span><br><span class="line">        return new PermissionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>异常定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public class LuckAuth2AuthencticationException extends OAuth2AuthenticationException &#123;</span><br><span class="line">    private final String code;</span><br><span class="line"></span><br><span class="line">    public LuckAuth2AuthencticationException(ResponseStatusEnum status) &#123;</span><br><span class="line">        super(new OAuth2Error(status.getMsg()), status.getMsg());</span><br><span class="line">        this.code = status.getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查异常处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LuckAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line">        ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);</span><br><span class="line">        AjaxResult&lt;?&gt; error;</span><br><span class="line">        if(authException instanceof InvalidBearerTokenException)&#123;</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.FAILED_DEPENDENCY);</span><br><span class="line">            error = AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, authException.getMessage());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            error = AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED, authException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpEndpointUtils.writeWithMessageConverters(error, servletServerHttpResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令牌适配器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class LuckBearerTokenResolver implements BearerTokenResolver &#123;</span><br><span class="line"></span><br><span class="line">    private final RedisService redisService;</span><br><span class="line"></span><br><span class="line">    private static final Pattern AUTHORIZATION_PATTERN = Pattern.compile(&quot;^Bearer (?&lt;token&gt;[a-zA-Z0-9-._~+/]+=*)$&quot;,</span><br><span class="line">            Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line">    private boolean allowFormEncodedBodyParameter = false;</span><br><span class="line"></span><br><span class="line">    private boolean allowUriQueryParameter = false;</span><br><span class="line"></span><br><span class="line">    private String bearerTokenHeaderName = HttpHeaders.AUTHORIZATION;</span><br><span class="line"></span><br><span class="line">//    public  LuckBearerTokenResolver(RedisService redisService)&#123;</span><br><span class="line">//        this.redisService = redisService;</span><br><span class="line">//    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String resolve(HttpServletRequest request) &#123;</span><br><span class="line">            final String authorizationHeaderToken = resolveFromAuthorizationHeader(request);</span><br><span class="line">            final String parameterToken = isParameterTokenSupportedForRequest(request)</span><br><span class="line">                    ? resolveFromRequestParameters(request) : null;</span><br><span class="line">            if (authorizationHeaderToken != null) &#123;</span><br><span class="line">                if (parameterToken != null) &#123;</span><br><span class="line">                    final BearerTokenError error = BearerTokenErrors</span><br><span class="line">                            .invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);</span><br><span class="line">                    throw new OAuth2AuthenticationException(error);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return authorizationHeaderToken;</span><br><span class="line">            &#125;</span><br><span class="line">            if (parameterToken != null &amp;&amp; isParameterTokenEnabledForRequest(request)) &#123;</span><br><span class="line">                return parameterToken;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Set if transport of access token using form-encoded body parameter is supported.</span><br><span class="line">     * Defaults to &#123;@code false&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param allowFormEncodedBodyParameter if the form-encoded body parameter is</span><br><span class="line">     *                                      supported</span><br><span class="line">     */</span><br><span class="line">    public void setAllowFormEncodedBodyParameter(boolean allowFormEncodedBodyParameter) &#123;</span><br><span class="line">        this.allowFormEncodedBodyParameter = allowFormEncodedBodyParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set if transport of access token using URI query parameter is supported. Defaults</span><br><span class="line">     * to &#123;@code false&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The spec recommends against using this mechanism for sending bearer tokens, and</span><br><span class="line">     * even goes as far as stating that it was only included for completeness.</span><br><span class="line">     *</span><br><span class="line">     * @param allowUriQueryParameter if the URI query parameter is supported</span><br><span class="line">     */</span><br><span class="line">    public void setAllowUriQueryParameter(boolean allowUriQueryParameter) &#123;</span><br><span class="line">        this.allowUriQueryParameter = allowUriQueryParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set this value to configure what header is checked when resolving a Bearer Token.</span><br><span class="line">     * This value is defaulted to &#123;@link HttpHeaders#AUTHORIZATION&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This allows other headers to be used as the Bearer Token source such as</span><br><span class="line">     * &#123;@link HttpHeaders#PROXY_AUTHORIZATION&#125;</span><br><span class="line">     *</span><br><span class="line">     * @param bearerTokenHeaderName the header to check when retrieving the Bearer Token.</span><br><span class="line">     * @since 5.4</span><br><span class="line">     */</span><br><span class="line">    public void setBearerTokenHeaderName(String bearerTokenHeaderName) &#123;</span><br><span class="line">        this.bearerTokenHeaderName = bearerTokenHeaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String resolveFromAuthorizationHeader(HttpServletRequest request) &#123;</span><br><span class="line">        String authorization = request.getHeader(this.bearerTokenHeaderName);</span><br><span class="line">        if (!StringUtils.startsWithIgnoreCase(authorization, &quot;bearer&quot;)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization);</span><br><span class="line">        if (!matcher.matches()) &#123;</span><br><span class="line">            BearerTokenError error = BearerTokenErrors.invalidToken(&quot;Bearer token is malformed&quot;);</span><br><span class="line">            throw new OAuth2AuthenticationException(error);</span><br><span class="line">        &#125;</span><br><span class="line">        return matcher.group(&quot;token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String resolveFromRequestParameters(HttpServletRequest request) &#123;</span><br><span class="line">        String[] values = request.getParameterValues(&quot;access_token&quot;);</span><br><span class="line">        if (values == null || values.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (values.length == 1) &#123;</span><br><span class="line">            return values[0];</span><br><span class="line">        &#125;</span><br><span class="line">        BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);</span><br><span class="line">        throw new OAuth2AuthenticationException(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isParameterTokenSupportedForRequest(final HttpServletRequest request) &#123;</span><br><span class="line">        return ((&quot;POST&quot;.equals(request.getMethod())</span><br><span class="line">                &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED_VALUE.equals(request.getContentType()))</span><br><span class="line">                || &quot;GET&quot;.equals(request.getMethod()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isParameterTokenEnabledForRequest(final HttpServletRequest request) &#123;</span><br><span class="line">        return ((this.allowFormEncodedBodyParameter &amp;&amp; &quot;POST&quot;.equals(request.getMethod())</span><br><span class="line">                &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED_VALUE.equals(request.getContentType()))</span><br><span class="line">                || (this.allowUriQueryParameter &amp;&amp; &quot;GET&quot;.equals(request.getMethod())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建 token key</span><br><span class="line">     * @param token token</span><br><span class="line">     * @return token key</span><br><span class="line">     */</span><br><span class="line">    private String buildKey(String token) &#123;</span><br><span class="line">        return String.format(&quot;%s:%s:%s&quot;, CacheConstants.TOKEN, OAuth2ParameterNames.ACCESS_TOKEN, token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    oauth2:</span><br><span class="line">      resourceserver:</span><br><span class="line">        jwt:</span><br><span class="line">          issuer-uri: http://192.168.1.186:1067</span><br></pre></td></tr></table></figure>



<h2 id="服务引用统一的资源服务器配置："><a href="#服务引用统一的资源服务器配置：" class="headerlink" title="服务引用统一的资源服务器配置："></a>服务引用统一的资源服务器配置：</h2><p>pom:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.luck.sugar&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;luck-common-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HomeController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;test&quot;)</span><br><span class="line">    @PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;)&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p>先到授权服务器获取token</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304403339-c483e02f-5dc0-44ee-ab67-dd137794d4f8.png"></p>
<p>然后在资源服务器中添加key为<font style="color:rgb(33, 33, 33);">Authorization的headers</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304459217-12582e36-cc83-4a25-80db-d973ec10e1c7.png">接着在token后面加数字1</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304562201-a7dc64ca-0218-438a-9a16-003074b4e014.png"></p>
<p>抛出异常An error occurred while attempting to decode the Jwt: Signed JWT rejected: Invalid signature</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在资源服务器的流程中有多个扩展点必须的扩展点为</p>
<p>jwtAuthenticationConverter  他定义了权限信息从jwt的那个Claims下取出，之前的授权服务器中将权限信息放入了authorities 所以上面的的例子定义了权限信息从authorities中获取</p>
<p>BearerTokenResolver：提取令牌</p>
<p>AuthenticationManagerResolver ：获取认证中心，一般使用默认的AuthenticationManager</p>
<p>JwtDecoder：他定义了jwt解析，可以结合jwtAuthenticationConverter 完成从缓存中获取权限信息</p>
<p>AuthenticationProvider：身份验证实现，如果身份验证有特殊处理可以增加</p>
<p>AuthenticationEntryPoint:BearerTokenResolver 获取失败的错误提示处理</p>
<p>AuthenticationFailureHandler: 授权失败错误处理</p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>集成Oauth2.1认证中心</title>
    <url>/2024/03/11/%E9%9B%86%E6%88%90Oauth2.1%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>新版本中的springcloud已经将springcloudoauth2包取消掉，oauth2新增了一个spring-authorization-server的项目，在spring-authorization-server下现在已经有3个可用版本，其中0.3.0对应的是jdk11版本， 0.4.0对应的是jdk8版本，1.0版本对应的是jdk17。以下的实例是以jdk11为例</p>
<span id="more"></span>
<h2 id="建立授权服务"><a href="#建立授权服务" class="headerlink" title="建立授权服务"></a>建立授权服务</h2><p>创建服务的过程这里不做赘述，项目需要的pom文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--jdbc--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;!--auth --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">Spring authorization Server</font><font style="color:rgb(18, 18, 18);">的建表文件在：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org/springframework/security/oauth2/server/authorization/oauth2-authorization-consent-schema.sql</span><br><span class="line"></span><br><span class="line">org/springframework/security/oauth2/server/authorization/oauth2-authorization-schema.sql</span><br><span class="line"></span><br><span class="line">org/springframework/security/oauth2/server/authorization/client/oauth2-registered-client-schema.sql</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">Spring Security</font><font style="color:rgb(18, 18, 18);">的建表语句在</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org/springframework/security/core/userdetails/jdbc/users.ddl</span><br></pre></td></tr></table></figure>

<p>总共5张表，这里放出0.3.0版本的sql其他版本需要自己找一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE oauth2_authorization_consent (</span><br><span class="line">    registered_client_id varchar(100) NOT NULL,</span><br><span class="line">    principal_name varchar(200) NOT NULL,</span><br><span class="line">    authorities varchar(1000) NOT NULL,</span><br><span class="line">    PRIMARY KEY (registered_client_id, principal_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">IMPORTANT:</span><br><span class="line">    If using PostgreSQL, update ALL columns defined with &#x27;blob&#x27; to &#x27;text&#x27;,</span><br><span class="line">    as PostgreSQL does not support the &#x27;blob&#x27; data type.</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE oauth2_authorization (</span><br><span class="line">    id varchar(100) NOT NULL,</span><br><span class="line">    registered_client_id varchar(100) NOT NULL,</span><br><span class="line">    principal_name varchar(200) NOT NULL,</span><br><span class="line">    authorization_grant_type varchar(100) NOT NULL,</span><br><span class="line">    attributes blob DEFAULT NULL,</span><br><span class="line">    state varchar(500) DEFAULT NULL,</span><br><span class="line">    authorization_code_value blob DEFAULT NULL,</span><br><span class="line">    authorization_code_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    authorization_code_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    authorization_code_metadata blob DEFAULT NULL,</span><br><span class="line">    access_token_value blob DEFAULT NULL,</span><br><span class="line">    access_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    access_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    access_token_metadata blob DEFAULT NULL,</span><br><span class="line">    access_token_type varchar(100) DEFAULT NULL,</span><br><span class="line">    access_token_scopes varchar(1000) DEFAULT NULL,</span><br><span class="line">    oidc_id_token_value blob DEFAULT NULL,</span><br><span class="line">    oidc_id_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    oidc_id_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    oidc_id_token_metadata blob DEFAULT NULL,</span><br><span class="line">    refresh_token_value blob DEFAULT NULL,</span><br><span class="line">    refresh_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    refresh_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    refresh_token_metadata blob DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE oauth2_registered_client (</span><br><span class="line">    id varchar(100) NOT NULL,</span><br><span class="line">    client_id varchar(100) NOT NULL,</span><br><span class="line">    client_id_issued_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,</span><br><span class="line">    client_secret varchar(200) DEFAULT NULL,</span><br><span class="line">    client_secret_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    client_name varchar(200) NOT NULL,</span><br><span class="line">    client_authentication_methods varchar(1000) NOT NULL,</span><br><span class="line">    authorization_grant_types varchar(1000) NOT NULL,</span><br><span class="line">    redirect_uris varchar(1000) DEFAULT NULL,</span><br><span class="line">    scopes varchar(1000) NOT NULL,</span><br><span class="line">    client_settings varchar(2000) NOT NULL,</span><br><span class="line">    token_settings varchar(2000) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    username varchar(50)  not null</span><br><span class="line">        primary key,</span><br><span class="line">    password varchar(500) not null,</span><br><span class="line">    enabled  tinyint(1)   not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table authorities</span><br><span class="line">(</span><br><span class="line">    username  varchar(50) not null,</span><br><span class="line">    authority varchar(50) not null,</span><br><span class="line">    constraint ix_auth_username</span><br><span class="line">        unique (username, authority),</span><br><span class="line">    constraint fk_authorities_users</span><br><span class="line">        foreign key (username) references users (username)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1067</span><br><span class="line">spring:</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/oauth2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure>

<h2 id="自定义授权服务器"><a href="#自定义授权服务器" class="headerlink" title="自定义授权服务器"></a>自定义授权服务器</h2><p>在springsecurity5.6以后配置文件为新建Configuration，然后覆盖Bean的形式进行配置，所以这里我们创建配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class AuthorizationServerConfig &#123;</span><br><span class="line">    @Autowired()</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Autowired()</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个Spring security 的过滤器链，默认会配置</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Introspection endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Revocation endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization Server Metadata endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * JWK Set endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 Provider Configuration endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 UserInfo endpoint</span><br><span class="line">     * 这些协议端点，只有配置了他才能够访问的到接口地址（类似mvc的controller）。</span><br><span class="line">     *</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(1)</span><br><span class="line">    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);</span><br><span class="line">        http</span><br><span class="line">                // Redirect to the login page when not authenticated from the</span><br><span class="line">                // authorization endpoint</span><br><span class="line">                .exceptionHandling((exceptions) -&gt; exceptions</span><br><span class="line">                        .authenticationEntryPoint(</span><br><span class="line">                                new LoginUrlAuthenticationEntryPoint(&quot;/login&quot;))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个也是个Spring Security的过滤器链，用于Spring Security的身份认证。</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(2)</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                // Form login handles the redirect to the login page from the</span><br><span class="line">                // authorization server filter chain</span><br><span class="line">                .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置用户信息，或者配置用户数据来源，主要用于用户的检索。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">//        UserDetails userDetails = User.withDefaultPasswordEncoder()</span><br><span class="line">//                .username(&quot;user&quot;)</span><br><span class="line">//                .password(&quot;password&quot;)</span><br><span class="line">//                .roles(&quot;USER&quot;)</span><br><span class="line">//                .build();</span><br><span class="line">//       return new InMemoryUserDetailsManager();</span><br><span class="line"></span><br><span class="line">        return new JdbcUserDetailsManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * oauth2 用于第三方认证，RegisteredClientRepository 主要用于管理第三方（每个第三方就是一个客户端）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RegisteredClientRepository registeredClientRepository() &#123;</span><br><span class="line">//        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">//                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">//                .clientSecret(&quot;&#123;noop&#125;secret&quot;)</span><br><span class="line">//                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/authorized&quot;)</span><br><span class="line">//                .scope(OidcScopes.OPENID)</span><br><span class="line">//                .scope(&quot;message.read&quot;)</span><br><span class="line">//                .scope(&quot;message.write&quot;)</span><br><span class="line">//                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">//                .build();</span><br><span class="line">//</span><br><span class="line">//        return new InMemoryRegisteredClientRepository(registeredClient);</span><br><span class="line">        return new JdbcRegisteredClientRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于给access_token签名使用。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JWKSource&lt;SecurityContext&gt; jwkSource() &#123;</span><br><span class="line">        KeyPair keyPair = generateRsaKey();</span><br><span class="line">        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        RSAKey rsaKey = new RSAKey.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        JWKSet jwkSet = new JWKSet(rsaKey);</span><br><span class="line">        return new ImmutableJWKSet&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成秘钥对，为jwkSource提供服务。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static KeyPair generateRsaKey() &#123;</span><br><span class="line">        KeyPair keyPair;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            keyPairGenerator.initialize(2048);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationService authorizationService() &#123;</span><br><span class="line">        return new JdbcOAuth2AuthorizationService(jdbcTemplate, registeredClientRepository());</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationConsentService authorizationConsentService() &#123;</span><br><span class="line">        return new JdbcOAuth2AuthorizationConsentService(jdbcTemplate, registeredClientRepository());</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 配置Authorization Server实例</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ProviderSettings providerSettings() &#123;</span><br><span class="line">        return ProviderSettings.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在spring-authorization-server中实现了jdbc模式的可以直接链接数据库进行操作</p>
<h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsManager userDetailsManager;</span><br><span class="line">  @Test</span><br><span class="line">void testSaveUser() &#123;</span><br><span class="line">        UserDetails userDetails = User.builder().passwordEncoder(s -&gt; &quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(s))</span><br><span class="line">                .username(&quot;user&quot;)</span><br><span class="line">                .password(&quot;password&quot;)</span><br><span class="line">                .roles(&quot;ADMIN&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        userDetailsManager.createUser(userDetails);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 UserDetailsManager 创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private RegisteredClientRepository registeredClientRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">    void testSaveClient() &#123;</span><br><span class="line">        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">                .clientSecret(&quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(&quot;secret&quot;))</span><br><span class="line">                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">                .redirectUri(&quot;http://127.0.0.1:1069/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">                .redirectUri(&quot;http://127.0.0.1:1069/authorized&quot;)</span><br><span class="line">                .scope(OidcScopes.OPENID).scope(&quot;message.read&quot;)</span><br><span class="line">                .scope(&quot;message.write&quot;)</span><br><span class="line">                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">                .build();</span><br><span class="line">        registeredClientRepository.save(registeredClient);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以registeredClientRepository创建客户端</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开：<a href="http://127.0.0.1:1067/oauth2/authorize?response_type=code&client_id=messaging-client&scope=message.read&redirect_uri=http://127.0.0.1:1067/authorized">http://127.0.0.1:1067/oauth2/authorize?response_type&#x3D;code&amp;client_id&#x3D;messaging-client&amp;scope&#x3D;message.read&amp;redirect_uri&#x3D;http://127.0.0.1:1067/authorized</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678243822906-ab077efe-c963-4e24-a89d-e5fc2beb53e8.png"></p>
<p>输入前面的添加的账号密码</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678243858497-5b68bed5-2d79-48fb-9209-c2e3639c258b.png"></p>
<p>报错了，不过没关系。因为在oath2中第一步是拿到code 拿到code之后才能换取token</p>
<p>我们只要拿到地址栏后面的code信息就好。复制出code信息，打开postman进行post请求</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244026029-0c3c4817-9483-481e-9899-69e8fb636d3b.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244264220-25530875-31db-4c3d-bd62-a4b910934a98.png"></p>
<p>点击访问</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244286055-479c09a7-92be-4354-9e80-831a3295a893.png"></p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义密码模式</title>
    <url>/2024/03/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679106524585-028d887a-7d9d-4e18-af56-f2bcdc192049.png"></p>
<p>在官方的说明中我们可以看到OAuth 2.1 废弃了 OAuth 2.0 中的密码模式，只提供了三种授权类型：授权码、刷新令牌、客户端凭证。</p>
<span id="more"></span>
<p>oauth2.1中授权码模式的流程为：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/jpeg/25873401/1679108178925-bf9d2710-85d2-45f0-a277-cfe3fe0595a5.jpeg" alt="画板"></p>
<p>由上图可知我们想要沿用密码模式会有两种方案</p>
<p>1.自定义密码模式   </p>
<p>2.修改授权码模式，自定义授权页面，使用授权页面自动提交获取token。</p>
<h2 id="自定义密码模式："><a href="#自定义密码模式：" class="headerlink" title="自定义密码模式："></a>自定义密码模式：</h2><p>在官网中对自定义配置的描述<img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109031954-9f6a10bf-a4a8-4c0b-9bee-229c07ae5844.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109044969-a5836447-2dc8-4a6c-b58b-dcad2c8d05f7.png"></p>
<p>这里可以看到在授权断点是可以实现自定义的，于是就有了接下来的思路：</p>
<p>直接略过前面的密码验证、用户确认， 直接自定义授权端点。在自定义的端点中处理授权信息，打开</p>
<p>7 <font style="color:rgb(25, 30, 30);">authorizationEndpoint</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109474910-3209f835-9aba-42bd-b42e-4a60b946d3b3.png"></p>
<p>这里可以看到自定义一个oauth2的授权请求需要定义一个处理器 一个主处理器，但是官方并没有给具体的例子所以需要看下其他授权端点的做法来完成自定义，以code授权的源码为例分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class OAuth2AuthorizationCodeAuthenticationConverter implements AuthenticationConverter &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	@Override</span><br><span class="line">	public Authentication convert(HttpServletRequest request) &#123;</span><br><span class="line">		// grant_type (REQUIRED)</span><br><span class="line">		String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE);</span><br><span class="line">		if (!AuthorizationGrantType.AUTHORIZATION_CODE.getValue().equals(grantType)) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">		MultiValueMap&lt;String, String&gt; parameters = OAuth2EndpointUtils.getParameters(request);</span><br><span class="line"></span><br><span class="line">		// code (REQUIRED)</span><br><span class="line">		String code = parameters.getFirst(OAuth2ParameterNames.CODE);</span><br><span class="line">		if (!StringUtils.hasText(code) ||</span><br><span class="line">				parameters.get(OAuth2ParameterNames.CODE).size() != 1) &#123;</span><br><span class="line">			OAuth2EndpointUtils.throwError(</span><br><span class="line">					OAuth2ErrorCodes.INVALID_REQUEST,</span><br><span class="line">					OAuth2ParameterNames.CODE,</span><br><span class="line">					OAuth2EndpointUtils.ACCESS_TOKEN_REQUEST_ERROR_URI);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// redirect_uri (REQUIRED)</span><br><span class="line">		// Required only if the &quot;redirect_uri&quot; parameter was included in the authorization request</span><br><span class="line">		String redirectUri = parameters.getFirst(OAuth2ParameterNames.REDIRECT_URI);</span><br><span class="line">		if (StringUtils.hasText(redirectUri) &amp;&amp;</span><br><span class="line">				parameters.get(OAuth2ParameterNames.REDIRECT_URI).size() != 1) &#123;</span><br><span class="line">			OAuth2EndpointUtils.throwError(</span><br><span class="line">					OAuth2ErrorCodes.INVALID_REQUEST,</span><br><span class="line">					OAuth2ParameterNames.REDIRECT_URI,</span><br><span class="line">					OAuth2EndpointUtils.ACCESS_TOKEN_REQUEST_ERROR_URI);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">		parameters.forEach((key, value) -&gt; &#123;</span><br><span class="line">			if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.CLIENT_ID) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.CODE) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.REDIRECT_URI)) &#123;</span><br><span class="line">				additionalParameters.put(key, value.get(0));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		return new OAuth2AuthorizationCodeAuthenticationToken(</span><br><span class="line">				code, clientPrincipal, redirectUri, additionalParameters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里可以看出Converter的主要作用是对参数整理然后生成一个新得OAuth2AuthorizationCodeAuthenticationToken 对象，接着看下OAuth2AuthorizationCodeAuthenticationToken的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2AuthorizationCodeAuthenticationToken extends OAuth2AuthorizationGrantAuthenticationToken &#123;</span><br><span class="line">	private final String code;</span><br><span class="line">	private final String redirectUri;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Constructs an &#123;@code OAuth2AuthorizationCodeAuthenticationToken&#125; using the provided parameters.</span><br><span class="line">	 *</span><br><span class="line">	 * @param code the authorization code</span><br><span class="line">	 * @param clientPrincipal the authenticated client principal</span><br><span class="line">	 * @param redirectUri the redirect uri</span><br><span class="line">	 * @param additionalParameters the additional parameters</span><br><span class="line">	 */</span><br><span class="line">	public OAuth2AuthorizationCodeAuthenticationToken(String code, Authentication clientPrincipal,</span><br><span class="line">			@Nullable String redirectUri, @Nullable Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">		super(AuthorizationGrantType.AUTHORIZATION_CODE, clientPrincipal, additionalParameters);</span><br><span class="line">		Assert.hasText(code, &quot;code cannot be empty&quot;);</span><br><span class="line">		this.code = code;</span><br><span class="line">		this.redirectUri = redirectUri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Returns the authorization code.</span><br><span class="line">	 *</span><br><span class="line">	 * @return the authorization code</span><br><span class="line">	 */</span><br><span class="line">	public String getCode() &#123;</span><br><span class="line">		return this.code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Returns the redirect uri.</span><br><span class="line">	 *</span><br><span class="line">	 * @return the redirect uri</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	public String getRedirectUri() &#123;</span><br><span class="line">		return this.redirectUri;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是保存参数对象的。</p>
<p>接着再看下主处理的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class OAuth2AuthorizationCodeAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">	private static final String ERROR_URI = &quot;https://datatracker.ietf.org/doc/html/rfc6749#section-5.2&quot;;</span><br><span class="line">	private static final OAuth2TokenType AUTHORIZATION_CODE_TOKEN_TYPE =</span><br><span class="line">			new OAuth2TokenType(OAuth2ParameterNames.CODE);</span><br><span class="line">	private static final OAuth2TokenType ID_TOKEN_TOKEN_TYPE =</span><br><span class="line">			new OAuth2TokenType(OidcParameterNames.ID_TOKEN);</span><br><span class="line">	private final OAuth2AuthorizationService authorizationService;</span><br><span class="line">	private final OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Constructs an &#123;@code OAuth2AuthorizationCodeAuthenticationProvider&#125; using the provided parameters.</span><br><span class="line">	 *</span><br><span class="line">	 * @param authorizationService the authorization service</span><br><span class="line">	 * @param tokenGenerator the token generator</span><br><span class="line">	 * @since 0.2.3</span><br><span class="line">	 */</span><br><span class="line">	public OAuth2AuthorizationCodeAuthenticationProvider(OAuth2AuthorizationService authorizationService,</span><br><span class="line">			OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator) &#123;</span><br><span class="line">		Assert.notNull(authorizationService, &quot;authorizationService cannot be null&quot;);</span><br><span class="line">		Assert.notNull(tokenGenerator, &quot;tokenGenerator cannot be null&quot;);</span><br><span class="line">		this.authorizationService = authorizationService;</span><br><span class="line">		this.tokenGenerator = tokenGenerator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">		OAuth2AuthorizationCodeAuthenticationToken authorizationCodeAuthentication =</span><br><span class="line">				(OAuth2AuthorizationCodeAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">		OAuth2ClientAuthenticationToken clientPrincipal =</span><br><span class="line">				getAuthenticatedClientElseThrowInvalidClient(authorizationCodeAuthentication);</span><br><span class="line">		RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();</span><br><span class="line"></span><br><span class="line">		OAuth2Authorization authorization = this.authorizationService.findByToken(</span><br><span class="line">				authorizationCodeAuthentication.getCode(), AUTHORIZATION_CODE_TOKEN_TYPE);</span><br><span class="line">		if (authorization == null) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line">		OAuth2Authorization.Token&lt;OAuth2AuthorizationCode&gt; authorizationCode =</span><br><span class="line">				authorization.getToken(OAuth2AuthorizationCode.class);</span><br><span class="line"></span><br><span class="line">		OAuth2AuthorizationRequest authorizationRequest = authorization.getAttribute(</span><br><span class="line">				OAuth2AuthorizationRequest.class.getName());</span><br><span class="line"></span><br><span class="line">		if (!registeredClient.getClientId().equals(authorizationRequest.getClientId())) &#123;</span><br><span class="line">			if (!authorizationCode.isInvalidated()) &#123;</span><br><span class="line">				// Invalidate the authorization code given that a different client is attempting to use it</span><br><span class="line">				authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());</span><br><span class="line">				this.authorizationService.save(authorization);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (StringUtils.hasText(authorizationRequest.getRedirectUri()) &amp;&amp;</span><br><span class="line">				!authorizationRequest.getRedirectUri().equals(authorizationCodeAuthentication.getRedirectUri())) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!authorizationCode.isActive()) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// @formatter:off</span><br><span class="line">		DefaultOAuth2TokenContext.Builder tokenContextBuilder = DefaultOAuth2TokenContext.builder()</span><br><span class="line">				.registeredClient(registeredClient)</span><br><span class="line">				.principal(authorization.getAttribute(Principal.class.getName()))</span><br><span class="line">				.providerContext(ProviderContextHolder.getProviderContext())</span><br><span class="line">				.authorization(authorization)</span><br><span class="line">				.authorizedScopes(authorization.getAttribute(OAuth2Authorization.AUTHORIZED_SCOPE_ATTRIBUTE_NAME))</span><br><span class="line">				.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">				.authorizationGrant(authorizationCodeAuthentication);</span><br><span class="line">		// @formatter:on</span><br><span class="line"></span><br><span class="line">		OAuth2Authorization.Builder authorizationBuilder = OAuth2Authorization.from(authorization);</span><br><span class="line"></span><br><span class="line">		// ----- Access token -----</span><br><span class="line">		OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();</span><br><span class="line">		OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">		if (generatedAccessToken == null) &#123;</span><br><span class="line">			OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">					&quot;The token generator failed to generate the access token.&quot;, ERROR_URI);</span><br><span class="line">			throw new OAuth2AuthenticationException(error);</span><br><span class="line">		&#125;</span><br><span class="line">		OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,</span><br><span class="line">				generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),</span><br><span class="line">				generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());</span><br><span class="line">		if (generatedAccessToken instanceof ClaimAccessor) &#123;</span><br><span class="line">			authorizationBuilder.token(accessToken, (metadata) -&gt;</span><br><span class="line">					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, ((ClaimAccessor) generatedAccessToken).getClaims()));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			authorizationBuilder.accessToken(accessToken);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// ----- Refresh token -----</span><br><span class="line">		OAuth2RefreshToken refreshToken = null;</span><br><span class="line">		if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &amp;&amp;</span><br><span class="line">				// Do not issue refresh token to public client</span><br><span class="line">				!clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) &#123;</span><br><span class="line"></span><br><span class="line">			tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();</span><br><span class="line">			OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">			if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) &#123;</span><br><span class="line">				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">						&quot;The token generator failed to generate the refresh token.&quot;, ERROR_URI);</span><br><span class="line">				throw new OAuth2AuthenticationException(error);</span><br><span class="line">			&#125;</span><br><span class="line">			refreshToken = (OAuth2RefreshToken) generatedRefreshToken;</span><br><span class="line">			authorizationBuilder.refreshToken(refreshToken);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// ----- ID token -----</span><br><span class="line">		OidcIdToken idToken;</span><br><span class="line">		if (authorizationRequest.getScopes().contains(OidcScopes.OPENID)) &#123;</span><br><span class="line">			tokenContext = tokenContextBuilder.tokenType(ID_TOKEN_TOKEN_TYPE).build();</span><br><span class="line">			OAuth2Token generatedIdToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">			if (!(generatedIdToken instanceof Jwt)) &#123;</span><br><span class="line">				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">						&quot;The token generator failed to generate the ID token.&quot;, ERROR_URI);</span><br><span class="line">				throw new OAuth2AuthenticationException(error);</span><br><span class="line">			&#125;</span><br><span class="line">			idToken = new OidcIdToken(generatedIdToken.getTokenValue(), generatedIdToken.getIssuedAt(),</span><br><span class="line">					generatedIdToken.getExpiresAt(), ((Jwt) generatedIdToken).getClaims());</span><br><span class="line">			authorizationBuilder.token(idToken, (metadata) -&gt;</span><br><span class="line">					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, idToken.getClaims()));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			idToken = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		authorization = authorizationBuilder.build();</span><br><span class="line"></span><br><span class="line">		// Invalidate the authorization code as it can only be used once</span><br><span class="line">		authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());</span><br><span class="line"></span><br><span class="line">		this.authorizationService.save(authorization);</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; additionalParameters = Collections.emptyMap();</span><br><span class="line">		if (idToken != null) &#123;</span><br><span class="line">			additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">			additionalParameters.put(OidcParameterNames.ID_TOKEN, idToken.getTokenValue());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return new OAuth2AccessTokenAuthenticationToken(</span><br><span class="line">				registeredClient, clientPrincipal, accessToken, refreshToken, additionalParameters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">		return OAuth2AuthorizationCodeAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到token的生成详细信息。</p>
<h3 id="自定义授权扩展"><a href="#自定义授权扩展" class="headerlink" title="自定义授权扩展"></a>自定义授权扩展</h3><p>以此为参展自定义一个模式总共需要三个类</p>
<p>OAuth2PasswordAuthenticationConverter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationConverter  implements AuthenticationConverter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication convert(HttpServletRequest request) &#123;</span><br><span class="line">        // grant_type (REQUIRED)</span><br><span class="line">        String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE);</span><br><span class="line">        if (!AuthorizationGrantType.PASSWORD.getValue().equals(grantType)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, String&gt; parameters = getParameters(request);</span><br><span class="line"></span><br><span class="line">        // username (REQUIRED)</span><br><span class="line">        String username = parameters.getFirst(OAuth2ParameterNames.USERNAME);</span><br><span class="line">        if (StrUtil.isEmpty(username) ||</span><br><span class="line">                parameters.get(OAuth2ParameterNames.USERNAME).size() != 1) &#123;</span><br><span class="line">            throw new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_NOT_EXIST, &quot;username cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // password (REQUIRED)</span><br><span class="line">        String password = parameters.getFirst(OAuth2ParameterNames.PASSWORD);</span><br><span class="line">        if (StrUtil.isEmpty(password) ||</span><br><span class="line">                parameters.get(OAuth2ParameterNames.PASSWORD).size() != 1) &#123;</span><br><span class="line">            throw new LuckOAuth2AuthencticationException(ResponseStatusEnum.PASSWORD_INCORRECT, &quot;password cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">        parameters.forEach((key, value) -&gt; &#123;</span><br><span class="line">            if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) &amp;&amp;</span><br><span class="line">                    !key.equals(OAuth2ParameterNames.USERNAME) &amp;&amp;</span><br><span class="line">                    !key.equals(OAuth2ParameterNames.PASSWORD)) &#123;</span><br><span class="line">                additionalParameters.put(key, value.get(0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return new OAuth2PasswordAuthenticationToken(username, password, clientPrincipal, additionalParameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MultiValueMap&lt;String, String&gt; getParameters(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; parameters = new LinkedMultiValueMap&lt;&gt;(parameterMap.size());</span><br><span class="line">        parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line">            if (values.length &gt; 0) &#123;</span><br><span class="line">                for (String value : values) &#123;</span><br><span class="line">                    parameters.add(key, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OAuth2PasswordAuthenticationToken</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationToken extends OAuth2AuthorizationGrantAuthenticationToken &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private final String username;</span><br><span class="line">    @Getter</span><br><span class="line">    private final String password;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &#123;@code OAuth2PasswordAuthenticationToken&#125; using the provided parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param username             the username</span><br><span class="line">     * @param password             the password</span><br><span class="line">     * @param clientPrincipal      the authenticated client principal</span><br><span class="line">     * @param additionalParameters the additional parameters</span><br><span class="line">     */</span><br><span class="line">    public OAuth2PasswordAuthenticationToken(String username, String password, Authentication clientPrincipal,</span><br><span class="line">                                                Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">        super(AuthorizationGrantType.PASSWORD, clientPrincipal, additionalParameters);</span><br><span class="line">        Assert.hasText(username, &quot;username cannot be empty&quot;);</span><br><span class="line">        Assert.hasText(password, &quot;password cannot be empty&quot;);</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OAuth2PasswordAuthenticationProvider</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">    private static final String ERROR_URI = &quot;https://datatracker.ietf.org/doc/html/rfc6749#section-5.2&quot;;</span><br><span class="line">    private final AuthenticationManager authenticationManager;</span><br><span class="line">    private final OAuth2AuthorizationService authorizationService;</span><br><span class="line">    private final OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &#123;@code OAuth2PasswordAuthenticationProvider&#125; using the provided parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param authorizationService the authorization service</span><br><span class="line">     * @param tokenGenerator       the token generator</span><br><span class="line">     */</span><br><span class="line">    public OAuth2PasswordAuthenticationProvider(AuthenticationManager authenticationManager,</span><br><span class="line">                                                OAuth2AuthorizationService authorizationService,</span><br><span class="line">                                                OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator) &#123;</span><br><span class="line">        Assert.notNull(authenticationManager, &quot;authenticationManager cannot be null&quot;);</span><br><span class="line">        Assert.notNull(authorizationService, &quot;authorizationService cannot be null&quot;);</span><br><span class="line">        Assert.notNull(tokenGenerator, &quot;tokenGenerator cannot be null&quot;);</span><br><span class="line">        this.authenticationManager = authenticationManager;</span><br><span class="line">        this.authorizationService = authorizationService;</span><br><span class="line">        this.tokenGenerator = tokenGenerator;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">        OAuth2PasswordAuthenticationToken passwordAuthentication = (OAuth2PasswordAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">        OAuth2ClientAuthenticationToken clientPrincipal = getAuthenticatedClientElseThrowInvalidClient(passwordAuthentication);</span><br><span class="line">        RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();</span><br><span class="line">        Assert.notNull(registeredClient, &quot;registeredClient cannot be null&quot;);</span><br><span class="line"></span><br><span class="line">        if (!registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.PASSWORD)) &#123;</span><br><span class="line">            throw new OAuth2AuthenticationException(OAuth2ErrorCodes.UNAUTHORIZED_CLIENT);</span><br><span class="line">        &#125;</span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;Retrieved registered client&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Attempts to authenticate the passwordAuthentication</span><br><span class="line">        Authentication authenticate = authenticate(passwordAuthentication);</span><br><span class="line"></span><br><span class="line">        DefaultOAuth2TokenContext.Builder tokenContextBuilder = getTokenContextBuilder(passwordAuthentication,</span><br><span class="line">                registeredClient, authenticate);</span><br><span class="line"></span><br><span class="line">        OAuth2Authorization.Builder authorizationBuilder = getAuthorizationBuilder(passwordAuthentication,</span><br><span class="line">                registeredClient);</span><br><span class="line"></span><br><span class="line">        OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();</span><br><span class="line"></span><br><span class="line">        // ----- Access token -----</span><br><span class="line">        OAuth2AccessToken accessToken = getAccessToken(authorizationBuilder, tokenContext);</span><br><span class="line"></span><br><span class="line">        // ----- Refresh token -----</span><br><span class="line">        OAuth2RefreshToken refreshToken = getRefreshToken(clientPrincipal, registeredClient, tokenContextBuilder, authorizationBuilder);</span><br><span class="line"></span><br><span class="line">        return new OAuth2AccessTokenAuthenticationToken(</span><br><span class="line">                registeredClient, clientPrincipal, accessToken, refreshToken, passwordAuthentication.getAdditionalParameters());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Authentication authenticate(OAuth2PasswordAuthenticationToken passwordAuthentication) &#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken token =</span><br><span class="line">                new UsernamePasswordAuthenticationToken(passwordAuthentication.getUsername(),</span><br><span class="line">                        passwordAuthentication.getPassword());</span><br><span class="line">        Authentication authenticate;</span><br><span class="line">        try &#123;</span><br><span class="line">            authenticate = authenticationManager.authenticate(token);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw oAuth2AuthenticationException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return authenticate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static DefaultOAuth2TokenContext.Builder getTokenContextBuilder(</span><br><span class="line">            OAuth2PasswordAuthenticationToken passwordAuthentication,</span><br><span class="line">            RegisteredClient registeredClient,</span><br><span class="line">            Authentication authenticate) &#123;</span><br><span class="line">        return DefaultOAuth2TokenContext.builder()</span><br><span class="line">                .registeredClient(registeredClient)</span><br><span class="line">                .principal(authenticate)</span><br><span class="line">                .providerContext(ProviderContextHolder.getProviderContext())</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.PASSWORD)</span><br><span class="line">                .authorizationGrant(passwordAuthentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static OAuth2Authorization.Builder getAuthorizationBuilder(</span><br><span class="line">            OAuth2PasswordAuthenticationToken passwordAuthentication,</span><br><span class="line">            RegisteredClient registeredClient) &#123;</span><br><span class="line">        return OAuth2Authorization.withRegisteredClient(registeredClient)</span><br><span class="line">                .principalName(passwordAuthentication.getName())</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OAuth2AccessToken getAccessToken(OAuth2Authorization.Builder authorizationBuilder,</span><br><span class="line">                                             OAuth2TokenContext tokenContext) &#123;</span><br><span class="line">        OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">        if (generatedAccessToken == null) &#123;</span><br><span class="line">            OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">                    &quot;The token generator failed to generate the access token.&quot;, ERROR_URI);</span><br><span class="line">            throw new OAuth2AuthenticationException(error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;Generated access token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,</span><br><span class="line">                generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),</span><br><span class="line">                generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());</span><br><span class="line">        if (generatedAccessToken instanceof ClaimAccessor) &#123;</span><br><span class="line">            authorizationBuilder.token(accessToken, (metadata) -&gt;</span><br><span class="line">                    metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME,</span><br><span class="line">                            ((ClaimAccessor) generatedAccessToken).getClaims()));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            authorizationBuilder.accessToken(accessToken);</span><br><span class="line">        &#125;</span><br><span class="line">        return accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OAuth2RefreshToken getRefreshToken(OAuth2ClientAuthenticationToken clientPrincipal,</span><br><span class="line">                                               RegisteredClient registeredClient,</span><br><span class="line">                                               DefaultOAuth2TokenContext.Builder tokenContextBuilder,</span><br><span class="line">                                               OAuth2Authorization.Builder authorizationBuilder) &#123;</span><br><span class="line">        OAuth2TokenContext tokenContext;</span><br><span class="line">        OAuth2RefreshToken refreshToken = null;</span><br><span class="line">        if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &amp;&amp;</span><br><span class="line">                // Do not issue refresh token to public client</span><br><span class="line">                !clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) &#123;</span><br><span class="line"></span><br><span class="line">            tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();</span><br><span class="line">            OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">            if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) &#123;</span><br><span class="line">                OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">                        &quot;The token generator failed to generate the refresh token.&quot;,ERROR_URI);</span><br><span class="line">                throw new OAuth2AuthenticationException(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Generated refresh token&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            refreshToken = (OAuth2RefreshToken) generatedRefreshToken;</span><br><span class="line">            authorizationBuilder.refreshToken(refreshToken);</span><br><span class="line"></span><br><span class="line">            this.authorizationService.save(authorizationBuilder.build());</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Saved authorization&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">        return OAuth2PasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * OAuth2 认证失败处理器只能处理 OAuth2AuthenticationException，故转换</span><br><span class="line">     *</span><br><span class="line">     * @param authenticationException 身份验证异常</span><br><span class="line">     * @return &#123;@link OAuth2AuthenticationException&#125;</span><br><span class="line">     */</span><br><span class="line">    private OAuth2AuthenticationException oAuth2AuthenticationException(Exception authenticationException) &#123;</span><br><span class="line">        if (authenticationException instanceof UsernameNotFoundException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof BadCredentialsException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.USERNAME_OR_PASSWORD_INCORRECT);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof LockedException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_FROZEN);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof AccountExpiredException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_EXPIRED);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof CredentialsExpiredException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.PASSWORD_EXPIRED);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof InternalAuthenticationServiceException) &#123;</span><br><span class="line">            if (authenticationException.getCause() instanceof DisabledException) &#123;</span><br><span class="line">                return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_DISABLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new LuckOAuth2AuthencticationException(ResponseStatusEnum.IDENTITY_VERIFICATION_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">    public OAuth2ClientAuthenticationToken getAuthenticatedClientElseThrowInvalidClient(Authentication authentication) &#123;</span><br><span class="line">        OAuth2ClientAuthenticationToken clientPrincipal = null;</span><br><span class="line">        if (OAuth2ClientAuthenticationToken.class.isAssignableFrom(authentication.getPrincipal().getClass())) &#123;</span><br><span class="line">            clientPrincipal = (OAuth2ClientAuthenticationToken) authentication.getPrincipal();</span><br><span class="line">        &#125;</span><br><span class="line">        if (clientPrincipal != null &amp;&amp; clientPrincipal.isAuthenticated()) &#123;</span><br><span class="line">            return clientPrincipal;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_CLIENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果需要自定义claims可以添加一个自定义OAuth2TokenCustomizer</p>
<p>这里以OAuth2TokenCustomizerImpl为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class OAuth2TokenCustomizerImpl implements OAuth2TokenCustomizer&lt;JwtEncodingContext&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void customize(JwtEncodingContext context) &#123;</span><br><span class="line">        JwtClaimsSet.Builder builder = context.getClaims();</span><br><span class="line"></span><br><span class="line">        // 客户端模式不返回具体用户信息</span><br><span class="line">        if (SecurityConstants.CLIENT_CREDENTIALS.equals(context.getAuthorizationGrantType().getValue())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User user = (User) context.getPrincipal().getPrincipal();</span><br><span class="line">        builder.claims((claims) -&gt; &#123;</span><br><span class="line">            claims.put(&quot;username&quot;, user.getUsername());</span><br><span class="line">            claims.put(&quot;authorities&quot;, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toArray());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>自定义鉴权成功或者鉴权失败代码可以参照</p>
<p>DefaultAuthenticationFailureHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAuthenticationFailureHandler implements AuthenticationFailureHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String AUTHENTICATION_METHOD = &quot;authentication_method&quot;;</span><br><span class="line">    private static final String CREDENTIALS = &quot;credentials&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123;</span><br><span class="line">        AjaxResult&lt;?&gt; error = createError(exception);</span><br><span class="line"></span><br><span class="line">            ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(error, servletServerHttpResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 创建 error</span><br><span class="line">         *</span><br><span class="line">         * @param exception /</span><br><span class="line">         * @return /</span><br><span class="line">         */</span><br><span class="line">        private AjaxResult&lt;?&gt; createError(AuthenticationException exception) &#123;</span><br><span class="line">            AjaxResult&lt;?&gt; error = null;</span><br><span class="line"></span><br><span class="line">            if (exception instanceof LuckOAuth2AuthencticationException) &#123;</span><br><span class="line">                error = AjaxResult.error(((LuckOAuth2AuthencticationException) exception).getCode(),</span><br><span class="line">                        exception.getMessage());</span><br><span class="line">            &#125; else if (exception instanceof OAuth2AuthenticationException) &#123;</span><br><span class="line">                OAuth2AuthenticationException oAuth2AuthenticationException= (OAuth2AuthenticationException) exception;</span><br><span class="line">                String errorCode = oAuth2AuthenticationException.getError().getErrorCode();</span><br><span class="line">                String description = oAuth2AuthenticationException.getError().getDescription();</span><br><span class="line">                if (OAuth2ErrorCodes.INVALID_CLIENT.equals(errorCode))&#123;</span><br><span class="line">                    if (StrUtil.isEmpty(description)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, &quot;无效的客户端&quot;);</span><br><span class="line">                    &#125; else if (description.contains(OAuth2ParameterNames.CLIENT_ID)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_NOT_EXIST);</span><br><span class="line">                    &#125; else if (description.contains(AUTHENTICATION_METHOD)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.AUTHORIZATION_DENIED);</span><br><span class="line">                    &#125; else if (description.contains(CREDENTIALS)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_PASSWORD_EMPTY);</span><br><span class="line">                    &#125; else if (description.contains(OAuth2ParameterNames.CLIENT_SECRET)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_PASSWORD_INCORRECT);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                switch (errorCode) &#123;</span><br><span class="line">                    case OAuth2ErrorCodes.UNSUPPORTED_GRANT_TYPE :</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.UNSUPPORTED_GRANT_TYPE);</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_REQUEST : &#123;</span><br><span class="line">                        if (StrUtil.isEmpty(description)) &#123;</span><br><span class="line">                            return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, &quot;无效的客户端&quot;);</span><br><span class="line">                        &#125; else if (description.contains(OAuth2ParameterNames.GRANT_TYPE)) &#123;</span><br><span class="line">                            return AjaxResult.error(ResponseStatusEnum.GRANT_TYPE_EMPTY);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_GRANT : return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT);</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_SCOPE : return AjaxResult.error(ResponseStatusEnum.INVALID_SCOPE);</span><br><span class="line">                    case OAuth2ErrorCodes.UNAUTHORIZED_CLIENT :</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED_CLIENT);</span><br><span class="line">                    default : error = AjaxResult.error(ResponseStatusEnum.USER_LOGIN_ABNORMAL.getCode(),</span><br><span class="line">                            oAuth2AuthenticationException.getError().getErrorCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error = AjaxResult.error(ResponseStatusEnum.USER_LOGIN_ABNORMAL, exception.getLocalizedMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DefaultAuthenticationSuccessHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定响应数据不使用 ResponseData 封装的参数名称</span><br><span class="line">     * Swagger 登录时可用</span><br><span class="line">     */</span><br><span class="line">    private static final String NO_RESPONSE_DATA_PARAM_NAME = &quot;no_response_data&quot;;</span><br><span class="line"></span><br><span class="line">    private final Converter&lt;OAuth2AccessTokenResponse, Map&lt;String, Object&gt;&gt; accessTokenResponseParametersConverter =</span><br><span class="line">            new DefaultOAuth2AccessTokenResponseMapConverter();</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">        OAuth2AccessTokenAuthenticationToken accessTokenAuthentication = (OAuth2AccessTokenAuthenticationToken) authentication;</span><br><span class="line">        OAuth2AccessToken accessToken = accessTokenAuthentication.getAccessToken();</span><br><span class="line">        OAuth2RefreshToken refreshToken = accessTokenAuthentication.getRefreshToken();</span><br><span class="line">        Map&lt;String, Object&gt; additionalParameters = accessTokenAuthentication.getAdditionalParameters();</span><br><span class="line">        OAuth2AccessTokenResponse.Builder builder = OAuth2AccessTokenResponse.withToken(accessToken.getTokenValue())</span><br><span class="line">                .tokenType(accessToken.getTokenType()).scopes(accessToken.getScopes());</span><br><span class="line">        if (accessToken.getIssuedAt() != null &amp;&amp; accessToken.getExpiresAt() != null) &#123;</span><br><span class="line">            builder.expiresIn(ChronoUnit.SECONDS.between(accessToken.getIssuedAt(), accessToken.getExpiresAt()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (refreshToken != null) &#123;</span><br><span class="line">            builder.refreshToken(refreshToken.getTokenValue());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!CollectionUtils.isEmpty(additionalParameters)) &#123;</span><br><span class="line">            builder.additionalParameters(additionalParameters);</span><br><span class="line">        &#125;</span><br><span class="line">        OAuth2AccessTokenResponse accessTokenResponse = builder.build();</span><br><span class="line">        Map&lt;String, Object&gt; tokenResponseParameters = this.accessTokenResponseParametersConverter.convert(accessTokenResponse);</span><br><span class="line">        ServletServerHttpResponse httpResponse = new ServletServerHttpResponse(response);</span><br><span class="line"></span><br><span class="line">        boolean noResponseData = Boolean.parseBoolean(request.getParameter(NO_RESPONSE_DATA_PARAM_NAME));</span><br><span class="line">        if (noResponseData) &#123;</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(tokenResponseParameters, httpResponse);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AjaxResult&lt;Map&lt;String, Object&gt;&gt; responseData = AjaxResult.ok(tokenResponseParameters);</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(responseData, httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然如果你需要自定义获取用户信息重写UserDetailsService，和其他版本的一致就好</p>
<h3 id="自定义配置信息"><a href="#自定义配置信息" class="headerlink" title="自定义配置信息"></a>自定义配置信息</h3><p>当代码逻辑写完之后需要增加配置让代码生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个Spring security 的过滤器链，默认会配置</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Introspection endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Revocation endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization Server Metadata endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * JWK Set endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 Provider Configuration endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 UserInfo endpoint</span><br><span class="line">     * 这些协议端点，只有配置了他才能够访问的到接口地址（类似mvc的controller）。</span><br><span class="line">     *</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(1)</span><br><span class="line">    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        OAuth2AuthorizationServerConfigurer&lt;HttpSecurity&gt; authorizationServerConfigurer =</span><br><span class="line">                new OAuth2AuthorizationServerConfigurer&lt;&gt;();</span><br><span class="line">        http.apply(authorizationServerConfigurer);</span><br><span class="line">        authorizationServerConfigurer</span><br><span class="line">                .authorizationService(authorizationService())</span><br><span class="line">                .tokenEndpoint(tokenEndpoint-&gt;tokenEndpoint</span><br><span class="line">                                .accessTokenRequestConverter(new OAuth2PasswordAuthenticationConverter())</span><br><span class="line">                                .accessTokenResponseHandler(responseDataAuthenticationSuccessHandler())</span><br><span class="line">                                .errorResponseHandler(authenticationFailureHandler()));</span><br><span class="line">        DefaultSecurityFilterChain chain = http</span><br><span class="line">                .requestMatcher(authorizationServerConfigurer.getEndpointsMatcher())</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt;</span><br><span class="line">                        authorize.anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                .csrf(CsrfConfigurer::disable)</span><br><span class="line">                .build();</span><br><span class="line">        addingAdditionalAuthenticationProvider(http);</span><br><span class="line">        return chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个也是个Spring Security的过滤器链，用于Spring Security的身份认证。</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(2)</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                // Form login handles the redirect to the login page from the</span><br><span class="line">                // authorization server filter chain</span><br><span class="line">                .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationSuccessHandler responseDataAuthenticationSuccessHandler() &#123;</span><br><span class="line">        return new DefaultAuthenticationSuccessHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationFailureHandler authenticationFailureHandler() &#123;</span><br><span class="line">        return new DefaultAuthenticationFailureHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置用户信息，或者配置用户数据来源，主要用于用户的检索。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">//        UserDetails userDetails = User.withDefaultPasswordEncoder()</span><br><span class="line">//                .username(&quot;user&quot;)</span><br><span class="line">//                .password(&quot;password&quot;)</span><br><span class="line">//                .roles(&quot;USER&quot;)</span><br><span class="line">//                .build();</span><br><span class="line">//       return new InMemoryUserDetailsManager();</span><br><span class="line"></span><br><span class="line">        return new OAuth2UserDetailsManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * oauth2 用于第三方认证，RegisteredClientRepository 主要用于管理第三方（每个第三方就是一个客户端）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RegisteredClientRepository registeredClientRepository() &#123;</span><br><span class="line">//        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">//                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">//                .clientSecret(&quot;&#123;noop&#125;secret&quot;)</span><br><span class="line">//                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/authorized&quot;)</span><br><span class="line">//                .scope(OidcScopes.OPENID)</span><br><span class="line">//                .scope(&quot;message.read&quot;)</span><br><span class="line">//                .scope(&quot;message.write&quot;)</span><br><span class="line">//                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">//                .build();</span><br><span class="line">//</span><br><span class="line">//        return new InMemoryRegisteredClientRepository(registeredClient);</span><br><span class="line">        return new JdbcRegisteredClientRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationService authorizationService()&#123;</span><br><span class="line">        return new OAuth2RedisAuthorizationService(redisService);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 用于给access_token签名使用。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JWKSource&lt;SecurityContext&gt; jwkSource() &#123;</span><br><span class="line">        KeyPair keyPair = generateRsaKey();</span><br><span class="line">        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        RSAKey rsaKey = new RSAKey.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        JWKSet jwkSet = new JWKSet(rsaKey);</span><br><span class="line">        return new ImmutableJWKSet&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成秘钥对，为jwkSource提供服务。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static KeyPair generateRsaKey() &#123;</span><br><span class="line">        KeyPair keyPair;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            keyPairGenerator.initialize(2048);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置Authorization Server实例</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ProviderSettings providerSettings() &#123;</span><br><span class="line">        return ProviderSettings.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void addingAdditionalAuthenticationProvider(HttpSecurity http) &#123;</span><br><span class="line">        AuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class);</span><br><span class="line">        OAuth2AuthorizationService authorizationService = http.getSharedObject(OAuth2AuthorizationService.class);</span><br><span class="line">        OAuth2TokenGenerator&lt;?&gt; tokenGenerator = http.getSharedObject(OAuth2TokenGenerator.class);</span><br><span class="line"></span><br><span class="line">        OAuth2PasswordAuthenticationProvider passwordAuthenticationProvider =</span><br><span class="line">                new OAuth2PasswordAuthenticationProvider(authenticationManager, authorizationService, tokenGenerator);</span><br><span class="line">        http.authenticationProvider(passwordAuthenticationProvider);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>备注：</p>
<p>registeredClientRepository 客户端信息</p>
<p>authorizationService token新增和处理</p>
<p>providerSettings  访问端点配置 默认为：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679126686151-d9dce2ff-ee10-4965-9c54-2744170deb62.png"></p>
<p>addingAdditionalAuthenticationProvider</p>
<p><code>OAuth2TokenEndpointConfigurer</code> 并没有提供批量设置 <code>AuthenticationProvider</code> 的方法，即，如果你要同时配置 authorization_code、refresh_token、client_credentials、password 的 <code>AuthenticationProvider</code> 的话，你需要调用多次 <code>accessTokenResponseHandler() </code>但是<code>HttpSecurity</code>提供了一个 <code>authenticationProvider()</code> 可以动态添加 <code>AuthenticationProvider</code></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>新版本的spring-authorization-server不同于原来的oauth2的版本，去除了密码模式，让很多简单的自定义登陆变的很麻烦，但是其中可自定义的地方有很多</p>
<p>Converter ：从访问令牌中获取参数，并格式化</p>
<p>Provider ：主处理器用于生成token以及保存token</p>
<p>AuthorizationService ：保存token信息，获取token信息</p>
<p>ResponseHandler ：返回信息处理</p>
<p>Token：格式化访问信息为Provider提供数据</p>
<p>Customizer ：自定义claims信息数据可以从context.getPrincipal().getPrincipal()中获取</p>
<p>Manager ：自定义获取用户信息逻辑</p>
<p>当然如果你不希望这么麻烦想要更简单的实现登陆，可以自定义<font style="color:rgb(25, 30, 30);">consentPage页面然后在自定义的consentPage中增加脚本自动提交表单获取令牌</font></p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudGateway详解</title>
    <url>/2024/03/25/SpringCloudGateway%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Spring-Cloud-Gateway-的核心功能："><a href="#Spring-Cloud-Gateway-的核心功能：" class="headerlink" title="Spring Cloud Gateway 的核心功能："></a><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway 的核心功能：</font></h2><p><font style="color:rgb(25, 27, 31);">断言（Predicate）：参照 Java8 的新特性Predicate，允许开发人员匹配 HTTP 请求中的任何内容，比如请求头或请求参数，最后根据匹配结果返回一个布尔值。 路由（route）：由ID、目标URI、断言集合和过滤器集合组成。如果聚合断言结果为真，则转发到该路由。 过滤器（filter）：可以在返回请求之前或之后修改请求和响应的内容。</font></p>
<span id="more"></span>
<h2 id="1、路由-Route"><a href="#1、路由-Route" class="headerlink" title="1、路由 Route"></a><font style="color:rgb(25, 27, 31);">1、路由 Route</font></h2><p><font style="color:rgb(25, 27, 31);">Route 主要由 路由id、目标uri、断言集合和过滤器集合组成，那我们简单看看这些属性到底有什么作用。 （1）id：路由标识，要求唯一，名称任意（默认值 uuid，一般不用，需要自定义） （2）uri：请求最终被转发到的目标地址 （3）order： 路由优先级，数字越小，优先级越高 （4）predicates：断言数组，即判断条件，如果返回值是boolean，则转发请求到 uri 属性指定的服务中 （5）filters：过滤器数组，在请求传递过程中，对请求做一些修改</font></p>
<h2 id="2、断言-Predicate"><a href="#2、断言-Predicate" class="headerlink" title="2、断言 Predicate"></a><font style="color:rgb(25, 27, 31);">2、断言 Predicate</font></h2><p><font style="color:rgb(25, 27, 31);">Predicate 来自于 Java8 的借口。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。 Predicate 可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。Spring Cloud Gateway 内置了许多 Predict，这些 Predict 的源码在 org.springframework.cloud.gateway.handler.predicate 包中，有兴趣可以阅读一下</font></p>
<h2 id="3、过滤器-filter"><a href="#3、过滤器-filter" class="headerlink" title="3、过滤器 filter"></a><font style="color:rgb(25, 27, 31);">3、过滤器 filter</font></h2><p><font style="color:rgb(25, 27, 31);">Gateway 过滤器的生命周期： PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。 POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。 Gateway 过滤器从作用范围可分为两种: GatewayFilter：应用到单个路由或者一个分组的路由上（需要在配置文件中配置） GlobalFilter：应用到所有的路由上（无需配置，全局生效） （1）局部过滤器 GatewayFilter： Spring Cloud Gateway 中内置了许多的局部过滤器；局部过滤器需要在指定路由配置才能生效，默认是不生效的</font></p>
<p><font style="color:rgb(25, 27, 31);">（2）自定义局部过滤器： 虽说内置的过滤器能够解决很多场景，但是难免还是有些特殊需求需要定制一个过滤器，下面就来介绍一下如何自定义局部过滤器。</font></p>
<p><font style="color:rgb(25, 27, 31);">(3) GlobalFilter 全局过滤器： 全局过滤器应用全部路由上，无需开发者配置，Spring Cloud Gateway 也内置了一些全局过滤器。GlobalFilter 的功能其实和 GatewayFilter 是相同的，只是 GlobalFilter 的作用域是所有的路由配置，而不是绑定在指定的路由配置上。多个 GlobalFilter 可以通过 @Order 或者 getOrder() 方法指定执行顺序，order值越小，执行的优先级越高。 注意，由于过滤器有 pre 和 post 两种类型，pre 类型过滤器如果 order 值越小，那么它就应该在pre过滤器链的顶层，post 类型过滤器如果 order 值越小，那么它就应该在 post 过滤器链的底层</font></p>
<p><font style="color:rgb(25, 27, 31);">(4) 过滤器规则（Filter）</font></p>
<p><font style="color:rgb(25, 27, 31);">过滤规则 实例 说明 PrefixPath - PrefixPath&#x3D;&#x2F;app 在请求路径前加上app RewritePath - RewritePath&#x3D;&#x2F;test, &#x2F;app&#x2F;test 访问localhost:9022&#x2F;test,请求会转发到localhost:8001&#x2F;app&#x2F;test SetPath SetPath&#x3D;&#x2F;app&#x2F;{path} 通过模板设置路径，转发的规则时会在路径前增加app，{path}表示原请求路径 RedirectTo 重定向 RemoveRequestHeader 去掉某个请求头信息 注：当配置多个filter时，优先定义的会被调用，剩余的filter将不会生效</font></p>
<h2 id="4、Predicate-断言条件-转发规则-介绍"><a href="#4、Predicate-断言条件-转发规则-介绍" class="headerlink" title="4、Predicate 断言条件(转发规则)介绍"></a><font style="color:rgb(25, 27, 31);">4、Predicate 断言条件(转发规则)介绍</font></h2><p><font style="color:rgb(25, 27, 31);">每一个Predicate的使用，你可以理解为：当满足这种条件后才会被转发，如果是多个，那就是都满足的情况下被转发。</font></p>
<h2 id="Path-方式匹配转发"><a href="#Path-方式匹配转发" class="headerlink" title="Path 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Path 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">通过Path转发示例，我们讲解下上面的两种配置，分别是application.yml以及RouteLocator。</font></p>
<p><font style="color:rgb(25, 27, 31);">配置文件匹配地址转发</font></p>
<p><font style="color:rgb(25, 27, 31);">我们在application.yml配置文件内添加对应的路由配置，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"></span><br><span class="line">application:</span><br><span class="line"></span><br><span class="line">name: spring-cloud-gateway-sample</span><br><span class="line"></span><br><span class="line">cloud:</span><br><span class="line"></span><br><span class="line">gateway:</span><br><span class="line"></span><br><span class="line">routes:</span><br><span class="line"></span><br><span class="line">- id: blog</span><br><span class="line"></span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line"></span><br><span class="line">predicates:</span><br><span class="line"></span><br><span class="line"># 匹配路径转发</span><br><span class="line"></span><br><span class="line">- Path=/api-boot-datasource-switch.html</span><br><span class="line"></span><br><span class="line"># 端口号</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line"></span><br><span class="line">port: 9090</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><strong><font style="color:rgb(25, 27, 31);">先来解释下route的组成部分：</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">id：路由的ID uri：匹配路由的转发地址 predicates：配置该路由的断言，通过PredicateDefinition类进行接收配置。 在上面的配置中，当访问<a href="http://localhost:9090/api-boot-datasource-switch.html%E6%97%B6%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8F%91%E5%88%B0">http://localhost:9090/api-boot-datasource-switch.html时就会被自动转发到</a></font><a href="https://link.zhihu.com/?target=http://blog.xx.com/api-boot-datasource-switch.html"><font style="color:rgb(25, 27, 31);">http://blog.xx.com/api-boot-datasource-switch.html</font></a><font style="color:rgb(25, 27, 31);">，这里要注意完全匹配Path的值时才会进行路由转发。</font></p>
<p><font style="color:rgb(25, 27, 31);">访问效果如下所示：</font></p>
<p><font style="color:rgb(25, 27, 31);">spring-cloud-gateway-path-predicate.png</font></p>
<p><font style="color:rgb(25, 27, 31);">RouteLocator 匹配路径转发</font></p>
<p><font style="color:rgb(25, 27, 31);">在上面的配置中，如果使用RouteLocator方式该怎么进行配置呢？</font></p>
<p><font style="color:rgb(25, 27, 31);">如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RouteLocator routeLocator(RouteLocatorBuilder builder) &#123;</span><br><span class="line">return builder.routes()</span><br><span class="line">.route(&quot;blog&quot;, r -&gt;</span><br><span class="line">r.path(&quot;/api-boot-datasource-switch.html&quot;).uri(&quot;http://blog.xx.com&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="Before-方式匹配转发"><a href="#Before-方式匹配转发" class="headerlink" title="Before 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Before 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">当部署有访问时间限制的接口时，我们可以通过Before Predicate来完成某一个时间点之前允许访问，过时后则不允许转发请求到具体的服务，配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Before=2019-05-01T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，我们允许2019-05-01日凌晨之前通过路由转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">，通过查看org.springframework.cloud.gateway.handler.predicate.BeforeRoutePredicateFactory源码我们发现，Spring Cloud Gateway的Before断言采用的ZonedDateTime进行匹配时间，这里要注意存在时区的问题，需要配置[Asia&#x2F;Shanghai]作为中国时区。</font></p>
<h2 id="After-方式匹配转发"><a href="#After-方式匹配转发" class="headerlink" title="After 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">After 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">After Predicate与Before配置使用一致，匹配某一个时间点之后允许路由转发，如下所示配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- After=2019-04-29T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中允许2019-04-29凌晨之后进行转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">。</font></p>
<h2 id="Between-方式匹配转发"><a href="#Between-方式匹配转发" class="headerlink" title="Between 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Between 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">那如果是一个时间段内允许请求转发，通过Before、After组合配置也可以完成，不过Spring Cloud Gateway还是提供了Between方式，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Between=2019-04-29T00:00:00+08:00[Asia/Shanghai], 2019-05-01T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，允许在2019-04-29日凌晨后 &amp; 2019-05-01凌晨之前请求转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">。</font></p>
<h2 id="Cookie-方式匹配转发"><a href="#Cookie-方式匹配转发" class="headerlink" title="Cookie 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Cookie 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway 还提供了根据Cookie值的方式匹配转发请求，如果请求中所携带的Cookie值与配置的Predicate匹配，那么就可以被允许转发到指定地址，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Cookie=hengboy, leo</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，如果客户端发送请求时携带了”hengboy&#x3D;leo”的Cookie信息，则允许请求转发。</font></p>
<p><strong><font style="color:rgb(25, 27, 31);">测试Cookie方式转发：</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">curl <a href="http://localhost:9090/">http://localhost:9090</a> –cookie “hengboy&#x3D;leo” 通过上面方式我们是可以成功转发请求的，如果我们修改Cookie的值，就会导致无法转发，出现404。</font></p>
<h2 id="Header-方式匹配转发"><a href="#Header-方式匹配转发" class="headerlink" title="Header 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Header 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以根据发送请求的Header信息进行匹配转发，加入我们可以根据X-Request-Id的值进行匹配，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，如果X-Request-Id的值为数字，那么就可以转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">，我们通过如下方式进行测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">curl <a href="http://localhost:9090/">http://localhost:9090</a> -H “X-Request-Id:123456” 如果头信息为X-Request-Id:abc时，就会转发失败，出现404。</font></p>
<h2 id="Host-方式匹配转发"><a href="#Host-方式匹配转发" class="headerlink" title="Host 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Host 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以根据Host主机名进行匹配转发，如果我们的接口只允许\.</font><a href="https://link.zhihu.com/?target=http://xx.com"><font style="color:rgb(25, 27, 31);">http://xx.com</font></a><font style="color:rgb(25, 27, 31);">域名进行访问，那么配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Host=\*\*.xx.com</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">测试如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. curl http://localhost:9090 -H &quot;Host: xx.com&quot; // 匹配</span><br><span class="line">2. curl http://localhost:9090 -H &quot;Host: api.xx.com&quot; // 匹配</span><br><span class="line">3. curl http://localhost:9090 -H &quot;Host: admin.xx.com&quot; // 匹配</span><br><span class="line">4. curl http://localhost:9090 -H &quot;Host: hengboy.com&quot; // 不匹配</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="请求方式-方式匹配转发"><a href="#请求方式-方式匹配转发" class="headerlink" title="请求方式 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">请求方式 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Rest请求风格的接口内往往会存在多种请求方式的接口，如果我们的接口只允许POST请求访问，那么配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Method=POST</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">发送GET请求测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">~ curl <a href="http://localhost:9090/">http://localhost:9090</a></font></p>
<p><font style="color:rgb(25, 27, 31);">{“timestamp”:”2019-04-29T06:27:41.121+0000”,”path”:”&#x2F;“,”status”:404,”error”:”Not Found”,”message”:null} 我们的请求并未被Spring Cloud Gateway进行转发，那么我们再来通过POST请求进行测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">curl -X POST <a href="http://localhost:9090/">http://localhost:9090</a> 是可以被转发到目标地址uri的，不过我的这个博客是OSS部署的，阿里云限制了POST访问，尽管如此我们也证明了可以转发。</font></p>
<p><font style="color:rgb(25, 27, 31);">请求参数 方式匹配转发 Spring Cloud GateWay还支持根据指定的参数进行匹配，Query方式的Predicate也有两种方式匹配情况，如下所示：</font></p>
<p><font style="color:rgb(25, 27, 31);">请求中存在xxx参数 cloud: gateway: routes: - id: blog uri: </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">predicates: - Query&#x3D;xxx 我们通过curl <a href="http://localhost:9090/?xxx%5C=123%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%88%90%E5%8A%9F%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%8C%E5%8F%AA%E8%A6%81%E5%8F%82%E6%95%B0%E5%AD%98%E5%9C%A8xxx%E5%B0%B1%E4%BC%9A%E8%A2%AB%E6%88%90%E5%8A%9F%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%90%A6%E5%88%99%E5%87%BA%E7%8E%B0404%E8%BD%AC%E5%8F%91%E5%A4%B1%E8%B4%A5%E3%80%82">http://localhost:9090\?xxx\=123是可以被成功转发的，只要参数存在xxx就会被成功转发，否则出现404转发失败。</a></font></p>
<p><font style="color:rgb(25, 27, 31);">请求中存在xxx参数且值为zzz cloud: gateway: routes: - id: blog uri: </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">predicates: - Query&#x3D;xxx, zzz 根据上面配置，我们限定了参数xxx必须为zzz时才会被成功转发，否则同样会出现404抓发失败。</font></p>
<p><font style="color:rgb(25, 27, 31);">请求路径 方式匹配转发 Spring Cloud Gateway提供了请求路径变量方式匹配转发，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Path=/article/&#123;articleId&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">在上面配置中{articleId}是一个路径变量，可以是任意值，匹配&#x2F;article&#x2F;1、&#x2F;article&#x2F;abc等，测试如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ curl http://localhost:9090/article/1 // 匹配</span><br><span class="line">~ curl http://localhost:9090/article/abc // 匹配</span><br><span class="line">~ curl http://localhost:9090/article/1/1 // 不匹配</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="请求IP-方式匹配转发"><a href="#请求IP-方式匹配转发" class="headerlink" title="请求IP 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">请求IP 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以限制允许访问接口的客户端IP地址，配置后只对指定IP地址的客户端进行请求转发，配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- RemoteAddr=192.168.1.56/24</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面我们配置了192.168.1.56&#x2F;24，其中192.168.1.56是客户端的IP地址，而24则是子网掩码。</font></p>
<h2 id="组合示例"><a href="#组合示例" class="headerlink" title="组合示例"></a><font style="color:rgb(25, 27, 31);">组合示例</font></h2><p><font style="color:rgb(25, 27, 31);">相同的Predicate也可以配置多个，请求的转发是必须满足所有的Predicate后才可以进行路由转发，组合使用示例如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Query=author, hengboy</span><br><span class="line">- Query=leo</span><br><span class="line">- Method=GET</span><br><span class="line">- Cookie=hengboy, leo</span><br><span class="line">- Header=X-Request-Id, \d+</span><br><span class="line">- RemoteAddr=192.168.1.56/24</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font style="color:rgb(25, 27, 31);">总结</font></h2><p><font style="color:rgb(25, 27, 31);">本章节讲解了Spring Cloud Gateway的相关谓词、断言基本使用方式，GateWay内部提供了很多种灵活的路由转发规则，在同一个路由内存在多个Predicate时，同时满足规则后请求才会被路由转发。</font></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot项目中引用SpringCloudGateway</title>
    <url>/2024/03/26/springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E7%94%A8SpringCloudGateway/</url>
    <content><![CDATA[<h1 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h1><p>首先我们打开官网可以看到如下的描述：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1672730319068-d939400c-0dc9-466e-ae30-1cff4d5c6783.png"></p>
<span id="more"></span>
<p>SpringCloudGateway旨在提供一种简单而有效的方式来路由到API，并为它们提供跨领域的关注点，例如：安全性、监控&#x2F;度量和弹性。</p>
<!-- more -->
<h1 id="为什么要使用网关"><a href="#为什么要使用网关" class="headerlink" title="为什么要使用网关"></a>为什么要使用网关</h1><p>当我们有多个服务的时候，前端需要访问服务的时候需要在前端维护好这几个服务的路径信息，<font style="color:rgb(0, 0, 0);">这样的架构会有如下几个典型的问题：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">每个微服务都需要配置单独的访问域名，开通外网访问权限，每新增一个服务都需要先让运维人员配置好域名映射</font></li>
<li><font style="color:rgb(1, 1, 1);">客户端需要维护所有微服务的访问地址，试想一下如果微服务有几十几百个呢？</font></li>
<li><font style="color:rgb(1, 1, 1);">当服务需要对接口进行权限控制，必须要认证用户才能调用，那么所有的权限逻辑在服务端都要重新编写一套。</font></li>
</ul>
<p><font style="color:rgb(0, 0, 0);">所以我们需要在微服务之前加一个网关服务，让所有的客户端只要访问网关，网关负责对请求进行转发；将权限校验逻辑放到网关的过滤器中，后端服务不需要再关注权限校验的代码；只需要对外提供一个可供外网访问的域名地址，新增服务后也不需要再让运维人员进行网络配置了，这样上面的架构就变成了通过网关转达到对应的服务</font></p>
<h1 id="如何在springboot项目中引用网关"><a href="#如何在springboot项目中引用网关" class="headerlink" title="如何在springboot项目中引用网关"></a>如何在springboot项目中引用网关</h1><h3 id="增加pom"><a href="#增加pom" class="headerlink" title="增加pom"></a>增加pom</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1672731071359-61f824de-4903-44e6-aba3-515a3f594da3.png"></p>
<p>我们从官网可以看到gateway需要的pom项，因为我们的服务都使用nacos所以需要加上nacos的pom项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--nacos--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(85, 86, 102);">由于springcloud2020弃用了</font><a href="https://so.csdn.net/so/search?q=Ribbon&spm=1001.2101.3001.7020">Ribbon</a><font style="color:rgb(85, 86, 102);">，因此Alibaba在2021版本nacos中删除了Ribbon的jar包，因此无法通过lb路由到指定微服务，出现了503情况。</font></p>
<p><font style="color:rgb(85, 86, 102);">所以只需要引入springcloud loadbalancer包即可</font></p>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LuckGatewayApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(LuckGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bootstap-yml"><a href="#bootstap-yml" class="headerlink" title="bootstap.yml"></a>bootstap.yml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1060</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: luck-gateway</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在nacos中建立网关的路由配置"><a href="#在nacos中建立网关的路由配置" class="headerlink" title="在nacos中建立网关的路由配置"></a><font style="color:rgb(1, 1, 1);">在nacos中建立网关的路由配置</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          lowerCaseServiceId: true</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: luck-uid</span><br><span class="line">        uri: lb://luck-uid</span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/uid/**</span><br><span class="line">        filters:</span><br><span class="line">          - StripPrefix=1</span><br></pre></td></tr></table></figure>



<h3 id="配置详解："><a href="#配置详解：" class="headerlink" title="配置详解："></a><font style="color:rgb(0, 0, 0);">配置详解：</font></h3><p><font style="color:rgb(119, 119, 119);">id: 在所有路由定义中需要唯一，不能重复</font><br><font style="color:rgb(119, 119, 119);">uri: lb:&#x2F;&#x2F;**  lb:&#x2F;&#x2F;为固定写法，表示开启负载均衡； ** 即服务在Nacos中注册的名字</font><br><font style="color:rgb(119, 119, 119);">predicates:- Path&#x3D;&#x2F;</font>uid<font style="color:rgb(119, 119, 119);">&#x2F;** 使用”Path Route Predicate Factory”，规则为&#x2F;</font>uid<font style="color:rgb(119, 119, 119);">&#x2F;** 的请求都还转发至微服务</font>luck-uid<font style="color:rgb(119, 119, 119);">中。</font></p>
<p>filters : - StripPrefix &#x3D;1 <strong><font style="color:rgb(77, 77, 77);">若有StripPrefix过滤器时，gateway会根据StripPrefix&#x3D;1所配的值（这里是1）去掉URL路径中的部分前缀</font></strong><font style="color:rgb(77, 77, 77);">（这里去掉一个前缀，即去掉lbs）</font></p>
<p><font style="color:rgb(0, 0, 0);"></font></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud项目使用nacos</title>
    <url>/2024/03/28/%E4%BD%8E%E4%BE%B5%E5%85%A5%E7%9A%84%E7%81%B0%E5%BA%A6%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="设计简介："><a href="#设计简介：" class="headerlink" title="设计简介："></a>设计简介：</h3><p>灰度平台配置的主键是以域名来做主键配置，以域名来关联规则，依托这些规则来判断哪些哪些请求需要走灰度</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/jpeg/25873401/1701237832373-b55015c3-0ea5-468c-bb8f-f849cbc5daba.jpeg" alt="画板"></p>
<span id="more"></span>
<h3 id="为什么要做这个平台"><a href="#为什么要做这个平台" class="headerlink" title="为什么要做这个平台"></a>为什么要做这个平台</h3><p>系统的稳定性，多有2方面造成</p>
<p>1.生产环境运行期间，异常造成的服务宕机，造成的系统不可用。</p>
<p>2.在更新服务时因为准备不足或者遗漏造成的更新时服务不可用。</p>
<p>在第一点上我们可以做好监控和告警，使用容器编排工具自动重启，服务集群来避免。</p>
<p>但是第二点人员干涉较多，很容易出现纰漏，所以构建一个灰度的平台，在系统上线后逐步的将系统开放出去，尽早的发现纰漏减少因为更新系统造成的宕机损失</p>
<h3 id="平台功能与使用场景"><a href="#平台功能与使用场景" class="headerlink" title="平台功能与使用场景"></a>平台功能<font style="color:rgb(47, 48, 52);">与使用场景</font></h3><p>平台包含规则域名管理、规则管理、比例管理。平台与openresty通过redis联动，规则的筛选通过lua脚本来执行。</p>
<p>域名管理：域名的增加、修改、删除、以及全量灰度修改、全量下线</p>
<p>规则灰度：主要配置请求类型，然后根据不同的请求类型获取对应的参数，通过规则类型（大于等于小于包含不等于等符号）来判断请求是否属于灰度</p>
<p>比例灰度：设置请求有多少数据进入灰度，这里需要注意：比例只能从小到大，最低到1%，最高到100%（第一次设置10%那后续只能从10%往上加）</p>
<p>使用场景：</p>
<p>服务A，B更新，创建服务A，B的灰度服务并在nacos的元空间中增加灰度版本，然后增加域名——规则灰度——ip灰度——白名单——公司IP地址；公司网络访问服务测试灰度内容，无异常后，再根据自己的需要配置参数规则匹配或者比例灰度来进行小部分的发布，当然如果对服务很有信息也可以直接更新到线上</p>
<h3 id="为了实现灰度都做了什么"><a href="#为了实现灰度都做了什么" class="headerlink" title="为了实现灰度都做了什么"></a>为了实现灰度都做了什么</h3><p><font style="color:rgb(47, 48, 52);"></font></p>
]]></content>
      <categories>
        <category>灰度平台</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>灰度</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud项目使用nacos</title>
    <url>/2024/03/27/springcloud%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8nacos/</url>
    <content><![CDATA[<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><h2 id="Nacos-融合-Spring-Cloud："><a href="#Nacos-融合-Spring-Cloud：" class="headerlink" title="Nacos 融合 Spring Cloud："></a><font style="color:rgb(36, 41, 46);">Nacos 融合 Spring Cloud：</font></h2><p><a href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html">https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html</a></p>
<span id="more"></span>
<h2 id="Java-SDK："><a href="#Java-SDK：" class="headerlink" title="Java SDK："></a><font style="color:rgb(36, 41, 46);">Java SDK：</font></h2><p><a href="https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html">https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html</a></p>
<h1 id="POM文件引用："><a href="#POM文件引用：" class="headerlink" title="POM文件引用："></a>POM文件引用：</h1><h2 id="父pom"><a href="#父pom" class="headerlink" title="父pom"></a>父pom</h2><p>springcloud，springboot，springcloudalibaba，nacos版本引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">      &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">      &lt;spring-boot.version&gt;2.6.13&lt;/spring-boot.version&gt;</span><br><span class="line">      &lt;spring-cloud.version&gt;2021.0.5&lt;/spring-cloud.version&gt;</span><br><span class="line">      &lt;spring-cloud-alibaba.version&gt;2021.0.4.0&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">      &lt;alibaba.nacos.version&gt;2.1.1&lt;/alibaba.nacos.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;!--统一版本--&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.luck.sugar&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;luck-bom&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- SpringBoot 依赖配置 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- SpringCloud 微服务 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- Alibaba Nacos 配置 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;alibaba.nacos.version&#125;&lt;/version&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- Mybatis 依赖配置 --&gt;</span><br><span class="line"></span><br><span class="line">           &lt;!-- SpringCloud Alibaba 微服务 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">       &lt;/dependencies&gt;</span><br><span class="line">   &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>因为我们使用了注册中心所以配置不能再使用application.yaml，需要优先级更高的bootstrap文件来找到nacos的配置文件，在springboot2.2以后bootstrap默认是关闭的需要打开才能默认使用bootstrap文件为配置文件，需要在pom文件中添加模块引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- bootstrap 启动器 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="子pom"><a href="#子pom" class="headerlink" title="子pom"></a>子pom</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;!--  spring web --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- spring test --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--nacos--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h1 id="配置文件修改："><a href="#配置文件修改：" class="headerlink" title="配置文件修改："></a>配置文件修改：</h1><p>上节解释了配置文件变化，以下是bootstrap.yml的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1066</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: luck-uid</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 49.235.122.65:8848</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 49.235.122.65:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="启动类注解添加："><a href="#启动类注解添加：" class="headerlink" title="启动类注解添加："></a>启动类注解添加：</h1><p><font style="color:#bbb529;">@EnableDiscoveryClient</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LuckUidApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(LuckUidApplication.class, args);</span><br><span class="line">        System.out.println(&quot;(♥◠‿◠)ﾉﾞ  ID服务启动成功   ლ(´ڡ`ლ)ﾞ  \n&quot; +</span><br><span class="line">                &quot; .-------.       .-------.          \n&quot; +</span><br><span class="line">                &quot; | i--------------------i |         \n&quot; +</span><br><span class="line">                &quot; | |                    | |         \n&quot; +</span><br><span class="line">                &quot; \\|   O       O        |/          \n&quot; +</span><br><span class="line">                &quot;   |      /\\           |           \n&quot; +</span><br><span class="line">                &quot;   |     /  \\          |           \n&quot; +</span><br><span class="line">                &quot;   |    \\__/           |           \n&quot; +</span><br><span class="line">                &quot;   |      __-- .        |           \n&quot; +</span><br><span class="line">                &quot;           `-..-&#x27;              &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1670814234495-463d58c8-b5df-4c44-9129-728a4b419988.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1670814281972-0e0c6a3b-0840-43c4-aafc-63de05ef2b20.png"></p>
<h1 id="异常备注："><a href="#异常备注：" class="headerlink" title="异常备注："></a>异常备注：</h1><h3 id="bootstrap-yml未生效：链接地址为-127-0-0-1"><a href="#bootstrap-yml未生效：链接地址为-127-0-0-1" class="headerlink" title="bootstrap.yml未生效：链接地址为 127.0.0.1"></a>bootstrap.yml未生效：链接地址为 127.0.0.1</h3><p>pom未添加spring-cloud-starter-bootstrap，</p>
<p>配置文件格式异常</p>
<h3 id="项目启动完成后没有注册到nacos中："><a href="#项目启动完成后没有注册到nacos中：" class="headerlink" title="项目启动完成后没有注册到nacos中："></a>项目启动完成后没有注册到nacos中：</h3><p>子pom中未引用：spring-cloud-starter-alibaba-nacos-discovery</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>Spring</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID总结</title>
    <url>/2024/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    <content><![CDATA[<h2 id="分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式-ID，那么我们如何设计它呢？本文将详细讲述分布式-ID-及其生成方案。"><a href="#分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式-ID，那么我们如何设计它呢？本文将详细讲述分布式-ID-及其生成方案。" class="headerlink" title="分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式 ID，那么我们如何设计它呢？本文将详细讲述分布式 ID 及其生成方案。"></a>分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式 ID，那么我们如何设计它呢？本文将详细讲述分布式 ID 及其生成方案。</h2><h1 id="为什么需要分布式-ID"><a href="#为什么需要分布式-ID" class="headerlink" title="为什么需要分布式 ID"></a>为什么需要分布式 ID</h1><p>目前大部分的系统都已是分布式系统，所以在这种场景的业务开发中，经常会需要唯一 ID 对数据进行标识，比如用户身份标识、消息标识等等。</p>
<span id="more"></span>


<p>并且在数据量达到一定规模后，大部分的系统也需要进行分库分表，这种场景下单库的自增 ID 已达不到我们的预期。所以我们需要分布式 ID 来对各种场景的数据进行唯一标识。</p>
<h1 id="分布式-ID-的特性"><a href="#分布式-ID-的特性" class="headerlink" title="分布式 ID 的特性"></a>分布式 ID 的特性</h1><p><strong>主要特性：</strong></p>
<ul>
<li>全局唯一：分布式 ID 最基本要求，必须全局唯一。</li>
<li>高可用：高并发下要保证 ID 的生成效率，避免影响系统。</li>
<li>易用性：使用简单，可快速接入。</li>
</ul>
<p><strong>除此之外根据不同场景还有：</strong></p>
<ul>
<li>有序性：数据库场景下的主键 ID，有序性可便于数据写入和排序。</li>
<li>安全性：无规则 ID，一般用于避免业务信息泄露场景，如订单量。</li>
</ul>
<h1 id="分布式-ID-常见生成方案"><a href="#分布式-ID-常见生成方案" class="headerlink" title="分布式 ID 常见生成方案"></a>分布式 ID 常见生成方案</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718614981558-bee358fe-b5f6-4890-b69e-9eb60310084d.jpeg" alt="画板"></p>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p><strong>UUID</strong>（Universally Unique Identifier），即通用唯一识别码。UUID 的目的是让分布式系统中的所有元素都能有唯一的识别信息。</p>
<p>UUID 是由128位二进制数组成，通常表示为32个十六进制字符，形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>



<p>这个字符串由五个部分组成，以连字符<code>-</code>分隔开，具体如下：</p>
<table>
<thead>
<tr>
<th align="center">部分</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">时间戳</td>
<td align="center">32 bits</td>
<td>UUID的前32位表示当前的时间戳。</td>
</tr>
<tr>
<td align="center">时钟序列和随机数</td>
<td align="center">16 bits</td>
<td>用于保证在同一时刻生成的UUID的唯一性。</td>
</tr>
<tr>
<td align="center">变体标识</td>
<td align="center">4 bits</td>
<td>标识 UUID 的变体，通常为固定值，表示是由 RFC 4122 定义。</td>
</tr>
<tr>
<td align="center">版本号</td>
<td align="center">4 bits</td>
<td>标识UUID的版本，常见版本有1、3、4和5</td>
</tr>
<tr>
<td align="center">节点</td>
<td align="center">48 bits</td>
<td>在版本 1 中，这部分包含生成 UUID 的计算机的唯一标识。</td>
</tr>
</tbody></table>
<p><strong>主要的 UUID 版本及其生成规则：</strong></p>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">场景</th>
<th>生成规则</th>
</tr>
</thead>
<tbody><tr>
<td align="center">版本 1</td>
<td align="center">基于时间和节点</td>
<td>由当前的时间戳和节点信息生成。包括时间戳、时钟序列、节点标识。</td>
</tr>
<tr>
<td align="center">版本 2</td>
<td align="center">基于DCE安全标识符</td>
<td>类似版本 1，但在时间戳部分包含 POSIX UID&#x2F;GID 信息。</td>
</tr>
<tr>
<td align="center">版本 3</td>
<td align="center">基于名字和散列值（MD5 版）</td>
<td>由命名空间和名字的MD5散列生成。</td>
</tr>
<tr>
<td align="center">版本 4</td>
<td align="center">完全随机生成</td>
<td>通过随机或伪随机生成128位数字。</td>
</tr>
<tr>
<td align="center">版本 5</td>
<td align="center">基于名字和散列值（SHA-1 版）</td>
<td>通过随机或伪随机生成128位数字。</td>
</tr>
</tbody></table>
<p><strong>Java中 UUID 对版本 4 进行了实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认版本 4</span></span><br><span class="line">    System.out.println(UUID.randomUUID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本 3，由命名空间和名字的MD5散列生成，相同命名空间结果相同</span></span><br><span class="line">    <span class="comment">// 如下，&quot;fuxing&quot;返回的UUID一直为8b9b6bc3-90c8-37ef-bbef-0ed0c552718f</span></span><br><span class="line">    System.out.println(UUID.nameUUIDFromBytes(<span class="string">&quot;fuxing&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong>本地生成，没有网络消耗，性能非常高。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>占用空间大，32 个字符串，128 位。</li>
<li>不安全：版本 1 可能会造成 mac 地址泄露。</li>
<li>无序，非自增。</li>
<li>机器时间不对，可能造成 UUID 重复。</li>
</ul>
<h2 id="数据库自增-ID"><a href="#数据库自增-ID" class="headerlink" title="数据库自增 ID"></a>数据库自增 ID</h2><p>实现简单，解释通过数据库表中的主键 ID 自增来生成唯一标识。如下，维护一个 MySQL 表来生成 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `unique_id` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `value` char(10) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当需要生成分布式 ID 时，向表中插入数据并返回主键 ID，这里 value 无含义，只是为了占位，方便插入数据。</p>
<p><strong>优点：</strong>实现简单，基本满足业务需求，且天然有序。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>那么有没有办法解决数据库自增 ID 的缺点呢？</p>
<p>通过水平拆分的方案，将表设置到不同的数据库中，设置不同的起始值和步长，这样可以有效的生成集群中的唯一 ID，也大大降低 ID 生成数据库操作的负载，示例如下。</p>
<p><code>&lt;font style=&quot;color:rgb(62, 62, 62);&quot;&gt;unique_id_1&lt;/font&gt;</code><font style="color:rgb(62, 62, 62);">配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>

<p><code>&lt;font style=&quot;color:rgb(62, 62, 62);&quot;&gt;unique_id_2&lt;/font&gt;</code><font style="color:rgb(62, 62, 62);">配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>



<p>这个还是需要根据自己的业务需求来，水平扩展的集群数量要符合自己的数据量，因为当设置的集群数量不足以满足高并发时，再次进行扩容集群会很麻烦。多台机器的起始值和步长都需要重新配置。</p>
<h2 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h2><p>号段模式是当下分布式 ID 生成器的主流实现方式之一，比如美团 Leaf-segment、滴滴 Tinyid、微信序列号等都使用的该方案，下面的大厂中间件中会展开说明。</p>
<p>号段模式也是基于数据库的自增 ID，数据库自增 ID 是一次性获取一个分布式 ID，**<font style="color:#5C8D07;">号段模式可以理解成从数据库批量获取 ID，然后将 ID 缓存在本地</font>**，以此来提高业务获取 ID 的效率。</p>
<p>例如，每次从数据库获取 ID 时，获取一个号段，如(1,1000]，这个范围表示 1000 个 ID，业务应用在请求获取 ID 时，只需要在本地从 1 开始自增并返回，而不用每次去请求数据库，一直到本地自增到 1000 时，才去数据库重新获取新的号段，后续流程循环往复。</p>
<p>表结构可进行如下设计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `id_generator` (</span><br><span class="line">  `id` int(10) NOT NULL,</span><br><span class="line">  `max_id` bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  `step` int(10) NOT NULL COMMENT &#x27;号段的步长&#x27;,</span><br><span class="line">  `version` int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  `biz_type` int(20) NOT NULL COMMENT &#x27;业务场景&#x27;,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>



<p>其中<code>max_id</code>和<code>step</code>用于获取批量的 ID，<code>version</code>是一个乐观锁，保证并发时数据的正确性。</p>
<p>比如，我们新增一条表数据如下。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">max_id</th>
<th align="center">step</th>
<th align="center">version</th>
<th align="center">biz_type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">100</td>
<td align="center">1000</td>
<td align="center">0</td>
<td align="center">001</td>
</tr>
</tbody></table>
<p>然后我们可以使用该号段批量生成的 ID，当<code>max_id = 1000</code>，则执行 update 操作生成新的号段。新的号段的 SQL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE </span><br><span class="line">id_generator </span><br><span class="line">SET </span><br><span class="line">max_id = #&#123;max_id+ step&#125;, </span><br><span class="line">version = version + 1 </span><br><span class="line">WHERE </span><br><span class="line">version = #&#123;version&#125; AND biz_type = 001;</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong>ID 有序递增、存储消耗空间小。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>缺点同样可以通过集群的方式进行优化，也可以如Tinyid 采用双缓存进行优化，下面的大厂中间件中会展开说明。</p>
<h2 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h2><p>当使用数据库来生成 ID 性能不够的时候，可以尝试使用 Redis 来生成 ID。原理则是利用 Redis 的原子操作 INCR 和 INCRBY 来实现。</p>
<p><strong>命令示例：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>INCR</strong></td>
<td>让一个整形的key自增1</td>
<td>:::tips redis&gt; <font style="color:#E8323C;">SET</font> mykey “10”<br/>“OK”<br/>redis&gt; <font style="color:#E8323C;">INCR</font> mykey<br/>(integer) 11<br/>:::</td>
</tr>
<tr>
<td align="center"><strong>INCRBY</strong></td>
<td>让一个整形的key自增并指定步长</td>
<td>:::tips redis&gt; <font style="color:#E8323C;">SET</font> mykey “10”<br/>“OK”<br/>redis&gt; <font style="color:#E8323C;">INCRBY</font> mykey 5<br/>(integer) 15<br/>:::</td>
</tr>
</tbody></table>
<p><strong>优点：</strong>不依赖于数据库，使用灵活，支持高并发。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>系统须引入 Redis 数据库。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li><font style="color:rgb(25, 27, 31);">Redis 出现单点故障问题，可能会丢数据导致 ID 重复</font>。</li>
</ul>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法（Snowflake）是 twitter 公司内部分布式项目采用的 ID 生成算法。结果是一个 long 型的 ID。Snowflake 算法将 64bit 划分为多段，分开来标识机器、时间等信息，具体组成结构如下图所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718695293290-53f569fe-4b3d-4e3b-8161-804a80c69b7a.jpeg" alt="画板"></p>
<p><strong>结构说明：</strong></p>
<table>
<thead>
<tr>
<th align="center">结构</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">符号位</td>
<td align="center">1 bit</td>
<td>0 表示正数，1 表示负数。</td>
</tr>
<tr>
<td align="center">时间戳</td>
<td align="center">41 bits</td>
<td>存储的是<code>当前时间戳 - 开始时间戳</code>，最长 69 年。</td>
</tr>
<tr>
<td align="center">机器位</td>
<td align="center">10 bits</td>
<td>前 5位 datacenterId，后 5 位 workerId ，最多表示 1024 台。</td>
</tr>
<tr>
<td align="center">序列号</td>
<td align="center">12 bits</td>
<td>毫秒内的流水号，意味着每个节点在每毫秒可以产生 4096 个 ID。</td>
</tr>
</tbody></table>
<p><strong>优点：</strong></p>
<p>稳定性高，不依赖于数据库等第三方系统。</p>
<p>使用灵活方便，可以根据业务需求的特性来调整算法中的 bit 位。</p>
<p>单机上 ID 单调自增，毫秒数在高位，自增序列在低位，整体上按照时间自增排序。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，可能导致发号重复或者服务处于不可用状态。</li>
<li>ID 可能不是全局递增，虽然 ID 在单机上是递增的。</li>
<li><font style="color:rgb(25, 27, 31);">Redis 出现单点故障问题，可能会丢数据导致 ID 重复</font>。</li>
</ul>
<p>当我们选择了雪花算法可以参考<font style="color:rgb(47, 48, 52);">shardingsphere的雪花算法，以此为例来写一个starter</font></p>
<p><font style="color:rgb(47, 48, 52);">定义接口</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultIdGenerator implements IdGenerator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long nextId() &#123;</span><br><span class="line">        Comparable&lt;?&gt; key=  IDUtils.generateKey();</span><br><span class="line">        return (Long) key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义雪花算法实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.fbb.pomelo.id.utils;</span><br><span class="line"></span><br><span class="line">import com.google.common.base.Preconditions;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import lombok.experimental.UtilityClass;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.net.NetworkInterface;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@UtilityClass</span><br><span class="line">public final class IDUtils &#123;</span><br><span class="line">    public static final long EPOCH;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_BITS = 12L;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_BITS = 10L;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_MASK = (1 &lt;&lt; SEQUENCE_BITS) - 1;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_LEFT_SHIFT_BITS = SEQUENCE_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long TIMESTAMP_LEFT_SHIFT_BITS = WORKER_ID_LEFT_SHIFT_BITS + WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_MAX_VALUE = 1L &lt;&lt; WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID = 0;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_VIBRATION_VALUE = 1;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS = 10;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    private static TimeService timeService = new TimeService();</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    private Properties properties = new Properties();</span><br><span class="line"></span><br><span class="line">    private int sequenceOffset = -1;</span><br><span class="line"></span><br><span class="line">    private long sequence;</span><br><span class="line"></span><br><span class="line">    private long lastMilliseconds;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(2016, Calendar.NOVEMBER, 1);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, 0);</span><br><span class="line">        calendar.set(Calendar.MINUTE, 0);</span><br><span class="line">        calendar.set(Calendar.SECOND, 0);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, 0);</span><br><span class="line">        EPOCH = calendar.getTimeInMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized Comparable&lt;?&gt; generateKey() &#123;</span><br><span class="line">        long currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">        if (waitTolerateTimeDifferenceIfNeed(currentMilliseconds)) &#123;</span><br><span class="line">            currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        if (lastMilliseconds == currentMilliseconds) &#123;</span><br><span class="line">            if (0L == (sequence = (sequence + 1) &amp; SEQUENCE_MASK)) &#123;</span><br><span class="line">                currentMilliseconds = waitUntilNextTime(currentMilliseconds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            vibrateSequenceOffset();</span><br><span class="line">            sequence = sequenceOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        lastMilliseconds = currentMilliseconds;</span><br><span class="line">        return ((currentMilliseconds - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (getWorkerId() &lt;&lt; WORKER_ID_LEFT_SHIFT_BITS) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    private boolean waitTolerateTimeDifferenceIfNeed(final long currentMilliseconds) &#123;</span><br><span class="line">        if (lastMilliseconds &lt;= currentMilliseconds) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeDifferenceMilliseconds = lastMilliseconds - currentMilliseconds;</span><br><span class="line">        Preconditions.checkState(timeDifferenceMilliseconds &lt; getMaxTolerateTimeDifferenceMilliseconds(),</span><br><span class="line">                &quot;Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds&quot;, lastMilliseconds, currentMilliseconds);</span><br><span class="line">        Thread.sleep(timeDifferenceMilliseconds);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getWorkerId() &#123;</span><br><span class="line">        long result = Long.valueOf(properties.getProperty(&quot;worker.id&quot;, String.valueOf(WORKER_ID)));</span><br><span class="line">        if (result &lt;= 0L)&#123;</span><br><span class="line">            result = generateWorkerId();</span><br><span class="line">        &#125;</span><br><span class="line">        Preconditions.checkArgument(result &gt;= 0L &amp;&amp; result &lt; WORKER_ID_MAX_VALUE);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxVibrationOffset() &#123;</span><br><span class="line">        int result = Integer.parseInt(properties.getProperty(&quot;max.vibration.offset&quot;, String.valueOf(DEFAULT_VIBRATION_VALUE)));</span><br><span class="line">        Preconditions.checkArgument(result &gt;= 0 &amp;&amp; result &lt;= SEQUENCE_MASK, &quot;Illegal max vibration offset&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxTolerateTimeDifferenceMilliseconds() &#123;</span><br><span class="line">        return Integer.valueOf(properties.getProperty(&quot;max.tolerate.time.difference.milliseconds&quot;, String.valueOf(MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long waitUntilNextTime(final long lastTime) &#123;</span><br><span class="line">        long result = timeService.getCurrentMillis();</span><br><span class="line">        while (result &lt;= lastTime) &#123;</span><br><span class="line">            result = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void vibrateSequenceOffset() &#123;</span><br><span class="line">        sequenceOffset = sequenceOffset &gt;= getMaxVibrationOffset() ? 0 : sequenceOffset + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long generateWorkerId() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return generateWorkerIdBaseOnMac();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return generateRandomWorkerId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * randomly generate one as workerId</span><br><span class="line">     * @return workerId</span><br><span class="line">     */</span><br><span class="line">    private long generateRandomWorkerId() &#123;</span><br><span class="line">        return new Random().nextInt((int)WORKER_ID_MAX_VALUE + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * use lowest 10 bit of available MAC as workerId</span><br><span class="line">     * @return workerId</span><br><span class="line">     * @throws Exception when there is no available mac found</span><br><span class="line">     */</span><br><span class="line">    private long generateWorkerIdBaseOnMac() throws Exception &#123;</span><br><span class="line">        Enumeration&lt;NetworkInterface&gt; all = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        while (all.hasMoreElements()) &#123;</span><br><span class="line">            NetworkInterface networkInterface = all.nextElement();</span><br><span class="line">            boolean loopBack = networkInterface.isLoopback();</span><br><span class="line">            boolean isVirtual = networkInterface.isVirtual();</span><br><span class="line">            if (loopBack || isVirtual) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] mac = networkInterface.getHardwareAddress();</span><br><span class="line">            return ((mac[4] &amp; 0B11) &lt;&lt; 8) | (mac[5] &amp; 0xFF);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(&quot;no available mac found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取随机ID</span><br><span class="line">     * @return 随机ID用以替代传统的UUID</span><br><span class="line">     */</span><br><span class="line">    public String get32UUID() &#123;</span><br><span class="line">        ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">        return (new UUID(random.nextLong(), random.nextLong())).toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TimeService &#123;</span><br><span class="line">    public long getCurrentMillis() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class IdAutoConfiguration &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 注入ID生成器实现</span><br><span class="line">     * @return see &#123;@link DefaultIdGenerator&#125;</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public IdGenerator idGenerator() &#123;</span><br><span class="line">        return new DefaultIdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>META-INF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">     com.fbb.pomelo.id.configuration.IdAutoConfiguration</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="大厂中间件"><a href="#大厂中间件" class="headerlink" title="大厂中间件"></a>大厂中间件</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718614818789-89d8afe6-37ff-4335-a746-1aea25018e23.jpeg" alt="画板"></p>
<h2 id="美团-Leaf"><a href="#美团-Leaf" class="headerlink" title="美团 Leaf"></a><font style="color:rgb(88, 90, 90);">美团 Leaf</font></h2><p><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html">Leaf 的官方文档</a>，简介和特性可访问了解，这里我将对 Leaf 的两种方案，Leaf segment 和 Leaf-snowflake 进行。</p>
<h3 id="Leaf-segment"><a href="#Leaf-segment" class="headerlink" title="Leaf segment"></a>Leaf segment</h3><p>基于数据库号段模式的 ID 生成方案，上面我们介绍到普通的号段模式有一些缺点：</p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>那么 Leaf 是如何做的呢？Leaf 采用了预分发的方式生成ID，也就是在 DB 之上挂 n 个 Leaf Server，每个Server启动时，都会去 DB 拿固定长度的 ID List。</p>
<p>这样就做到了完全基于分布式的架构，同时因为ID是由内存分发，所以也可以做到很高效，处理流程图如下：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718698426441-afdf835d-f486-4d25-b783-42521191ff2b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Leaf"></p>
<p><strong>其中：</strong></p>
<ul>
<li>Leaf Server 1：从 DB 加载号段[1，1000]。</li>
<li>Leaf Server 2：从 DB 加载号段[1001，2000]。</li>
<li>Leaf Server 3：从 DB 加载号段[2001，3000]。</li>
</ul>
<p>用户**<font style="color:#5C8D07;">通过轮询的方式</font>**调用 Leaf Server 的各个服务，所以某一个 Client 获取到的ID序列可能是：1，1001，2001，2，1002，2002。当某个 Leaf Server 号段用完之后，下一次请求就会从 DB 中加载新的号段，这样保证了每次加载的号段是递增的。</p>
<p>为了解决在更新DB号段的时出现的耗时和阻塞服务的问题，Leaf 采用了**<font style="color:#5C8D07;">异步更新</font>**的策略，同时通过双缓存的方式，保证无论何时DB出现问题，都能有一个 Buffer 的号段可以正常对外提供服务，只要 DB 在一个 Buffer 的下发的周期内恢复，就不会影响整个 Leaf 的可用性。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718698969771-dbe0fd2a-5501-44d0-8db1-2c250de2b7d9.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Leaf"></p>
<p>除此之外，Leaf 还**<font style="color:#5C8D07;">通过动态调整步长</font>**，解决由于步长固定导致的缓存中的 ID 被过快消耗问题，以及步长设置过大导致的号段 ID 跨度过大问题，具体公式可去官方文档中了解。</p>
<p>对于数据一致性问题，Leaf 目前是通过中间件 Zebra 加 MHA 做的主从切换。</p>
<h3 id="Leaf-Snowflake"><a href="#Leaf-Snowflake" class="headerlink" title="Leaf Snowflake"></a>Leaf Snowflake</h3><p>Leaf-snowflake 方案沿用 Snowflake 方案的 bit 位设计。</p>
<p>对于 workerID 的分配：当服务集群较小时，通过配置即可；服务集群较大时，基于 zookeeper 持久顺序节点的特性引入 zookeeper 组件配置 workerID。架构如下图所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/3003575/1718699670231-b390838f-2dd5-4e13-a52d-f446cb8fd6dc.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10"></p>
<h2 id="百度-UidGenerator"><a href="#百度-UidGenerator" class="headerlink" title="百度 UidGenerator"></a>百度 UidGenerator</h2><p><a href="https://github.com/baidu/uid-generator">开源地址</a></p>
<p>UidGenerator 方案是基于 Snowflake 算法的 ID 生成器，其对雪花算法的 bit 位的分配做了微调。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718700335302-7c7d4146-8057-464e-af50-6e39a5c6d527.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_25,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10"></p>
<hr>
<p><strong>结构说明（参数可在 Spring Bean 配置中进行配置）：</strong></p>
<table>
<thead>
<tr>
<th>结构</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>符号位</td>
<td align="center">1 bit</td>
<td><font style="color:rgb(37, 43, 58);">最高位始终是 0。</font></td>
</tr>
<tr>
<td>增量秒</td>
<td align="center"><font style="color:rgb(37, 43, 58);">28</font> bits</td>
<td>表示自客户纪元（2016-05-20）以来的增量秒。最大时间为 8.7 年。</td>
</tr>
<tr>
<td>工作节点</td>
<td align="center">22 bits</td>
<td>表示工作节点 ID，最大值为 4.2 百万个。</td>
</tr>
<tr>
<td>序列号</td>
<td align="center">13 bits</td>
<td>表示一秒钟内的序列，默认情况下每秒最多 8192 个。</td>
</tr>
</tbody></table>
<p>UidGenerator 方案包含两种实现方式，DefaultUidGenerator 和 CachedUidGenerator ，性能要求高的情况下推荐 CachedUidGenerator。</p>
<h2 id="滴滴-Tinyid"><a href="#滴滴-Tinyid" class="headerlink" title="滴滴 Tinyid"></a>滴滴 Tinyid</h2><p><a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">Tinyid 官方文档</a></p>
<p>Tinyid 方案是在 Leaf-segment 的算法基础上升级而来，不仅支持了数据库多主节点模式，还提供了 tinyid-client 客户端的接入方式，使用起来更加方便。</p>
<p>Tinyid 也是采用了异步加双缓存策略，首先可用号段加载到内存中，并在内存中生成 ID，可用号段在首次获取 ID 时加载，号段用到一定程度的时候，就去异步加载下一个号段，保证内存中始终有可用号段，则可避免性能波动。</p>
<p><strong>实现原理如下所示：</strong></p>
<p><img src="https://github.com/didi/tinyid/raw/master/doc/tinyid_final.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_29,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Tinyid"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文对分布式 ID 以及其场景的生成方案做了介绍，还针对一下大厂的中间件进行简单分析，中间件的接入代码本文并没有做详细介绍，但是官方文档的链接都帖子了每个子标题下，其中都有详细介绍。</p>
<p>文中还针对每个生成方案的优缺点作出了说明，具体的使用可针对优缺点加上业务需求来进行选型。</p>
<hr>
<blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/534893180">[1] 腾讯技术工程. 分布式唯一 ID 生成方案浅谈.</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2377401">[2] 孟斯特. UUID 介绍.</a></p>
<p><a href="https://blog.csdn.net/jiaomubai/article/details/124385324">[3] 文丑颜不良啊. 雪花算法（SnowFlake）.</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>ID</tag>
      </tags>
  </entry>
  <entry>
    <title>实现用户配置数据源引用切换</title>
    <url>/2024/10/03/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90%E5%BC%95%E7%94%A8%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="需求来源"><a href="#需求来源" class="headerlink" title="需求来源"></a>需求来源</h2><p>实现代码生成器的时候因为做了分库，所以在实现代码生成时就需要根据不同的配置去拉取不同的表结构，所以需要实现不同的库使用不同的数据源</p>
<span id="more"></span>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在mybatis中是以DataSource的形式来管理数据源的，在mybaitis-plus中预留了AbstractRoutingDataSource接口来实现数据源的切换与查找</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1726735329465-48b3cd5d-4d56-4e45-8b43-afdec1a7c275.png"></p>
<p>targetDataSources就是数据源的结合，如果我们需要增加数据源就需要在targetDataSources中增加新定义的数据源，并通知引用规则，实现如下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先我们要定义一个节点用于确定使用targetDataSources中的哪个数据源，定义DataSourceContextHolder，用于实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DataSourceContextHolder &#123;</span><br><span class="line">    </span><br><span class="line">    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public static void setDataSourceKey(String dataSourceKey) &#123;</span><br><span class="line">        contextHolder.set(dataSourceKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String getDataSourceKey() &#123;</span><br><span class="line">        return contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void clearDataSourceKey() &#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义DynamicDataSource继承与AbstractRoutingDataSource</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DynamicDataSource(DataSource defaultDataSource, Map&lt;Object, Object&gt; targetDataSources) &#123;</span><br><span class="line">    // 设置数据源集合</span><br><span class="line">    super.setTargetDataSources(targetDataSources);</span><br><span class="line">    super.setDefaultTargetDataSource(defaultDataSource);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">    return DataSourceContextHolder.getDataSourceKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里只做了两件事定义数据源，以及确认当前数据源的key</p>
<p>定义一个Configuration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(DataSourceProperties.class)</span><br><span class="line">public class PomeloDataSourceConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">    @Resource</span><br><span class="line">    private DataSourceProperties dataSourceProperties;</span><br><span class="line">    private DataSource defaultDataSource() &#123;</span><br><span class="line">        DataSource dataSource = DataSourceBuilder.create()</span><br><span class="line">                .url(dataSourceProperties.getUrl())</span><br><span class="line">                .username(dataSourceProperties.getUsername())</span><br><span class="line">                .password(dataSourceProperties.getPassword())</span><br><span class="line">                .driverClassName(dataSourceProperties.getDriverClassName())</span><br><span class="line">                .build();;</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public DynamicDataSource dynamicDataSource() &#123;</span><br><span class="line">        DynamicDataSource dynamicDataSource = new DynamicDataSource(defaultDataSource(), new HashMap&lt;&gt;());</span><br><span class="line">        return dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>如果我们需要使用多个数据源那需要我们获取到多个数据源，我们这里以数据库获取为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatasourceConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Resource</span><br><span class="line">    private GenDatabaseService genDatabaseService;</span><br><span class="line">    @Resource</span><br><span class="line">    private DynamicDataSource dynamicDataSource;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public DynamicDataSource dataSourceInit() &#123;</span><br><span class="line">        // 创建数据源</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;GenDatabase&gt; genDatabaseList = genDatabaseService.selectList();</span><br><span class="line">        for (GenDatabase genDatabase : genDatabaseList) &#123;</span><br><span class="line">            targetDataSources.put(genDatabase.getDatabaseId().toString(), DataSourceBuilder.create()</span><br><span class="line">                    .driverClassName(genDatabase.getDatabaseDriver())</span><br><span class="line">                    .url(genDatabase.getDatabaseUrl())</span><br><span class="line">                    .password(genDatabase.getDatabasePwd())</span><br><span class="line">                    .username(genDatabase.getDatabaseName()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        dynamicDataSource.setTargetDataSources(targetDataSources);</span><br><span class="line">        dynamicDataSource.afterPropertiesSet();</span><br><span class="line">        return dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时如果需要再不同的地方调用数据源可以根据 DataSourceContextHolder.setDataSourceKey来确认使用哪个数据源，如果有需要也可以以aop形式完成，这里不多赘述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DataSourceContextHolder.setDataSourceKey(tableQuery.getDatabaseId());</span><br><span class="line">DataSourceContextHolder.clearDataSourceKey();</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>权限模型RBAC模型</title>
    <url>/2024/10/03/%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8BRBAC%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="什么是RBAC模型"><a href="#什么是RBAC模型" class="headerlink" title="什么是RBAC模型"></a>什么是RBAC模型</h3><p>权限是需要给对应的用户的，当用户太多的时候如果一个一个用户的设定权限就会显得很复杂，这时候我们可以引入角色，<font style="color:rgb(74, 74, 74);">每个角色可以拥有多个权限，每个用户可以分配多个角色，这样用户就拥有了多个角色的多个权限</font></p>
<span id="more"></span>
<h3 id="为什么要用RBAC模型"><a href="#为什么要用RBAC模型" class="headerlink" title="为什么要用RBAC模型"></a>为什么要用RBAC模型</h3><p><font style="color:rgb(74, 74, 74);">因为有角色作为媒介，大大降低了错综复杂的交互关系，比如一家有上万人的公司，角色可能只需要几百个就搞定了，因为很多用户需要的权限是一样的，分配一样的角色就可以了。这种模型的对应关系图如下所示：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1723708654558-0d0105e6-79d2-40f7-b9c8-3e07cb75e2c5.png"></p>
<p><font style="color:rgb(74, 74, 74);">用户和角色，角色和权限都是多对多的关系，这种模型是最通用的权限管理模型，节省了很大的权限维护成本，当然这种只是通用的模式，在实际的业务是千变万化的，比如大部分公司是分层级的，层级越高权限越大这时候可以用角色继承的RBAC模型。还有很多角色是互斥的这时候可以使用带约束的RBAC。比如同一个角色有多个用户，我们可以采用在角色的前提下增加一个用户组来简化角色分配。在pomelo中我们使用了通用的RBAC模型，这里只展示通用的模型</font></p>
<h3 id="RBAC模型数据结构"><a href="#RBAC模型数据结构" class="headerlink" title="RBAC模型数据结构"></a>RBAC模型数据结构</h3><p>菜单表（权限表）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P TABLE IF EXISTS customer_menu;</span><br><span class="line">CREATE TABLE customer_menu(</span><br><span class="line">    `menu_id` varchar(32) NOT NULL  COMMENT &#x27;菜单编号;菜单编号&#x27; ,</span><br><span class="line">    `parent_id` varchar(32) NOT NULL  COMMENT &#x27;父菜单编号;父菜单编号&#x27; ,</span><br><span class="line">    `name` varchar(255) NOT NULL  COMMENT &#x27;菜单名称;菜单名称&#x27; ,</span><br><span class="line">    `another_name` varchar(255) NOT NULL  COMMENT &#x27;别称;别称&#x27; ,</span><br><span class="line">    `path` varchar(255) NOT NULL  COMMENT &#x27;菜单URL;菜单地址（目录 菜单信息为/xxx/xxx   按钮为:delete，create等）&#x27; ,</span><br><span class="line">    `order_num` int   COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    `component` varchar(255)   COMMENT &#x27;组件路径;组件路径&#x27; ,</span><br><span class="line">    `perms` varchar(255) NOT NULL  COMMENT &#x27;授权;授权(多个用逗号分隔，如：user:list,user:create);&#x27; ,</span><br><span class="line">    `type` tinyint(4) NOT NULL  COMMENT &#x27;类型;类型   0：目录   1：菜单   2：按钮;&#x27; ,</span><br><span class="line">    `icon` varchar(255) NOT NULL  COMMENT &#x27;菜单图标;菜单图标&#x27; ,</span><br><span class="line">    `is_full` tinyint(4)   COMMENT &#x27;是否跳转;是否跳转&#x27; ,</span><br><span class="line">    `is_link` varchar(255)   COMMENT &#x27;是否外链;是否外链&#x27; ,</span><br><span class="line">    `is_hide` tinyint(4)   COMMENT &#x27;是否隐藏;是否隐藏&#x27; ,</span><br><span class="line">    `is_affix` tinyint(4)   COMMENT &#x27;是否固定;是否固定&#x27; ,</span><br><span class="line">    `is_keep_alive` tinyint(4)   COMMENT &#x27;是否长连接;是否长连接&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; ,</span><br><span class="line">    PRIMARY KEY (menu_id)</span><br><span class="line">)  COMMENT = &#x27;菜单表&#x27;;</span><br></pre></td></tr></table></figure>

<p>角色表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_role;</span><br><span class="line">CREATE TABLE customer_role(</span><br><span class="line">    `role_id` varchar(32) NOT NULL  COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    `role_name` varchar(100) NOT NULL  COMMENT &#x27;角色名称;角色名称&#x27; ,</span><br><span class="line">    `role_key` varchar(32) NOT NULL  COMMENT &#x27;角色权限字符串;角色权限字符串&#x27; ,</span><br><span class="line">    `role_sort` int   COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    `data_scope` tinyint(4)   COMMENT &#x27;数据范围（1：全部数据权限 2：自定数据权限 ）;数据范围（1：全部数据权限 2：自定数据权限 ）&#x27; ,</span><br><span class="line">    `status` tinyint(4) NOT NULL  COMMENT &#x27;角色状态（0正常 1停用）;角色状态（0正常 1停用）&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; </span><br><span class="line">)  COMMENT = &#x27;角色表&#x27;;</span><br></pre></td></tr></table></figure>

<p>用户表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_user;</span><br><span class="line">CREATE TABLE customer_user(</span><br><span class="line">    `user_id` varchar(32) NOT NULL  COMMENT &#x27;用户编号;用户编号&#x27; ,</span><br><span class="line">    `user_name` varchar(30) NOT NULL  COMMENT &#x27;用户账号;用户账号&#x27; ,</span><br><span class="line">    `nick_name` varchar(30) NOT NULL  COMMENT &#x27;用户昵称;用户昵称&#x27; ,</span><br><span class="line">    `phone_number` varchar(20)   COMMENT &#x27;用户手机号;用户手机号&#x27; ,</span><br><span class="line">    `open_id` varchar(32)   COMMENT &#x27;微信Id;微信唯一标识&#x27; ,</span><br><span class="line">    `dy_id` varchar(32)   COMMENT &#x27;抖音Id;抖音唯一标识&#x27; ,</span><br><span class="line">    `sex` tinyint(4)   COMMENT &#x27;性别;性别（0男 1女 2未知）&#x27; ,</span><br><span class="line">    `avatar` varchar(100)   COMMENT &#x27;头像地址;头像地址&#x27; ,</span><br><span class="line">    `invite_code` varchar(32)   COMMENT &#x27;邀请码;邀请码&#x27; ,</span><br><span class="line">    `password` varchar(16) NOT NULL  COMMENT &#x27;密码;密码&#x27; ,</span><br><span class="line">    `salt` varchar(32) NOT NULL  COMMENT &#x27;盐;盐&#x27; ,</span><br><span class="line">    `status` tinyint(4) NOT NULL  COMMENT &#x27;用户状态;账号状态（0未验证  1已验证 2已冻结 3已过期）&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; ,</span><br><span class="line">    PRIMARY KEY (user_id)</span><br><span class="line">)  COMMENT = &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure>

<p>用户角色表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_user_role;</span><br><span class="line">CREATE TABLE customer_user_role(</span><br><span class="line">    `ID` INT AUTO_INCREMENT COMMENT &#x27;&#x27; ,</span><br><span class="line">    `user_id` varchar(32)   COMMENT &#x27;用户ID;用户ID&#x27; ,</span><br><span class="line">    `role_id` varchar(32)   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色表&#x27;;</span><br></pre></td></tr></table></figure>

<p>角色权限表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_role_menu;</span><br><span class="line">CREATE TABLE customer_role_menu(</span><br><span class="line">    `ID` INT AUTO_INCREMENT COMMENT &#x27;&#x27; ,</span><br><span class="line">    `role_id` varchar(32)   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    `menu_id` varchar(32)   COMMENT &#x27;菜单ID;菜单ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;角色菜单管理表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>构建一个通用的数据访问模块</title>
    <url>/2024/10/01/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>当构建一个通用的数据访问模块的时候，一般需要处理分页，乐观锁、以及插入或者修改时一些公共字段默认值填充，以及慢查询处理定制化（虽然mysql自带的有这方面功能但是通知的灵活性不如自定义更实用）</p>
<span id="more"></span>
<h2 id="处理分页、乐观锁"><a href="#处理分页、乐观锁" class="headerlink" title="处理分页、乐观锁"></a>处理分页、乐观锁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    //分页</span><br><span class="line">    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">    // 乐观锁</span><br><span class="line">    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</span><br><span class="line">    return interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入或者修改设置默认字段"><a href="#插入或者修改设置默认字段" class="headerlink" title="插入或者修改设置默认字段"></a>插入或者修改设置默认字段</h2><p>首先定义基类BaseEntity，这里定义了createTime，updateTime，delFlag三个默认配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@SuperBuilder</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class BaseEntity &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建时间</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改时间</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除标志</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Integer delFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MetaObjectHandler接口是mybatisPlus为我们提供的的一个扩展接口，我们可以利用这个接口在我们插入或者更新数据的时候，为一些字段指定默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DailyMartMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;delFlag&quot;, Integer.class, DelEnum.NORMAL.code());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 2023/10/28 调整</span><br><span class="line">     * Mybatis-plus的自动更新要求待更新的字段为null，否则不更新。这就导致select 后 更新时无法自动更新 updateTime</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public MetaObjectHandler strictFillStrategy(MetaObject metaObject, String fieldName, Supplier&lt;?&gt; fieldVal) &#123;</span><br><span class="line">        Object obj = fieldVal.get();</span><br><span class="line">        if (Objects.nonNull(obj)) &#123;</span><br><span class="line">            metaObject.setValue(fieldName, obj);</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>将MetaObjectHandler注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在 插入/更新 数据时自动填充默认值</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public PomeloMetaObjectHandler myMetaObjectHandler() &#123;</span><br><span class="line">    return new PomeloMetaObjectHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="慢查询处理"><a href="#慢查询处理" class="headerlink" title="慢查询处理"></a>慢查询处理</h2><p>mysql的慢查询可以通过很多地方拦截，比如数据库本身就可以通过配置来实现拦击并打印为日志，一部分开源的数据库连接池也可以实现，比如阿里的druid。这些虽然都可以实现慢查询拦截，但是这些属于第三方，不够灵活所以我们这里可以使用<font style="color:rgb(47, 48, 52);">Mybatis提供的拦截器接口Interceptor来自己实现拦截，自己是实现时可以结合消息队列来完成阀值式处理，这些为后话，我们先来进行一个简单的实现</font></p>
<p><font style="color:rgb(47, 48, 52);">定义一个配置文件实体</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;pomelo.sql.slow&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class SlowSQLProperties &#123;</span><br><span class="line"></span><br><span class="line">    private boolean enable = false;</span><br><span class="line"></span><br><span class="line">    private long cost = 1000L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(47, 48, 52);">实现Interceptor</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;),</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;),</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class SlowSqlInterceptor implements Interceptor &#123;</span><br><span class="line">    private final SlowSQLProperties slowSQLProperties;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        StatementHandler statementHandler = (StatementHandler) target;</span><br><span class="line">        try &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            long costTime = stopWatch.getTotalTimeMillis();</span><br><span class="line"></span><br><span class="line">            if (costTime &gt;= slowSQLProperties.getCost()) &#123;</span><br><span class="line">                BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line"></span><br><span class="line">                String sql = boundSql.getSql();</span><br><span class="line"></span><br><span class="line">                // 20230901 去掉sql中的换行符</span><br><span class="line">                sql = sql.replaceAll(&quot;\\n+&quot;, &quot; &quot;);</span><br><span class="line"></span><br><span class="line">                log.warn(&quot;WARN !!!,监测到慢查询SQL:[&#123;&#125;] 执行耗时 &#123;&#125; ms &quot;, sql, costTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注入mybatis插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注入mybatis插件，可以统计SQL执行耗时</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnProperty(name = &quot;pomelo.sql.slow.enable&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><br><span class="line">public ConfigurationCustomizer mybatisConfigurationCustomizer() &#123;</span><br><span class="line">    return configuration -&gt; configuration.addInterceptor(new SlowSqlInterceptor(slowSQLProperties));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换ID生成器"><a href="#替换ID生成器" class="headerlink" title="替换ID生成器"></a>替换ID生成器</h2><p>在<a href="https://www.yuque.com/u25495771/ghfr2q/zsg53g1qtc5fxxeo">分布式ID</a>一文中我们自定义了ID，这里修改一下mybatis的id的生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IdGenerator implements IdentifierGenerator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Number nextId(Object entity) &#123;</span><br><span class="line">        return (Long)IDUtils.generateKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String nextUUID(Object entity) &#123;</span><br><span class="line">        return IDUtils.get32UUID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 替换Mybatis-plus的算法生成器</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public IdGenerator identifierGenerator() &#123;</span><br><span class="line">    return new IdGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一扫描地址"><a href="#统一扫描地址" class="headerlink" title="统一扫描地址"></a><font style="color:rgb(51, 51, 51);">统一扫描地址</font></h2><p>当我们使用mybatis时需要在<font style="color:rgb(47, 48, 52);">每个服务启动类上都需要通过@MapperScan注解指定Mapper对象的包路径地址。如果各个模块的命名规则之间遵循统一的命名规范，那么我们可以在配置主类中直接设置Mapper对象的包路径地址，这样SpringBoot启动类就不再需要依赖此注解了</font></p>
<p><font style="color:rgb(47, 48, 52);"></font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>构建统一返回以及全局异常处理</title>
    <url>/2024/10/03/%E6%9E%84%E5%BB%BA%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BB%A5%E5%8F%8A%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="统一返回格式"><a href="#统一返回格式" class="headerlink" title="统一返回格式"></a>统一返回格式</h2><h3 id="为什么需要统一返回格式"><a href="#为什么需要统一返回格式" class="headerlink" title="为什么需要统一返回格式"></a>为什么需要统一返回格式</h3><p><font style="color:rgb(47, 48, 52);">接口的返回值类型众多，有的直接返回数据传输对象（DTO），甚至直接返回数据对象（DO），还有的返回Result对象。这样对外交互时对方处理起来特别的复杂，所以需要统一的返回格式。</font></p>
<span id="more"></span>
<h3 id="构建统一返回格式"><a href="#构建统一返回格式" class="headerlink" title="构建统一返回格式"></a>构建统一返回格式</h3><h4 id="构建Result对象"><a href="#构建Result对象" class="headerlink" title="构建Result对象"></a><font style="color:rgb(51, 51, 51);">构建Result对象</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ResultHelper &#123;</span><br><span class="line">    </span><br><span class="line">    // 成功的响应结果</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(Result.SUCCESS_CODE)</span><br><span class="line">                .setData(data)</span><br><span class="line">                .setMessage(Result.SUCCESS_MESSAGE)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 失败的响应结果</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(String code, String message) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(code)</span><br><span class="line">                .setMessage(message)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 失败的响应结果，使用默认的错误码</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(String message) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(ErrorCode.SERVICE_ERROR.getCode())</span><br><span class="line">                .setMessage(message)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(ErrorCode errorCode) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(errorCode.getCode())</span><br><span class="line">                .setMessage(errorCode.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问下接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public Result&lt;String&gt; test() &#123;</span><br><span class="line">        return ResultHelper.success(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723015024331-f73efb26-3859-4649-9d2d-60d30bb50bc0.png"></p>
<h2 id="统一的模板方法"><a href="#统一的模板方法" class="headerlink" title="统一的模板方法"></a>统一的模板方法</h2><h3 id="为什么需要统一的模板方法"><a href="#为什么需要统一的模板方法" class="headerlink" title="为什么需要统一的模板方法"></a>为什么需要统一的模板方法</h3><p>按照上面的示例一切都很美好，代码也很简洁，内容也如预期做了输出，但是我们考虑一个问题，如果有上百个接口的时候，需要对接口进行一些公共代码的调整，比如讲参数和输出打印出来，对参数进行验证，统计代码执行的时间。当遇到这种需求可以使用AOP做切面编程，但是切面编程的效率并不是很好，所以可以选择使用统一的模板方法来处理这些问题。既可以实现统一的管理公共代码，又可以更规范的书写代码</p>
<h3 id="构建统一的模板方法"><a href="#构建统一的模板方法" class="headerlink" title="构建统一的模板方法"></a>构建统一的模板方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public abstract class ServerTemplate&lt;T, R&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    public R Process(T request) &#123;</span><br><span class="line">        log.info(&quot;开始执行，参数：&#123;&#125;&quot;, request);</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            // 参数校验</span><br><span class="line">            validParam(request);</span><br><span class="line">            // 执行业务代码</span><br><span class="line">            R response = doProcess(request);</span><br><span class="line">            // 记录时间信息</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            log.info(&quot;执行结束，耗时:&#123;&#125;ms&quot;, stopWatch.getTotalTimeMillis());</span><br><span class="line">            return response;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;执行异常，异常信息:&#123;&#125;&quot;, Arrays.toString(e.getStackTrace()));</span><br><span class="line">            // 抛出异常 统一处理</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected abstract void validParam(T request);</span><br><span class="line">    </span><br><span class="line">    protected abstract R doProcess(T request);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="使用统一格式创建一个接口"><a href="#使用统一格式创建一个接口" class="headerlink" title="使用统一格式创建一个接口"></a>使用统一格式创建一个接口</h2><p>改造一下之前的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">  public Result&lt;String&gt; test(@RequestBody String request) &#123;</span><br><span class="line">      return ResultHelper.success((new ServerTemplate&lt;String, String&gt;()&#123;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          protected void validParam(String request) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          protected String doProcess(String request) &#123;</span><br><span class="line">              return request;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;).process(request));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>执行代码</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723017417888-cb2a2f15-b9ec-4264-be8b-6c9331e82b5f.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723017431106-aa9e0616-a24b-4b47-9848-680c7a980206.png"></p>
<h2 id="再次优化：自动包装类"><a href="#再次优化：自动包装类" class="headerlink" title="再次优化：自动包装类"></a>再次优化：自动包装类</h2><p>每次都ResultHelper.success(）还要在参数中增加Result来维护一致性总是觉着有点太浪费时间，而且如果忘记了就会出错。所以需要再进一步优化一下，springboot的<font style="color:rgb(47, 48, 52);">ResponseBodyAdvice可以实现自动包装类</font></p>
<p>:::info<br><font style="color:rgb(154, 154, 154);">提示: ResponseBodyAdvice 可以拦截控制器(Controller)方法的返回值，允许我们统一处理返回值或响应体。这对于统一返回格式、加密、签名等场景非常有用。</font></p>
<p>:::</p>
<p>集成<font style="color:rgb(47, 48, 52);">ResponseBodyAdvice接口</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalResponseBodyAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        // boolean supports = returnType.getContainingClass().getPackage().getName().startsWith(&quot;com.jianzh5.dailymart&quot;);</span><br><span class="line">        return true;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request,</span><br><span class="line">                                  ServerHttpResponse response) &#123;</span><br><span class="line">        if (body == null) &#123;</span><br><span class="line">            return JsonUtils.obj2String(ResultHelper.success(&quot;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        if (body instanceof String) &#123;</span><br><span class="line">            // 当响应体是String类型时，使用ObjectMapper转换，因为Spring默认使用StringHttpMessageConverter处理字符串，不会将字符串识别为JSON</span><br><span class="line">            // return objectMapper.writeValueAsString(ResultFactory.success(body));</span><br><span class="line">            return JsonUtils.obj2String(ResultHelper.success(body));</span><br><span class="line">        &#125;</span><br><span class="line">        if (body instanceof Result&lt;?&gt;) &#123;</span><br><span class="line">            // 已经包装过的结果无需再次包装</span><br><span class="line">            return body;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对响应体进行包装</span><br><span class="line">        return ResultHelper.success(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再修改一下之前的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public String test(@RequestBody String request) &#123;</span><br><span class="line">        return (new ServerTemplate&lt;String, String&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected void validParam(String request) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected String doProcess(String request) &#123;</span><br><span class="line">                return request;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;).process(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723024004078-4916bbdd-5b70-49a2-b0c6-29ddd9be84cd.png"></p>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>在构建系统的可靠性时容错处理是重要的考虑方便之一，想要系统更加的健壮全局就需要添加全局异常处理，springboot其实已经做了前期的工作，@RestControllerAdvice注解+@ExceptionHandler可以解决这方面的顾虑</p>
<h3 id="自定义异常的创建和使用"><a href="#自定义异常的创建和使用" class="headerlink" title="自定义异常的创建和使用"></a>自定义异常的创建和使用</h3><p>定义自定义异常基类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public abstract class AbstractException extends RuntimeException &#123;</span><br><span class="line">    </span><br><span class="line">    @Serial</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    </span><br><span class="line">    private final String code;</span><br><span class="line">    private final String message;</span><br><span class="line">    </span><br><span class="line">    public AbstractException(ErrorCode errorCode, String message, Throwable throwable) &#123;</span><br><span class="line">        super(message, throwable);</span><br><span class="line">        this.code = errorCode.getCode();</span><br><span class="line">        this.message = Optional.ofNullable(message).orElse(errorCode.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public AbstractException(String code, String message, Throwable throwable) &#123;</span><br><span class="line">        super(message, throwable);</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义自定义异常类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BusinessException extends AbstractException &#123;</span><br><span class="line"></span><br><span class="line">    public BusinessException(ErrorCode errorCode, String message, Throwable throwable) &#123;</span><br><span class="line">        super(errorCode, message, throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(String code, String message, Throwable throwable) &#123;</span><br><span class="line">        super(code, message, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局异常的定义"><a href="#全局异常的定义" class="headerlink" title="全局异常的定义"></a>全局异常的定义</h3><p>在服务端在接收到参数，通常是不受信任的，这时我们需要对参数进行验证，因为参数验证并不是业务错误所以需要进行额外的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(value = &#123;MethodArgumentNotValidException.class, BindException.class, ValidationException.class&#125;)</span><br><span class="line">    public Result&lt;Void&gt; handleValidException(HttpServletRequest request, Exception e) &#123;</span><br><span class="line">        String exceptionStr = &quot;参数校验异常&quot;;</span><br><span class="line">        if (e instanceof MethodArgumentNotValidException ex) &#123;</span><br><span class="line">            BindingResult bindingResult = ex.getBindingResult();</span><br><span class="line">            FieldError firstFieldError = CollectionUtil.getFirst(bindingResult.getFieldErrors());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstFieldError)</span><br><span class="line">                    .map(FieldError::getDefaultMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">            </span><br><span class="line">        &#125; else if (e instanceof ConstraintViolationException) &#123;</span><br><span class="line">            ConstraintViolationException ex = (ConstraintViolationException) e;</span><br><span class="line">            </span><br><span class="line">            ConstraintViolation&lt;?&gt; firstConstraintViolation = CollectionUtil.getFirst(ex.getConstraintViolations());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstConstraintViolation)</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">            </span><br><span class="line">        &#125; else if (e instanceof BindException) &#123;</span><br><span class="line">            BindException ex = (BindException) e;</span><br><span class="line">            ObjectError firstObjectError = CollectionUtil.getFirst(ex.getAllErrors());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstObjectError)</span><br><span class="line">                    .map(ObjectError::getDefaultMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;, request.getMethod(), getUrl(request), exceptionStr);</span><br><span class="line">        return ResultHelper.failure(ErrorCode.PARAMETER_VALIDATION_FAILED.getCode(), exceptionStr);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理自定义异常</span><br><span class="line">    @ExceptionHandler(value = &#123;AbstractException.class&#125;)</span><br><span class="line">    public Result&lt;Void&gt; handleAbstractException(HttpServletRequest request, AbstractException ex) &#123;</span><br><span class="line">        String requestURL = getUrl(request);</span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;, request.getMethod(), requestURL, ex.toString());</span><br><span class="line">        return ResultHelper.failure(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 兜底处理</span><br><span class="line">    @ExceptionHandler(value = Throwable.class)</span><br><span class="line">    public Result&lt;Void&gt; handleThrowable(HttpServletRequest request, Throwable throwable) &#123;</span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; &quot;, request.getMethod(), getUrl(request), throwable);</span><br><span class="line">        return ResultHelper.failure(ErrorCode.SERVICE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取浏览地址信息</span><br><span class="line">    private String getUrl(HttpServletRequest request) &#123;</span><br><span class="line">        if (StrUtil.isEmpty(request.getQueryString())) &#123;</span><br><span class="line">            return request.getRequestURL().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return request.getRequestURL().toString() + &quot;?&quot; + request.getQueryString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试全局异常的定义"><a href="#测试全局异常的定义" class="headerlink" title="测试全局异常的定义"></a>测试全局异常的定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public String test(@RequestBody String request) &#123;</span><br><span class="line">        return (new ServerTemplate&lt;String, String&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected void validParam(String request) &#123;</span><br><span class="line">                if (request == null)&#123;</span><br><span class="line">                    throw new BusinessException(ErrorCode.CLIENT_ERROR.getCode(), &quot;请求参数不能为空&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected String doProcess(String request) &#123;</span><br><span class="line">                return request;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;).process(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723025785241-71b9b63e-878a-48ae-bf8f-ebf6754ca7b1.png"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上文中实现了统一返回格式以及统一的模板方法，以及为了简化写法的自动包装类和全局异常的处理，在日常开发中每个人的写法各异，统一的写法规定可以避免错误的代码实现以及提升代码的可读性，可以提升整个系统的可靠性，我们可以借助springboot的注解来实现这些在</p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>构建通用的Redis辅助类</title>
    <url>/2024/10/03/%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8%E7%9A%84Redis%E8%BE%85%E5%8A%A9%E7%B1%BB/</url>
    <content><![CDATA[<p>Redis中常用的功能可以分为两款，第一是缓存用于提升读性能，可以根据不同的数据类型来实现月签到统计，排行榜，消息订阅等功能。第二是用于实现分布式锁，一个成熟的辅助类可以对这两项功能进行封装，并列出常用的方法</p>
<span id="more"></span>
<h2 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h2><p>这里讲的是构建通用的辅助类，主要针对的是在开发中遇到的问题的解决方案，在实际的开发中</p>
<p>1.在集群环境中所有的数据都集中在0数据页中，key如果没有清晰的标识，容易出现互相覆盖的问题</p>
<p>2.不同的系统序列化问题</p>
<p>3.散乱的引用，后续对某个功能进行修改或者扩展太过繁杂</p>
<p>架构就是为了解决问题，根绝以上的问题，在构建辅助类的时候我们可以来</p>
<p>首先需要定义配置项key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;pomelo.cache.redis&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class PomeloRedisProperties &#123;</span><br><span class="line">    /**Redis前缀**/</span><br><span class="line">    private String prefix = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**默认超时时间**/</span><br><span class="line">    private Long timeout = 30000L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间单位</span><br><span class="line">     */</span><br><span class="line">    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义统一的key序列化方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class PomeloRedisKeySerializer  implements RedisSerializer&lt;String&gt; &#123;</span><br><span class="line">    private final String keyPrefix;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(String key) throws SerializationException &#123;</span><br><span class="line">        String buildKey = keyPrefix + key;</span><br><span class="line">        return buildKey.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String deserialize(byte[] bytes) throws SerializationException &#123;</span><br><span class="line">        return new String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自动注入设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableConfigurationProperties(PomeloRedisProperties.class)</span><br><span class="line">public class PomeloRedisCacheAutoConfiguration &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 构建Redis的Key</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PomeloRedisKeySerializer redisKeySerializer() &#123;</span><br><span class="line">        String prefix = pomeloRedisProperties.getPrefix();</span><br><span class="line">        return new PomeloRedisKeySerializer(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * redisTemplate相关配置</span><br><span class="line">     * [@Role(BeanDefinition.ROLE_INFRASTRUCTURE)] 表明这个bean是完全后台模式，不需要被代理。</span><br><span class="line">     *</span><br><span class="line">     * @param factory Redis连接工厂类</span><br><span class="line">     * @return 返回配置项对象</span><br><span class="line">     */</span><br><span class="line">    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        // 配置连接工厂</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jacksonSerial = new Jackson2JsonRedisSerializer&lt;&gt;(objectMapper, Object.class);</span><br><span class="line"></span><br><span class="line">        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        // null值字段不显示</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        // 美化JSON输出</span><br><span class="line">        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span><br><span class="line">        objectMapper.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        // 值采用json序列化</span><br><span class="line">        template.setValueSerializer(jacksonSerial);</span><br><span class="line">        // 使用StringRedisSerializer来序列化和反序列化redis的key值</span><br><span class="line">        template.setKeySerializer(redisKeySerializer());</span><br><span class="line">        // 设置hash key 和value序列化模式</span><br><span class="line">        template.setHashKeySerializer(redisKeySerializer());</span><br><span class="line">        // template.setHashValueSerializer(jacksonSerial);</span><br><span class="line">        template.setHashValueSerializer(jacksonSerial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义公共的辅助类：</p>
<h4 id="key操作辅助类"><a href="#key操作辅助类" class="headerlink" title="key操作辅助类"></a>key操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    /**</span><br><span class="line">     * 删除key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     */</span><br><span class="line">    public void delete(String key) &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量删除key</span><br><span class="line">     *</span><br><span class="line">     * @param keys</span><br><span class="line">     */</span><br><span class="line">    public void delete(Collection&lt;String&gt; keys) &#123;</span><br><span class="line">        stringRedisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public byte[] dump(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.dump(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否存在key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean exists(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean expire(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param date</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean expireAt(String key, Date date) &#123;</span><br><span class="line">        return stringRedisTemplate.expireAt(key, date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查找匹配的key</span><br><span class="line">     *</span><br><span class="line">     * @param pattern</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; keys(String pattern) &#123;</span><br><span class="line">        return stringRedisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将当前数据库的 key 移动到给定的数据库 db 当中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param dbIndex</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean move(String key, int dbIndex) &#123;</span><br><span class="line">        return stringRedisTemplate.move(key, dbIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除 key 的过期时间，key 将持久保持</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean persist(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.persist(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 的剩余的过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long getExpire(String key, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.getExpire(key, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 的剩余的过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long getExpire(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.getExpire(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从当前数据库中随机返回一个 key</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String randomKey() &#123;</span><br><span class="line">        return stringRedisTemplate.randomKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改 key 的名称</span><br><span class="line">     *</span><br><span class="line">     * @param oldKey</span><br><span class="line">     * @param newKey</span><br><span class="line">     */</span><br><span class="line">    public void rename(String oldKey, String newKey) &#123;</span><br><span class="line">        stringRedisTemplate.rename(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 仅当 newkey 不存在时，将 oldKey 改名为 newkey</span><br><span class="line">     *</span><br><span class="line">     * @param oldKey</span><br><span class="line">     * @param newKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean renameIfAbsent(String oldKey, String newKey) &#123;</span><br><span class="line">        return stringRedisTemplate.renameIfAbsent(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 所储存的值的类型</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public DataType type(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.type(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="String类型操作辅助类"><a href="#String类型操作辅助类" class="headerlink" title="String类型操作辅助类"></a>String类型操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisStringUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 中字符串值的子字符</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().get(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将给定 key 的值设为 value ，并返回 key 的旧值(old value)</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getAndSet(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对 key 所储存的字符串值，获取指定偏移量上的位(bit)</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param offset</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean getBit(String key, long offset) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().getBit(key, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量获取</span><br><span class="line">     *</span><br><span class="line">     * @param keys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; multiGet(Collection&lt;String&gt; keys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().multiGet(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置ASCII码, 字符串&#x27;a&#x27;的ASCII码是97, 转为二进制是&#x27;01100001&#x27;, 此方法是将二进制第offset位值变为value</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @param value 值,true为1, false为0</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean setBit(String key, long offset, boolean value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().setBit(key, offset, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param timeout 过期时间</span><br><span class="line">     * @param unit    时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES</span><br><span class="line">     *                秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS</span><br><span class="line">     */</span><br><span class="line">    public void setEx(String key, String value, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只有在 key 不存在时设置 key 的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return 之前已经存在返回false, 不存在返回true</span><br><span class="line">     */</span><br><span class="line">    public boolean setIfAbsent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param offset 从指定位置开始覆写</span><br><span class="line">     */</span><br><span class="line">    public void setRange(String key, String value, long offset) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取字符串的长度</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long size(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量添加</span><br><span class="line">     *</span><br><span class="line">     * @param maps</span><br><span class="line">     */</span><br><span class="line">    public void multiSet(Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().multiSet(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</span><br><span class="line">     *</span><br><span class="line">     * @param maps</span><br><span class="line">     * @return 之前已经存在返回false, 不存在返回true</span><br><span class="line">     */</span><br><span class="line">    public boolean multiSetIfAbsent(Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().multiSetIfAbsent(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加(自增长), 负数则为自减</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long incrBy(String key, long increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double incrByFloat(String key, double increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 追加到末尾</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Integer append(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().append(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="List操作辅助类"><a href="#List操作辅助类" class="headerlink" title="List操作辅助类"></a>List操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisListUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过索引获取列表中的元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lIndex(String key, long index) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().index(key, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取列表指定范围内的元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start 开始位置, 0是开始位置</span><br><span class="line">     * @param end   结束位置, -1返回所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; lRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存储在list头部</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPush(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushAll(String key, String... value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushAll(String key, Collection&lt;String&gt; value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当list存在的时候才加入</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushIfPresent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果pivot存在,再pivot前面添加</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param pivot</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPush(String key, String pivot, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPush(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushAll(String key, String... value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushAll(String key, Collection&lt;String&gt; value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为已存在的列表添加值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushIfPresent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在pivot元素的右边添加值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param pivot</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPush(String key, String pivot, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过索引设置列表元素的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index 位置</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    public void lSet(String key, long index, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForList().set(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的第一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return 删除的元素</span><br><span class="line">     */</span><br><span class="line">    public String lLeftPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout 等待时间</span><br><span class="line">     * @param unit    时间单位</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBLeftPop(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除并获取列表最后一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return 删除的元素</span><br><span class="line">     */</span><br><span class="line">    public String lRightPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout 等待时间</span><br><span class="line">     * @param unit    时间单位</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBRightPop(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span><br><span class="line">     *</span><br><span class="line">     * @param sourceKey</span><br><span class="line">     * @param destinationKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lRightPopAndLeftPush(String sourceKey, String destinationKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPopAndLeftPush(sourceKey,</span><br><span class="line">                destinationKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param sourceKey</span><br><span class="line">     * @param destinationKey</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBRightPopAndLeftPush(String sourceKey, String destinationKey,</span><br><span class="line">                                        long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPopAndLeftPush(sourceKey,</span><br><span class="line">                destinationKey, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除集合中值等于value得元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index index=0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素;</span><br><span class="line">     *              index&lt;0, 从尾部开始删除第一个值等于value的元素;</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRemove(String key, long index, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().remove(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 裁剪list</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     */</span><br><span class="line">    public void lTrim(String key, long start, long end) &#123;</span><br><span class="line">        stringRedisTemplate.opsForList().trim(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取列表长度</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLen(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Set操作类型辅助类"><a href="#Set操作类型辅助类" class="headerlink" title="Set操作类型辅助类"></a>Set操作类型辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisSetUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set添加元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sAdd(String key, String... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set移除元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sRemove(String key, Object... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除并返回集合的一个随机元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String sPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().pop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将元素value从一个集合移到另一个集合</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean sMove(String key, String value, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().move(key, value, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断集合是否包含value</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean sIsMember(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sIntersect(String key, String otherKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersect(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sIntersect(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersect(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的交集存储到destKey集合中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sIntersectAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersectAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的交集存储到destKey集合中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sIntersectAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersectAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的并集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sUnion(String key, String otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的并集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sUnion(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的并集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sUnionAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的并集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sUnionAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                               String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的差集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDifference(String key, String otherKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().difference(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的差集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDifference(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().difference(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的差集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sDifference(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().differenceAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的差集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sDifference(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                            String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().differenceAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合所有元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; setMembers(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中的一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String sRandomMember(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().randomMember(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中count个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param count</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; sRandomMembers(String key, long count) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().randomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中count个元素并且去除重复的</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param count</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDistinctRandomMembers(String key, long count) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().distinctRandomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;String&gt; sScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Hash操作辅助类"><a href="#Hash操作辅助类" class="headerlink" title="Hash操作辅助类"></a>Hash操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisHashUtils &#123;</span><br><span class="line"></span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取存储在哈希表中指定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Object hGet(String key, String field) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().get(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有给定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;Object, Object&gt; hGetAll(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有给定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param fields</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; hMultiGet(String key, Collection&lt;Object&gt; fields) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().multiGet(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hPut(String key, String hashKey, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hPutAll(String key, Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(key, maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 仅当hashKey不存在时才设置</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param hashKey</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean hPutIfAbsent(String key, String hashKey, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().putIfAbsent(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个或多个哈希表字段</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param fields</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hDelete(String key, Object... fields) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().delete(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查看哈希表 key 中，指定的字段是否存在</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean hExists(String key, String field) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().hasKey(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为哈希表 key 中的指定字段的整数值加上增量 increment</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @param increment</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hIncrBy(String key, Object field, long increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().increment(key, field, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为哈希表 key 中的指定字段的整数值加上增量 increment</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @param delta</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double hIncrByFloat(String key, Object field, double delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().increment(key, field, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有哈希表中的字段</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;Object&gt; hKeys(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().keys(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取哈希表中字段的数量</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取哈希表中所有值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; hValues(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().values(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 迭代哈希表中的键值对</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; hScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ZSet操作辅助类"><a href="#ZSet操作辅助类" class="headerlink" title="ZSet操作辅助类"></a>ZSet操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisZSetUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加元素,有序集合是按照元素的score值由小到大排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param score</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean zAdd(String key, String value, double score) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().add(key, value, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zAdd(String key, Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemove(String key, Object... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long zRemove(String key, Collection&lt;String&gt; values) &#123;</span><br><span class="line">        if (values != null &amp;&amp; !values.isEmpty()) &#123;</span><br><span class="line">            Object[] objs = values.toArray(new Object[values.size()]);</span><br><span class="line">            return stringRedisTemplate.opsForZSet().remove(key, objs);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加元素的score值，并返回增加后的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param delta</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double zIncrementScore(String key, String value, double delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().incrementScore(key, value, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return 0表示第一位</span><br><span class="line">     */</span><br><span class="line">    public Long zRank(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回元素在集合的排名,按元素的score值由大到小排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zReverseRank(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从小到大排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start 开始位置</span><br><span class="line">     * @param end   结束位置, -1查询所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取zset集合的所有元素, 从小到大排序</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRangeAll(String key) &#123;</span><br><span class="line">        return zRange(key, 0, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合元素, 并且把score值也获取</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, long start,</span><br><span class="line">                                                                   long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeWithScores(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min 最小值</span><br><span class="line">     * @param max 最大值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRangeByScore(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从小到大排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min 最小值</span><br><span class="line">     * @param max 最大值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,</span><br><span class="line">                                                                          double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,</span><br><span class="line">                                                                          double min, double max, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max,</span><br><span class="line">                start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRange(key, start, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, long min, long max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从大到小排序, 并返回score值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key,</span><br><span class="line">                                                                          long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeWithScores(key, start,</span><br><span class="line">                end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, double min,</span><br><span class="line">                                            double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores(</span><br><span class="line">            String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key,</span><br><span class="line">                min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, double min,</span><br><span class="line">                                            double max, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max,</span><br><span class="line">                start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据score值获取集合元素数量</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zCount(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().count(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zZCard(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().zCard(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合中value元素的score值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double zScore(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().score(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除指定索引位置的成员</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemoveRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().removeRange(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据指定的score值的范围来移除成员</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemoveRangeByScore(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().removeRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key和otherKey的并集并存储在destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zUnionAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zUnionAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                               String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet()</span><br><span class="line">                .unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zIntersectAndStore(String key, String otherKey,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().intersectAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zIntersectAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().intersectAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="管道辅助类"><a href="#管道辅助类" class="headerlink" title="管道辅助类"></a>管道辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisPipelineUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    /**</span><br><span class="line">     * 扫描主键，建议使用</span><br><span class="line">     *</span><br><span class="line">     * @param patten</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; scan(String patten) &#123;</span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.execute((RedisCallback&lt;Set&lt;String&gt;&gt;) connection -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">            try (Cursor&lt;byte[]&gt; cursor = connection.scan( ScanOptions.scanOptions()</span><br><span class="line">                    .match(patten).count(10000).build())) &#123;</span><br><span class="line">                while (cursor.hasNext()) &#123;</span><br><span class="line">                    result.add(new String(cursor.next()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;);</span><br><span class="line">        return keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 管道技术，提高性能</span><br><span class="line">     *</span><br><span class="line">     * @param type</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; lRightPushPipeline(String type, Collection&lt;String&gt; values) &#123;</span><br><span class="line">        List&lt;Object&gt; results = stringRedisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;</span><br><span class="line">                //集合转换数组</span><br><span class="line">                String[] strings = values.toArray(new String[values.size()]);</span><br><span class="line">                //直接批量发送</span><br><span class="line">                stringRedisConn.rPush(type, strings);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public List&lt;Object&gt; refreshWithPipeline(String futureKey, String topicKey, Collection&lt;String&gt; tasks) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; result = stringRedisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Nullable</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123;</span><br><span class="line">                StringRedisConnection stringRedisConnection = (StringRedisConnection) redisConnection;</span><br><span class="line">                String[] allTask = tasks.toArray(new String[tasks.size()]);</span><br><span class="line">                stringRedisConnection.lPush(topicKey, allTask);</span><br><span class="line">                stringRedisConnection.zRem(futureKey, allTask);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自定义RedissonClient"><a href="#自定义RedissonClient" class="headerlink" title="自定义RedissonClient"></a>自定义RedissonClient</h2><p>缓存我们使用的RedisTemplate，但是布隆处理器和分布式锁我们需要使用RedissonClient，增加RedissonClient配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><br><span class="line">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><br><span class="line">public class RedissonClientAutoConfiguration &#123;</span><br><span class="line">    private RedisProperties redisProperties;</span><br><span class="line"></span><br><span class="line">    private final static String SCHEMA = &quot;redis://&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">            name = &#123;&quot;redissonClient&quot;&#125;</span><br><span class="line">    )</span><br><span class="line">    public RedissonClient redissonClient()&#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line"></span><br><span class="line">        //集群模式</span><br><span class="line">        if(redisProperties.getCluster() != null)&#123;</span><br><span class="line">            RedisProperties.Cluster cluster = redisProperties.getCluster();</span><br><span class="line">            List&lt;String&gt; nodes = cluster.getNodes();</span><br><span class="line"></span><br><span class="line">            ClusterServersConfig clusterServersConfig = config.useClusterServers()</span><br><span class="line">                    .addNodeAddress(getSchemaAddress(nodes));</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                clusterServersConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line">            //哨兵模式</span><br><span class="line">        &#125;else if (redisProperties.getSentinel() != null)&#123;</span><br><span class="line">            RedisProperties.Sentinel sentinel = redisProperties.getSentinel();</span><br><span class="line">            List&lt;String&gt; nodes = sentinel.getNodes();</span><br><span class="line"></span><br><span class="line">            SentinelServersConfig sentinelServersConfig = config.useSentinelServers()</span><br><span class="line">                    .setMasterName(sentinel.getMaster())</span><br><span class="line">                    .setConnectTimeout(50000)</span><br><span class="line">                    .addSentinelAddress(getSchemaAddress(nodes))</span><br><span class="line">                    .setMasterConnectionPoolSize(64)</span><br><span class="line">                    .setMasterConnectionMinimumIdleSize(32)</span><br><span class="line">                    .setSlaveConnectionPoolSize(64)</span><br><span class="line">                    .setSlaveConnectionMinimumIdleSize(32);</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                sentinelServersConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            SingleServerConfig singleServerConfig = config.useSingleServer()</span><br><span class="line">                    .setAddress(SCHEMA + redisProperties.getHost() + &quot;:&quot; + redisProperties.getPort())</span><br><span class="line">                    .setDatabase(redisProperties.getDatabase());</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                singleServerConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        config.setCodec(new JsonJacksonCodec());</span><br><span class="line"></span><br><span class="line">        return Redisson.create(config);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建Schema的redis连接</span><br><span class="line">     * @param nodes 节点</span><br><span class="line">     * @return schema数组</span><br><span class="line">     */</span><br><span class="line">    private String[] getSchemaAddress(List&lt;String&gt; nodes) &#123;</span><br><span class="line">        String[] sentinelAddressesWithSchema = new String[nodes.size()];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            sentinelAddressesWithSchema[i] = SCHEMA + nodes.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sentinelAddressesWithSchema;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布隆处理器"><a href="#布隆处理器" class="headerlink" title="布隆处理器"></a>布隆处理器</h2><p>布隆过滤器（Bloom filter）是一种空间效率极高的概率型数据结构，用于判断一个元素是否在一个集合中。它的原理是当一个元素被加入集合时，通过几个不同的Hash函数将元素映射成一个位数组中的多个位置，再次查询时如果位数组中的每一位都此被设置过，则肯定在集合中。如果这些位有任何一位没有被设置过，则肯定不在集合中。主要的优点是空间效率和查询时间都远超一般的算法。</p>
<p>布隆过滤器可以用来解决缓存穿透问题。在接到一个查询请求时，先用布隆过滤器检查，如果布隆过滤器判断元素不在集合中，那么就可以不用去数据库中查询了，直接返回“元素不存在”。</p>
<p>一般在使用布隆过滤器的具体操作为：</p>
<ol>
<li>先将所有可能查询的数据hash到布隆过滤器中</li>
<li>当用户查询数据的时候，首先在布隆过滤器查询数据是否存在</li>
<li>如果布隆过滤器认为数据不存在，则直接返回给用户“数据不存在”</li>
<li>如果布隆过滤器认为数据存在，那么再去数据库中查询数据</li>
<li>再将数据库查询出来的数据存入缓存</li>
</ol>
<p>定义一个简单的布隆过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class PomeloBloomFilterAutoConfiguration &#123;</span><br><span class="line">    private static final String BLOOM_KEY = &quot;pomelo_bloom_filter&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 布隆过滤器</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RBloomFilter&lt;String&gt; cacheBloomFilter(RedissonClient redissonClient) &#123;</span><br><span class="line">        RBloomFilter&lt;String&gt; rBloomFilter = redissonClient.getBloomFilter(BLOOM_KEY);</span><br><span class="line">        rBloomFilter.tryInit(50000L, 0.03D);</span><br><span class="line">        return rBloomFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义一个简单的过滤器工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisBloomFilterUtils &#123;</span><br><span class="line">    private  final RBloomFilter bloomFilter;;</span><br><span class="line">    public boolean add(String value) &#123;</span><br><span class="line">        return bloomFilter.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean contains(String value) &#123;</span><br><span class="line">        return bloomFilter.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><font style="color:rgb(77, 77, 77);">并发执行是比较场景的场景，单机情况下，我们可以利用</font><a href="https://so.csdn.net/so/search?q=%E9%94%81%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020">锁机制</a><font style="color:rgb(77, 77, 77);">来实现顺序执行。然而微服务时代，多节点运行，如何让某业务可以同一时刻只允许一个任务运行呢？</font><br><font style="color:rgb(77, 77, 77);">Redisson实现分布式锁的用法，可以很容易实现分布式锁的配置。</font></p>
<p><font style="color:rgb(77, 77, 77);">我们按照本地模式来在辅助类中实现本地锁</font></p>
<p><font style="color:rgb(77, 77, 77);">定义ILock</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ILock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 加锁，并返回锁对象</span><br><span class="line">     */</span><br><span class="line">    Lock tryLock(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放锁对象</span><br><span class="line">     */</span><br><span class="line">    void unlock(Lock lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义DistributeLock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface DistributeLock extends ILock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建锁实例</span><br><span class="line">     */</span><br><span class="line">    RLock getLock(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建公平锁实例</span><br><span class="line">     */</span><br><span class="line">    RLock getFairLock(String key);</span><br><span class="line"></span><br><span class="line">    boolean tryLock(RLock lock);</span><br><span class="line">    boolean tryLock(RLock lock, long timeout);</span><br><span class="line"></span><br><span class="line">    RLock tryLock(String key);</span><br><span class="line">    RLock tryLock(String key, long timeout) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    RLock tryLock(String key, long timeout, TimeUnit timeUnit) throws InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现DistributeLock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedissonDistributeLock implements DistributeLock&#123;</span><br><span class="line">    private final RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock getLock(String key) &#123;</span><br><span class="line">        return redissonClient.getLock(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock getFairLock(String key) &#123;</span><br><span class="line">        return redissonClient.getFairLock(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(RLock lock) &#123;</span><br><span class="line">        return lock.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(RLock lock, long timeout) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (lock.tryLock(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key) &#123;</span><br><span class="line">        RLock lock = getLock(key);</span><br><span class="line">        if (lock.tryLock()) &#123;</span><br><span class="line">            return lock; // 直接返回锁对象</span><br><span class="line">        &#125;</span><br><span class="line">        return null; // 获取锁失败，返回null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key, long timeout) &#123;</span><br><span class="line">        return tryLock(key, timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key, long timeout, TimeUnit timeUnit) &#123;</span><br><span class="line">        RLock lock = getLock(key);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (lock.tryLock(timeout, timeUnit)) &#123;</span><br><span class="line">                return lock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(Lock lock) &#123;</span><br><span class="line">        if (lock instanceof RLock) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自动配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class PomeloLockAutoConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnClass(RedissonClient.class)</span><br><span class="line">    public DistributeLock redissonDistributeLock(RedissonClient redissonClient) &#123;</span><br><span class="line">        return new RedissonDistributeLock(redissonClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>工具</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>统一返回时间格式</title>
    <url>/2024/10/06/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>在springboot中@RestController的返回会使用Jackson来将响应序列化为json格式，所以构建统一的响应中的日期格式可以定义统一的序列化参数来实现，springboot自带的时间格式定义怎么处理的</p>
<span id="more"></span>
<h3 id="1-使用-DateTimeFormat和-JsonFormat都是处理时间格式化问题的"><a href="#1-使用-DateTimeFormat和-JsonFormat都是处理时间格式化问题的" class="headerlink" title="1.使用@DateTimeFormat和@JsonFormat都是处理时间格式化问题的"></a>1.使用@DateTimeFormat和@JsonFormat都是处理时间格式化问题的</h3><table>
<thead>
<tr>
<th>区别</th>
<th>@DateTimeFormat</th>
<th>@JsonFormat</th>
</tr>
</thead>
<tbody><tr>
<td>使用方法</td>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”)</font></td>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”, timezone &#x3D; “GMT+8”)</font></td>
</tr>
<tr>
<td>使用场景</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">URL传参时，格式化前端传向后端日期类型的时间格式</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">JSON传参，格式化前端传参和后端返回给前端的时间格式，传参可能不一定是json，但是一般接口向前端返回数据，基本上都是封装的统一返回格式，然后JSON返回。所以这个注解是一定要加的！</font></td>
</tr>
<tr>
<td>使用地方</td>
<td><font style="color:rgb(79, 79, 79);">实体类日期字段上、或者字段的set方法上、或者方法入参上</font></td>
<td><font style="color:rgb(79, 79, 79);">实体类日期字段上、或者字段的set方法上、、或者方法入参上</font></td>
</tr>
<tr>
<td>来源</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">org.springframework.format.annotation</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">com.fasterxml.jackson.annotation</font></td>
</tr>
</tbody></table>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>一旦使用yyyy-MM-dd 格式，如果传时分秒就会报错，或者是使用 yyyy-MM-dd HH:mm:ss，如果传yyyy-MM-dd 也会报错。</li>
<li>假如是springboot项目的话，使用这两个注解是不用导其他的依赖包的！</li>
<li>框架当中默认他会认为 前端传的是UTC时间，然后SpringMVC在接到参数的时候，会进行转换为本地区时间，向前端返回参数的时候会转换为UTC时间！</li>
<li>这两个注解可以选择在实体类的set方法当中使用，也可以在字段上使用，效果是一样的！</li>
</ul>
<h3 id="2-在全局配置文件中设置"><a href="#2-在全局配置文件中设置" class="headerlink" title="2.在全局配置文件中设置"></a>2.在全局配置文件中设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss </span><br><span class="line">    time-zone: GMT+8</span><br></pre></td></tr></table></figure>

<h3 id="3-通过JavaBean方式配置"><a href="#3-通过JavaBean方式配置" class="headerlink" title="3.通过JavaBean方式配置"></a>3.通过JavaBean方式配置</h3><p>定义DateForamtConfiguration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DateForamtConfiguration &#123;</span><br><span class="line"></span><br><span class="line">        public static final String timeFormat = &quot;HH:mm:ss&quot;;</span><br><span class="line">        public static final String dateFormat = &quot;yyyy-MM-dd&quot;;</span><br><span class="line">        public static final String dateTimeFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 全局时间格式化</span><br><span class="line">         */</span><br><span class="line">        @Bean</span><br><span class="line">        public Jackson2ObjectMapperBuilderCustomizer customizer() &#123;</span><br><span class="line">            return builder -&gt; &#123;</span><br><span class="line">                builder.simpleDateFormat(dateTimeFormat);</span><br><span class="line">                //日期序列化</span><br><span class="line">                builder.serializers(new LocalTimeSerializer(DateTimeFormatter.ofPattern(timeFormat)));</span><br><span class="line">                builder.serializers(new LocalDateSerializer(DateTimeFormatter.ofPattern(dateFormat)));</span><br><span class="line">                builder.serializers(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(dateTimeFormat)));</span><br><span class="line">                //日期反序列化</span><br><span class="line">                builder.deserializers(new LocalTimeDeserializer(DateTimeFormatter.ofPattern(timeFormat)));</span><br><span class="line">                builder.deserializers(new LocalDateDeserializer(DateTimeFormatter.ofPattern(dateFormat)));</span><br><span class="line">                builder.deserializers(new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(dateTimeFormat)));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>格式化</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>集成Nacos+SpringCloudGateway实现配置中心以及服务发现</title>
    <url>/2024/10/03/%E9%9B%86%E6%88%90Nacos+SpringCloudGateway%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>前面已经实现了统一返回以及异常处理，也完成了通用的数据模块，我们已经可以借此来实现服务，但是在微服务中肯定不会只有一个服务，当我们有多个服务的时候，会出现多个痛点：</p>
<ol>
<li>当服务多的时候分布在不同的服务器上部署的时候，前端寻址将是困难重重，所以需要一个统一的入口，来帮助前端来访问这些服务</li>
<li>多个服务分部在不同的主机上，当我们因为某种原因需要修改多个服务的配置文件时，工作量巨大。</li>
</ol>
<p>而Nacos+SpringCloudGateway可以帮我们解决这个问题</p>
<span id="more"></span>
<h2 id="集成Nacos"><a href="#集成Nacos" class="headerlink" title="集成Nacos"></a>集成Nacos</h2><h3 id="nacos是做什么的"><a href="#nacos是做什么的" class="headerlink" title="nacos是做什么的"></a>nacos是做什么的</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723102566330-cd999175-7353-4a7c-977c-9c09184126c6.png"></p>
<p>nacos的官网关于nacos的介绍一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台，那他有什么作用呢<img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723102912210-7e6f66de-bf32-4988-aeae-aa4e993406c0.png"></p>
<p>官网的描述是这样的，总结一下有两点：服务发现和服务注册以及配置管理，那nacos能做些什么呢</p>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册:"></a>服务注册:</h4><p>服务提供者在启动时向 Nacos 注册中心注册自己的服务信息，包括服务名称、IP 地址、端口号等。</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现:"></a>服务发现:</h4><p>服务消费者从 Nacos 注册中心获取服务提供者的信息，从而能够调用服务。</p>
<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查:"></a>健康检查:</h4><p>Nacos 支持服务实例的健康检查，可以自动剔除不健康的服务实例。</p>
<h4 id="服务元数据管理"><a href="#服务元数据管理" class="headerlink" title="服务元数据管理:"></a>服务元数据管理:</h4><p>除了基本的服务信息外，还可以附加服务的元数据，如版本、权重等。</p>
<h4 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组:"></a>服务分组:</h4><p>支持服务分组，可以根据不同的业务场景将服务划分到不同的组。</p>
<h4 id="服务版本控制"><a href="#服务版本控制" class="headerlink" title="服务版本控制:"></a>服务版本控制:</h4><p>支持服务版本管理，便于灰度发布和回滚。</p>
<h4 id="配置管理："><a href="#配置管理：" class="headerlink" title="配置管理："></a>配置管理：</h4><p>动态的配置管理用于集中管理配置文件</p>
<h3 id="在user模块中集成nacos"><a href="#在user模块中集成nacos" class="headerlink" title="在user模块中集成nacos"></a>在user模块中集成nacos</h3><p>首先定义pom文件（前文中已经定义了nacos的版本）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>启动类增加@EnableDiscoveryClient</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class PomeloCustomerModulesApplication &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(PomeloCustomerModulesApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加文件bootstrap.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 5030</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: pomelo-customer</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        namespace: c3477374-9bfd-4c52-a511-8a99468d7759</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: c3477374-9bfd-4c52-a511-8a99468d7759</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>启动服务</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723189847074-be1be5fa-4d1c-4948-bd2a-95e1bbc355d7.png"></p>
<p>可以看到已经连接到nacos</p>
<h2 id="集成SpringCloudGateway"><a href="#集成SpringCloudGateway" class="headerlink" title="集成SpringCloudGateway"></a>集成SpringCloudGateway</h2><h3 id="SpringCloudGateway是做什么的"><a href="#SpringCloudGateway是做什么的" class="headerlink" title="SpringCloudGateway是做什么的"></a>SpringCloudGateway是做什么的</h3><pre><code>在微服务架构中，一个系统会被拆分为很多个微服务。那么作为客户端要如何去调用这么多的微服务呢？如果没有网关的存在，我们只能在客户端记录每个微服务的地址，然后分别去调用。这样的话会产生很多问题，例如：
</code></pre>
<ul>
<li>客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性</li>
<li>认证复杂，每个微服务都有独立认证</li>
<li>存在跨域请求，在一定场景下处理相对复杂</li>
</ul>
<p>为解决上面的问题所以引入了网关的概念：所谓的API网关，就是指系统的统一入口，提供内部服务的路由中转，为客户端提供统一服务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、路由转发等。</p>
<p><font style="color:rgb(0, 0, 0);">Spring Cloud Gateway就是api网关。官网上对Spring Cloud Gateway如下：</font></p>
<p>:::info<br><font style="color:rgb(0, 0, 0);">This project provides a libraries for building an API Gateway on top of Spring WebFlux or Spring WebMVC. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring&#x2F;metrics, and resiliency.</font></p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a><font style="color:rgb(0, 0, 0);">Features</font></h2><p><font style="color:rgb(0, 0, 0);">Spring Cloud Gateway features:</font></p>
<ul>
<li><font style="color:rgb(0, 0, 0);">Built on Spring Framework and Spring Boot</font></li>
<li><font style="color:rgb(0, 0, 0);">Able to match routes on any request attribute.</font></li>
<li><font style="color:rgb(0, 0, 0);">Predicates and filters are specific to routes.</font></li>
<li><font style="color:rgb(0, 0, 0);">Circuit Breaker integration.</font></li>
<li><font style="color:rgb(0, 0, 0);">Spring Cloud DiscoveryClient integration</font></li>
<li><font style="color:rgb(0, 0, 0);">Easy to write Predicates and Filters</font></li>
<li><font style="color:rgb(0, 0, 0);">Request Rate Limiting</font></li>
<li><font style="color:rgb(0, 0, 0);">Path Rewriting</font></li>
</ul>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring5.0+Spring Boot20和 Project Reactor等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的API路由管理方式。</font></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><font style="color:rgb(79, 79, 79);">作用</font></h4><ul>
<li><font style="color:rgb(77, 77, 77);">反向代理</font></li>
<li><font style="color:rgb(77, 77, 77);">鉴权</font></li>
<li><font style="color:rgb(77, 77, 77);">流量控制</font></li>
<li><font style="color:rgb(77, 77, 77);">熔断</font></li>
<li><font style="color:rgb(77, 77, 77);">日志监控</font></li>
</ul>
<h3 id="通过SpringCloudGateway找到user模块"><a href="#通过SpringCloudGateway找到user模块" class="headerlink" title="通过SpringCloudGateway找到user模块"></a>通过SpringCloudGateway找到user模块</h3><p>当了解过概念后我们来动手实践一下</p>
<h4 id="第一步引入pom"><a href="#第一步引入pom" class="headerlink" title="第一步引入pom"></a>第一步引入pom</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--nacos--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二步引入nacos"><a href="#第二步引入nacos" class="headerlink" title="第二步引入nacos"></a>第二步引入nacos</h4><p>按照上面nacos的步驟做一遍</p>
<h4 id="第三步配置路由"><a href="#第三步配置路由" class="headerlink" title="第三步配置路由"></a>第三步配置路由</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          lowerCaseServiceId: true</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: pomelo-user</span><br><span class="line">        uri: lb://pomelo-user</span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/user/**</span><br><span class="line">        filters:</span><br><span class="line">          - StripPrefix=1</span><br></pre></td></tr></table></figure>

<h4 id="第四步测试"><a href="#第四步测试" class="headerlink" title="第四步测试"></a>第四步测试</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723191800165-3fce78f5-7a95-4d7e-8fd5-c36b50d2b6bd.png"></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>nacos</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2024/05/03/%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>类型</th>
<th>单体</th>
<th>微服务</th>
</tr>
</thead>
<tbody><tr>
<td>部署速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>扩展能力</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>复用能力</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>复杂度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>耦合度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>调试</td>
<td>容易</td>
<td>困难</td>
</tr>
<tr>
<td>问题排查</td>
<td>容易</td>
<td>困难</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>差</td>
</tr>
</tbody></table>
<span id="more"></span>


<p>单体应用：随着时间的积累代码量越来越大构建速度会越来越慢，部署也会越来越慢，随着代码的积累各种代码的耦合度会越来越高，技术债务逐步上升代码的扩展能力持续下降，复用困难，业务为了避免各种技术债务复杂度会越来越高。因为技术债务较高当开发人员离职后，继任者需要大量的时间去熟悉系统和代码，造成经济损失。但是在开发中单体服务代码集中日志集中所以调试简单，问题排查过程简单。而且单体中不需要额外的服务调用所以性能会更好一点</p>
<p>微服务应用：通过设计将业务进行拆分，降低各个服务间的耦合，每个服务独立部署并且实现服务轻量化，所以构建迅速。因为各个服务独立与其他服务耦合度低所以复用能力和扩展能力更强，每个服务更专注自己的业务领域所以业务的复杂度更低。复杂度更低即使开发人员离职，继任者只需要了解自己需要负责的服务就可以胜任。但是微服务因为做了拆分所以数据的交换需要进行进程通讯，而且同一个请求可能经过多个服务。进程间的通讯会对性能产生影响，请求经过多个服务会使数据的事务实施困难，以及单个请求的异常因为链路太长定位问题困难。</p>
<p>针对微服务的缺点我们的弥补措施：</p>
<p>微服务之间互相调用网络请求的瓶颈：尽量的明确接口数据长度，使用缓存，减少服务间的交互，更改交互方式为rpc</p>
<p>调试和问题排查：问题排查主要是分为两部分</p>
<p>1.问题的定位问题： 引入skywalking来对全链路进行追踪</p>
<p>2.问题的上下文信息获取：引入ELK日志管理解决方案，对日志进行集中，并通过skywalking提供的唯一ID对数据进行查询分析</p>
<p>事务：事务可以根据业务情况来使用诸如两段式提交的解决方案或者使用最终一致性解决方案来解决</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>单体</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign调用时如何传递传递Token并且多线程环境也能适用</title>
    <url>/2024/10/16/OpenFeign%E8%B0%83%E7%94%A8%E6%97%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E4%BC%A0%E9%80%92Token%E5%B9%B6%E4%B8%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B9%9F%E8%83%BD%E9%80%82%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>在上一片文章中我<font style="color:rgb(47, 48, 52);">们解决了网关层认证后向后端服务传递用户信息的问题。今天我们来解决另外一个问题：如何在 OpenFeign 中传递 Token，并且保证多线程情况下也能适用。</font></p>
<span id="more"></span>
<p><font style="color:rgb(47, 48, 52);">如果我们想要在OpenFeign中获取到用户信息，我们可以通过如下步骤实现</font></p>
<h3 id="实现RequestInterceptor接口"><a href="#实现RequestInterceptor接口" class="headerlink" title="实现RequestInterceptor接口"></a><font style="color:rgb(47, 48, 52);">实现RequestInterceptor接口</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloFeignRequestInterceptor implements RequestInterceptor &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void apply(RequestTemplate requestTemplate) &#123;</span><br><span class="line">        Map&lt;String, String&gt; headerMap = RequestHeaderContextHolder.getInstance().get();</span><br><span class="line">        if (ObjectUtil.isNotEmpty(headerMap)) &#123;</span><br><span class="line">            // heders头透传</span><br><span class="line">            for (Map.Entry&lt;String, String&gt; entry : headerMap.entrySet()) &#123;</span><br><span class="line">                requestTemplate.header(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用InheritableThreadLocal保存header信息"><a href="#使用InheritableThreadLocal保存header信息" class="headerlink" title="使用InheritableThreadLocal保存header信息"></a>使用<font style="color:rgb(47, 48, 52);">InheritableThreadLocal保存header信息</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RequestHeaderContextHolder &#123;</span><br><span class="line">    </span><br><span class="line">    // 使用InheritableThreadLocal，使得共享变量可被子线程继承</span><br><span class="line">    private final ThreadLocal&lt;Map&lt;String, String&gt;&gt; REQUEST_HEADER_HOLDER;</span><br><span class="line">    private RequestHeaderContextHolder() &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER = new InheritableThreadLocal&lt;&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected Map&lt;String, String&gt; initialValue() &#123;</span><br><span class="line">                return new HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * return RequestHeaderHolder instance</span><br><span class="line">     */</span><br><span class="line">    public static RequestHeaderContextHolder getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 根据键获取请求头的值</span><br><span class="line">     * @param key 请求头的键</span><br><span class="line">     * @return 对应键的值</span><br><span class="line">     */</span><br><span class="line">    public String getValue(String key) &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取当前线程的请求头信息</span><br><span class="line">     * @return 请求头Map</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, String&gt; get() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取当前线程的用户信息</span><br><span class="line">     * @return 当前用户信息</span><br><span class="line">     */</span><br><span class="line">    public String getCurrentUser() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCurrentUserName() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 设置当前线程的用户信息</span><br><span class="line">     * @param userId 用户ID</span><br><span class="line">     */</span><br><span class="line">    public void setCurrentUser(String userId) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_ID_HEADER, userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentUser(String userId, String userName) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_ID_HEADER, userId);</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_NAME_HEADER, userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 设置请求头信息</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, String value) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类的单例模式</span><br><span class="line">     */</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        </span><br><span class="line">        private static final RequestHeaderContextHolder instance = new RequestHeaderContextHolder();</span><br><span class="line">        private SingletonHolder() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改请求拦截器"><a href="#修改请求拦截器" class="headerlink" title="修改请求拦截器"></a><font style="color:rgb(47, 48, 52);">修改请求拦截器</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserTokenHandlerInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String userId = request.getHeader(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">        String userName = request.getHeader(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">        RequestHeaderContextHolder.getInstance().setCurrentUser(userId, userName);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        RequestHeaderContextHolder.getInstance().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>通过实现requestInterceotor接口我们在每次进行feign调用时都会将header头文件进行传递。但是在异步的环境中无法获取到header头文件信息，我们通过自定义<font style="color:rgb(47, 48, 52);">InheritableThreadLocal结构体对header进行保存然后贡献的形式进行处理。这样可以在不同的场景下依然可以完成数据的保存</font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Sa-Token的微服务权限验证</title>
    <url>/2024/10/06/%E5%9F%BA%E4%BA%8ESa-Token%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p><strong><font style="color:rgb(44, 62, 80);">Sa-Token</font></strong><font style="color:rgb(52, 73, 94);"> 是一个轻量级 Java 权限认证框架主，要解决：</font><strong><font style="color:rgb(44, 62, 80);">登录认证</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">权限认证</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">单点登录</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">OAuth2.0</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">分布式Session会话</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">微服务网关鉴权</font></strong><font style="color:rgb(52, 73, 94);"> 等一系列权限相关问题。Sa-Token 旨在以简单、优雅的方式完成系统的权限认证部分。</font></p>
<p><font style="color:rgb(52, 73, 94);">官网地址：</font><a href="https://sa-token.cc/">https://sa-token.cc/</a></p>
<span id="more"></span>
<h2 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>多种登陆模式，账号密码，手机号验证码等</li>
<li>网关验证登陆是否过期，黑白名单等处理</li>
<li>可以支持角色和权限字符串鉴权验证</li>
<li>实现登出功能</li>
<li>减少数据库访问，登陆后数据详情放入redis中</li>
</ul>
<p>在pomelo中权限的验证，采用了token格式的数据，对与用户信息进行缓存的形式进行操作，并没有使用jwt，主要考虑有两种：jwt的数据保存在token字符串中，增加了前端到后段的通讯负担，敏感数据的解析一样需要从服务端中获取，所以在pomelo中，我们直接使用token来进行交互，并把用户的数据保存在redis缓存中，虽然需要承担redis缓存宕机带来的用户验证异常，但是也拥有很高的灵活性</p>
<h3 id="网关统一认证处理"><a href="#网关统一认证处理" class="headerlink" title="网关统一认证处理"></a>网关统一认证处理</h3><p>网关可以统一的来实现权限的认证，但是不够灵活，所以在网关中只对消息中是否存在token来进行判断，token消息是否过期进行处理，当消息正常时新增Header对token进行透传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class AuthFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DistributedCache distributedCache;</span><br><span class="line">    // 排除过滤的 uri 地址，nacos自行添加</span><br><span class="line">    @Autowired</span><br><span class="line">    private IgnoreWhiteProperties ignoreWhite;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthProperties authProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 连接 Token 前缀和 Token 值的字符</span><br><span class="line">     */</span><br><span class="line">    public static final String TOKEN_CONNECTOR_CHAT  = &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">        String path = exchange.getRequest().getURI().getPath();</span><br><span class="line">        // 跳过不需要验证的路径</span><br><span class="line">        if (StringUtils.matches(path, ignoreWhite.getWhites())) &#123;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        String token = getToken(request);</span><br><span class="line">        if (StrUtil.isEmpty(token)) &#123;</span><br><span class="line">            return unauthorizedResponse(exchange, ErrorCode.TOKEN_EMPTY_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        // 验证token是否过期</span><br><span class="line">        if (!distributedCache.hasKey(authProperties.getIdentifier() + &quot;:login:token:&quot; + token)) &#123;</span><br><span class="line">            return unauthorizedResponse(exchange, ErrorCode.TOKEN_EXPIRATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String prefixToken =String.format(&quot;%s%s%s&quot;, authProperties.getPrefix(),TOKEN_CONNECTOR_CHAT, token) ;</span><br><span class="line">        addHeader(mutate, authProperties.getIdentifier(), prefixToken,true);</span><br><span class="line">        String loginUserKey  = String.format(&quot;%S%S&quot;, SecurityConstants.USER_KEY, token);</span><br><span class="line">        if (distributedCache.hasKey(loginUserKey)) &#123;</span><br><span class="line">            LoginUser loginUser= distributedCache.get(loginUserKey, LoginUser.class);</span><br><span class="line">            if (loginUser != null)&#123;</span><br><span class="line">                addHeader(mutate, SecurityConstants.USER_ID_HEADER, loginUser.getUserId(),false);</span><br><span class="line">                addHeader(mutate, SecurityConstants.USER_NAME_HEADER, loginUser.getUserName(),false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addHeader(ServerHttpRequest.Builder mutate, String name, Object value,Boolean isEncode) &#123;</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueStr = value.toString();</span><br><span class="line">        if (isEncode)&#123;</span><br><span class="line">            mutate.header(name, valueStr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueEncode = ServletUtils.urlEncode(valueStr);</span><br><span class="line">        mutate.header(name, valueEncode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Mono&lt;Void&gt; unauthorizedResponse(ServerWebExchange exchange, ErrorCode errorCode) &#123;</span><br><span class="line">        log.error(&quot;[鉴权异常处理]请求路径:&#123;&#125;&quot;, exchange.getRequest().getPath());</span><br><span class="line">        return ServletUtils.webFluxResponseWriter(exchange.getResponse(), errorCode.getMessage(), errorCode.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求token</span><br><span class="line">     */</span><br><span class="line">    private String getToken(ServerHttpRequest request) &#123;</span><br><span class="line">        String token = request.getHeaders().getFirst(SecurityConstants.AUTHORIZATION_HEADER);</span><br><span class="line">        // 如果前端设置了令牌前缀，则裁剪掉前缀</span><br><span class="line">        if (StrUtil.isNotEmpty(token) &amp;&amp; token.startsWith(authProperties.getPrefix())) &#123;</span><br><span class="line">            token = token.replaceFirst(authProperties.getPrefix(), &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="登陆授权"><a href="#登陆授权" class="headerlink" title="登陆授权"></a>登陆授权</h3><p>登陆需要支持两种模式一种是短信登陆，以及账号密码登陆。短信登陆时如果账号未注册，直接注册新用户，账号密码需要提前注册后才能登陆。当用户身份验证通过后，需要将token放入redis用于处理token超时的问题，2将token与用户信息关联，为后续验证做好准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public LoginRspVo login(LoginDTO loginDTO) &#123;</span><br><span class="line">       // 预认证 验证参数</span><br><span class="line">       preAuthenticationCheck(loginDTO);</span><br><span class="line">       // 认证</span><br><span class="line">       LoginUser loginUser = authenticate(loginDTO);</span><br><span class="line">       CacheUtil.addLoginUser(loginUser);</span><br><span class="line">       // 角色获取</span><br><span class="line">       List&lt;String&gt; roles = getRoles(loginUser.getUserId());</span><br><span class="line">       if (CollectionUtil.isNotEmpty(roles))&#123;</span><br><span class="line">           CacheUtil.updateRoleCache(loginUser.getUserId(), roles);</span><br><span class="line"></span><br><span class="line">           // 权限获取</span><br><span class="line">           for (String role : roles) &#123;</span><br><span class="line">               List&lt;String&gt; permissions = getPermissions(role);</span><br><span class="line">               CacheUtil.updatePermissionCache(role, permissions);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       LoginRspVo loginRspVo = new LoginRspVo();</span><br><span class="line">       loginRspVo.setAccess_token(loginUser.getToken());</span><br><span class="line">       loginRspVo.setUserId(loginUser.getUserId());</span><br><span class="line">       loginRspVo.setUserName(loginUser.getUserName());</span><br><span class="line">       loginRspVo.setLoginTime(loginUser.getLoginTime());</span><br><span class="line">       return loginRspVo;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>实现思路：当系统用户登录完成后，将用户数据放入缓存，以及将用户的角色和权限信息放入到缓存。以供网关以及后续鉴权提供数据支持。</p>
<h3 id="服务鉴权"><a href="#服务鉴权" class="headerlink" title="服务鉴权"></a>服务鉴权</h3><p>在sa-token中提供了StpInterface借口，来对权限以及角色进行处理，处理思路：定义PomeloInterfaceImpl对用户的权限以及角色获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PomeloInterfaceImpl implements StpInterface &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public List&lt;String&gt; getPermissionList(Object loginId, String loginType) &#123;</span><br><span class="line">        // 1. 声明权限码集合</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        // 2. 遍历角色列表，查询拥有的权限码</span><br><span class="line">        for (String roleId : getRoleList(loginId, loginType)) &#123;</span><br><span class="line">            List&lt;String&gt; permissionList = (List&lt;String&gt;) SaManager.getSaTokenDao()</span><br><span class="line">                    .getObject(SaManager.getConfig().getTokenName()+&quot;:role-find-permission:&quot; + roleId);</span><br><span class="line">            if (permissionList == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            list.addAll(permissionList);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public List&lt;String&gt; getRoleList(Object loginId, String loginType) &#123;</span><br><span class="line">        List&lt;String&gt; roleList = (List&lt;String&gt;) SaManager.getSaTokenDao()</span><br><span class="line">                .getObject(SaManager.getConfig().getTokenName()+&quot;:loginId-find-role:&quot; + loginId);</span><br><span class="line">        return roleList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>权限</tag>
        <tag>sa-token</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务中的ACL与OpenFeign的绝佳配合</title>
    <url>/2024/10/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84ACL%E4%B8%8EOpenFeign%E7%9A%84%E7%BB%9D%E4%BD%B3%E9%85%8D%E5%90%88/</url>
    <content><![CDATA[<h2 id="ACL的概念"><a href="#ACL的概念" class="headerlink" title="ACL的概念"></a>ACL的概念</h2><p>在一些情况下我们需要引入第三方的接口来进行操作，但是当我们引用第三方接口的时候也会有一些隐患，第三方&#x3D;不可空，没准哪一天对方的接口参数突然就变掉了，如果我们直接在多个地方引用了第三方的接口，我们就需要在不同的地方处理接口方法，这时我们就需要引入防腐层的概念</p>
<h3 id="什么是防腐层"><a href="#什么是防腐层" class="headerlink" title="什么是防腐层"></a>什么是防腐层</h3><p>在许多情况下，我们的系统需要依赖其他系统，但被依赖的系统可能具有不合理的数据结构、API、协议或技术实现。如果我们强烈依赖外部系统，就会导致我们的系统受到<strong>“腐蚀”</strong>。在这种情况下，通过引入防腐层，可以有效地隔离外部依赖和内部逻辑，无论外部如何变化，内部代码尽可能保持不变。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737213600511-5dd8e777-8274-4482-92b6-db88a7a8179e.png"></p>
<span id="more"></span>
<p>防腐层不仅仅是一层简单的调用封装，在实际开发中，ACL可以提供更多强大的功能：</p>
<ol>
<li><strong>适配器：</strong> 很多时候外部依赖的数据、接口和协议并不符合内部规范，通过适配器模式，可以将数据转化逻辑封装到ACL内部，降低对业务代码的侵入。</li>
<li><strong>缓存：</strong> 对于频繁调用且数据变更不频繁的外部依赖，通过在ACL里嵌入缓存逻辑，能够有效的降低对于外部依赖的请求压力。同时，很多时候缓存逻辑是写在业务代码里的，通过将缓存逻辑嵌入ACL，能够降低业务代码的复杂度。</li>
<li><strong>兜底：</strong> 如果外部依赖的稳定性较差，提高系统稳定性的策略之一是通过ACL充当兜底，例如在外部依赖出问题时，返回最近一次成功的缓存或业务兜底数据。这种兜底逻辑通常复杂，如果散布在核心业务代码中，会难以维护。通过集中在ACL中，更容易进行测试和修改。</li>
<li><strong>易于测试：</strong> ACL的接口类能够很容易的实现Mock或Stub，以便于单元测试。</li>
<li><strong>功能开关：</strong> 有时候，我们希望在某些场景下启用或禁用某个接口的功能，或者让某个接口返回特定值。我们可以在ACL中配置功能开关，而不会影响真实的业务代码。</li>
</ol>
<h3 id="如何实现防腐层"><a href="#如何实现防腐层" class="headerlink" title="如何实现防腐层"></a>如何实现防腐层</h3><p><font style="color:rgb(47, 48, 52);">实现ACL防腐层的步骤如下：</font></p>
<ol>
<li><font style="color:rgb(47, 48, 52);">对于依赖的外部对象，我们提取所需的字段，并创建一个内部所需的DTO类。</font></li>
<li><font style="color:rgb(47, 48, 52);">构建一个新的Facade，在Facade中封装调用链路，将外部类转化为内部类。Facade可以参考Repository的实现模式，将接口定义在领域层，而将实现放在基础设施层。</font></li>
<li><font style="color:rgb(47, 48, 52);">在ApplicationService中依赖内部的Facade对象。</font></li>
</ol>
<p>具体的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class CustomerMenuDTO &#123;</span><br><span class="line">    // 菜单ID</span><br><span class="line">    private String menuId;</span><br><span class="line">    // 父菜单ID，一级菜单为0</span><br><span class="line">    private String parentId;</span><br><span class="line">    // 菜单名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 别称</span><br><span class="line">    private String anotherName;</span><br><span class="line">    // 组件路径</span><br><span class="line">    private String component;</span><br><span class="line">    // 菜单URL</span><br><span class="line">    private String path;</span><br><span class="line">    // 排序</span><br><span class="line">    private Integer orderNum;</span><br><span class="line">    // 菜单标题</span><br><span class="line">    private String title;</span><br><span class="line">    // 授权(多个用逗号分隔)</span><br><span class="line">    private String perms;</span><br><span class="line">    // 类型 0：目录 1：菜单 2：按钮</span><br><span class="line">    private Integer type;</span><br><span class="line">    // 菜单图标</span><br><span class="line">    private String icon;</span><br><span class="line">    // 是否跳转</span><br><span class="line">    private Boolean IsFull;</span><br><span class="line">    // 是否外链</span><br><span class="line">    private String isLink;</span><br><span class="line">    // 是否隐藏</span><br><span class="line">    private Boolean isHide;</span><br><span class="line">    // 是否固定</span><br><span class="line">    private Boolean isAffix;</span><br><span class="line">    // 是否长连接</span><br><span class="line">    private Boolean isKeepAlive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">Facade</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(name = &quot;pomelo-customer&quot;)</span><br><span class="line">public interface CustomerRemoteFacade &#123;</span><br><span class="line">    //获取用户角色</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName);</span><br><span class="line">    //获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserId/&#123;UserId&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserId(@PathVariable(&quot;UserId&quot;) String UserId);</span><br><span class="line">    //根据手机号获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber);</span><br><span class="line">    //获取用户角色信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId);</span><br><span class="line">    //获取用户权限</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在服务中应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final CustomerRemoteFacade customerRemoteFacade;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  CustomerUserDTO customerUser = customerRemoteFacade.getUserInfoByPhoneNumber(phonePasswordLoginDTO.getPhone());</span><br><span class="line">       if (customerUser ==null)&#123;</span><br><span class="line">           throw new BusinessException(ErrorCode.USERNAME_PASSWORD_INCORRECT);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这样，经过acl防腐处理，我们的服务中就不需要直接调用第三方接口了，当第三方的接口有过修改，我们只需要在acl中将逻辑更改，这样并不会影响到主体业务</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><font style="color:rgb(47, 48, 52);">在没有防腐层ACL的情况下，系统需要直接依赖外部对象和外部调用接口，调用逻辑如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737214136984-079e1779-c4fe-4ae8-b17d-eab63490e35b.png"></p>
<font style="color:rgb(47, 48, 52);">  
</font>

<p><font style="color:rgb(47, 48, 52);">而有了防腐层ACL后，系统只需要依赖内部的值类和接口，调用逻辑如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737214136953-fab41375-7967-4827-a6d7-eb95351dd551.png"></p>
<h2 id="OpenFeign的应用"><a href="#OpenFeign的应用" class="headerlink" title="OpenFeign的应用"></a>OpenFeign的应用</h2><h3 id="微服务中的远程调用"><a href="#微服务中的远程调用" class="headerlink" title="微服务中的远程调用"></a>微服务中的远程调用</h3><p>在pomelo中服务间的远程调用，我们单独的定义一个包来完成。同样我们在引用方，也可以以acl的思想来使用openFeign应用。接下来我们看一下用户登录引用用户服务的实现过程</p>
<h4 id="定义服务接口"><a href="#定义服务接口" class="headerlink" title="定义服务接口"></a>定义服务接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span><br><span class="line">public class CustomerUserInternal &#123;</span><br><span class="line">    private final CustomerUserService customerUserService;</span><br><span class="line">    private final CustomerRoleService customerRoleService;</span><br><span class="line">    private final CustomerMenuService customerMenuService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据用户名获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param UserName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    public CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName) &#123;</span><br><span class="line">        return customerUserService.selectUserByUserName(UserName);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 根据手机号获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param PhoneNumber</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    public CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber) &#123;</span><br><span class="line">        return customerUserService.selectUserByPhoneNumber(PhoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 根据id获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoById/&#123;id&#125;&quot;)</span><br><span class="line">    public CustomerUserListDTO getUserInfoById(@PathVariable(&quot;id&quot;) String id) &#123;</span><br><span class="line">        return customerUserService.selectUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    public List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId) &#123;</span><br><span class="line">        return customerRoleService.selectRoleByUserId(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据角色获取权限信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    public List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId) &#123;</span><br><span class="line">        return customerMenuService.getMenuOptionsByRoleId(roleId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acl防腐层facade实现"><a href="#acl防腐层facade实现" class="headerlink" title="acl防腐层facade实现"></a>acl防腐层facade实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(name = &quot;pomelo-customer&quot;)</span><br><span class="line">public interface CustomerRemoteFacade &#123;</span><br><span class="line">    //获取用户角色</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName);</span><br><span class="line">    //获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserId/&#123;UserId&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserId(@PathVariable(&quot;UserId&quot;) String UserId);</span><br><span class="line">    //根据手机号获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber);</span><br><span class="line">    //获取用户角色信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId);</span><br><span class="line">    //获取用户权限</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="启动服务增加注解"><a href="#启动服务增加注解" class="headerlink" title="启动服务增加注解"></a>启动服务增加注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(&quot;com.fbb.pomelo.auth.acl&quot;)</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在引用方调用接口进行参数处理</p>
<h3 id="自定义微服务解码器"><a href="#自定义微服务解码器" class="headerlink" title="自定义微服务解码器"></a>自定义微服务解码器</h3><p>我们在构建统一返回以及全局异常处理中提出过对参数的返回体进行了包装，那我们引用feign的时间就需要对之前的包装进行解码</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloFeignResponseDecoder implements Decoder &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object decode(Response response, Type type) throws IOException, DecodeException, FeignException &#123;</span><br><span class="line">        // 因为在web中定义过返回自动转换为Result，所以在使用openfeign时为了方便我们需要自定义解码将Result接触</span><br><span class="line">        Result&lt;?&gt; result = JsonUtils.inputStream2Obj(response.body().asInputStream(),Result.class);</span><br><span class="line">        if (ErrorCode.OK.getCode().equals(result.getCode())) &#123;</span><br><span class="line">            Object data = result.getData();</span><br><span class="line">            if (ObjectUtil.isEmpty(data))&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            JavaType javaType = TypeFactory.defaultInstance().constructType(type);</span><br><span class="line">            return JsonUtils.convertValue(data, javaType);</span><br><span class="line">        &#125;</span><br><span class="line">        // 异常则抛出业务异常</span><br><span class="line">        throw new RemoteException(result.getCode(), result.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="上游异常的统一处理"><a href="#上游异常的统一处理" class="headerlink" title="上游异常的统一处理"></a>上游异常的统一处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class PomeloFeignErrorDecoder implements ErrorDecoder &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Exception decode(String s, Response response) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Reader reader = response.body().asReader(Charset.defaultCharset());</span><br><span class="line">            Result&lt;?&gt; result = JsonUtils.reader2Obj(reader, Result.class);</span><br><span class="line">            return new RemoteException(result.getCode(), result.getMessage());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;Response转换异常&quot;, e);</span><br><span class="line">            throw new RemoteException(ErrorCode.FEIGN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Feign全局异常处理"><a href="#Feign全局异常处理" class="headerlink" title="Feign全局异常处理"></a>Feign全局异常处理</h3><p>feign的全局异常依然是沿用了spring的RestControllerAdvice注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">@Slf4j</span><br><span class="line">@Order(Ordered.HIGHEST_PRECEDENCE) // 优先级</span><br><span class="line">@ResponseStatus(code = HttpStatus.BAD_REQUEST) // 统一 HTTP 状态码</span><br><span class="line">public class PomeloFeignExceptionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(FeignException.class)</span><br><span class="line">    public Result&lt;?&gt; handleFeignException(FeignException e) &#123;</span><br><span class="line">        // log.error(&quot;FeignException: &quot;, e);</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(ErrorCode.REMOTE_ERROR.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(DecodeException.class)</span><br><span class="line">    public Result&lt;?&gt; handleDecodeException(DecodeException e) &#123;</span><br><span class="line">        log.error(&quot;Feign Decode Error: &quot;, e);</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        if (cause instanceof AbstractException) &#123;</span><br><span class="line">            RemoteException remoteException = (RemoteException) cause;</span><br><span class="line">            // 上游符合全局响应包装约定的再次抛出即可</span><br><span class="line">            return new Result&lt;Void&gt;()</span><br><span class="line">                    .setCode(remoteException.getCode())</span><br><span class="line">                    .setMessage(remoteException.getMessage())</span><br><span class="line">                    .setTimestamp(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        // 全部转换成RemoteException</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(ErrorCode.REMOTE_ERROR.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    @ExceptionHandler(RemoteException.class)</span><br><span class="line">    public Result&lt;?&gt; handleRemoteException(RemoteException e) &#123;</span><br><span class="line">        log.error(&quot;Feign Remote Error: &quot;, e);</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(e.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><font style="color:rgb(47, 48, 52);">我们学习了如何使用ACL来隔离外部依赖，降低系统耦合度。在微服务架构中，我们探讨了如何通过OpenFeign来实现跨服务调用，并解决了全局包装和异常处理的问题，希望本文的内容对您在软件开发项目中有所帮助。</font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2024/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><font style="color:rgb(77, 77, 77);">1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</font></p>
<p>:::info</p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.5);">Consistency（一致性）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">Availability（可用性）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">Partition tolerance （分区容错性）</font></li>
</ul>
<p>:::</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727676127141-2d6e2681-9b7a-40cc-a38f-71676129af12.png"></p>
<span id="more"></span>
<p><font style="color:rgb(77, 77, 77);">它们的第一个字母分别是 C、A、P。</font></p>
<p><font style="color:rgb(77, 77, 77);">Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</font></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><font style="color:rgb(77, 77, 77);">Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</font></p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p><font style="color:rgb(77, 77, 77);">Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</font></p>
<h3 id="分区容错"><a href="#分区容错" class="headerlink" title="分区容错"></a>分区容错</h3><p><strong><font style="color:rgb(77, 77, 77);">Partition（分区）</font></strong><font style="color:rgb(77, 77, 77);">：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">Tolerance（容错）</font></strong><font style="color:rgb(77, 77, 77);">：在集群出现分区时，整个系统也要持续对外提供服务</font></p>
<h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p><font style="color:rgb(77, 77, 77);">在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727676224018-30b6e228-e99e-4d1f-b7e9-e33ebe7f5390.png"></p>
<p>如果此时要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</p>
<p>如果此时要保证可用性，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。</p>
<p>也就是说，在P(分区情况下)一定会出现的情况下，A和C之间只能实现一个。</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li>
<li><strong>Soft State（软状态）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态。</li>
<li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li>
</ul>
<h2 id="解决分布式事务的思路"><a href="#解决分布式事务的思路" class="headerlink" title="解决分布式事务的思路"></a><font style="color:rgb(79, 79, 79);">解决分布式事务的思路</font></h2><p><font style="color:rgb(77, 77, 77);">分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：</font></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">AP模式：</font><strong><font style="color:rgb(77, 77, 77);">各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。  既最终一致性</font></strong></li>
<li><font style="color:rgb(77, 77, 77);">CP模式：</font><strong><font style="color:rgb(77, 77, 77);">各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态</font></strong><font style="color:rgb(77, 77, 77);">。既最终一致性</font></li>
</ul>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在实际应用中，</p>
<p>2PC与3PC都是使用的AP模式</p>
<p>本地事务表使用的CP模式</p>
<h3 id="2PC与3PC"><a href="#2PC与3PC" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h3><h4 id="二阶段提交（2PC）"><a href="#二阶段提交（2PC）" class="headerlink" title="二阶段提交（2PC）"></a>二阶段提交（2PC）</h4><h5 id="阶段一：准备阶段"><a href="#阶段一：准备阶段" class="headerlink" title="阶段一：准备阶段"></a>阶段一：准备阶段</h5><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727680107070-126ca8cb-a71a-4392-b599-9a044ac40c3d.png"></p>
<ol>
<li><font style="color:rgb(37, 41, 51);">协调者向所有参与者发送commit请求，询问是否可以提交事务，并等待答复。</font></li>
<li><font style="color:rgb(37, 41, 51);">各参与者开始准备执行事务，将uodo log和redo log记入事务日志中，并不提交事务。</font></li>
<li><font style="color:rgb(37, 41, 51);">如果参与者执行成功，则向协调者返回yes，否则返回no。</font></li>
</ol>
<h5 id="阶段二：提交阶段"><a href="#阶段二：提交阶段" class="headerlink" title="阶段二：提交阶段"></a>阶段二：提交阶段</h5><p><font style="color:rgb(37, 41, 51);">协调者收到各个参与者的准备信息后，根据反馈情况，通知各个参与者Commit或者Rollback。</font></p>
<h6 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a><font style="color:rgb(37, 41, 51);">事务提交</font></h6><p>当第一阶段所有参与者都反馈同意时，协调者发起正式提交事务请求，当所有的参与者都回复成功，则表明完成事务，具体流程如下：</p>
<ol>
<li><font style="color:rgb(37, 41, 51);">协调者向所有参与者发送正式提交事务请求（即：commit请求）。</font></li>
<li><font style="color:rgb(37, 41, 51);">参与者收到协调者的commit请求后，参与者正式执行事务提交操作，并释放整个事务期间占用的资源。</font></li>
<li><font style="color:rgb(37, 41, 51);">参与者完成事务提交后，向协调者发送ACK消息。</font></li>
<li><font style="color:rgb(37, 41, 51);">协调者收到所有参与者反馈的ACK消息后，完成事务。</font></li>
</ol>
<h6 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h6><p>如果任意一个参与者在第一阶段返回中止信息，或者由于超时协调者无法获取到所有参与者的信息，那么这个事务将会被回滚，具体流程如下：</p>
<ol>
<li>协调者向所有参与者发送回滚请求（即：rollback请求）。</li>
<li>参与者收到协调者发送的回滚请求后，参与者使用第一阶段中的undo log信息执行回滚操作，并释放在整个事务期间占用的资源。</li>
<li>参与者在执行完回滚操作之后，向协调者发送ACK信息。</li>
<li>协调者受到所有参与者反馈的信息后，取消事务。</li>
</ol>
<h5 id="2PC的优缺点"><a href="#2PC的优缺点" class="headerlink" title="2PC的优缺点"></a>2PC的优缺点</h5><p><strong>二阶段的确可以提供原子性操作，但是仍有如下缺点：</strong></p>
<ol>
<li>性能问题：所有参与者在提交阶段，都处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li>可靠性问题：如果协调者出现单点故障，或者出现不可用状态，参与者将一直处于锁定状态。</li>
<li>数据一致性问题：在阶段2中，如果出现协调者和参与者都挂了，有可能导致数据不一致。</li>
</ol>
<h4 id="三阶段提交（3PC）"><a href="#三阶段提交（3PC）" class="headerlink" title="三阶段提交（3PC）"></a><font style="color:rgb(37, 41, 51);">三阶段提交（3PC）</font></h4><p>与两阶段提交不同的是，三阶段提交有两个改动点：</p>
<ul>
<li>引入超时机制，在协调者与参与者中都引入了超时机制。</li>
<li>在第一阶段与第二阶段中，插入了一个<code>准备阶段</code>。保证了在最后提交阶段之前，各参与节点的状态是一致的。故3PC有CanCommit，PreCommit，DoCommit。</li>
</ul>
<p>所以3PC处理流程如下：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727680774753-2f1543a6-0c4c-4e5c-a214-d22cc31374c1.webp"></p>
<h5 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title=" CanCommit阶段"></a><font style="color:rgb(37, 41, 51);"> CanCommit阶段</font></h5><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回yes，否则返回no。</p>
<ol>
<li><strong>事务询问：</strong> 协调者向参与者发送CanCommit请求，询问是否可以执行事务提交操作，然后开始等待答复。</li>
<li><strong>响应反馈：</strong> 参与者接到CanCommit请求后，如果可以顺利执行事务，则反馈yes响应，并进入<code>预备状态</code>，否则反馈no。</li>
</ol>
<h5 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a><font style="color:rgb(37, 41, 51);">PreCommit阶段</font></h5><p><code>协调者</code>根据<code>参与者</code>的反馈情况决定是否可以继续执行事务的<code>PreCommit</code>阶段。</p>
<p>有两种反馈情况：</p>
<p>一、所有的参与者都反馈yes响应，那么就会执行事务的<code>PreCommit</code>阶段。</p>
<ol>
<li><strong>发送预提交请求：</strong> 协调者向参与者发送<code>PreCommit</code>请求，并进入Prepared阶段。</li>
<li><strong>预提交事务：</strong> 参与者收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中 <strong>（但不提交事务）</strong> 。</li>
<li><strong>响应反馈：</strong> 如果参与者都成功了执行事务操作，则返回ack响应，同时开始等待最终命令。</li>
</ol>
<p>二、加入有任何一个参与者反馈no响应，或者等待超时之后，协调者也没收到参与者的反馈，那么就执行事务中断。</p>
<ol>
<li><strong>发送中断请求：</strong> 协调者向所有参与者发送abort请求。</li>
<li><strong>中断事务：</strong> 参与者收到协调者发送的abort请求后（或者超时后，仍未收到协调者的请求），开始执行事务的中断。</li>
</ol>
<h5 id="DoCommit阶段"><a href="#DoCommit阶段" class="headerlink" title="DoCommit阶段"></a><font style="color:rgb(37, 41, 51);">DoCommit阶段</font></h5><p>该阶段进行真正的事务提交，可以分为如下两种情况：</p>
<p><strong>一、执行事务提交：协调者收到所有参与者的ack信息，开始执行提交事务。</strong></p>
<ol>
<li>发送DoCommit请求：协调者收到参与者发送的ack响应后，那么就会从<code>预提交状态</code>进入到<code>提交状态</code>，并向所有的参与者发送DoCommit请求。</li>
<li>事务提交：参与者接收到协调者发送的DoCommit请求，开始执行事务提交操作，并在完成事务操作后释放所有的事务资源。</li>
<li>响应反馈：事务提交完成后，参与者向协调者发送ack信息。</li>
<li>事务完成：协调者受到所有参与者的ack信息后，完成事务。</li>
</ol>
<p><strong>二、中断事务：协调者没能收到所有参与者的ack信息，开始执行中断事务。</strong></p>
<ol>
<li>发送中断请求：协调者性所有的参与者发送abort请求。</li>
<li>事务回滚：参与者收到abort请求后，开始利用阶段2中记录的undo log执行事务的回滚操作，并在完成回滚后，释放所有的事务资源。</li>
<li>响应反馈：参与者完成事务回滚后，向协调者发送ack信息。</li>
<li>中断事务：协调者受到所有参与者的ack信息后，执行事务中断。</li>
</ol>
<p>在进入DoCommit阶段是，如果协调者或者参与者出现问题，导致参与者无法接收到协调者发出的<code>提交事务/中断事务</code>请求，此时，参与者都会在等待超时之后，继续执行事务提交。这是基于概率来决定，当进入第三阶段时，说明第一阶段，所有的参与者都同意进行修改操作，同时在第二阶段，所有的参与者都统一同意PreCommit操作。所以，如果在第三阶段，如果出现网络问题，虽然参与者没有收到commit&#x2F;abort请求，但是它有理由相信：成功提交的几率很大。</p>
<p><font style="color:rgb(37, 41, 51);">3PC的优缺点</font></p>
<p><font style="color:rgb(37, 41, 51);">与2PC相比，3PC降低了阻塞范围，并且在等待超时后，协调者或者参与者中断事务，避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务，可能造成数据不一致。</font></p>
<p><strong><font style="color:rgb(37, 41, 51);">2PC和3PC都无法保证数据绝对的一致性，一般为预防这种问题，可以提交一个告警。</font></strong></p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a><font style="color:rgb(77, 77, 77);">TCC</font></h3><p><strong><font style="color:rgb(37, 41, 51);">TCC：</font></strong><font style="color:rgb(37, 41, 51);"> </font><font style="color:rgb(37, 41, 51);">TCC（Try Confirm Cancel）是应用层的两阶段提交，所以对业务有侵入。</font></p>
<p><strong><font style="color:rgb(37, 41, 51);">核心思想：</font></strong><font style="color:rgb(37, 41, 51);"> 针对每个操作，都要实现对应的</font><code>&lt;font style=&quot;color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);&quot;&gt;确认&lt;/font&gt;</code><font style="color:rgb(37, 41, 51);">和</font><code>&lt;font style=&quot;color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);&quot;&gt;补偿&lt;/font&gt;</code><font style="color:rgb(37, 41, 51);">操作，也就是业务逻辑的每个分支，都要实现Try、Confirm、Cancel三个操作。</font></p>
<h4 id="TCC的执行流程"><a href="#TCC的执行流程" class="headerlink" title="TCC的执行流程"></a><font style="color:rgb(37, 41, 51);">TCC的执行流程</font></h4><p>TCC的执行过程可以分成两个阶段：</p>
<ol>
<li><strong>第一阶段：</strong> Try。该阶段，通过try操作做检测并预留资源。（比如：下单，在try阶段，并不是真正的扣减库存，只是把下单的库存进行锁定。）</li>
<li><strong>第二阶段：</strong> Confirm&#x2F;Cancel。根据第一阶段的结果决定是执行confirm还是cancel。<ol>
<li>Confirm：对Try阶段锁定的资源实际扣除。</li>
<li>Cancel：对Try阶段锁定的资源进行释放。</li>
</ol>
</li>
</ol>
<h4 id="TCC是如何保证最终一致性"><a href="#TCC是如何保证最终一致性" class="headerlink" title="TCC是如何保证最终一致性"></a><font style="color:rgb(37, 41, 51);">TCC是如何保证最终一致性</font></h4><ul>
<li>TCC是以Try为中心的，Confirm操作和Cancel操作都是围绕着Try展开的。所以在Try阶段保障性是最好的，即使出现失败，也可以通过Cancel操作将其执行结果撤销。</li>
<li>在Try阶段执行成功，并进入到Confirm阶段时，默认Confirm阶段是不会出错的，也就是说只要Try成功，Confirm一定成功（TCC设计之初的定义）。</li>
<li>Confirm和Cancel如果失败，则由TCC框架进行重试补偿（定时）。</li>
<li>但仍存在极低情况下在<strong>CC</strong>阶段彻底失败，则需要人工介入。</li>
</ul>
<h4 id="TCC的注意事项"><a href="#TCC的注意事项" class="headerlink" title=" TCC的注意事项"></a><font style="color:rgb(37, 41, 51);"> TCC的注意事项</font></h4><h5 id="1-允许空回滚："><a href="#1-允许空回滚：" class="headerlink" title="(1) 允许空回滚："></a>(1) 允许空回滚：</h5><p>空回滚的原因是Try阶段超时或者丢包，导致TCC二阶段进行回滚，触发Cancel操作，此时事务参与者可能可能未收到Try操作，但是收到了Cancel操作。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727681701463-5db96149-aabe-4002-aa6b-496cb9967df8.webp"></p>
<p>所以，Cancel操作在实现的时候需要允许空回滚，即在Cancel执行时，如果没有查到对应业务的Try操作时，也是需要返回成功，让事务管理器认为已回滚。</p>
<h5 id="2-防悬挂控制："><a href="#2-防悬挂控制：" class="headerlink" title="(2) 防悬挂控制："></a>(2) 防悬挂控制：</h5><p><strong>悬挂</strong>是指二阶段的Cancel比一阶段的Try操作先执行，出现该问题的原因是Try阶段由于网络拥堵而超时，导致事务管理器生成回滚，触发Cancel操作，但之后拥堵网络的Try又被资源管理器收到了，但是Cancel操作比Try操作先到。如果按照前面允许空回滚的逻辑，回滚是会成功，事务管理器认为回滚成功，所以，此时应该<code>拒绝</code>空回滚之后的Try操作，否则会产生数据不一致。</p>
<p>因此，我们在Cancel空回滚返回成功之前，应记录该条事务xid或者业务主键，标识该记录已经回滚过，Try操作在执行前先检查这条事务xid或者业务主键是否标记为回滚成功，如果是，则不执行Try操作。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727681701424-9de15540-02c8-47b1-9359-05020686875c.webp"></p>
<h5 id="3-幂等控制"><a href="#3-幂等控制" class="headerlink" title="(3) 幂等控制"></a>(3) 幂等控制</h5><p>由于网络原因或者重试操作都有可能导致Try - Confirm - Cancel三个操作重复执行，所以使用TCC时需要注意这三个操作的幂等控制。通常针对具体业务选择对应的<code>业务幂等键</code>来做防重控制。</p>
<h4 id="TCC方案的优缺点"><a href="#TCC方案的优缺点" class="headerlink" title="TCC方案的优缺点"></a><font style="color:rgb(37, 41, 51);">TCC方案的优缺点</font></h4><h6 id="TCC事务机制相比上面的2PC3PC事务机制，有如下优点："><a href="#TCC事务机制相比上面的2PC3PC事务机制，有如下优点：" class="headerlink" title="TCC事务机制相比上面的2PC3PC事务机制，有如下优点："></a>TCC事务机制相比上面的2PC3PC事务机制，有如下优点：</h6><ol>
<li>性能提升：具体业务实现，控制资源锁的粒度变小，不会锁定整个资源。</li>
<li>数据最终一致性：基于Confirm和Cancel操作的幂等性，确保事务最终完成或者取消，保证了数据一致性。</li>
<li>可靠性：解决了XA协议的协调者单点故障问题。由主业务发起并控制整个业务活动，业务活动管理器可以变成多点，引入集群。</li>
</ol>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>TCC的Try - Confirm - Cancel操作功能需要按具体业务实现，业务耦合度高，提高了开发成功。</p>
<h3 id="本地事务表"><a href="#本地事务表" class="headerlink" title="本地事务表"></a>本地事务表</h3><h4 id="什么是本地消息表"><a href="#什么是本地消息表" class="headerlink" title="什么是本地消息表"></a><font style="color:rgb(37, 41, 51);">什么是本地消息表</font></h4><p><strong>本地事务表</strong>的核心思路是将**<code>分布式事务</code><strong>拆分</strong><code>**成本地事务**</code><strong>进行处理，该方案中主要有两个角色：</strong><code>事务主动方</code><strong>和</strong><code>事务被动方</code>**。<br>**<code>事务主动方</code><strong>需要额外新建事务消息表，并在本地事务中完成业务处理和记录事务消息，并轮训事务消息表的数据发哦那个事务消息，</strong><code>事务被动方</code>**基于消息中间件消费事务消息表中的事务。</p>
<p>这样可以避免一下两种情况导致的数据不一致性：</p>
<ul>
<li>业务处理成功，事务消息发送失败。</li>
<li>业务处理失败，事务消息发送成功。</li>
</ul>
<h4 id="本地事务表的执行流程"><a href="#本地事务表的执行流程" class="headerlink" title="本地事务表的执行流程"></a><font style="color:rgb(37, 41, 51);">本地事务表的执行流程</font></h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727682899971-9cb09696-10ea-493b-998e-11ccc9a0eecf.webp"></p>
<ul>
<li>事务主动方在同一个本地事务中处理业务和写消息表操作。</li>
<li>事务主动方通过消息中间件发送消息，通知事务被动发处理事务消息。</li>
<li>事务被动方接收到消息后，处理业务逻辑。</li>
<li>事务被动方通过消息中间件发送消息，通知事务主动方事务已处理。</li>
<li>事务主动方接收到消息后，更新消息表的状态为已处理。</li>
</ul>
<h5 id="一些必要的容错处理如下"><a href="#一些必要的容错处理如下" class="headerlink" title="一些必要的容错处理如下"></a><font style="color:rgb(37, 41, 51);">一些必要的容错处理如下</font></h5><ul>
<li>当①处理出错，由于事务还在事务主动方的本地事务中，直接回滚即可。</li>
<li>当②、④、⑤处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，通知事务被动方重新读取消息处理业务即可。</li>
<li>当③业务上处理失败，事务被动方可以发送消息给事务主动方回滚事务。</li>
</ul>
<h4 id="本地消息表优缺点"><a href="#本地消息表优缺点" class="headerlink" title="本地消息表优缺点"></a><font style="color:rgb(37, 41, 51);">本地消息表优缺点</font></h4><h5 id="1-优点："><a href="#1-优点：" class="headerlink" title="1) 优点："></a>1) 优点：</h5><ul>
<li>由于写消息表和业务数据在同一个本地事务中处理，确保了消息数据的可靠性，消息数据可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<h5 id="2-缺点："><a href="#2-缺点：" class="headerlink" title="2) 缺点："></a>2) 缺点：</h5><ul>
<li>与具体业务场景绑定，耦合性强，不可公用。</li>
<li>消息数据和业务数据同库，占用业务系统资源。</li>
<li>由于需要将消息持久化到数据库中，消息服务性能会受到一定的影响。</li>
</ul>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a><font style="color:rgb(37, 41, 51);">事务消息</font></h3><h4 id="MQ事务消息执行流程"><a href="#MQ事务消息执行流程" class="headerlink" title="MQ事务消息执行流程"></a><font style="color:rgb(37, 41, 51);">MQ事务消息执行流程</font></h4><p>通过消息的异步事务，可以保证<code>本地事务</code>和<code>消息发送</code>同时执行成功或失败，既能实现系统间的解耦，又能保证数据的最终一致性。</p>
<p><code>本地消息表</code>方案中，<code>事务主动方</code>通过在<code>同一个本地事务</code>中写<code>业务数据</code>和<code>消息数据</code>来保证数据的一致性。而事务消息相对于普通的MQ提供了<code>2PC</code>的提交接口，流程如下：</p>
<h5 id="1-正常执行情况"><a href="#1-正常执行情况" class="headerlink" title="1) 正常执行情况"></a><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727683362207-58fe821c-381b-4aca-9f6e-d05b6833fbbf.webp">1) 正常执行情况</h5><p>在事务主动方服务正常，没有发生故障的情况下，发消息流程如下：</p>
<ul>
<li>步骤①：发送Half消息</li>
<li>步骤②：Half消息发送成功</li>
<li>步骤③：开始执行本地事务</li>
<li>步骤④：根据本地事务执行结果向MQ Server发送Commit&#x2F;Rollback。</li>
<li>最终步骤：MQ Server基于Commit&#x2F;Rollback进行消息投递或者删除。</li>
</ul>
<h5 id="2-异常情况"><a href="#2-异常情况" class="headerlink" title="2) 异常情况"></a>2) 异常情况</h5><p>在断网或者应用重启情况下，图中的步骤④Commit或者Rollback未到达MQ Server，此时处理逻辑如下：</p>
<ul>
<li>步骤⑤：MQ Server未收到二次确认消息，发起消息回查。</li>
<li>步骤⑥：收到消息回查后，需要检查对应消息的本地事务执行状态。</li>
<li>步骤⑦：根据检查的本地事务执行状态，再次向MQ发送Commit&#x2F;Rollback。</li>
<li>最终步骤：MQ Server基于Commit&#x2F;Rollback进行消息投递或者删除</li>
</ul>
<h4 id="MQ事务消息的优缺点"><a href="#MQ事务消息的优缺点" class="headerlink" title="MQ事务消息的优缺点"></a>MQ事务消息的优缺点</h4><h5 id="1-优点（-相较于本地消息表-）"><a href="#1-优点（-相较于本地消息表-）" class="headerlink" title="1) 优点（ 相较于本地消息表 ）"></a>1) 优点（ 相较于本地消息表 ）</h5><ul>
<li>消息数据独立存储，降低业务系统与消息系统的耦合性。</li>
<li>吞吐量有所提升。</li>
</ul>
<h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2) 缺点"></a>2) 缺点</h5><ul>
<li>一次消息发送需要两次网络请求（Half消息+Commit&#x2F;Rollback）。</li>
<li>业务处理服务需要实现消息状态回查接口。</li>
</ul>
<h4 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h4><p>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对接口，如果事务被动方没有接收到主动方发送的消息，此时可以调用事务主动方提供的消息校对接口<code>主动获取</code>。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727683362353-4ab255e2-2fa1-4673-a0cf-aac6358c75d5.webp"> 在可靠事务消息中，事务主动方需要将消息发送出去，并且让接收方成功接收消息，这种可靠性是由事务主动方保证的。</p>
<p>但是最大努力通知，事务主动方仅仅是做到尽最大努力（重试，轮询…）将信息发送给事务被动方，所以存在事务被动方接收不到信息的情况，所以需要事务被动发通过消息校对接口主动查询获取消息并消费，这种通知的可靠性是由事务被动方保证的。</p>
<p><strong>适用场景：</strong></p>
<p>适用于业务通知类型，如支付宝&#x2F;微信交易的结果，就是通过最大努力通知方式通知商户，既有回调通知，也有交易查询接口。</p>
<h3 id="分布式事务中间件Seata"><a href="#分布式事务中间件Seata" class="headerlink" title="分布式事务中间件Seata"></a>分布式事务中间件Seata</h3><h4 id="初识Seata"><a href="#初识Seata" class="headerlink" title="初识Seata"></a><font style="color:rgb(79, 79, 79);">初识Seata</font></h4><p><font style="color:rgb(77, 77, 77);">Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的</font><a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&spm=1001.2101.3001.7020"><font style="color:rgb(77, 77, 77);">分布式事务解决方案</font></a><font style="color:rgb(77, 77, 77);">。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</font></p>
<p><font style="color:rgb(77, 77, 77);">官网地址：</font><a href="http://seata.io/">http://seata.io/</a><font style="color:rgb(77, 77, 77);">，其中的文档、播客中提供了大量的使用说明、源码分析。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727683681068-3113ed0f-ef7b-438f-8112-1e6af770a110.png"></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<h4 id="Seata的架构"><a href="#Seata的架构" class="headerlink" title="Seata的架构"></a><font style="color:rgb(79, 79, 79);">Seata的架构</font></h4><p>Seata事务管理中有三个重要的角色：</p>
<ul>
<li>TC (Transaction Coordinator) - <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li>
<li>TM (Transaction Manager) - <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li>
<li>RM (Resource Manager) - <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p>整体的架构如图：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727683745367-07fb02a0-a23e-463f-940c-cf4d4ad22024.png"></p>
<p>Seata基于上述架构提供了四种不同的分布式事务解决方案：</p>
<ul>
<li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li>
<li>TCC模式：最终一致的分阶段事务模式，有业务侵入</li>
<li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li>
<li>SAGA模式：长事务模式，有业务侵入</li>
</ul>
<p>:::info<br>无论哪种方案，都离不开TC，也就是事务的协调者。</p>
<p>:::</p>
<p>这里XA模式可以理解为2PC或者3PC</p>
<p>TCC模式：上面已经讲过 </p>
<p>SAGA模式<font style="color:rgb(77, 77, 77);">和tcc很想,但是TCC操作的是冻结的预留数据,这个是直接操作数据</font></p>
<p>但是我们主要需要学习的是AT模式</p>
<h4 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h4><p><font style="color:rgb(77, 77, 77);">AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</font></p>
<h5 id="Seata的AT模型"><a href="#Seata的AT模型" class="headerlink" title="Seata的AT模型"></a><font style="color:rgb(79, 79, 79);">Seata的AT模型</font></h5><p><font style="color:rgb(77, 77, 77);">基本流程图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685192520-38d73085-a173-4ffb-ad7d-36010bf6b7a1.png"></p>
<h6 id="阶段一RM的工作："><a href="#阶段一RM的工作：" class="headerlink" title="阶段一RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段一RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">注册分支事务</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">记录undo-log（数据快照）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">执行业务sql并提交</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">报告事务状态</font></li>
</ul>
<h6 id="阶段二提交时RM的工作："><a href="#阶段二提交时RM的工作：" class="headerlink" title="阶段二提交时RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段二提交时RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">删除undo-log即可</font></li>
</ul>
<h6 id="阶段二回滚时RM的工作："><a href="#阶段二回滚时RM的工作：" class="headerlink" title="阶段二回滚时RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段二回滚时RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">根据undo-log恢复数据到更新前</font></li>
</ul>
<p>:::info<br><font style="color:rgb(85, 86, 102);">事务执行成功 删除快照 事务执行失败 同一回复到快照</font></p>
<p>:::</p>
<h5 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a><font style="color:rgb(79, 79, 79);">流程梳理</font></h5><p><font style="color:rgb(77, 77, 77);">我们用一个真实的业务来梳理下AT模式的原理。</font></p>
<p><font style="color:rgb(77, 77, 77);">比如，现在又一个数据库表，记录用户余额：</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);">id</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);">money</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">1</font></td>
<td><font style="color:rgb(79, 79, 79);">100</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">其中一个分支业务要执行的SQL为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tb_account set money = money - 10 where id = 1</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">AT模式下，当前分支事务执行流程如下：</font></p>
<p><font style="color:rgb(77, 77, 77);">一阶段：</font></p>
<p><font style="color:rgb(77, 77, 77);">1）TM发起并注册全局事务到TC</font></p>
<p><font style="color:rgb(77, 77, 77);">2）TM调用分支事务</font></p>
<p><font style="color:rgb(77, 77, 77);">3）分支事务准备执行业务SQL</font></p>
<p><font style="color:rgb(77, 77, 77);">4）RM拦截业务SQL，根据where条件查询原始数据，形成快照。</font></p>
<p><font style="color:rgb(77, 77, 77);">5）RM执行业务SQL，提交本地事务，释放数据库锁。此时</font><font style="color:rgb(77, 77, 77);"> </font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;money = 90&lt;/font&gt;</code></p>
<p><font style="color:rgb(77, 77, 77);">6）RM报告本地事务状态给TC</font></p>
<p><font style="color:rgb(77, 77, 77);">二阶段：</font></p>
<p><font style="color:rgb(77, 77, 77);">1）TM通知TC事务结束</font></p>
<p><font style="color:rgb(77, 77, 77);">2）TC检查分支事务状态</font></p>
<p><font style="color:rgb(77, 77, 77);">a）如果都成功，则立即删除快照</font></p>
<p><font style="color:rgb(77, 77, 77);">b）如果有分支事务失败，需要回滚。读取快照数据（</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;&#123;&quot;id&quot;: 1, &quot;money&quot;: 100&#125;&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">），将快照恢复到数据库。此时数据库再次恢复为100</font></p>
<p><font style="color:rgb(77, 77, 77);">流程图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685541924-773c552b-0b8a-411f-aebd-c538347de620.png"></p>
<h5 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a><font style="color:rgb(79, 79, 79);">AT与XA的区别</font></h5><p><font style="color:rgb(77, 77, 77);">简述AT模式与XA模式最大的区别是什么？</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式强一致；AT模式最终一致 中间状态是软提交</font></li>
</ul>
<h5 id="脏写问题"><a href="#脏写问题" class="headerlink" title="脏写问题"></a><font style="color:rgb(79, 79, 79);">脏写问题</font></h5><p>在多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p>
<p>假如多个线程操作同一事务,其中一个线程先拿到数据锁执行完sql 提交事务以后释放锁,另一个线程就能拿到锁在进行一次sql执行,并且线程一刚好完at模式中有个事务失败需要回滚,这个时候数据就脏写了</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685613699-c21e200f-32a7-47e9-a759-5cc24175eaa1.png"></p>
<p>解决思路就是引入了全局锁的概念。</p>
<p>在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685625629-d0eb8311-bbe7-4762-809c-a3752dde5983.png"></p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><font style="color:rgb(79, 79, 79);">优缺点</font></h5><p><font style="color:rgb(77, 77, 77);">AT模式的优点：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">一阶段完成直接提交事务,释放数据库资源，性能比较好</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">利用全局锁实现读写隔离</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">没有代码侵入，框架自动完成回滚和提交</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">AT模式的缺点：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">两阶段之间属于软状态，属于最终一致</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">框架的快照功能会影响性能，但比XA模式要好很多</font></li>
</ul>
<p>:::info<br><font style="color:rgb(85, 86, 102);">XA事务的强一致性是通过事务等待来实现的,分支事务等待所有事务完成才能进行提交,提交后才能释放锁sql锁,对性能一致处于消耗,AT模式是直接先进性提交 然后释放sql锁,最后靠全局锁来实现防止脏数据,且回复靠快照,无序等待事务链中所有数据</font></p>
<p>:::</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>在现实的架构设计中分布式事务，我们一般会本地事务表和seata结合使用，本地事务表来实现最终一致性，用来实现可以允许一定程度的不一致，但是最终结果一致的业务，比如涉及到第三方的支付，开票，优惠结算等。seata我们一般使用AT来实现一些要求强一致性的业务，比如下单库存扣减之类的场景。在实际的开发中我们应该尽量避免使用事务，因为涉及到第三方系统的可用性隐患+1，而且数据覆写需要尽量避免掉</p>
<p><font style="color:rgb(79, 79, 79);"></font></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务中的SpringCloudGateway如何传递用户信息</title>
    <url>/2024/10/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84SpringCloudGateway%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>我们在权限验证中提到了在网关中会通过缓存取出用户数据。当我们获取到用户信息后应该怎么传递下去，有两种方案：</p>
<p>一种是通过redis对数据进行存储，在不同的服务中通过同一个redis进行调用。</p>
<p>第二种：在SpringCloudGateway中将数据取出后放入请求头，然后通过请求头进行传输</p>
<span id="more"></span>
<p>第一种方案的弊端很明显，需要多次的进行redis链接，增加了redis的负担，也增加了系统的不稳定性</p>
<p>所以我们这次的实现以第二种方法为主</p>
<p> 代码实现：</p>
<p>网关处获取到用户信息，通过定义header头信息将用户信息进行传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String loginUserKey  = String.format(&quot;%S%S&quot;, SecurityConstants.USER_KEY, token);</span><br><span class="line">      if (distributedCache.hasKey(loginUserKey)) &#123;</span><br><span class="line">          LoginUser loginUser= distributedCache.get(loginUserKey, LoginUser.class);</span><br><span class="line">          if (loginUser != null)&#123;</span><br><span class="line">              addHeader(mutate, SecurityConstants.USER_ID_HEADER, loginUser.getUserId(),false);</span><br><span class="line">              addHeader(mutate, SecurityConstants.USER_NAME_HEADER, loginUser.getUserName(),false);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>在服务中我们通过拦截器对请求进行拦截，通过拦截器来实现header头文件中的用户信息捕捉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserTokenHandlerInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String userId = request.getHeader(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">        String userName = request.getHeader(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">        RequestHeaderContextHolder.getInstance().setCurrentUser(userId, userName);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        RequestHeaderContextHolder.getInstance().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spring中注册拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WebMvcConfigurerAdaptor implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new UserTokenHandlerInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就可以在服务中获取到用户信息</p>
<p>小结：</p>
<p>本文主要讲的spingcloud gateway中实现健权后如何将用户信息进行传递，通过拦截器以及网关传递轻松的实现了用户身份的传递</p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign调用时如何传递传递Token并且多线程环境也能适用</title>
    <url>/2024/10/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="为什么要自定义负载均衡"><a href="#为什么要自定义负载均衡" class="headerlink" title="为什么要自定义负载均衡"></a>为什么要自定义负载均衡</h2><p>在实际的开发中总是会遇到如下的场景：A,B两个成员一起开发，A在开发C服务，B在开发D服务，测试环境中也部署有C服务和D服务，A和B的诉求是不互相干扰对方。但是实际中nacos中注册了服务之后默认的负载策略是根据权重来决定访问哪个服务，当权重一致时就是各50%的访问，很容易就对其他成员造成干扰，所以我们需要一个自定义负载均衡器来做一个分流。</p>
<h2 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h2><p>在springcloud的解决方案中负载均衡器使用的LoadBalancer框架，我们需要实现ReactorServiceInstanceLoadBalancer接口来完成自定义负载均衡。所以我们的思路就是在网关中进行打标，然后通过自定义负载均衡器来确定具体调用的服务。</p>
<span id="more"></span>
<h3 id="网关处理打标"><a href="#网关处理打标" class="headerlink" title="网关处理打标"></a>网关处理打标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class LoadBalancerFilter  implements GlobalFilter, Ordered &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloLoadBalancerProperties pomeloLoadBalancerProperties;</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">        //灰度标识分两种情况，1.通过header传过来，2.通过url传过来</span><br><span class="line">        String gray = request.getHeaders().getFirst(&quot;gray&quot;);</span><br><span class="line">        if (StrUtil.isNotEmpty(gray)) &#123;</span><br><span class="line">            HeaderUtils.addHeader(mutate, pomeloLoadBalancerProperties.getHeader(), gray, true);</span><br><span class="line">            return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        String grayUrl = request.getQueryParams().getFirst(&quot;gray&quot;);</span><br><span class="line">        if (StrUtil.isNotEmpty(grayUrl)) &#123;</span><br><span class="line">            HeaderUtils.addHeader(mutate, pomeloLoadBalancerProperties.getHeader(), grayUrl, true);</span><br><span class="line">            return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自定义负载均衡处理器"><a href="#自定义负载均衡处理器" class="headerlink" title="自定义负载均衡处理器"></a>自定义负载均衡处理器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloLoadBalancer implements ReactorServiceInstanceLoadBalancer &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(PomeloLoadBalancer.class);</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloLoadBalancerProperties pomeloLoadBalancerProperties;</span><br><span class="line"></span><br><span class="line">    private final ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider;</span><br><span class="line">    private final String serviceId;</span><br><span class="line"></span><br><span class="line">    private final AtomicInteger position;</span><br><span class="line"></span><br><span class="line">    public PomeloLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider</span><br><span class="line">            , String serviceId,PomeloLoadBalancerProperties pomeloLoadBalancerProperties) &#123;</span><br><span class="line">        this(serviceInstanceListSupplierProvider,serviceId,new Random().nextInt(1000),pomeloLoadBalancerProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PomeloLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider,</span><br><span class="line">                              String serviceId, int seedPosition,</span><br><span class="line">                              PomeloLoadBalancerProperties pomeloLoadBalancerProperties) &#123;</span><br><span class="line">        this.serviceId = serviceId;</span><br><span class="line">        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;</span><br><span class="line">        this.position = new AtomicInteger(seedPosition);</span><br><span class="line">        this.pomeloLoadBalancerProperties = pomeloLoadBalancerProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123;</span><br><span class="line">        ServiceInstanceListSupplier supplier = this.serviceInstanceListSupplierProvider</span><br><span class="line">                .getIfAvailable(NoopServiceInstanceListSupplier::new);</span><br><span class="line">        return supplier.get(request).next()</span><br><span class="line">                .map(serviceInstances -&gt; processInstanceResponse(serviceInstances,request));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 灰度处理</span><br><span class="line">     * @param instances</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Response&lt;ServiceInstance&gt; processInstanceResponse(List&lt;ServiceInstance&gt; instances, Request request) &#123;</span><br><span class="line">        if (instances.isEmpty()) &#123;</span><br><span class="line">            return new EmptyResponse();</span><br><span class="line">        &#125;</span><br><span class="line">        DefaultRequestContext requestContext = (DefaultRequestContext) request.getContext();</span><br><span class="line">        RequestData clientRequest = (RequestData) requestContext.getClientRequest();</span><br><span class="line">        HttpHeaders headers = clientRequest.getHeaders();</span><br><span class="line">        // get Request Header</span><br><span class="line">        String reqVersion = headers.getFirst(pomeloLoadBalancerProperties.getHeader());</span><br><span class="line"></span><br><span class="line">        List&lt;ServiceInstance&gt; normalServiceInstances = instances.stream()</span><br><span class="line">                .filter(instance -&gt; !instance.getMetadata().containsKey(pomeloLoadBalancerProperties.getHeader()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        log.debug(&quot;X-Pomelo-LoadBalancer:&#123;&#125;&quot;,reqVersion);</span><br><span class="line">        if (!StrUtil.isEmpty(reqVersion)) &#123;</span><br><span class="line">            // filter service instances</span><br><span class="line">            List&lt;ServiceInstance&gt; gsServiceInstances = instances.stream()</span><br><span class="line">                    .filter(instance -&gt; reqVersion.equals(instance.getMetadata().get(pomeloLoadBalancerProperties.getHeader())))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">            if (gsServiceInstances.size() &gt; 0) &#123;</span><br><span class="line">                return processRibbonInstanceResponse(gsServiceInstances);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return processRibbonInstanceResponse(normalServiceInstances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 负载均衡器</span><br><span class="line">     * 参考 org.springframework.cloud.loadbalancer.core.RoundRobinLoadBalancer#getInstanceResponse</span><br><span class="line">     */</span><br><span class="line">    private Response&lt;ServiceInstance&gt; processRibbonInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123;</span><br><span class="line">        int pos = Math.abs(this.position.incrementAndGet());</span><br><span class="line">        ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line">        return new DefaultResponse(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>nacos</tag>
        <tag>脚手架</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装mysql8</title>
    <url>/2023/06/15/Centos7%E5%AE%89%E8%A3%85mysql8/</url>
    <content><![CDATA[<h4 id="1-下载mysql8安装包"><a href="#1-下载mysql8安装包" class="headerlink" title="1.下载mysql8安装包"></a>1.下载mysql8安装包</h4><p> 下载安装包需要到官网上直接下载，下载地址：</p>
<p><a href="https://www.mysql.com/downloads/">https://www.mysql.com/downloads/</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655968595661-5eabc2f9-9c20-48d7-9b40-ad2981566a92.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655969188020-f03f92d2-3da0-4999-b075-b024647674f0.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655969237916-c02ff7c1-1ba2-4c01-bedb-af80b7139851.png"></p>
<span id="more"></span>
<p>选择服务器对应的版本下载RPM</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655969724257-181c08ba-4a94-4972-9688-74dc2faf4be4.png"></p>
<h4 id="2-安装mysql"><a href="#2-安装mysql" class="headerlink" title="2.安装mysql"></a>2.安装mysql</h4><p>解压文件后获得</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655969975657-46e50cd0-ccd4-42e9-8712-77a2c8cabd9a.png"></p>
<p>实际并不需要这么多的包只需要</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655973216196-7db70d10-31a4-4410-a6c6-1e60c703a075.png"></p>
<p>将下载好的文件放入&#x2F;opt&#x2F;server文件夹中</p>
<p>然后查看依赖是否安装</p>
<ul>
<li><font style="color:rgb(51, 51, 51);">libaio</font></li>
</ul>
<p><font style="background-color:#FADB14;">rpm -qa|grep libaio</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655971393997-06dc71b6-95b0-483c-81b1-1f259b8de304.png"></p>
<p><font style="color:rgb(77, 77, 77);">如图，如果存在libaio的字样说明有libaio相关依赖，否则执行下面命令，进行依赖的安装：</font></p>
<p><font style="background-color:#FADB14;">yum install libaio</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">net-tools</font></li>
</ul>
<p><font style="background-color:#FADB14;">rpm -qa|grep net-tools</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655971602253-f483ab6e-beef-4346-98fe-d7f0aec95d80.png"></p>
<p><font style="color:rgb(77, 77, 77);">如图，如果存在</font><font style="color:rgb(51, 51, 51);">net-tools</font><font style="color:rgb(77, 77, 77);">的字样说明有</font><font style="color:rgb(51, 51, 51);">net-tools</font><font style="color:rgb(77, 77, 77);">相关依赖，否则执行下面命令，进行依赖的安装：</font><font style="background-color:#FADB14;">rpm -qa|grep net-tools</font></p>
<p><font style="background-color:#FADB14;"></font></p>
<p>接下来是安装过程：</p>
<p>首先要进入到文件所在的文件下</p>
<p><font style="background-color:#FADB14;">cd &#x2F;opt&#x2F;server&#x2F;mysql</font></p>
<p><font style="background-color:#FADB14;"></font></p>
<p>然后执行安装指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rmp -ivh mysql-community-client-plugins-8.0.29-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-icu-data-files-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-8.0.29-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">在安装第三个包的时候如果出现如下错误：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655973480139-84c03370-8697-4feb-a4e0-705266488e04.png"></p>
<p><font style="color:rgb(77, 77, 77);">需要解除之前安装过的依赖即可，执行下面命令：</font></p>
<p><font style="background-color:#FADB14;">yum remove mysql-libs</font></p>
<p><font style="color:rgb(77, 77, 77);">在安装地五个包的时候如果出现如下错误：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655973545638-bf8a4294-bae2-448c-bf6f-87f4ed90f500.png"></p>
<p><font style="color:rgb(77, 77, 77);">需要安装libnuma依赖，执行如下命令解决：</font></p>
<p><font style="background-color:#FADB14;">yum install libnuma*</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">检测是否安装成功</font></strong></p>
<p><font style="background-color:#FADB14;">rpm -qa|grep -i mysql</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655973593040-c581901d-60c6-4f87-ac2b-97548bcfaf31.png"></p>
<p><font style="color:rgb(77, 77, 77);">如果成功显示上面安装的6个包，说明安装成功。</font></p>
<h4 id="3-设置权限"><a href="#3-设置权限" class="headerlink" title="3.设置权限"></a>3.设置权限</h4><p><font style="color:rgb(77, 77, 77);">如果你是以root身份安装和允许mysql服务，为了保证数据库目录与文件（默认&#x2F;var&#x2F;lib&#x2F;mysql下）的所有者为mysql用户，需要执行下面的命令初始化：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --user=mysql</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">–initialize选项默认以安全模式来初始化，则会为root用户生成一个临时密码，并将该密码标记为过期，登录后不能做其他任何操作，需要重新设置一个新的密码。生成的临时密码会记录在日志中，使用如下命令查看日志：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655974562598-3be22c55-9a64-4951-b213-153e0a91b5ea.png"></p>
<p>先启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start|stop|restart mysqld</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">其中start|stop|restart分别为启动、停止和重启mysql服务。</font></p>
<p><font style="color:rgb(77, 77, 77);">如果需要开机自启动需要：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld</span><br></pre></td></tr></table></figure>

<p>然后先使用临时密码登陆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">回车并输入临时密码登录，登录成功后，执行如下命令修改密码：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Your New Password&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="4-开启远程"><a href="#4-开启远程" class="headerlink" title="4.开启远程"></a>4.开启远程</h4><p>如果是在远程服务器上安装服务需要打开远程设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql</span><br><span class="line">update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-优化配置"><a href="#5-优化配置" class="headerlink" title="5.优化配置"></a>5.优化配置</h4><p><font style="color:rgb(85, 85, 85);">SQL执行慢有时候不一定完全是SQL问题，手动安装一台数据库而不做任何参数调整，再怎么优化SQL都无法让其性能最大化。要让一台数据库实例完全发挥其性能，首先我们就得先优化数据库的实例参数。</font></p>
<p><font style="color:rgb(85, 85, 85);">数据库实例参数优化遵循三句口诀：</font><strong><font style="color:rgb(85, 85, 85);">日志不能小、缓存足够大、连接要够用。</font></strong></p>
<p><font style="color:rgb(85, 85, 85);">所以数据库事务提交后需要将事务对数据页的修改刷（ fsync）到磁盘上，才能保证数据的持久性。这个刷盘，是一个随机写，性能较低，如果每次事务提交都要刷盘，会极大影响数据库的性能。数据库在架构设计中都会采用如下两个优化手法：</font></p>
<ul>
<li><font style="color:rgb(85, 85, 85);">先将事务写到日志文件RedoLog（WAL），将随机写优化成顺序写</font></li>
<li><font style="color:rgb(85, 85, 85);">加一层缓存结构Buffer，将单次写优化成顺序写</font></li>
</ul>
<p><font style="color:rgb(85, 85, 85);">所以日志跟缓存对数据库实例尤其重要。而连接如果不够用，数据库会直接抛出异常，系统无法访问。，以下是常见的优化项或者需要修改的项</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(85, 85, 85);">参数分类</font></strong></th>
<th><strong><font style="color:rgb(85, 85, 85);">参数名</font></strong></th>
<th><strong><font style="color:rgb(85, 85, 85);">参数值</font></strong></th>
<th><strong><font style="color:rgb(85, 85, 85);">备注</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(85, 85, 85);">数据缓存</font></td>
<td><font style="color:rgb(85, 85, 85);">INNODB_BUFFER_POOL_SIZE</font></td>
<td><font style="color:rgb(85, 85, 85);">物理内存50-80%</font></td>
<td><font style="color:rgb(85, 85, 85);">一般来说越大性能越好</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">日志相关</font></td>
<td><font style="color:rgb(85, 85, 85);">Innodb_log_buffer_size</font></td>
<td><font style="color:rgb(85, 85, 85);">16-32M</font></td>
<td><font style="color:rgb(85, 85, 85);">根据运行情况调整</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">日志相关</font></td>
<td><font style="color:rgb(85, 85, 85);">sync_binlog</font></td>
<td><font style="color:rgb(85, 85, 85);">1、100、0</font></td>
<td><font style="color:rgb(85, 85, 85);">1安全性最好</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">监听及连接</font></td>
<td><font style="color:rgb(85, 85, 85);">max_connections</font></td>
<td><font style="color:rgb(85, 85, 85);">根据业务情况调整</font></td>
<td><font style="color:rgb(85, 85, 85);">可以预留一部分值</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">文件读写性能</font></td>
<td><font style="color:rgb(85, 85, 85);">innodb_flush_log_at_trx_commit</font></td>
<td><font style="color:rgb(85, 85, 85);">2</font></td>
<td><font style="color:rgb(85, 85, 85);">安全和性能的折中考虑</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">其他</font></td>
<td><font style="color:rgb(85, 85, 85);">wait_timeout，interactive_timeout</font></td>
<td><font style="color:rgb(85, 85, 85);">28800</font></td>
<td><font style="color:rgb(85, 85, 85);">避免应用连接定时中断</font></td>
</tr>
<tr>
<td>端口</td>
<td><font style="color:rgb(77, 77, 77);">port</font></td>
<td>非3306的值</td>
<td>基于数据库安全</td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">日志相关</font></td>
<td><font style="color:rgb(77, 77, 77);">log-bin</font></td>
<td>&#x2F;opt&#x2F;date</td>
<td>binglog日志的存放地址</td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">日志相关</font></td>
<td><font style="color:rgb(77, 77, 77);">expire_logs_days </font></td>
<td>7</td>
<td><font style="color:rgb(77, 77, 77);"> 只保留 7 天的日志文件（需要重启mysql数据库）</font></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>工具</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL快速清空数据库中的所有表</title>
    <url>/2023/06/15/MySQL%E7%94%A8truncate%E5%91%BD%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%B8%85%E7%A9%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="先执行sql语句讲要情况的数据库中的数据库变成执行语句"><a href="#先执行sql语句讲要情况的数据库中的数据库变成执行语句" class="headerlink" title="先执行sql语句讲要情况的数据库中的数据库变成执行语句"></a>先执行sql语句讲要情况的数据库中的数据库变成执行语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select CONCAT(&#x27;truncate TABLE &#x27;,table_schema,&#x27;.&#x27;,TABLE_NAME, &#x27;;&#x27;) from INFORMATION_SCHEMA.TABLES where table_schema =&quot;数据库&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="执行sql后将结果复制出来"><a href="#执行sql后将结果复制出来" class="headerlink" title="执行sql后将结果复制出来"></a>执行sql后将结果复制出来</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655362274515-0b955c92-36af-4b47-b88b-98ea9c8a2fe2.png"></p>
<h3 id="再次执行结果拼接成的sql语句"><a href="#再次执行结果拼接成的sql语句" class="headerlink" title="再次执行结果拼接成的sql语句"></a>再次执行结果拼接成的sql语句</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655362297359-e7698f2a-6388-4c50-bdf9-b40e1e42789b.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用函数</title>
    <url>/2023/06/15/Mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="字符串函数："><a href="#字符串函数：" class="headerlink" title="字符串函数："></a><font style="color:rgb(77, 77, 77);">字符串函数：</font></h4><table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">CANCAT(S1,S2,…Sn)</font></td>
<td><font style="color:rgb(79, 79, 79);">连接 S1,S2,…Sn 为一个字符串</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">LENGTH(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">计算字符串长度函数，返回字符串的字节长度</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">LEFT(s，n)</font></td>
<td><font style="color:rgb(79, 79, 79);">函数返回字符串 s 最左边的 n 个字符，s&#x3D;1表示第一个字符</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">RIGHT(s，n)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">函数返回字符串 s 最右边的 n 个字符</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">LOWER(str)</font></td>
<td><font style="color:rgb(79, 79, 79);">将字符串str中所有字符变为小写</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">UPPER(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">将字符串str中所有字符变为大写</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">LTRIM(str)</font></td>
<td><font style="color:rgb(79, 79, 79);">去掉字符串str左侧的空格</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">RTRIM(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">去掉字符串str行尾的空格</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">REPLACE(str,a,b)</font></td>
<td><font style="color:rgb(79, 79, 79);">用字符串b替换字符串str中所有出现的字符串a</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">TRIM(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">去掉字符串行尾和行头的空格</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">substr&#x2F;substring</font></td>
<td><font style="color:rgb(79, 79, 79);">截取字符串，返回从指定位置开始的指定长度的字符换</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">reverse(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</font></td>
</tr>
</tbody></table>
<span id="more"></span>

<p><font style="color:rgb(77, 77, 77);">substring使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 12  6</span><br><span class="line">select length(&#x27;javacode2018&#x27;),length(&#x27;路人&#x27;);</span><br><span class="line">-- 路人    路人甲JAVA </span><br><span class="line">select left(&#x27;路人甲JAVA&#x27;,2),left(&#x27;路人甲JAVA&#x27;,10);</span><br><span class="line">/** 第三个字符之后的子字符串：inese **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27;, 3);</span><br><span class="line">/** 倒数第三个字符之后的子字符串：ese **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27;, -3);</span><br><span class="line">/** 第三个字符之后的两个字符：in **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27;, 3, 2);</span><br><span class="line">/** 倒数第三个字符之后的两个字符：es **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27;, -3, 2);</span><br><span class="line">/** 第三个字符之后的子字符串：inese **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27; FROM 3);</span><br><span class="line">/** 倒数第三个字符之后的子字符串：ese **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27; FROM -3);</span><br><span class="line">/** 第三个字符之后的两个字符：in **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27; FROM 3 FOR 2);</span><br><span class="line">/** 倒数第三个字符之后的两个字符：es **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27; FROM -3 FOR 2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数:"></a><font style="color:rgb(79, 79, 79);">数值函数:</font></h4><table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">ABS(x)</font></td>
<td><font style="color:rgb(79, 79, 79);">返回 x 的绝对值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">SQRT(x)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">返回 x 的求二次方根</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">CEIL(x)&#x2F;CEILING(x)</font></td>
<td><font style="color:rgb(79, 79, 79);">返回大于 x 的最小整数值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">FLOOR(x)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">返回小于 x 的最大整数值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">MOD(x，y)</font></td>
<td><font style="color:rgb(79, 79, 79);">返回 x&#x2F;y 的模</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">RAND()</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">返回 0 到 1 内的随机值。传入整数参数时，用来产生重复序列</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">ROUND(x,y)</font></td>
<td><font style="color:rgb(79, 79, 79);">返回参数 x 的四舍五入的有 y 位小数的值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">POW(x,y)&#x2F;POWER(x,y)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">返回计算x的y次方</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 5  NULL</span><br><span class="line">select sqrt(25),sqrt(-9);</span><br><span class="line">-- -2  3</span><br><span class="line">select ceil(-2.5),ceiling(2.5);</span><br><span class="line">-- 5  5  -4  -5</span><br><span class="line">select floor(5),floor(5.66),floor(-4),floor(-4.66);</span><br><span class="line">-- -7   -8   3</span><br><span class="line">select round(-6.6),round(-8.44),round(3.44);</span><br><span class="line">-- 0.04   1000</span><br><span class="line">select pow(5,-2),pow(10,3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数:"></a><font style="color:rgb(79, 79, 79);">日期时间函数:</font></h4><table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CURDATE()</font><font style="color:rgb(79, 79, 79);"> &#x2F; </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">current_date()</font></td>
<td><font style="color:rgb(79, 79, 79);">当前日期</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CURTIME()</font><font style="color:rgb(79, 79, 79);"> &#x2F; </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">current_time()</font></td>
<td><font style="color:rgb(79, 79, 79);">当前时间</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">NOW()</font><font style="color:rgb(79, 79, 79);"> &#x2F; </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sysdate()</font></td>
<td><font style="color:rgb(79, 79, 79);">当前的日期和时间</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UNIX_TIMESTAMP(date)</font></td>
<td><font style="color:rgb(79, 79, 79);">获取日期date的UNIX 时间戳</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FROM_UNIXTIME</font></td>
<td><font style="color:rgb(79, 79, 79);">将UNIX 时间戳格式化</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">dayofweek</font></td>
<td><font style="color:rgb(79, 79, 79);">获取指定日期是一周中是第几天，返回值范围是1~7,1&#x3D;周日</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">WEEK(date)</font></td>
<td><font style="color:rgb(79, 79, 79);">日期 date 为一年中的第几周，返回值的范围是否为 0-52 或 1-53</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">dayofyear</font></td>
<td><font style="color:rgb(79, 79, 79);">获取指定曰期是一年中的第几天，返回值范围是1~366</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">YEAR(date)</font></td>
<td><font style="color:rgb(79, 79, 79);">日期 date 的年份</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">dayofmonth</font></td>
<td><font style="color:rgb(79, 79, 79);">获取指定日期是一个月中是第几天，返回值范围是1~31</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">HOUR(time)</font></td>
<td><font style="color:rgb(79, 79, 79);">time 的小时值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">MINUTE(time)</font></td>
<td><font style="color:rgb(79, 79, 79);">time 的分钟值</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATE_FORMAT</font><font style="color:rgb(79, 79, 79);">(date,fmt)</font></td>
<td><font style="color:rgb(79, 79, 79);">按字符串 fmt 格式化日期 date 值</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATE_ADD</font><font style="color:rgb(79, 79, 79);">(date,INTERVAL expr type)&#x2F;adddate</font></td>
<td><font style="color:rgb(79, 79, 79);">一个日期或时间值加上一个时间间隔的时间值</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATE_SUB</font><font style="color:rgb(79, 79, 79);">&#x2F;subdate</font></td>
<td><font style="color:rgb(79, 79, 79);">都是向日期减去指定的时间间隔</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATEDIFF</font><font style="color:rgb(79, 79, 79);">(expr,expr2)</font></td>
<td><font style="color:rgb(79, 79, 79);">起始时间 expr 和结束时间 expr2 之间的天数</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 2019-09-17 16:13:28   2019-09-17 16:13:28</span><br><span class="line">select now(),sysdate();</span><br><span class="line">-- 12</span><br><span class="line">select month(&#x27;2017-12-15&#x27;);</span><br><span class="line">-- 1</span><br><span class="line">select dayofmonth(&#x27;2019-01-01&#x27;);</span><br><span class="line">-- 2019-01-11</span><br><span class="line">select date_add(&#x27;2019-01-01&#x27;,INTERVAL 10 day);</span><br><span class="line">-- 2018-12-22</span><br><span class="line">select date_sub(&#x27;2019-01-01&#x27;,INTERVAL 10 day);</span><br><span class="line">-- 1</span><br><span class="line">select datediff(&#x27;2017-11-30&#x27;,&#x27;2017-11-29&#x27;);</span><br><span class="line">-- 20171130</span><br><span class="line">select date_format(&#x27;2017-11-30&#x27;,&#x27;%Y%m%d&#x27;);</span><br><span class="line">-- 1</span><br><span class="line">select weekday(now());</span><br><span class="line">-- 1303195194 </span><br><span class="line">select unix_timestamp();</span><br><span class="line">-- 2020-06-19 00:00:00</span><br><span class="line">SELECT FROM_UNIXTIME(1592515200, &#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数:"></a><font style="color:rgb(79, 79, 79);">流程函数:</font></h4><p><font style="color:rgb(77, 77, 77);">主要指case…when…函数：</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">IF(expr,v1,v2)</font></td>
<td><font style="color:rgb(79, 79, 79);">当 expr 为真是返回 v1 的值，否则返回 v2</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">IFNULL(v1,v2)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">v1为空返回v2，否则返回v1</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">case</font></td>
<td><font style="color:rgb(79, 79, 79);">多条件判断</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">case语句有2种写法：</font></p>
<p>:::tips<br>CASE &lt;表达式&gt;</p>
<p> WHEN &lt;值1&gt; THEN &lt;操作&gt;</p>
<p> WHEN &lt;值2&gt; THEN &lt;操作&gt;</p>
<p> …</p>
<p> ELSE &lt;操作&gt;</p>
<p>END CASE;</p>
<p>CASE</p>
<p> WHEN &lt;条件1&gt; THEN &lt;命令&gt;</p>
<p> WHEN &lt;条件2&gt; THEN &lt;命令&gt;</p>
<p> …</p>
<p> ELSE commands</p>
<p>END CASE;</p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1 x yes</span><br><span class="line">select if(1&lt;2,1,0) c1,if(1&gt;5,&#x27;√&#x27;,&#x27;×&#x27;) c2,if(strcmp(&#x27;abc&#x27;,&#x27;ab&#x27;),&#x27;yes&#x27;,&#x27;no&#x27;) c3;</span><br><span class="line">-- 12345  非空</span><br><span class="line">select ifnull(null,&#x27;12345&#x27;),ifnull(&#x27;非空&#x27;,&#x27;为空&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数:"></a><font style="color:rgb(79, 79, 79);">聚合函数:</font></h4><p><font style="color:rgb(77, 77, 77);">分组时，可以使用聚合函数。</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">max</font></td>
<td><font style="color:rgb(79, 79, 79);">查询指定列的最大值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">min</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">查询指定列的最小值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">count</font></td>
<td><font style="color:rgb(79, 79, 79);">统计查询结果的行数</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">sum</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">求和，返回指定列的总和</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">avg</font></td>
<td><font style="color:rgb(79, 79, 79);">求平均值，返回指定列数据的平均值</font></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/2023/06/15/Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><font style="color:rgb(77, 77, 77);">Mysql提供了多种数据类型，主要包括数值型、字符串类型、日期和时间类型。接下来以Mysql5.0为例，详细介绍Mysql中的各种数据类型。</font></p>
<span id="more"></span>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a><font style="color:rgb(79, 79, 79);">数值类型</font></h2><h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a><font style="color:rgb(79, 79, 79);">整数类型</font></h5><table>
<thead>
<tr>
<th><font style="color:rgb(79, 79, 79);"></font></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字节</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最小值</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最大值</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);">备注</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">TINYINT</font></td>
<td>1</td>
<td><font style="color:rgb(79, 79, 79);">有符号-128(-2</font><sup><font style="color:rgb(79, 79, 79);">7</font></sup><font style="color:rgb(79, 79, 79);">)</font>   <font style="color:rgb(79, 79, 79);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);">有符号127(2</font><sup><font style="color:rgb(79, 79, 79);">7</font></sup><font style="color:rgb(79, 79, 79);">-1)</font>   <font style="color:rgb(79, 79, 79);">无符号255(2</font><sup><font style="color:rgb(79, 79, 79);">8</font></sup><font style="color:rgb(79, 79, 79);">-1)</font></td>
<td><font style="color:rgb(79, 79, 79);">很小的整数</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">SMALLINT</font></td>
<td>2</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">有符号-32768(-2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">15</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">)</font>   <font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">有符号32767(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">15</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)</font>   <font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">无符号65535(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">16</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">小的整数</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">MEDIUMINT</font></td>
<td>3</td>
<td><font style="color:rgb(79, 79, 79);">   </font><font style="color:rgb(79, 79, 79);">有符号- 8388608(-2</font><sup><font style="color:rgb(79, 79, 79);">23</font></sup><font style="color:rgb(79, 79, 79);">)   </font><font style="color:rgb(79, 79, 79);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);">有符号8388607(2</font><sup><font style="color:rgb(79, 79, 79);">23</font></sup><font style="color:rgb(79, 79, 79);">-1)</font>   <font style="color:rgb(79, 79, 79);">无符号1677215(2</font><sup><font style="color:rgb(79, 79, 79);">24</font></sup><font style="color:rgb(79, 79, 79);">-1)</font></td>
<td><font style="color:rgb(79, 79, 79);">中等大小的整数</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">INT</font><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">、INTEGER</font></td>
<td>4</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">有符号- 2147483648(-2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">31</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">)</font>   <font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">有符号2147483647(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">31</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)</font>   <font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">无符号4294967295(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">32</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">普通大小的整数</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">BIGINT</font></td>
<td>8</td>
<td><font style="color:rgb(79, 79, 79);">有符号-9223372036854775808(-2</font><sup><font style="color:rgb(79, 79, 79);">63</font></sup><font style="color:rgb(79, 79, 79);">)</font>   <font style="color:rgb(79, 79, 79);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);">有符号9223372036854775807(2</font><sup><font style="color:rgb(79, 79, 79);">63</font></sup><font style="color:rgb(79, 79, 79);">-1)</font>   <font style="color:rgb(79, 79, 79);">无符号18446744073709551615(2</font><sup><font style="color:rgb(79, 79, 79);">64</font></sup><font style="color:rgb(79, 79, 79);">-1)</font></td>
<td><font style="color:rgb(79, 79, 79);">大的整数</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);"> 对于整型数据，Mysql支持在类型名称后面的小括号内指定显示宽度。例如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">int(5)表示当数值宽度小于5位的时候在数字前面，默认用空格填满宽度，如果不显示指定宽度则默认为int(11)</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">如果需要用哪个数字’0’填充，则需要使用zerofill，并且使用zerofill 时，默认会自动unsigned(无符号)属性，使用unsigned属性后，数值范围是原值的2倍，例如，有符号为-128</font><sub><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">+127，无符号为0</font></sub><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">256。</font></p>
<p>:::</p>
<h5 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a><font style="color:rgb(79, 79, 79);">浮点数类型</font></h5><table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字节</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最小值</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最大值</font></strong></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">FLOAT</font></td>
<td><font style="color:rgb(79, 79, 79);">4</font></td>
<td><font style="color:rgb(79, 79, 79);">±1.175494351E-38</font></td>
<td><font style="color:rgb(79, 79, 79);">±3.402823466E+38</font></td>
<td><font style="color:rgb(79, 79, 79);">单精度浮点型，m总个数，d小数位</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">DOUBLE</font></td>
<td>8</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">±2.2250738585072014E-308</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">±1.7976931348623157E+308</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">双精度浮点型， m总个数，d小数位</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">DEC(M,D)</font></td>
<td><font style="color:rgb(79, 79, 79);">M+2</font></td>
<td><font style="color:rgb(79, 79, 79);">最大取值范围与DOUBLE相同，给定DECIMAL的有效取值范围由M和D决定</font></td>
<td><font style="color:rgb(79, 79, 79);">压缩严格的定点数</font></td>
<td></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DECIMAL(M,D)</font></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> 对于小数的表示，MySQL分为两种方式：浮点数和定点数。浮点数包括float（单精度）和double（双精度），而定点数则只有decimal一种表示。定点数在MySQL内部以字符串形式存放，比浮点数更精确，适合用来表示金额等精度高的数据。</p>
<p>  浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示，“(M,D)”表示该值一共显示M位数字（整数位+小数位），其中D位于小数点后面。M和D又称为精度和标度。</p>
<p>:::tips<br><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">float和double在不指定精度时，默认会按照实际的精度来显示</font><font style="color:rgb(77, 77, 77);">，而</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DECIMAL在不指定精度时，默认整数为10，小数为0</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">decimal插入的数据超过精度之后会触发警告</font></p>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">decimal采用的是四舍五入</font><font style="color:rgb(77, 77, 77);">。</font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"><br></font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">float和double采用的是四舍六入五成双</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">四舍六入五成双：就是5以下舍弃5以上进位，如果需要处理数字为5的时候，需要看5后面是否还有不为0的任何数字，如果有，则直接进位；如果没有，需要看5前面的数字，若是奇数则进位，若是偶数则将5舍掉。</font></p>
<p><font style="color:rgb(77, 77, 77);">如果将数据库中 float 、 double类型的数据进行计算时，会存在精度问题。而使用decimal时是正常的，所以非int数据，一般decimal用的比较多</font></p>
<p>:::</p>
<h5 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a><font style="color:rgb(79, 79, 79);">日期时间类型</font></h5><table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字节</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最小值</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最大值</font></strong></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">DATE</font></td>
<td><font style="color:rgb(79, 79, 79);">4</font></td>
<td><font style="color:rgb(79, 79, 79);">1000-01-01</font></td>
<td><font style="color:rgb(79, 79, 79);">9999-12-31</font></td>
<td><font style="color:rgb(79, 79, 79);">YYYY-MM-DD</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATETIME</font></td>
<td><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">8</font></strong></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">1000-01-01 00:00:00</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">9999-12-31 23:59:59</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">YYYY-MM-DD HH:MM:SS</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">TIMESTAMP</font></td>
<td><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">4</font></strong></td>
<td><font style="color:rgb(79, 79, 79);">19700101080001</font></td>
<td><font style="color:rgb(79, 79, 79);">2038-01-19 03:14:07UTC（格林尼治时间）</font></td>
<td><font style="color:rgb(79, 79, 79);">YYYY-MM-DD HH:MM:SS</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">TIME</font></td>
<td><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">3</font></strong></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-838:59:59</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">838:59:59</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">HH:MM:SS</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">YEAR</font></td>
<td><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">1</font></strong></td>
<td><font style="color:rgb(79, 79, 79);">1901</font></td>
<td><font style="color:rgb(79, 79, 79);">2155</font></td>
<td><font style="color:rgb(79, 79, 79);">YYYY</font></td>
</tr>
</tbody></table>
<p>如果要用来表示年月日，通常用DATE来表示。</p>
<p>  如果要用来表示年月日时分秒，通常用DATETIME表示。</p>
<p>  如果只用来表示时分秒，通常用TIME来表示。</p>
<p>  如果需要经常插入或者更新日期为当前系统时间，则通常使用TIMESTAMP来表示。</p>
<p>  如果只是表示年份，可以用YEAR来表示，它比DATE占用更少的空间。YEAR有2位或4位格式的年。默认是4位格式。在4位格式中，允许的值是1901～2155和0000。在2位格式中，允许的值是70～69，表示从1970～2069年。</p>
<p>  DATETIME是DATE和TIME的组合。</p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> TIMESTAMP还有一个重要特点，就是和时区相关。当插入日期时，会先转换为本地时区后存放；而从数据库里面取出时，也同样需要将日期转换为本地时区后显示。这样，两个不同时区的用户看到的同一个日期可能是不一样的。</font></p>
<p>:::</p>
<p>尽量使用timestamp，空间效率高于datetime（datetime占用8字节，timestamp占用4字节）。</p>
<p>  如果需要存储微秒，可以使用bigint存储。</p>
<p>  DATETIME表示的时间范围较大，TIMESTAMP表示的时间范围较小。</p>
<p>  关于表中的更新时间字段，使用示例（插入数据时为当前时间，更新数据时也会随之更新）：</p>
<h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a><font style="color:rgb(79, 79, 79);">字符串类型</font></h5><table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字节</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">范围</font></strong></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">char</font><font style="color:rgb(79, 79, 79);">(M)</font></td>
<td><font style="color:rgb(79, 79, 79);">m</font></td>
<td><font style="color:rgb(79, 79, 79);">[0,m]，m的范围[0, 2</font><sup><font style="color:rgb(79, 79, 79);">8</font></sup><font style="color:rgb(79, 79, 79);">-1]</font></td>
<td><font style="color:rgb(79, 79, 79);">定长字符串</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">varchar</font><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">(M)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">m</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">[0,m]，m的范围[0, 2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">16</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1]</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-65535 字节</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">tinyblob</font></td>
<td><font style="color:rgb(79, 79, 79);">L+1</font></td>
<td><font style="color:rgb(79, 79, 79);">0-255(2</font><sup><font style="color:rgb(79, 79, 79);">8</font></sup><font style="color:rgb(79, 79, 79);"> -1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);">不超过 255 个字符的二进制字符串</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">blob</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">L+2</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-65535( 2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">16</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">二进制形式的长文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">mediumblob</font></td>
<td><font style="color:rgb(79, 79, 79);">L+3</font></td>
<td><font style="color:rgb(79, 79, 79);">0-16777215(2</font><sup><font style="color:rgb(79, 79, 79);">24</font></sup><font style="color:rgb(79, 79, 79);"> -1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);">二进制形式的中等长度文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">longblob</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">L+4</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-4294967295( 2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">32</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">二进制形式的极大文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">tinytext</font></td>
<td><font style="color:rgb(79, 79, 79);">L+1</font></td>
<td><font style="color:rgb(79, 79, 79);">0-255( 2</font><sup><font style="color:rgb(79, 79, 79);">8</font></sup><font style="color:rgb(79, 79, 79);">-1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);">短文本字符串</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">text</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">L+2</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-65535(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">16</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);"> -1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">长文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">mediumtext</font></td>
<td><font style="color:rgb(79, 79, 79);">L+3</font></td>
<td><font style="color:rgb(79, 79, 79);">0-16777215(2</font><sup><font style="color:rgb(79, 79, 79);">24</font></sup><font style="color:rgb(79, 79, 79);"> -1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);">中等长度文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">longtext</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">L+4</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-4294967295( 2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">32</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">极大文本数据</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">char类型占用固定长度，如果存放的数据为固定长度的建议使用char类型，如：手机号码、身份证等固定长度的信息</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(77, 77, 77);">表格中的L表示存储的数据本身占用的字节，L 以外所需的额外字节为存放该值的长度所需的字节数。<br></font><font style="color:rgb(77, 77, 77);"> CHAR和VARCHAR很类似，都用来保存MySQL中较短的字符串。二者的主要区别在于存储方式的不同：</font></p>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CHAR列的长度固定为创建表时声明的长度，长度可以为从0～255的任何值，存储的字符串长度不足时用空格填充到特定长度</font><font style="color:rgb(77, 77, 77);">；</font></p>
<p><font style="color:rgb(77, 77, 77);">而VARCHAR列中的值为可变长字符串，也就是说申请的只是最大长度，占用的空间为实际字符长度+1，最后一个字符存储使用了多长的空间。<br></font><font style="color:rgb(77, 77, 77);"> 在检索效率上来讲,char &gt; varchar。</font></p>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">在检索的时候，CHAR删除了尾部的空格</font><font style="color:rgb(77, 77, 77);">，而VARCHAR则保留这些空格</font></p>
<p><font style="color:rgb(77, 77, 77);">BINARY和VARBINARY类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不包含非二进制字符串。</font></p>
<p><font style="color:rgb(77, 77, 77);">  关于varchar(n)中n的单位，Mysql4.1及之后的版本，VARCHAR的单位是字符；Mysql4.1之前的版本，VARCHAR的单位是字节。</font></p>
<p><font style="color:rgb(77, 77, 77);">  varchar和char的使用策略：</font></p>
<p>:::tips</p>
<ol>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">对于经常变更的数据来说，CHAR</font><font style="color:rgba(0, 0, 0, 0.5);">比VARCHAR</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">更好，因为CHAR不容易产生碎片</font><font style="color:rgba(0, 0, 0, 0.5);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">使用时要注意只分配需要的空间。</font></li>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销</font><font style="color:rgba(0, 0, 0, 0.5);">。</font></li>
</ol>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT也称作 非标准字符串类型。</font></p>
<h4 id="Mysql数据类型相关问题"><a href="#Mysql数据类型相关问题" class="headerlink" title="Mysql数据类型相关问题"></a><font style="color:rgb(79, 79, 79);">Mysql数据类型相关问题</font></h4><h5 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少" class="headerlink" title="若一张表中只有一个字段VARCHAR(N) 类型，utf8编码，则N最大值为多少"></a>若一张表中只有一个字段VARCHAR(N) 类型，utf8编码，则N最大值为多少</h5><p>  由于utf8的每个字符最多占用3个字节。而MySQL定义行的长度不能超过65535，因此N的最大值计算方法为：(65535-1-2)&#x2F;3。</p>
<p> 减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</p>
<h5 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a><font style="color:rgb(79, 79, 79);">选择合适的数据类型</font></h5><h6 id="CHAR与VARCHAR"><a href="#CHAR与VARCHAR" class="headerlink" title="CHAR与VARCHAR"></a>CHAR与VARCHAR</h6><p>  CHAR和VARCHAR类型类似，都用来存储字符串，但它们保存和检索的方式不同。CHAR属于固定长度的字符类型，而VARCHAR属于可变长度的字符类型。</p>
<p>  看一个字符串值保存到CHAR(4)和VARCHAR(4)列的结果对比：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1716948693406-7caa2e19-123f-4cca-af84-e307c5e2ebfb.png"></p>
<p>  由于CHAR是固定长度的，所以它的处理速度比VARCHAR快得多，但是缺点是浪费存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较高要求的数据可以考虑使用CHAR类型来存储。</p>
<p>  在MySQL中，不同的存储引擎对CHAR和VARCHAR的使用原则有所不同，简单概括：</p>
<p>:::tips<br>  MyISAM：建议使用固定长度的数据列代替可变长度的数据列。</p>
<p>  MEMORY：目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理。</p>
<p>  InnoDB：建议使用VARCHAR类型。对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I&#x2F;O是比较好的。</p>
<p>:::</p>
<h6 id="浮点数与定点数"><a href="#浮点数与定点数" class="headerlink" title="浮点数与定点数"></a><font style="color:rgba(0, 0, 0, 0.75);">浮点数与定点数</font></h6><p> 浮点数一般用于表示含有小数部分的数值。当一个字段被定义为浮点类型后，如果插入数据的精度超过该列定义的实际精度，则插入值会被四舍五入到实际定义的精度值，然后插入，四舍五入的过程不会报错。在MySQL中float、double（或 real）用来表示浮点数。</p>
<p>  定点数不同于浮点数，定点数实际上是以字符串形式存放的，所以定点数可以更加精确的保存数据。</p>
<p>  浮点数和定点数使用的几个原则：</p>
<p>:::tips</p>
<ol>
<li><font style="color:rgba(0, 0, 0, 0.5);">浮点数存在误差问题；</font></li>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">对货币等对精度敏感的数据，应该用定点数表示或存储</font><font style="color:rgba(0, 0, 0, 0.5);">；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">在编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">要注意浮点数中一些特殊值的处理。</font></li>
</ol>
<p>:::</p>
<h6 id="日期类型选择"><a href="#日期类型选择" class="headerlink" title="日期类型选择"></a><font style="color:rgba(0, 0, 0, 0.75);">日期类型选择</font></h6><p><font style="color:rgba(0, 0, 0, 0.75);">MySQL提供的常用日期类型有DATE、TIME 、DATETIME、TIMESTAMP。使用原则：</font></p>
<p>:::tips<br>根据实际需要选择能够满足应用的最小存储的日期类型。如果应用只需要记录“年份”，那么用1个字节来存储的YEAR类型完全可以满足，而不需要用4个字节来存储的DATE类型。这样不仅仅能节约存储，更能够提高表的操作效率。</p>
<p>如果要记录年月日时分秒，并且记录的年份比较久远，那么最好使用DATETIME，</p>
<p>而不要使用TIMESTAMP。因为TIMESTAMP表示的日期范围比DATETIME要短得多。</p>
<p>如果记录的日期需要让不同时区的用户使用，那么最好使用TIMESTAMP，因为日期类型中只有它能够和实际时区相对应。</p>
<p>:::</p>
<h6 id="ENUM和VARCHAR"><a href="#ENUM和VARCHAR" class="headerlink" title="ENUM和VARCHAR"></a><font style="color:rgba(0, 0, 0, 0.75);">ENUM和VARCHAR</font></h6><p>ENUM类型是非常快和紧凑的。在实际上，其保存的是TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p>
<p>  如果有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，这些字段的取值是有限而且固定的，那么，就应该使用ENUM而不是VARCHAR。</p>
<h5 id="数据类型选择的一些建议"><a href="#数据类型选择的一些建议" class="headerlink" title="数据类型选择的一些建议"></a><font style="color:rgb(79, 79, 79);">数据类型选择的一些建议</font></h5><h6 id="选小不选大"><a href="#选小不选大" class="headerlink" title="选小不选大"></a>选小不选大</h6><p>  一般情况下选择可以正确存储数据的最小数据类型，越小的数据类型通常更快，占用磁盘，内存和CPU缓存更小。</p>
<h6 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h6><p>  简单的数据类型的操作通常需要更少的CPU周期，例如：整型比字符操作代价要小得多，因为字符集和校对规则(排序规则)使字符比整型比较更加复杂。</p>
<h6 id="尽量避免NULL"><a href="#尽量避免NULL" class="headerlink" title="尽量避免NULL"></a>尽量避免NULL</h6><p>  尽量制定列为NOT NULL，除非真的需要NULL类型的值，有NULL的列值会使得索引、索引统计和值比较更加复杂。</p>
<h6 id="浮点类型的建议统一选择decimal"><a href="#浮点类型的建议统一选择decimal" class="headerlink" title="浮点类型的建议统一选择decimal"></a>浮点类型的建议统一选择decimal</h6><h6 id="记录时间的建议使用int或者bigint类型"><a href="#记录时间的建议使用int或者bigint类型" class="headerlink" title="记录时间的建议使用int或者bigint类型"></a>记录时间的建议使用int或者bigint类型</h6><p>将时间转换为时间戳格式，如将时间转换为秒、毫秒，进行存储，方便走索引</p>
<h5 id="使用int做主键和使用string有什么优劣"><a href="#使用int做主键和使用string有什么优劣" class="headerlink" title="使用int做主键和使用string有什么优劣"></a><font style="color:rgb(79, 79, 79);">使用int做主键和使用string有什么优劣</font></h5><p><strong><font style="color:rgba(0, 0, 0, 0.75);">使用整数（int）作为主键</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.75);">优势：</font></p>
<p>:::tips<br>性能：整数类型通常占用较少的存储空间，并且在进行比较和排序操作时速度更快。</p>
<p>索引效率：整数类型的索引通常比字符串类型的索引更加紧凑和高效。</p>
<p>自增属性：许多数据库系统支持整数类型的自增属性，这可以自动为新记录分配一个唯一的标识符，无需应用程序干预。</p>
<p>空间效率：整数类型占用的存储空间较小，有助于减少数据库的总体大小。</p>
<p>:::</p>
<p>劣势：</p>
<p>:::tips</p>
<ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">可读性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：整数类型不如字符串类型直观，不容易从主键值中直接获取有关记录的信息。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">扩展性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：在某些情况下，如果整数主键达到其最大值，可能需要更复杂的方案来处理。</font></li>
</ol>
<p>:::</p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">使用字符串（string）作为主键</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.75);"> 优势：</font></p>
<p>:::tips</p>
<ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">可读性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：字符串类型的主键通常更容易理解，因为它们可能包含描述性信息。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">灵活性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：字符串类型可以容纳更多种类的数据，包括字母、数字和特殊字符，使得它们在处理复杂的主键需求时更加灵活。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">扩展性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：字符串类型的主键在达到存储限制之前可以容纳更多的信息。</font></li>
</ol>
<p>:::</p>
<p>劣势：</p>
<p>:::tips<br>性能：字符串类型通常比整数类型占用更多的存储空间，并且在进行比较和排序操作时速度较慢。</p>
<p>索引效率：字符串类型的索引通常比整数类型的索引更大且效率较低。</p>
<p>错误风险：在处理字符串类型的主键时，需要更加小心地处理大小写敏感性、空格、特殊字符等问题，以避免潜在的错误。</p>
<p>存储空间：由于字符串的长度可变，因此可能会浪费存储空间，特别是在存储较短的字符串时。</p>
<p>:::</p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">如何选择合适的主键类型</font></strong></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);"> </font></strong><font style="color:rgba(0, 0, 0, 0.75);">1、根据业务需求：根据具体业务场景来选择合适的主键类型。例如，如果业务需求中需要处理大量数值类型的数据，可以使用 int 作为主键；如果需要处理字符串类型的数据，可以使用 string 作为主键。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.75);">  2、考虑数据量的大小：如果数据量较大，可以使用 int 作为主键，以提高查询和更新的效率；如果数据量较小，可以使用 string 作为主键，以提高数据的可读性和可操作性。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.75);">  3、考虑数据类型的稳定性和一致性：如果数据类型需要保持稳定性和一致性，可以使用 int 作为主键；如果数据类型可能会发生变化，可以使用 string 作为主键。 综上所述，使用 int 和 string 作为主键各有优劣。在实际应用中，需要根据具体业务场景和数据特点来选择合适的主键类型，以满足数据的存储、管理和处理需求。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.75);"></font></p>
<p><font style="color:rgba(0, 0, 0, 0.75);"></font></p>
<h2 id="Mysql字符集"><a href="#Mysql字符集" class="headerlink" title="Mysql字符集"></a><font style="color:rgb(79, 79, 79);">Mysql字符集</font></h2><p><font style="color:rgb(77, 77, 77);">简单地说，字符集就是一套文字符号及其编码、比较规则的集合。</font><br><font style="color:rgb(77, 77, 77);"> Mysql常用字符集：</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字符集</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">是否定长</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">编码方式</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">说明</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">ACSII</font></td>
<td><font style="color:rgb(79, 79, 79);">是</font></td>
<td><font style="color:rgb(79, 79, 79);">单字节 7 位编码</font></td>
<td><font style="color:rgb(79, 79, 79);">最早的奠基性字符集</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">GBK</font></td>
<td><font style="color:rgb(79, 79, 79);">是</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">双字节编码</font></td>
<td></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">UTF-32</font></td>
<td><font style="color:rgb(79, 79, 79);">是</font></td>
<td><font style="color:rgb(79, 79, 79);">4 字节编码</font></td>
<td><font style="color:rgb(79, 79, 79);">目前很少采用</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">UTF-16</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">否</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">2 字节或 4 字节编码</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">Java和Windows XP&#x2F;NT等内部使用UTF-16</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">UTF-8</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">否</font></td>
<td><font style="color:rgb(79, 79, 79);">1 至 4 字节编码</font></td>
<td><font style="color:rgb(79, 79, 79);">互联网和UNIX&#x2F;Linux 广泛支持的Unicode字符集；MySQLServer也使用UTF-8</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">utf8mb4</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">否</font></td>
<td><font style="color:rgb(79, 79, 79);"> 4 字节编码</font></td>
<td><font style="color:rgb(13, 13, 13);">完全支持所有Unicode字符，包括Emoji。建议在新项目中使用此字符集。</font></td>
</tr>
</tbody></table>
<h3 id="选择字符集时，要考虑的因素："><a href="#选择字符集时，要考虑的因素：" class="headerlink" title="选择字符集时，要考虑的因素："></a><font style="color:rgb(77, 77, 77);">选择字符集时，要考虑的因素：</font></h3><ol>
<li>满足应用支持语言的需求，如果应用要处理各种各样的文字，或者将发布到使用不同语言的国家或地区，就应该选择Unicode字符集。对MySQL来说，目前就是UTF-8。</li>
<li>如果应用中涉及已有数据的导入，就要充分考虑数据库字符集对已有数据的兼容性。</li>
<li>如果数据库只需要支持一般中文，数据量很大，性能要求也很高，那就应该选择双字节定长编码的中文字符集，比如GBK。因为，相对于UTF-8而言，GBK比较“小”，每个汉字只占2个字节，而UTF-8汉字编码需要3个字节，这样可以减少磁盘I&#x2F;O、数据库cache，以及网络传输的时间，从而提高性能。相反，如果应用主要处理英文字符，仅有少量汉字数据，那么选择UTF-8更好，因为GBK、UCS-2、UTF-16的西文字符编码都是2个字节,会造成很大不必要的开销。</li>
<li>如果数据库需要做大量的字符运算，如比较、排序等，选择定长字符集可能更好，因为定长字符集的处理速度要比变长字符集的处理速度快。</li>
</ol>
<p><font style="color:rgb(77, 77, 77);"> MySQL服务器可以支持多种字符集，在同一台服务器、同一个数据库、甚至同一个表的不同字段都可以指定使用不同的字符集。</font></p>
<p><font style="color:rgb(77, 77, 77);">总的来说，建议在能够完全满足应用的前提下，尽量使用小的字符集。因为更小的字符集意味着能够节省空间、减少网络传输字节数，同时由于存储空间的较小间接地提高了系统的性能。</font></p>
<p><font style="color:rgb(77, 77, 77);">  有很多字符集可以保存汉字，比如utf8、gb2312、gbk等等，但是常用的是gb2312和gbk。因为gb2312字库比gbk字库小，有些偏僻字（如：洺）不能保存。因此在选择字符集时一定要权衡这些偏僻字在应用出现的几率以及造成的影响，不能做出肯定答复的最好选用gbk。</font></p>
<p><font style="color:rgb(77, 77, 77);">  在实际项目开发时，使用utf8mb4即可，即：CHARSET&#x3D;utf8mb4。</font></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL运算符</title>
    <url>/2023/06/15/Mysql%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p><strong><font style="color:rgba(0, 0, 0, 0.75);">算术运算符</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716952872238-4ee53880-6fa9-4013-aa2a-78b906778163.png"></p>
<span id="more"></span>
<p><font style="color:rgb(77, 77, 77);">除法运算和模运算中，如果除数为0，将是非法除数，返回结果为NULL。示例：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716952882465-6298b71b-028f-4e2a-8e4f-021cae62f3d7.png"></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">比较运算符</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716952896033-1bc2f9c6-db83-450e-b1f2-200c851aeef0.png"></p>
<p><font style="color:rgb(77, 77, 77);">BETWEEN的用法格式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a BETWEEN min AND max</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">逻辑运算符</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716952912817-356dd4c6-4675-4fd7-a997-71d0a2ef9013.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL开启binlog</title>
    <url>/2023/06/15/mysql%E5%BC%80%E5%90%AFbinlog/</url>
    <content><![CDATA[<p>binlog是二进制日志文件，用于记录mysql的数据变更，数据在恢复的时候binlog日志起着至关重要的作用。</p>
<p>开启binlog<br>默认情况下mysql是关闭状态off状态，我的已经设置过了是on状态</p>
<span id="more"></span>

<p>进入mysql，使用下面命令，查看是否开启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;log_%&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果没有开启，需要下面的方法进行开启<br>在linux系统下，修改&#x2F;etc&#x2F;my.cnf文件</p>
<p>#编辑模式进入&#x2F;etc&#x2F;my.cnf<br>vi &#x2F;etc&#x2F;my.cnf</p>
<h1 id="i开始进行编辑"><a href="#i开始进行编辑" class="headerlink" title="i开始进行编辑"></a>i开始进行编辑</h1><h1 id="在-log-bin-后面添加内容"><a href="#在-log-bin-后面添加内容" class="headerlink" title="在#log bin 后面添加内容"></a>在#log bin 后面添加内容</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_id=2</span><br><span class="line">log_bin = mysql-bin</span><br><span class="line">binlog_format = ROW</span><br><span class="line">expire_logs_days = 30</span><br></pre></td></tr></table></figure>

<h1 id="esc-退出编辑，shift-保存"><a href="#esc-退出编辑，shift-保存" class="headerlink" title="esc 退出编辑，shift+:保存"></a>esc 退出编辑，shift+:保存</h1><p>重启mysql服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p>到这里已经开启binlog了，可以用查看命令看一下是否开启  </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语法整理</title>
    <url>/2023/06/11/sql%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a><font style="color:rgb(79, 79, 79);">SQL通用语法</font></h2><ul>
<li><font style="color:rgb(77, 77, 77);">SQL语句可以单行或多行书写，以分号结尾。</font></li>
<li><font style="color:rgb(77, 77, 77);">可使用空格和缩进来增强语句的可读性。</font></li>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">MySQL数据库的SQL语言不区分大小写，关键字建议使用大写</font><font style="color:rgb(77, 77, 77);">，对所有列和表名使用小写，这样做使代码更容易阅读和调试。</font></li>
<li><font style="color:rgb(77, 77, 77);">3种注释：</font><span id="more"></span>
<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">单行注释： – 注释内容<br></font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">单行注释：# 注释内容（mysql特有）<br></font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">多行注释：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">&#x2F;<em>注释</em>&#x2F;</font><!-- more --></li>
</ul>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a><font style="color:rgb(79, 79, 79);">SQL分类</font></h2><p>Mysql中SQL语句的分类可以分成：数据定义语言DDL、数据操纵语言DML、数据控制语言DCL、数据查询语言DQL。</p>
<p>  DDL：数据定义语言，这些语句主要用来创建、修改、删除数据库的逻辑结构，其中包括表结构，视图和索引等。常用的关键字有主要包括create、drop、alter等，truncate也是DDL关键字。</p>
<p>  DML：数据操纵语言，这些语句用于添加、删除、更新和查询数据库中的数据，并检查数据完整性。常用的关键字有insert、delete、update、select等。</p>
<p>  DCL：数据控制语言，这些语句主要用来控制数据库的访问权限。常用的关键字有主要包括grant、revoke、commit、rollback等。DCL主要用来控制数据库的权限。</p>
<p>  DQL：数据查询语言，各种简单查询，连接查询等 都属于DQL。</p>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p><font style="color:rgb(77, 77, 77);">DDL：Data Define Language数据定义语言，主要用来对数据库、表进行一些管理操作。如：建库、删库、建表、修改表、删除表、对列的增删改等等。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建数据库</span><br><span class="line">	CREATE DATABASE dbname</span><br><span class="line">	#查看系统中都有哪些数据库</span><br><span class="line">	SHOW DATABASES</span><br><span class="line">	#建库通用的写法</span><br><span class="line">	drop database if exists 旧库名;</span><br><span class="line">	create database 新库名;</span><br><span class="line">	#选择某个数据库</span><br><span class="line">	USE dbname</span><br><span class="line">	#删除数据库</span><br><span class="line">	DROP DATABASE dbname</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--创建表语法</span><br><span class="line">	create table 表名(</span><br><span class="line">    	字段名1 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],</span><br><span class="line">    	字段名2 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],</span><br><span class="line">    	字段名3 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;]</span><br><span class="line">	)[表的一些设置];</span><br><span class="line"></span><br><span class="line">	--建表示例</span><br><span class="line">	create table test2(</span><br><span class="line">  		a int not null comment &#x27;字段a&#x27;,</span><br><span class="line">  		b int not null default 0 comment &#x27;字段b&#x27;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	#删除表</span><br><span class="line">	DROP TABLE tablename</span><br><span class="line">	#删除表更常见的用法</span><br><span class="line">	DROP TABLE IF EXISTS tablename</span><br><span class="line"></span><br><span class="line">    -- 只复制表结构</span><br><span class="line">    create table 表名 like 被复制的表名;</span><br><span class="line">    -- 复制表结构+数据</span><br><span class="line">   create table 表名 [as] select 字段,... from 被复制的表 [where 条件];</span><br><span class="line"></span><br><span class="line">	#更改表名 </span><br><span class="line">	ALTER TABLE tablename RENAME [TO] new_table</span><br><span class="line">	#示例:将表名由emp改成emp1</span><br><span class="line">	ALTER TABLE emp RENAME emp1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改字段类型</span><br><span class="line">ALTER TABLE tablename MODIFY [COLUMN] column_definition</span><br><span class="line">#示例：将emp字段类型改成VARCHAR(20)</span><br><span class="line">ALTER TABLE emp MODIFY name VARCHAR(20)</span><br><span class="line">#增加字段</span><br><span class="line">ALTER TABLE tablename ADD [column] column_definition</span><br><span class="line">#示例：增加类型为int(3)的age字段</span><br><span class="line">ALTER TABLE emp ADD COLUMN age INT(3)</span><br><span class="line">#删除字段</span><br><span class="line">ALTER TABLE tablename DROP [column] col_name</span><br><span class="line">#修改字段名</span><br><span class="line">ALTER TABLE tablename CHANGE [column] old_col_name column_definition</span><br><span class="line">#示例：将age改名为age1，并修改字段类型</span><br><span class="line">ALTER TABLE emp CHANGE age age1 INT(4)</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);"> 注意：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">modify不能修改列名，change可以修改列名</font><font style="color:rgb(77, 77, 77);">。</font><br><font style="color:rgb(77, 77, 77);"> 使用上面命令增加的字段默认都在表的最后位置，而CHANGE&#x2F;MODIFY不会修改字段的位置。如果要修改字段的位置，要用AFTER&#x2F;FIRST等关键字：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#将birth字段添加到ename之后</span><br><span class="line">	ALTER TABLE emp ADD birth DATE AFTER ename</span><br><span class="line">	#将age字段放在最前面</span><br><span class="line">	ALTER TABLE emp MODIFY age INT(3) FIRST</span><br></pre></td></tr></table></figure>

<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p><font style="color:rgb(77, 77, 77);">DML(Data Manipulation Language)数据操作语言，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是必须要掌握的指令，DML和SQL中的select俗称CRUD（增删改查）。</font></p>
<h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a><font style="color:rgb(77, 77, 77);">新增数据</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#可以不指定字段名称，但value后面的顺序应该和字段的排列顺序一致</span><br><span class="line">	INSERT INTO tablename (field1,field2,...,fieldn) VALUES (value1,value2,...valuen)</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">使用INSERT时，可以一次性插入多条数据：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tablename (field1,field2,...,fieldn) </span><br><span class="line">	VALUES </span><br><span class="line">	(record1_value1,record1_value2,...record1_valuen)</span><br><span class="line">	(record2_value1,record2_value2,...record2_valuen)	</span><br><span class="line">	...</span><br><span class="line">	(recordn_value1,recordn_value2,...recordn_valuen)	</span><br></pre></td></tr></table></figure>

<p>这里有个变种的写法 INSERT INTO SELECT FROM </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#可以不指定字段名称，但value后面的顺序应该和字段的排列顺序一致</span><br><span class="line">	INSERT INTO tablename (field1,field2,...,fieldn) SELECT value1,value2,...valuen FROM SOURETABLE</span><br></pre></td></tr></table></figure>

<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a><font style="color:rgba(0, 0, 0, 0.75);">更新数据</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE tablename SET field1=value1,field2=value2,...,fieldn=valuen</span><br><span class="line">	#示例</span><br><span class="line">	UPDATE emp SET sal=4000 WHERE ename=&#x27;lisa&#x27;</span><br></pre></td></tr></table></figure>

<p>变种写法UPDATE JOIN  SET ，主要用于两张表的数据同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table1</span><br><span class="line">JOIN table2 ON table1.common_column = table2.common_column</span><br><span class="line">SET table1.column_to_update = table2.value</span><br><span class="line">WHERE table1.condition_column = condition_value;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><font style="color:rgba(0, 0, 0, 0.75);">删除数据</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM tablename [WHERE CONDITION]</span><br><span class="line">#示例</span><br><span class="line">DELETE FROM emp WHERE ename=&#x27;tony&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">如果使用DELETE关键字时，后面没加条件，就会把整张表的数据删掉</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="delete、truncate与drop"><a href="#delete、truncate与drop" class="headerlink" title="delete、truncate与drop*"></a><font style="color:rgb(79, 79, 79);">delete、truncate与drop*</font></h5><p><font style="color:rgb(77, 77, 77);"> 三者都可以删除表中的数据，三者的差别：</font></p>
<table>
<thead>
<tr>
<th align="center"><strong><font style="color:rgb(79, 79, 79);">   </font></strong></th>
<th align="center"><strong><font style="color:rgb(79, 79, 79);">delete</font></strong></th>
<th align="center"><strong><font style="color:rgb(79, 79, 79);">truncate</font></strong></th>
<th align="center"><strong><font style="color:rgb(79, 79, 79);">drop</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font style="color:rgb(79, 79, 79);">回滚</font></td>
<td align="center"><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">可回滚</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">不可回滚</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">不可回滚</font></td>
</tr>
<tr>
<td align="center"><font style="color:rgb(79, 79, 79);">删除内容</font></td>
<td align="center"><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">表结构还在，删除表的全部或者一部分数据行</font></td>
<td align="center"><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">表结构还在，删除表中的所有数据</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">从数据库中删除表结果和所有的数据行，索引和权限也会被删除</font></td>
</tr>
<tr>
<td align="center"><font style="color:rgb(79, 79, 79);">删除速度</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">删除速度慢，需要逐行删除</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">删除速度快</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">删除速度最快</font></td>
</tr>
</tbody></table>
<p><strong><font style="color:rgb(77, 77, 77);">想删除部分数据，用delete</font></strong><font style="color:rgb(77, 77, 77);">；</font><br><strong><font style="color:rgb(77, 77, 77);">保留表结构而删除所有数据，用truncate</font></strong><font style="color:rgb(77, 77, 77);">；</font><br><strong><font style="color:rgb(77, 77, 77);">不再需要一张表，用drop</font></strong><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">delete一次删除一行，会将删除操作作为食物记录在日志中保存以便进行回滚操作，</font><font style="color:rgba(0, 0, 0, 0.75);">TRUNCATE TABLE则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">表和索引所占空间。当表被TRUNCATE后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。DROP语句将表所占用的空间全释放掉。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">一般而言，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">执行速度：DROP&gt;TRUNCATE&gt;DELETE</font><font style="color:rgba(0, 0, 0, 0.75);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">应用范围。TRUNCATE只能对TABLE；DELETE可以是TABLE和VIEW</font></li>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TRUNCATE和DELETE只删除数据，而DROP则删除整个表（结构和数据）</font><font style="color:rgba(0, 0, 0, 0.75);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">TRUNCATE与不带 WHERE的DELETE：只删除数据，而不删除表的结构（定义）drop 语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程&#x2F;函数将被保留，但其状态会变为：invalid。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">truncate、drop是ddl，操作立即生效。</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE table_name;</span><br><span class="line"></span><br><span class="line">DROP TABLE table_name;</span><br></pre></td></tr></table></figure>

<h4 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a><font style="color:rgb(79, 79, 79);">SELECT语句</font></h4><h5 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a><font style="color:rgb(79, 79, 79);">简单查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询指定列</span><br><span class="line">SELECT 查询的列1,查询的列2 FROM tablename [WHERE CONDITION]</span><br><span class="line">#查询所有列</span><br><span class="line">select * from 表名</span><br></pre></td></tr></table></figure>

<h5 id="列别名"><a href="#列别名" class="headerlink" title="列别名"></a><font style="color:rgb(79, 79, 79);">列别名</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列 [as] 别名 from 表;</span><br><span class="line">-- 使用双引号创建别名</span><br><span class="line">select a &quot;列1&quot;,b &quot;列2&quot; from test1;</span><br><span class="line">-- 使用单引号创建别名</span><br><span class="line">select a &#x27;列1&#x27;,b &#x27;列2&#x27; from test1;</span><br><span class="line">-- 不用引号创建别名</span><br><span class="line">select a 列1,b 列2 from test1;</span><br><span class="line">-- 使用as创建别名</span><br><span class="line">select a as 列1,b as 列2 from test1;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">建议给列起别名时，使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">as</font><font style="color:rgb(77, 77, 77);">关键字，sql易读。</font></p>
<h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a><font style="color:rgb(79, 79, 79);">条件查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 列 运算符 值</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);"> WHERE后面跟的条件中，除了可以使用&#x3D;，还可以使用&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、！&#x3D;等比较运算符，多个条件之间可以用OR、AND等逻辑运算符。</font></p>
<h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a><font style="color:rgb(79, 79, 79);">模糊查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ％对应于0个或更多字符,_只是 LIKE 语句中的一个字符</span><br><span class="line">select 列名 from 表名 where 列 like pattern;</span><br></pre></td></tr></table></figure>

<h5 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a><font style="color:rgb(79, 79, 79);">区间查询</font></h5><p><font style="color:rgb(77, 77, 77);">操作符 BETWEEN … AND 会选取介于两个值之间的数据范围，这些值可以是数值、文本或者日期，属于一个闭区间查询。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selec 列名 from 表名 where 列名 between 值1 and 值2;</span><br></pre></td></tr></table></figure>

<h5 id="IN查询"><a href="#IN查询" class="headerlink" title="IN查询"></a><font style="color:rgb(79, 79, 79);">IN查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 字段 in (值1,值2,值3,值4);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">in后面括号中可以包含多个值，对应记录的字段满足in中任意一个都会被返回。</font><br><font style="color:rgb(77, 77, 77);"> in列表的值类型必须一致或兼容。</font><br><font style="color:rgb(77, 77, 77);"> in列表中不支持通配符。</font></p>
<h5 id="EXIST"><a href="#EXIST" class="headerlink" title="EXIST"></a><font style="color:rgba(0, 0, 0, 0.75);">EXIST</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM a WHERE EXISTS(SELECT 1 FROM b WHERE B.id  = A.id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">等价于：</font></p>
<p><font style="color:#000000;background-color:rgb(238, 240, 244);">1、SELECT * FROM A;<br></font><font style="color:#000000;background-color:rgb(238, 240, 244);">2、SELECT I FROM B WHERE B.id &#x3D; A.id;</font></p>
<p>:::info<br><font style="color:rgb(77, 77, 77);">EXISTS()查询会执行SELECT * FROM A查询，执行A.length次，并不会将  EXISTS()查询结果结果进行缓存，因为EXISTS()查询返回一个布尔值true或flase，它只在乎EXISTS()的查询中是否有记录，与具体的结果集无关。</font></p>
<p><font style="color:rgb(77, 77, 77);">  EXISTS()查询是将主查询的结果集放到子查询中做验证，根据验证结果是true或false来决定主查询数据结果是否得以保存。</font></p>
<p><font style="color:rgb(77, 77, 77);">  可以看出，使用EXIST时，子查询中适合放大表（数据量大的表）。</font></p>
<p>:::</p>
<h5 id="NOT-IN查询"><a href="#NOT-IN查询" class="headerlink" title="NOT IN查询"></a><font style="color:rgb(79, 79, 79);">NOT IN查询</font></h5><p><font style="color:rgb(77, 77, 77);">not in和in刚好相反，in是列表中被匹配的都会被返回，NOT IN是和列表中都不匹配的会被返回。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 字段 not in (值1,值2,值3,值4);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">用 not in 的时候，如果 not in 后面的选项中有 null，不会查询出来任何数据。sql 语句本身直接返回 false。所以使用 not in 的时候，要保证 in 中的条件不会出现 null 的情况。</font></p>
<h5 id="NULL值查询"><a href="#NULL值查询" class="headerlink" title="NULL值查询"></a><font style="color:rgb(79, 79, 79);">NULL值查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 列 is null;</span><br><span class="line">select 列名 from 表名 where 列 is not null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a><font style="color:rgb(79, 79, 79);">排序查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tablename </span><br><span class="line">[WHERE CONDITION] </span><br><span class="line">[ORDER BY field1 [DESC|ASC],field2 [DESC|ASC],...,fieldn [DESC|ASC]]</span><br><span class="line">-- 示例</span><br><span class="line">select * from product order by price desc,order_count asc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">DESC表示按字段进行降序排列，ASC表示升序排列，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">默认是升序排列</font><font style="color:rgb(77, 77, 77);">。支持多个字段进行排序，多字段排序之间用逗号隔开，order by后越靠前的字段排序优先级越高。</font></p>
<h5 id="LIMIT语句"><a href="#LIMIT语句" class="headerlink" title="LIMIT语句"></a><font style="color:rgb(79, 79, 79);">LIMIT语句</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列 from 表 limit [offset,] count;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">offset：表示偏移量，通俗点讲就是跳过多少行，offset可以省略，默认为0，表示跳过0行；范围：[0,+∞)。</font><br><font style="color:rgb(77, 77, 77);"> count：跳过offset行之后开始取数据，取count行记录；范围：[0,+∞)。</font><br><font style="color:rgb(77, 77, 77);"> limit中offset和count的值不能用表达式。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取前n行记录</span><br><span class="line">	select 列 from 表 limit 0,n;</span><br><span class="line">	select 列 from 表 limit n;</span><br><span class="line">	#获取排名第n到m的记录</span><br><span class="line">	select 列 from 表 limit n-1,m-n+1;</span><br><span class="line">	#示例：显示从第2条数据开始的3条数据</span><br><span class="line">	SELECT * FROM emp ORDER BY sal LIMIT 1,3</span><br></pre></td></tr></table></figure>



<h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a><font style="color:rgb(79, 79, 79);">分页查询</font></h5><p>LIMIT经常和ORDER BY一起使用，进行数据的分页显示。</p>
<p>  开发过程中，分页我们经常使用，分页一般有2个参数：</p>
<p>  page：表示第几页，从1开始，范围[1,+∞)。</p>
<p>  pageSize：每页显示多少条记录，范围[1,+∞)。</p>
<p>  如：page &#x3D; 2，pageSize &#x3D; 10，表示获取第2页10条数据。使用limit分页的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列 from 表名 limit (page - 1) * pageSize,pageSize;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">注意事项：</font></p>
<ol>
<li><font style="color:rgba(0, 0, 0, 0.75);">limit中不能使用表达式，只能够跟明确的数字。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">limit后面的2个数字不能为负数。</font></li>
</ol>
<h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a><font style="color:rgb(79, 79, 79);">分组查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT [filed1,field2,...,fieldn] fun_name</span><br><span class="line">FROM tablename</span><br><span class="line">[WHERE where_condition]</span><br><span class="line">[GROUP BY field1,field2,...,fieldn]</span><br><span class="line">[HAVING where_condition]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fun_name表示聚合函数，常用的有sum、count(*)、avg、max、min等。GROUP BY后面跟的是要进行分类聚合的字段。HAVING表示对分类后的结果在进行条件过滤。</p>
<p>分组中，select后面只能有两种类型的列：</p>
<p>1）出现在group by后的列；</p>
<p>2）或者使用聚合函数的列。</p>
<p>  Group BY用来创建分组，如果分组中有NULL值，将NULL作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p>
<h5 id="UNION语句"><a href="#UNION语句" class="headerlink" title="UNION语句"></a><font style="color:rgb(79, 79, 79);">UNION语句</font></h5><p><font style="color:rgb(77, 77, 77);">将多个查询的数据合并用到的关键字是UNION&#x2F;UNION ALL：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1</span><br><span class="line">UNION|UNION ALL</span><br><span class="line">SELECT * FROM t2</span><br><span class="line">...</span><br><span class="line">UNION|UNION ALL</span><br><span class="line">SELECT * FROM tn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">UNION和UNION ALL的区别：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.5);">UNION ALL：把结果集直接合并在一起；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">UNION：将UNION ALL的结果进行去重。</font></li>
</ul>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">因为UNION有个去重的过程，所以UNION ALL的效率较高</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="COUNT语句"><a href="#COUNT语句" class="headerlink" title="COUNT语句*"></a><font style="color:rgb(79, 79, 79);">COUNT语句*</font></h5><p><font style="color:rgb(77, 77, 77);">COUNT(*)函数返回表中所有行的数量，包括NULL值行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) FROM students;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">COUNT(column_name)函数返回指定列非NULL值的数量，忽略NULL值行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(age) FROM students;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">COUNT(DISTINCT column_name)返回指定列中不同值的数量，忽略NULL值行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT age) FROM students;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">COUNT(DISTINCT expr,[expr…])函数返回指定表达式中不同非NULL值的数量，忽略NULL值行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT age, gender) FROM students;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">COUNT(IF(condition, column_name, NULL))函数返回满足指定条件的指定列的非NULL值数量。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 这个 SQL 语句的含义是统计学生表中性别为 ‘Female’ 的人数。通过 IF 函数，将所有性别</span><br><span class="line">-- 为 ‘Female’ 的行转换成 1，然后 COUNT 函数就会返回这些 1 的数量，即性别为 ‘Female’ </span><br><span class="line">-- 的学生数量</span><br><span class="line">SELECT COUNT(IF(gender=&#x27;Female&#x27;, 1, NULL)) FROM students;</span><br></pre></td></tr></table></figure>

<p>ount(*)、count(1)、count(列名)的选择</p>
<p>  COUNT(*) 是最常用的方式，它可以统计所有行的数量，包括 NULL 值。</p>
<p>  COUNT(1) 也可以统计所有行的数量，包括 NULL 值。</p>
<p>  COUNT(column_name) 只会统计指定列中非 NULL 值的数量，而忽略 NULL 值。因此，如果需要统计指定列的非 NULL 值数量，那么可以使用 COUNT(column_name)。这种方式的性能相对较低，因为需要扫描整个表，对于每一行都要进行判断。</p>
<h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a><font style="color:rgb(79, 79, 79);">关联查询</font></h4><p><font style="color:rgb(77, 77, 77);">Mysql中常用的关联查询有左外连接、右外连接、全连接、自连接等。</font></p>
<h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a><font style="color:rgb(79, 79, 79);">笛卡尔积</font></h5><p><font style="color:rgb(77, 77, 77);"> 笛卡尔积简单点理解：有两个集合A和B，笛卡尔积表示A集合中的元素和B集合中的元素任意相互关联产生的所有可能的结果。假如A中有m个元素，B中有n个元素，A、B笛卡尔积产生的结果有m*n个结果，相当于循环遍历两个集合中的元素，任意组合。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">过程：拿A集合中的第1行，去匹配集合B中所有的行，然后再拿集合A中的第2行，去匹配集合B中所有的行，最后结果数量为m*n。</font></p>
<h5 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接 (INNER JOIN)"></a><font style="color:rgb(13, 13, 13);">内连接 (INNER JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">内连接返回两个表中满足连接条件的行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">INNER JOIN departments ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="左连接-LEFT-JOIN"><a href="#左连接-LEFT-JOIN" class="headerlink" title="左连接 (LEFT JOIN)"></a><font style="color:rgb(13, 13, 13);">左连接 (LEFT JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">左连接返回左表中的所有行以及右表中满足连接条件的行。如果右表中没有匹配的行，结果中包含的右表列将包含NULL。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">LEFT JOIN departments ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="右连接-RIGHT-JOIN"><a href="#右连接-RIGHT-JOIN" class="headerlink" title="右连接 (RIGHT JOIN)"></a><font style="color:rgb(13, 13, 13);">右连接 (RIGHT JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">右连接返回右表中的所有行以及左表中满足连接条件的行。如果左表中没有匹配的行，结果中包含的左表列将包含NULL。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">RIGHT JOIN departments ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="全连接-FULL-JOIN"><a href="#全连接-FULL-JOIN" class="headerlink" title="全连接 (FULL JOIN)"></a><font style="color:rgb(13, 13, 13);">全连接 (FULL JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">MySQL不直接支持FULL JOIN，但可以通过使用UNION来模拟。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">LEFT JOIN departments ON employees.department_id = departments.department_id</span><br><span class="line">UNION</span><br><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">RIGHT JOIN departments ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="交叉连接-CROSS-JOIN"><a href="#交叉连接-CROSS-JOIN" class="headerlink" title="交叉连接 (CROSS JOIN)"></a><font style="color:rgb(13, 13, 13);">交叉连接 (CROSS JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">交叉连接返回两个表的笛卡尔积，即表1中的每一行与表2中的每一行组合。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">CROSS JOIN departments;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="自连接（Self-Join）"><a href="#自连接（Self-Join）" class="headerlink" title="自连接（Self-Join）"></a>自连接（<font style="color:rgb(13, 13, 13);">Self-Join</font>）</h5><p><font style="color:rgb(13, 13, 13);">自连接（Self-Join）是在同一个表中进行的联接查询，用于将表中的一行与另一行相关联。自连接常用于需要比较表中不同行的数据的情况，例如查找员工和他们的经理、产品的父子关系等。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e1.employee_name AS employee, e2.employee_name AS manager</span><br><span class="line">FROM employees e1</span><br><span class="line">LEFT JOIN employees e2 ON e1.manager_id = e2.employee_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(13, 13, 13);">在自连接查询中，使用表别名（如 e1 和 e2）是必需的，以区分表的不同实例。</font></p>
<p><font style="color:rgb(13, 13, 13);">自连接可能对大表进行性能影响，因此在实际应用中需要注意索引和查询优化。</font></p>
<p><font style="color:rgb(13, 13, 13);">根据需求，可以使用不同的连接类型（INNER JOIN、LEFT JOIN等）来决定是否包括没有匹配关系的行。</font></p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a><font style="background-color:rgb(249, 242, 244);">DCL</font></h3><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DCL：数据控制语言，这些语句主要用来控制数据库的访问权限</font><font style="color:rgb(77, 77, 77);">。常用的关键字有主要包括grant、revoke、commit、rollback等。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DCL主要用来控制数据库的权限</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p><font style="color:rgb(77, 77, 77);">数据查询语言，各种简单查询，连接查询等 都属于DQL。</font></p>
<h2 id="查询语句的书写和执行顺序"><a href="#查询语句的书写和执行顺序" class="headerlink" title="查询语句的书写和执行顺序"></a><font style="color:rgb(79, 79, 79);">查询语句的书写和执行顺序</font></h2><p><font style="color:rgb(77, 77, 77);">Mysql的一般书写顺写为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select  &lt;要返回的数据列&gt;</span><br><span class="line">from   &lt;表名&gt;</span><br><span class="line">&lt;join, left join, right join...&gt; join    &lt;join表&gt;</span><br><span class="line">on   &lt;join条件&gt;</span><br><span class="line">where   &lt;where条件&gt;</span><br><span class="line">group by  &lt;分组条件&gt;</span><br><span class="line">having  &lt;分组后的筛选条件&gt;</span><br><span class="line">order by  &lt;排序条件&gt;</span><br><span class="line">limit  &lt;行数限制&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常见执行顺序"><a href="#常见执行顺序" class="headerlink" title="常见执行顺序*"></a><font style="color:rgb(79, 79, 79);">常见执行顺序*</font></h5><ol>
<li><font style="color:rgb(77, 77, 77);">一个查询语句同时出现了where、group by、having、order by的时候，执行顺序和编写顺序是：</font></li>
<li><font style="color:rgb(77, 77, 77);">执行where xx对全表数据做筛选，返回第1个结果集。</font></li>
<li><font style="color:rgb(77, 77, 77);">针对第1个结果集使用group by分组，返回第2个结果集。</font></li>
<li><font style="color:rgb(77, 77, 77);">针对第2个结果集中的每1组数据执行select xx，有几组就执行几次，返回第3个结果集。</font></li>
<li><font style="color:rgb(77, 77, 77);">针对第3个结集执行having xx进行筛选，返回第4个结果集。</font></li>
<li><font style="color:rgb(77, 77, 77);">针对第4个结果集排序。</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);">按照执行顺序的关键词首字母分别是W（where）-&gt;G（Group）-&gt;S（Select）-&gt;H（Having）-&gt;O（Order），对应汉语首字母可以编成容易记忆的顺口溜：我(W)哥(G)是(SH)偶(O)像。</font></p>
<h5 id="完整执行顺序"><a href="#完整执行顺序" class="headerlink" title="完整执行顺序"></a><font style="color:rgb(79, 79, 79);">完整执行顺序</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from </span><br><span class="line">    &lt;表名&gt;          # 笛卡尔积</span><br><span class="line">on </span><br><span class="line">    &lt;筛选条件&gt;          #对笛卡尔积的虚表进行筛选</span><br><span class="line">&lt;join, left join, right join...&gt; join </span><br><span class="line">    &lt;join表&gt;  #指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中</span><br><span class="line">where </span><br><span class="line">    &lt;where条件&gt;     #对上述虚表进行筛选</span><br><span class="line">group by</span><br><span class="line">    &lt;分组条件&gt;      #分组</span><br><span class="line">&lt;sum()等聚合函数&gt;   #用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的</span><br><span class="line">having </span><br><span class="line">    &lt;分组筛选&gt;      #对分组后的结果进行聚合筛选</span><br><span class="line">select </span><br><span class="line">    &lt;返回数据列表&gt;       #返回的单列必须在group by子句中，聚合函数除外</span><br><span class="line">distinct</span><br><span class="line">order by </span><br><span class="line">    &lt;排序条件&gt;      #排序</span><br><span class="line">limit </span><br><span class="line">    &lt;行数限制&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">执行流程：</font></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">from：select * from table_1, table_2; 与 select * from table_1 join table_2; 的结果一致，都是表示求笛卡尔积；</font></li>
<li><font style="color:rgb(77, 77, 77);">  用于直接计算两个表笛卡尔积，得到虚拟表VT1，这是所有select语句最先执行的操作，其他操作时在这个表上进行的，也就是from操作所完成的内容。</font></li>
<li><font style="color:rgb(77, 77, 77);">on：从VT1表中筛选符合条件的数据，形成VT2表；</font></li>
<li><font style="color:rgb(77, 77, 77);">join：将该join类型的数据补充到VT2表中，例如left join会将左表的剩余数据添加到虚表VT2中，形成VT3表；若表的数量大于2，则会重复1-3步；</font></li>
<li><font style="color:rgb(77, 77, 77);">where：执行筛选，（不能使用聚合函数）得到VT4表；</font></li>
<li><font style="color:rgb(77, 77, 77);">group by：对VT4表进行分组，得到VT5表；其后处理的语句，如select，having，所用到的列必须包含在group by条件中，没有出现的需要用聚合函数；</font></li>
<li><font style="color:rgb(77, 77, 77);">having：筛选分组后的数据，得到VT6表；</font></li>
<li><font style="color:rgb(77, 77, 77);">select：返回列得到VT7表；</font></li>
<li><font style="color:rgb(77, 77, 77);">distinct：用于去重得到VT8表；</font></li>
<li><font style="color:rgb(77, 77, 77);">order by：用于排序得到VT9表；</font></li>
<li><font style="color:rgb(77, 77, 77);">limit：返回需要的行数，得到VT10。</font></li>
</ul>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式*"></a><font style="color:rgb(79, 79, 79);">三大范式*</font></h2><p><font style="color:rgb(77, 77, 77);">数据库的三大范式的设计目的是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">减少数据冗余</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a><font style="color:rgb(79, 79, 79);">第一范式</font></h5><p>第一范式是最基本的范式。如果数据库表中的所有字段值都不可再分解（列不可再分），就说明该数据库表满足了第一范式，确保数据库表字段的原子性。</p>
<p>  第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</p>
<h5 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a><font style="color:rgb(79, 79, 79);">第二范式</font></h5><p><font style="color:rgb(77, 77, 77);">第二范式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">表必须有一个主键，非主键列必须完全依赖于主键，而不能只依赖于主键的一部分</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a><font style="color:rgb(79, 79, 79);">第三范式</font></h5><p><font style="color:rgb(77, 77, 77);">满足第三范式（3NF）必须先满足第二范式（2NF）。</font><br><font style="color:rgb(77, 77, 77);"> 第三范式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">非主键列必须直接依赖于主键，不能存在传递依赖</font><font style="color:rgb(77, 77, 77);">。即不能存在：非主键列A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</font></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">2NF和3NF的区别</font></strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font><font style="color:rgba(0, 0, 0, 0.75);">2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。<br></font><font style="color:rgba(0, 0, 0, 0.75);">3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。</font></li>
</ul>
<h5 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a><font style="color:rgb(79, 79, 79);">简单总结</font></h5><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">1、第一范式：</font><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">列不可分</font><font style="color:rgba(0, 0, 0, 0.75);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">2、第二范式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">列必须直接依赖主键</font><font style="color:rgba(0, 0, 0, 0.75);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">3、第三范式： </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">表里面的列不能出现其它表的非主键字段</font></li>
</ul>
<h5 id="范式化和反范式化设计的优缺点"><a href="#范式化和反范式化设计的优缺点" class="headerlink" title="范式化和反范式化设计的优缺点"></a><font style="color:rgb(79, 79, 79);">范式化和反范式化设计的优缺点</font></h5><ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">范式化</font></strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font><font style="color:rgba(0, 0, 0, 0.75);">优点：可以尽量得减少数据冗余，使得更新快，体积小。<br></font><font style="color:rgba(0, 0, 0, 0.75);">缺点：对于查询需要多个表进行关联，减少写得效率增加读得效率。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">反范式化</font></strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font><font style="color:rgba(0, 0, 0, 0.75);">优点：可以减少表得关联，可以更好得进行索引优化。<br></font><font style="color:rgba(0, 0, 0, 0.75);">缺点：数据冗余，数据的修改需要更多的成本。</font></li>
</ul>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a><font style="color:rgb(79, 79, 79);">约束</font></h2><p><font style="color:rgb(77, 77, 77);">创建表的时候，同时可以指定所插入数据的一些规则，比如说某个字段不能为空值，某个字段的值（比如年龄）不能小于零等等，这些规则称为约束。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">约束是在表上强制执行的数据校验规则</font><font style="color:rgb(77, 77, 77);">。</font><br><font style="color:rgb(77, 77, 77);"> 数据库中的五大约束：</font></p>
<ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">主键约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);">： 唯一，非空【常用】；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">唯一约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：唯一，可以为空，但只能有一个【常用】；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">非空约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：非空【常用】；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">默认约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：该列数据的默认值；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">外键约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 两表间的关系；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">检查约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);"> ： 检查字段值是否符合要求。</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);"> 约束示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--添加主键约束</span><br><span class="line">Alter table 表名 add Constraint 主键名 primary key(字段)</span><br><span class="line">--添加唯一约束</span><br><span class="line">Alter table 表名 add Constraint 约束名 unique(字段)</span><br><span class="line">--添加默认约束</span><br><span class="line">Alter table 表名 add Constraint 约束名 default(默认内容) for 字段名</span><br><span class="line">--添加检查约束</span><br><span class="line">Alter table 表名 add Constraint 约束名 check (字段表达)</span><br><span class="line">--添加外键约束</span><br><span class="line">Alter table 表名 add Constraint 约束名 foreign key(字段) references 表名(字段名)</span><br><span class="line">--约束常常在建表时添加，如对某个极端添加非空约束</span><br><span class="line">`account_name` varchar(64) NOT NULL COMMENT &#x27;账户名称&#x27;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SQL相关问题"><a href="#SQL相关问题" class="headerlink" title="SQL相关问题"></a><font style="color:rgb(79, 79, 79);">SQL相关问题</font></h2><h5 id="HAVNG和WHERE的区别"><a href="#HAVNG和WHERE的区别" class="headerlink" title="HAVNG和WHERE的区别*"></a><font style="color:rgb(79, 79, 79);">HAVNG和WHERE的区别*</font></h5><ul>
<li><p>语法</p>
<pre><code>   where用表中列名，having用select结果别名；
</code></pre>
</li>
<li><p>是否能使用索引</p>
<pre><code>    where可以使用索引，having不能使用索引，只能在临时结果集操作；
</code></pre>
</li>
<li><p>是否能使用聚集函数</p>
</li>
</ul>
<p>where 后面不能使用聚集函数，having是专门使用聚集函数的。</p>
<ul>
<li>一个聚集函数从多个输入行中计算出一个结果，比如count（数目）， sum（和），avg（ 均值 ）， max（最大值）和min（最小值）。</li>
<li>HAVING是对聚合(数据分组)后的结果进行条件的过滤，而WHERE是在聚合(数据分组)前就对记录进行过滤。如果逻辑允许，尽可能用WHERE先过滤条件，因为这样结果集减小，聚合的效率将大大提高，最后再根据逻辑看是否用HAVING进行过滤。</li>
</ul>
<h5 id="SELECT-和-SELECT-全部字段-的区别1、是否解析数据字典"><a href="#SELECT-和-SELECT-全部字段-的区别1、是否解析数据字典" class="headerlink" title="[SELECT *] 和 [SELECT 全部字段]的区别1、是否解析数据字典"></a><font style="color:rgb(79, 79, 79);">[SELECT *] 和 [SELECT 全部字段]的区别</font><font style="color:rgb(79, 79, 79);">1、是否解析数据字典</font></h5><p><font style="color:rgb(79, 79, 79);">1、前者要解析数据字典（数据字典是指对数据的数据项、数据结构、数据流、数据存储、处理逻辑、外部实体等进行定义和描述，其目的是对数据流程图中的各个元素做出详细的说明），后者不需要数据字典。</font></p>
<p><font style="color:rgb(79, 79, 79);">2、是否可指定输出顺序</font></p>
<p><font style="color:rgb(79, 79, 79);">  前者与建表列顺序相同（建表后不增删字段的话），后者可以指定字段顺序。</font></p>
<p><font style="color:rgb(79, 79, 79);">3、表字段改名，前者不需要修改，后者需要改。</font></p>
<p><font style="color:rgb(79, 79, 79);">4、是否可优化</font></p>
<p><font style="color:rgb(79, 79, 79);">  后者可以建立索引进行优化，前者无法优化。</font></p>
<p><font style="color:rgb(79, 79, 79);">5、可读性</font></p>
<p><font style="color:rgb(79, 79, 79);">  后者的可读性比前者要高。</font></p>
<h5 id="Mysql分组中的坑"><a href="#Mysql分组中的坑" class="headerlink" title="Mysql分组中的坑"></a><font style="color:rgb(79, 79, 79);">Mysql分组中的坑</font></h5><p> 分组中select后面的列只能有2种：1）出现在group by后面的列；2）使用聚合函数的列。</p>
<p>  这是在Mysql后期版本加上的功能，在早期版本中没这个要求。建议：在写分组查询的时候，最好按照标准的规范来写，即：select后面出现的列必须在group by中或者必须使用聚合函数。</p>
<h2 id="数据库开发规范"><a href="#数据库开发规范" class="headerlink" title="数据库开发规范"></a><font style="color:rgb(79, 79, 79);">数据库开发规范</font></h2><h5 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a><font style="color:rgb(79, 79, 79);">基础规范</font></h5><p> 1）必须使用InnoDB存储引擎解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高。</p>
<p>  2）必须使用UTF8字符集解读：万国码，无需转码，无乱码风险，节省空间。</p>
<p>  3）数据表、数据字段必须加入中文注释。</p>
<p>  4）禁止使用存储过程、视图、触发器、Event解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。</p>
<p>  5）禁止存储大文件或者大照片解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URL。</p>
<h5 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a><font style="color:rgb(79, 79, 79);">命名规范</font></h5><p> 1）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用.</p>
<p>  2）表名t_xxx，非唯一索引名uniq_xxx，唯一索引名idx_xxx.</p>
<p>  3）单实例表数目必须小于500。</p>
<p>  4）单表列数目必须小于30。</p>
<p>  5）表必须有主键，例如自增主键：</p>
<p><font style="color:rgb(77, 77, 77);">      6）禁止使用外键，如果有外键完整性约束，需要应用程序控制解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率。</font></p>
<p>:::</p>
<h5 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a><font style="color:rgb(79, 79, 79);">字段设计规范</font></h5><p><font style="color:rgb(77, 77, 77);">1）必须把字段定义为NOT NULL并且提供默认值：</font></p>
<p>:::tips<br> a）null的列使索引&#x2F;索引统计&#x2F;值比较都更加复杂，对MySQL来说更难优化。</p>
<p>  b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多。</p>
<p>  c）null值需要更多的存储空间，无论是表还是索引中每行中的null的列都需要额外的空间来标识。</p>
<p>  d）对null 的处理时候，只能采用is null或is not null，而不能采用&#x3D;、in、&lt;、&lt;&gt;、!&#x3D;、not in这些操作符号。</p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">2）禁止使用TEXT、BLOB类型解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能。</font><br><font style="color:rgb(77, 77, 77);"> 3）禁止使用小数存储货币解读，小数容易导致钱对不上。</font><br><font style="color:rgb(77, 77, 77);"> 4）必须使用varchar(20)存储手机号：</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">a）涉及到区号或者国家代号，可能出现±。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）varchar可以支持模糊查询，例如：like“138%”。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">5）禁止使用ENUM，可使用TINYINT代替：</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> a）增加新的ENUM值要做DDL操作。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）ENUM的内部实际存储就是整数。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">6）单表索引建议控制在5个以内。</font><br><font style="color:rgb(77, 77, 77);"> 7）单索引字段数不允许超过5个。字段超过5个时，实际已经起不到有效过滤数据的作用了。</font><br><font style="color:rgb(77, 77, 77);"> 8）禁止在更新十分频繁、区分度不高的属性上建立索引：</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">9）建立组合索引，必须把区分度高的字段放在前面解读：能够更加有效的过滤数据。</font><br><font style="color:rgb(77, 77, 77);"> 10）禁止使用SELECT *，只获取必要的字段，需要显示说明列属性：</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">a）读取不需要的列会增加CPU、IO、NET消耗。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）不能有效的利用覆盖索引。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> c）使用SELECT *容易在增加或者删除字段后出现程序BUG。</font></p>
<p>:::</p>
<p>11）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性解读：容易在增加或者删除字段后出现程序BUG。</p>
<p>  12）禁止使用属性隐式转换解读：SELECT uid FROM t_user WHERE phone&#x3D;13800000000 会导致全表扫描，而不能命中phone索引。</p>
<p>  13）禁止在WHERE条件的属性上使用函数或者表达式：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;&#x3D;’2017-01-15’会导致全表扫描，正确的写法是：SELECT uid FROM t_user WHERE day&gt;&#x3D;unix_timestamp(‘2017-01-15 00:00:00’)。</p>
<p>  14）禁止负向查询，以及%开头的模糊查询：</p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">a）负向查询条件：NOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）%开头的模糊查询，会导致全表扫描。</font></p>
<p>:::</p>
<p>15）禁止使用OR条件，必须改为IN查询解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p>
<p>  16）应用程序必须捕获SQL异常，并有相应处理.</p>
<p>  17）同表的增删字段、索引合并一条DDL语句执行，提高执行效率，减少与数据库的交互。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title>too many connections 解决方法</title>
    <url>/2023/06/15/too%20many%20connections%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>mysql -u root -p<font style="color:rgb(77, 77, 77);"> 回车输入密码进入mysql</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<h1 id="too-many-connections-解决方法"><a href="#too-many-connections-解决方法" class="headerlink" title="too many connections 解决方法"></a><font style="color:rgb(38, 38, 38);">too many connections 解决方法</font></h1><p><font style="background-color:rgb(247, 247, 247);">mysql -u root -p</font><font style="color:rgb(77, 77, 77);"> 回车输入密码进入mysql</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25873401/1646018837018-04475fb7-2931-430a-80fc-e6c91d289b2c.png"></p>
<span id="more"></span>
<p><font style="color:rgb(38, 38, 38);">show processlist;</font></p>
<p><font style="color:rgb(38, 38, 38);">查看连接数，可以发现有很多连接处于sleep状态，这些其实是暂时没有用的，所以可以kill掉</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">show variables like “max_connections”;</font></p>
<p><font style="color:rgb(38, 38, 38);">查看最大连接数，应该是与上面查询到的连接数相同，才会出现too many connections的情况</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">set GLOBAL max_connections&#x3D;1000;</font></p>
<p><font style="color:rgb(38, 38, 38);">修改最大连接数，但是这不是一劳永逸的方法，应该要让它自动杀死那些sleep的进程。</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">show global variables like ‘wait_timeout’;</font></p>
<p><font style="color:rgb(38, 38, 38);">这个数值指的是mysql在关闭一个非交互的连接之前要等待的秒数，默认是28800s</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">set global wait_timeout&#x3D;300;</font></p>
<p><font style="color:rgb(38, 38, 38);">修改这个数值，这里可以随意，最好控制在几分钟内</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1646018837062-a511ca3d-05f7-4cb2-addb-9cb0e82d0562.png"></p>
<p><font style="color:rgb(38, 38, 38);">set global interactive_timeout&#x3D;500;</font></p>
<p><font style="color:rgb(38, 38, 38);">修改这个数值，表示mysql在关闭一个连接之前要等待的秒数，至此可以让mysql自动关闭那些没用的连接，但要注意的是，正在使用的连接到了时间也会被关闭，因此这个时间值要合适</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">批量kill之前没用的sleep连接，在网上搜索的方法对我都不奏效，因此只好使用最笨的办法，一个一个kill</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">select concat(‘KILL ‘,id,’;’) from information_schema.processlist where user&#x3D;’root’; 先把要kill的连接id都查询出来</font></p>
<p><font style="color:rgb(38, 38, 38);">复制中间的kill id;内容到word文档</font></p>
<p><font style="color:rgb(38, 38, 38);">替换掉符号“|”和回车符（在word中查询^p即可查询到回车符）</font></p>
<p><font style="color:rgb(38, 38, 38);">把修改过的内容复制回终端，最后按回车执行！</font></p>
<p><font style="color:rgb(38, 38, 38);">原文链接：<a href="https://blog.csdn.net/qq_31454017/article/details/71108278">https://blog.csdn.net/qq_31454017/article/details/71108278</a></font></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>事务处理</title>
    <url>/2023/06/13/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="		事务的四大特性"></a><font style="color:rgb(79, 79, 79);">		事务的四大特性</font></h4><ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">原子性(Atomicity) </font></strong><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">事务是最小的执行单位，不允许分割</font><font style="color:rgba(0, 0, 0, 0.75);">。事务的原子性确保动作要么全部完成，要么完全不起作用；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">一致性(Consistency) </font></strong><font style="color:rgba(0, 0, 0, 0.75);">一致性是指</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">事务必须使数据库从一个一致性状态变换到另一个一致性状态</font><font style="color:rgba(0, 0, 0, 0.75);">，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</font><span id="more"></span>
:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</font></li>
</ol>
<p>:::</p>
<ol start="3">
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">隔离性(Isolation) </font></strong><font style="color:rgba(0, 0, 0, 0.75);">并发访问数据库时，即一个事务内部的操作及使用的数据对并发的其他事务是隔离</font><strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font></strong><font style="color:rgba(0, 0, 0, 0.75);">的，并发执行的各个事务之间不能互相干扰。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">持久性(Durability) </font></strong><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">一个事务被提交之后。它对数据库中数据的改变是持久的</font><font style="color:rgba(0, 0, 0, 0.75);">，即使数据库发生故障也不应该对其有任何影响</font></li>
</ol>
<h4 id="事务产生的问题"><a href="#事务产生的问题" class="headerlink" title="事务产生的问题"></a><font style="color:rgb(79, 79, 79);">事务产生的问题</font></h4><h5 id="脏读-Drity-Read"><a href="#脏读-Drity-Read" class="headerlink" title="脏读(Drity Read)"></a>脏读<font style="color:rgb(79, 79, 79);">(Drity Read)</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">已知有两个事务A和B, A读取了已经被B更新但还没有被提交的数据。之后，B回滚事务，A读取的数据就是脏数据</font><font style="color:rgb(77, 77, 77);">。即：一个事务在执行的过程中读取到了其他事务还没有提交的数据。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">此处的”脏”主要指由于回滚，导致了数据的无效性，也就是读到了脏数据。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);"> 脏读，可以简单理解为读到了无效数据。</font></p>
<h5 id="不可重复读-Non-repeatable-read"><a href="#不可重复读-Non-repeatable-read" class="headerlink" title="不可重复读(Non-repeatable read)"></a>不可重复读<font style="color:rgb(79, 79, 79);">(Non-repeatable read)</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">已知有两个事务A和B，A多次读取同一数据，B在A多次读取的过程中对数据作了修改并提交，导致A多次读取同一数据时，结果不一致</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">此处的”重复”指的是由于修改，某个事务重复读取的某个值发生了变化。</font></p>
<p><font style="color:rgb(77, 77, 77);">不可重复读，可简单理解为多次重复读取，读取到了不一样的数据。</font></p>
<h5 id="幻读-Phantom-Read"><a href="#幻读-Phantom-Read" class="headerlink" title="幻读(Phantom Read)"></a>幻读<font style="color:rgb(79, 79, 79);">(Phantom Read)</font></h5><p> 幻读在可重复读的模式下才会出现，其他隔离级别中不会出现。</p>
<p>  有两个事务A和B，A从一个表中读取了数据，然后B在该表中插入了一些新数据，导致A再次读取同一个表, 就会多出几行。简单地说，一个事务中先后读取一个范围的记录，但每次读取的纪录数不同，多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<h5 id="不可重复读和幻读区别"><a href="#不可重复读和幻读区别" class="headerlink" title="不可重复读和幻读区别"></a><font style="color:rgba(0, 0, 0, 0.75);">不可重复读和幻读区别</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);"> 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</font></p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a><font style="color:rgb(79, 79, 79);">事务的隔离级别</font></h4><p><font style="color:rgb(77, 77, 77);">了解决多个事务之间数据可见性及数据正确性的问题，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted(读未提交)、Read committed(读已提交)、Repeatable read(可重复读)、Serializable(串行)。</font></p>
<p><font style="color:rgb(77, 77, 77);">事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。<br></font><font style="color:rgb(77, 77, 77);"> InnoDB存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</font></p>
<h5 id="查看隔离级别命令"><a href="#查看隔离级别命令" class="headerlink" title="查看隔离级别命令"></a><font style="color:rgb(77, 77, 77);">查看隔离级别命令</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看隔离级别命令</span><br><span class="line">   show variables like &#x27;transaction_isolation&#x27;;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">要修改隔离级别的话，可以进行全局修改，也就是修改配置文件（my.ini），示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transaction-isolation=READ-UNCOMMITTED</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);"> 也可以通过命令修改当前session的隔离级别：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set session transaction isolation level 事务级别;</span><br></pre></td></tr></table></figure>

<h5 id="各种隔离级别中会出现的问题"><a href="#各种隔离级别中会出现的问题" class="headerlink" title="各种隔离级别中会出现的问题"></a><font style="color:rgb(79, 79, 79);">各种隔离级别中会出现的问题</font></h5><ul>
<li>读未提交  存在脏读，不可重复读，幻读的问题 </li>
<li>读已提交  处理了脏读的问题但是存在不可重复读和幻读的问题</li>
<li>可重复读  处理了不可重复读的问题，幻读依然存在 ，但是mysql中的这一级别因为mvcc的存在已经将幻读的问题也处理了</li>
<li>串型化   都一个一个处理了肯定不存在脏读 重复读 幻读的问题</li>
</ul>
<h5 id="READ-UNCOMMITTED-读未提交"><a href="#READ-UNCOMMITTED-读未提交" class="headerlink" title="READ-UNCOMMITTED(读未提交)"></a><font style="color:rgb(79, 79, 79);">READ-UNCOMMITTED(读未提交)</font></h5><p><font style="color:rgb(77, 77, 77);">最低的隔离级别，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">允许一个事务可以读取另外一个事务未提交的事务</font><font style="color:rgb(77, 77, 77);">。多次读取结果不一样，会出现了脏读、不可重复读问题。</font><br><font style="color:rgb(77, 77, 77);"> 这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用。</font></p>
<h5 id="READ-COMMITTED-读已提交"><a href="#READ-COMMITTED-读已提交" class="headerlink" title="READ-COMMITTED(读已提交)*"></a><font style="color:rgb(79, 79, 79);">READ-COMMITTED(读已提交)*</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">允许一个事务读取另一个并发事务已经提交的数据</font><font style="color:rgb(77, 77, 77);">。读已提交情况下，无法读取到其他事务还未提交的数据，可以读取到其他事务已经提交的数据，多次读取结果不一样，未出现脏读，出现了读已提交、不可重复读。</font></p>
<h5 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE-READ(可重复读)*"></a><font style="color:rgb(79, 79, 79);">REPEATABLE-READ(可重复读)*</font></h5><p>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。即使数据被其他事务修改， 当前事务也不会读取到新的数据。重复读事务中的查询看到的是事务开始时的快照， 而不是该事务当前查询开始时的快照。</p>
<p>  可重复读情况下，未出现脏读，未读取到其他事务已提交的数据，多次读取结果一致，即可重复读。</p>
<h5 id="SERIALIZABLE-串行"><a href="#SERIALIZABLE-串行" class="headerlink" title="SERIALIZABLE(串行)*"></a><font style="color:rgb(79, 79, 79);">SERIALIZABLE(串行)*</font></h5><p><font style="color:rgb(77, 77, 77);">最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰（多个事务之间读写、写读、写写会产生互斥，效果就是串行执行，多个事务之间的读读不会产生互斥）。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">该级别可以防止脏读、不可重复读以及幻读。</font></p>
<p>:::</p>
<h4 id="Mysql中的事务操作"><a href="#Mysql中的事务操作" class="headerlink" title="Mysql中的事务操作"></a><font style="color:rgb(79, 79, 79);">Mysql中的事务操作</font></h4><p> Mysql中事务默认是隐式事务，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。</p>
<p>:::tips<br>  事务分为隐式事务和显式事务。是否开启隐式事务是由变量 autocommit 控制的。可以通过set session autoCommit &#x3D; on&#x2F;off来设置mysql事务是否自动开启。如果我们设置autoCommit为off的时候，需要手动开启mysql事务。</p>
<p>:::</p>
<h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a><font style="color:rgb(79, 79, 79);">隐式事务</font></h5><h5 id="事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。"><a href="#事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。" class="headerlink" title="事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。"></a><font style="color:rgb(77, 77, 77);">事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。</font></h5><p><font style="color:rgb(77, 77, 77);"> 实际项目开发时，用隐式事务即可。</font></p>
<h5 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a><font style="color:rgb(79, 79, 79);">显式事务</font></h5><p><font style="color:rgb(77, 77, 77);">需要手动开启、提交或回滚，由开发者自己控制。有两种方式：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式1</span><br><span class="line">//设置不自动提交事务</span><br><span class="line">set autocommit=0;</span><br><span class="line">//执行事务操作</span><br><span class="line">commit|rollback;</span><br><span class="line"></span><br><span class="line">-- 方式2</span><br><span class="line">start transaction;//开启事务</span><br><span class="line">//执行事务操作</span><br><span class="line">commit|rollback;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a><font style="color:rgb(79, 79, 79);">savepoint</font></h5><p><font style="color:rgb(77, 77, 77);">如果在事务中我们执行了一大批操作，可只想回滚部分数据。此时可以将一大批操作分为几个部分，然后指定回滚某个部分，通过savepoint(保存点)来实现。示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into test1 values (1);</span><br><span class="line">-- 设置一个保存点</span><br><span class="line">savepoint part1;</span><br><span class="line">insert into test1 values (2);</span><br><span class="line">-- 将savepint = part1的语句到当前语句之间所有的操作回滚</span><br><span class="line">rollback to part1;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a><font style="color:rgb(79, 79, 79);">只读事务</font></h5><p><font style="color:rgb(77, 77, 77);">表示在事务中执行的是一些只读操作，如查询，但是不会做insert、update、delete操作。开启只读事务后，执行修改操作会报错。</font></p>
<h5 id="查看变量-autocommit-是否开启了自动提交命令："><a href="#查看变量-autocommit-是否开启了自动提交命令：" class="headerlink" title="查看变量 autocommit 是否开启了自动提交命令："></a><font style="color:rgb(77, 77, 77);">查看变量 autocommit 是否开启了自动提交命令：</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;autocommit&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ACID的保证"><a href="#ACID的保证" class="headerlink" title="ACID的保证"></a><font style="color:rgb(79, 79, 79);">ACID的保证</font></h4><p><font style="color:rgb(77, 77, 77);"> 事务的原子性是通过 undo log 来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的持久性是通过 redo log 来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的隔离性是通过 (读写锁+MVCC)来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的一致性是通过原子性、持久性、隔离性来实现的。</font></p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><font style="color:rgba(0, 0, 0, 0.75);">原子性</font></h5><p>1、每条数据变更(insert&#x2F;update&#x2F;delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上。</p>
<p>2、所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</p>
<h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><font style="color:rgba(0, 0, 0, 0.75);">持久性</font></h5><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716974826311-3b0e8907-86d6-44db-a7cb-7d738e3f4780.png"></p>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><font style="color:rgba(0, 0, 0, 0.75);">隔离性</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);">MySQL定义了4种隔离级别。隔离性是要做到什么呢？ 隔离性是要管理多个并发读写请求的访问顺序。MVCC和读写锁都能达到一定的隔离效果。</font></p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><font style="color:rgba(0, 0, 0, 0.75);">一致性</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);">数据库总是从一个一致性的状态转移到另一个一致性的状态。通过回滚，以及恢复，和在并发环境下的隔离可以达到一致性的效果。</font></p>
<h4 id="InnoDB的幻读问题"><a href="#InnoDB的幻读问题" class="headerlink" title="InnoDB的幻读问题"></a><font style="color:rgb(79, 79, 79);">InnoDB的幻读问题</font></h4><p><font style="color:rgb(79, 79, 79);">隔离级别REPEATABLE-READ（可重复读）的时候，并没有解决幻读的问题，串行的话性能无法保证，所以在InnoDB引擎中引入了mvcc和间隙锁以及行锁来处理</font></p>
<h6 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a><font style="color:rgb(79, 79, 79);">快照读</font></h6><p><font style="color:rgb(79, 79, 79);">InnoDB引擎通过mvcc来解决快照读的幻读问题，生成一个ReadView然后结合undo日志来解决幻读的问题</font></p>
<h6 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a><font style="color:rgb(79, 79, 79);">当前读</font></h6><p><font style="color:rgb(79, 79, 79);">InnoDB引擎通过间隙锁来解决幻读问题，事务A和事务B产生并发，事务A未提交时阻塞事务B，这样就不会产生幻读问题</font></p>
<h4 id="MVCC基础概念"><a href="#MVCC基础概念" class="headerlink" title="MVCC基础概念"></a><font style="color:rgb(79, 79, 79);">MVCC基础概念</font></h4><p>:::tips<br><font style="color:black;">数据库通过</font><strong><font style="color:rgb(37, 132, 181);">加锁</font></strong><font style="color:black;">，可以实现事务的隔离性，</font><strong><font style="color:rgb(37, 132, 181);">串行化隔离级别就是加锁实现的</font></strong><font style="color:black;">，但是加锁会</font><strong><font style="color:rgb(37, 132, 181);">降低数据库性能</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">因此，数据库引入了</font><strong><font style="color:rgb(37, 132, 181);">MVCC多版本并发控制</font></strong><font style="color:black;">，在读取数据不用加锁的情况下，实现读取数据的同时可以修改数据，修改数据时同时可以读取数据。</font></p>
<p>:::</p>
<h5 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h5><p><font style="color:rgb(79, 79, 79);">MVCC(Mutil-Version Concurrency Control)，多版本并发控制。是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。用于支持读已提交(RC）和可重复读(RR）隔离级别的实现。</font></p>
<p>:::tips<br><font style="color:rgb(79, 79, 79);">MVCC</font><font style="color:rgb(79, 79, 79);">在</font><font style="color:rgb(79, 79, 79);">MySQL InnoDB</font><font style="color:rgb(79, 79, 79);">引擎中的实现主要是为了在处理读-写冲突时提高数据库并发性能，记录读已提交和可重复读这两种隔离级别下事务操作版本连的过程。</font></p>
<p>:::</p>
<ul>
<li><font style="color:rgb(79, 79, 79);">数据库并发场景一般有三种：</font><ul>
<li><font style="color:rgb(79, 79, 79);">读-读</font><font style="color:rgb(79, 79, 79);">：不存在任何问题，不需要并发控制</font></li>
<li><font style="color:rgb(79, 79, 79);">读-写</font><font style="color:rgb(79, 79, 79);">：有线程安全问题，可能会造成事务隔离性问题，可能会有脏读，幻读，不可重复读</font></li>
<li><font style="color:rgb(79, 79, 79);">写-写</font><font style="color:rgb(79, 79, 79);">：有线程安全问题，可能会存在更新丢失问题。</font></li>
</ul>
</li>
<li><font style="color:rgb(79, 79, 79);">MVCC主要是用来解决【</font><font style="color:rgb(79, 79, 79);">读-写</font><font style="color:rgb(79, 79, 79);">】冲突的</font><font style="color:rgb(79, 79, 79);">无锁并发控制</font><font style="color:rgb(79, 79, 79);">，可以解决以下问题：</font><ul>
<li><font style="color:rgb(79, 79, 79);">在并发读写数据时，可以做到在读操作时不用阻塞写操作，写操作不用阻塞读操作，提高数据库并发读写的性能</font><font style="color:rgb(79, 79, 79);">。</font></li>
<li><font style="color:rgb(79, 79, 79);">可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决【写-写】引起的更新丢失问题</font><font style="color:rgb(79, 79, 79);">。</font></li>
</ul>
</li>
<li><font style="color:rgb(79, 79, 79);">MVCC与锁的组合</font><font style="color:rgb(79, 79, 79);">：</font></li>
</ul>
<p><font style="color:rgb(79, 79, 79);">一般数据库中都会采用以上MVCC与锁的两种组合来解决并发场景的问题，以此最大限度的提高数据库性能</font><font style="color:rgb(79, 79, 79);">。</font></p>
<pre><code>- &lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC + 悲观锁&lt;/font&gt;&lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC解决读-写冲突，悲观锁解决写-写冲突。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC + 乐观锁MVCC解决读-写冲突，乐观锁解决写-写冲突。&lt;/font&gt;
</code></pre>
<p>:::tips<br><font style="color:rgb(0, 0, 0);">通过上述描述，MVCC的作用可以概括为就是为了解决【读写冲突】，提高数据库性能的，而MVCC的实现又依赖于六个概念：【隐式字段】【undo日志】【版本链】【快照读和当前读】【读视图】。</font></p>
<p>:::</p>
<h5 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h5><p><strong><font style="color:rgb(37, 132, 181);">在InnoDB存储引擎，针对每行记录都有固定的两个隐藏列【DB_TRX_ID】【DB_ROLL_PTR】以及一个可能存在的隐藏列【DB_ROW_ID】</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039295214-f6b578a9-f5b8-42ad-a084-574eadda6268.webp"></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(248, 248, 248);">隐式字段</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);">描述</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);">是否必须存在</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">DB_TRX_ID</font></td>
<td><font style="color:rgb(0, 0, 0);">事物Id，也叫事物版本号，占用6byte的标识，</font><strong><font style="color:rgb(37, 132, 181);">事务开启之前，从数据库获得一个自增长的事务ID，用其判断事务的执行顺序</font></strong></td>
<td><font style="color:rgb(0, 0, 0);">是</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">DB_ROLL_PTR</font></td>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">占用7byte，</font><strong><font style="color:rgb(37, 132, 181);background-color:rgb(248, 222, 203);">回滚指针，指向这条记录的上一个版本的undo log记录，存储于回滚段（rollback segment）中</font></strong></td>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">是</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">DB_ROW_ID</font></td>
<td><font style="color:rgb(0, 0, 0);">隐含的自增ID（隐藏主键），如果表中没有主键和非NULL唯一键时，则会生成一个</font><strong><font style="color:rgb(37, 132, 181);">单调递增的行ID作为聚簇索引</font></strong></td>
<td><font style="color:rgb(0, 0, 0);">否</font></td>
</tr>
</tbody></table>
<p><font style="color:black;">表中的数据会因此分为两种形式：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">有主键或唯一非空字段</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039890546-106f9f7f-79d2-40c7-b110-1bec3c7d5758.webp"></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">没有主键且没有唯一非空字段</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039898106-00a40ce6-3800-47f8-a8cc-ce1156f47093.webp"><font style="color:black;"><br></font></p>
<h5 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h5><p><strong><font style="color:rgb(37, 132, 181);">一种用于撤销回退的日志，在事务开始之前，会先记录存放到 Undo 日志文件里，备份起来，当事务回滚时或者数据库崩溃时用于回滚事务。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">undo日志的主要作用是事务回滚和实现MVCC快照读</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">undo log日志分为两种</font></strong><font style="color:black;">：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">insert undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">代表事务在</font></strong></strong><font style="color:rgb(30, 107, 184);">insert</font><strong><strong><font style="color:rgb(37, 132, 181);">新记录时产生的</font></strong></strong><font style="color:rgb(30, 107, 184);">undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">, 仅用于事务回滚，并且在事务提交后可以被立即丢弃</font></strong></strong><font style="color:rgb(1, 1, 1);">。</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">update undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">事务在进行</font></strong></strong><font style="color:rgb(30, 107, 184);">update</font><strong><strong><font style="color:rgb(37, 132, 181);">或</font></strong></strong><font style="color:rgb(30, 107, 184);">delete</font><strong><strong><font style="color:rgb(37, 132, 181);">时产生的</font></strong></strong><font style="color:rgb(30, 107, 184);">undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">; 不仅在事务回滚时需要，在实现MVCC快照读时也需要</font></strong></strong><font style="color:rgb(1, 1, 1);">；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被清理线程统一清除。</font></strong></li>
</ul>
<p><font style="color:black;">MVCC实际上是使用的</font><font style="color:rgb(30, 107, 184);">update undo log</font><font style="color:black;"> 实现的快照读。</font></p>
<p>:::tips<br><strong><font style="color:rgb(37, 132, 181);">InnoDB 并不会真正地去开辟空间存储多个版本的行记录，只是借助 undo log 记录每次写操作的反向操作。所以B+ 索引树上对应的记录只会有一个最新版本，InnoDB 可以根据 undo log 得到数据的历史版本，从而实现多版本控制。</font></strong></p>
<p>:::</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039960367-31d88ae9-d08e-4582-aa7d-5f4b07627fec.webp"></p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>:::tips<br><font style="color:rgb(0, 0, 0);">一致性非锁定读是通过 </font><strong><font style="color:rgb(37, 132, 181);">MVCC</font></strong><font style="color:rgb(0, 0, 0);"> 来实现的。但是MVCC 没有一个统一的实现标准，所以各个存储引擎的实现机制不尽相同。InnoDB 存储引擎中 MVCC 的实现是通过 </font><strong><font style="color:rgb(37, 132, 181);">undo log</font></strong><font style="color:rgb(0, 0, 0);"> 来完成的</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(37, 132, 181);">当事务对某一行数据进行改动时，会产生一条Undo日志，多个事务同时操作一条记录时，就会产生多个版本的Undo日志，这些日志通过回滚指针（DB_ROLL_PTR）连成一个链表，称为版本链</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717040314866-11d5dd8b-e6dd-440b-92d2-0a384c1d896b.webp"></p>
<p><font style="color:black;">只要有事务写入数据时，就会产生一条对应的 undo log，一条 undo log 对应这行数据的一个版本，当这行数据有多个版本时，就会有多条 undo log 日志，undo log 之间通过回滚指针（DB_ROLL_PTR）连接，这样就形成了一个 undo log 版本链。</font></p>
<h5 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a><font style="color:rgb(0, 0, 0);">快照读和当前读</font></h5><h6 id="快照读："><a href="#快照读：" class="headerlink" title="快照读："></a><font style="color:rgb(79, 79, 79);">快照读：</font></h6><p><strong><font style="color:rgb(51, 51, 51);">也叫普通读，读取的是记录数据的可见版本，不加锁，不加锁的普通select语句都是快照读，即不加锁的非阻塞读</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">快照读的执行方式是生成 ReadView，直接利用 MVCC 机制来进行读取，并不会对记录进行加锁</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<h6 id="当前读："><a href="#当前读：" class="headerlink" title="当前读："></a><font style="color:rgb(79, 79, 79);">当前读：</font></h6><p><strong><font style="color:rgb(51, 51, 51);">也称锁定读【Locking Read】，读取的是记录数据的最新版本，并且需要先获取对应记录的锁</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE;  # 共享锁</span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ...  # 排他锁</span><br><span class="line">DELETE FROM student WHERE ...  # 排他锁</span><br><span class="line">UPDATE student SET ...  # 排他锁</span><br></pre></td></tr></table></figure>

<h5 id="读视图"><a href="#读视图" class="headerlink" title="读视图"></a><font style="color:rgb(0, 0, 0);">读视图</font></h5><p><strong><font style="color:rgb(37, 132, 181);">Read View提供了某一时刻事务系统的快照，主要是用来做</font><strong><strong><font style="color:rgb(30, 107, 184);">可见性</font></strong></strong><font style="color:rgb(37, 132, 181);">判断, 里面保存了【对本事务不可见的其他活跃事务】</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">当事务在开始执行的时候，会产生一个读视图（Read View），用来判断当前事务可见哪个版本的数据，即可见性判断</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">实际上在innodb中，每个SQL语句执行前都会生成一个Read View</font></strong><font style="color:black;">。</font></p>
<h6 id="读视图的四个属性"><a href="#读视图的四个属性" class="headerlink" title="读视图的四个属性"></a><font style="color:black;">读视图的四个属性</font></h6><p><font style="color:rgb(0, 0, 0);">MySQL</font><font style="color:rgb(30, 107, 184);">5.7</font><font style="color:rgb(0, 0, 0);">源码中对</font><font style="color:rgb(30, 107, 184);">Read View</font><font style="color:rgb(0, 0, 0);">定义了四个属性，如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ReadView &#123;</span><br><span class="line">	private:</span><br><span class="line">		/** The read should not see any transaction with trx id &gt;= this</span><br><span class="line">		value. In other words, this is the &quot;high water mark&quot;. */</span><br><span class="line">		trx_id_t	m_low_limit_id;</span><br><span class="line"></span><br><span class="line">		/** The read should see all trx ids which are strictly</span><br><span class="line">		smaller (&lt;) than this value.  In other words, this is the</span><br><span class="line">		low water mark&quot;. */</span><br><span class="line">		trx_id_t	m_up_limit_id;</span><br><span class="line"></span><br><span class="line">		/** trx id of creating transaction, set to TRX_ID_MAX for free</span><br><span class="line">		views. */</span><br><span class="line">		trx_id_t	m_creator_trx_id;</span><br><span class="line"></span><br><span class="line">		/** Set of RW transactions that was active when this snapshot</span><br><span class="line">		was taken */</span><br><span class="line">		ids_t		m_ids;</span><br><span class="line"></span><br><span class="line">		/** The view does not need to see the undo logs for transactions</span><br><span class="line">		whose transaction number is strictly smaller (&lt;) than this value:</span><br><span class="line">		they can be removed in purge if not needed by other views */</span><br><span class="line">		trx_id_t	m_low_limit_no;</span><br><span class="line"></span><br><span class="line">		/** AC-NL-RO transaction view that has been &quot;closed&quot;. */</span><br><span class="line">		bool		m_closed;</span><br><span class="line"></span><br><span class="line">		typedef UT_LIST_NODE_T(ReadView) node_t;</span><br><span class="line"></span><br><span class="line">		/** List of read views in trx_sys */</span><br><span class="line">		byte		pad1[64 - sizeof(node_t)];</span><br><span class="line">		node_t		m_view_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(37, 132, 181);">creator_trx_id </font>****<font style="color:rgb(0, 0, 0);">创建当前read view的事务ID</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_ids </font>****<font style="color:rgb(0, 0, 0);">当前系统中所有的活跃事务的 id，活跃事务指的是当前系统中开启了事务，但还没有提交的事务;</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_low_limit_id  </font>****<font style="color:rgb(0, 0, 0);">表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_up_limit_id  </font>****<font style="color:rgb(0, 0, 0);">当前系统中事务的 id 值最大的那个事务 id 值再加 1，也就是系统中下一个要生成的事务 id。</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">ReadView 会根据这 4 个属性，结合 undo log 版本链，来实现 MVCC 机制，决定一个事务能读取到数据那个版本</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p>:::tips<br><font style="color:black;">假设现在有事务 A 和事务 B 并发执行，事务 A 的事务 id 为 10，事务 B 的事务 id 为 20。</font></p>
<p><font style="color:black;">事务A的ReadView ：m_ids&#x3D;[10,20]，m_low_limit_id&#x3D;10，m_up_limit_id&#x3D;21，creator_trx_id&#x3D;10。</font></p>
<p><font style="color:black;">事务B的ReadView ：m_ids&#x3D;[10,20]，m_low_limit_id&#x3D;10，m_up_limit_id&#x3D;21，creator_trx_id&#x3D;20。</font></p>
<p>:::</p>
<h6 id="读视图可见性判断规则"><a href="#读视图可见性判断规则" class="headerlink" title="读视图可见性判断规则"></a><font style="color:black;">读视图可见性判断规则</font></h6><p><font style="color:black;">将Read View中的活跃事务Id按照大小放在坐标轴上表示的话，如下图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717040599275-ea807cb7-1694-4ca0-8396-60c6dc9c385c.webp"></p>
<p><font style="color:black;">当一个事务读取某条数据时，会</font><strong><font style="color:rgb(37, 132, 181);">通过DB_TRX_ID【Uodo日志的事务Id】在坐标轴上的位置</font></strong><font style="color:black;">来进行可见性规则判断，如下：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID &lt; m_low_limit_id</font></strong></li>
</ul>
<p><strong><font style="color:black;">表示DB_TRX_ID对应这条数据【Undo日志】是在当前事务开启之前，其他的事务就已经将该条数据修改了并提交了事务(事务的 id 值是递增的)，所以当前事务【开启Read View的事务】能读取到。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID &gt;&#x3D; m_up_limit_id</font></strong></li>
</ul>
<p><strong><font style="color:black;">表示在当前事务【creator_trx_id】开启以后，有新的事务开启，并且新的事务修改了这行数据的值并提交了事务，因为这是【creator_trx_id】后面的事务修改提交的数据，所以当前事务【creator_trx_id】是不能读取到的。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">m_low_limit_id &#x3D;&lt; DB_TRX_ID &lt; m_up_limit_id</font></strong><ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID  在 m_ids 数组中</font></strong></li>
</ul>
</li>
</ul>
<p><font style="color:rgb(0, 0, 0);"></font><font style="color:rgb(0, 0, 0);">表</font><font style="color:rgb(0, 0, 0);">示DB_TRX_ID【</font><font style="color:rgb(0, 0, 0);">写Undo日志的事务】 和当前事务【creator_trx_id】是在同一</font><font style="color:rgb(0, 0, 0);">时</font><font style="color:rgb(0, 0, 0);">刻开启</font><font style="color:rgb(0, 0, 0);">的</font><font style="color:rgb(0, 0, 0);">事</font><font style="color:rgb(0, 0, 0);">务</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID  不等于creator_trx_id</font></strong></p>
<p><strong><font style="color:rgb(0, 0, 0);">DB_TRX_ID事务修改了数据的值，并提交了事务，所以当前事务【creator_trx_id】不能读取到。</font></strong><font style="color:black;"></font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;DB_TRX_ID  等于creator_trx_id&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt;&lt;/font&gt;
</code></pre>
<p><font style="color:black;"></font><font style="color:rgb(0, 0, 0);">表明数据【Undo日志】 是自己生成的，因此是</font><strong><font style="color:rgb(37, 132, 181);">可见</font></strong><font style="color:rgb(0, 0, 0);">的</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;DB_TRX_ID  不在 m_ids 数组中&lt;/font&gt;**
</code></pre>
<p><strong><font style="color:black;">表示的是在当前事务【creator_trx_id】开启之前，其他事务【DB_TRX_ID】将数据修改后就已经提交了事务，所以当前事务能读取到。</font></strong></p>
<h6 id="读视图可见性判断规则案例说明"><a href="#读视图可见性判断规则案例说明" class="headerlink" title="读视图可见性判断规则案例说明"></a><font style="color:black;">读视图可见性判断规则案例说明</font></h6><p><font style="color:black;">了解了读视图可见性判断规则，下面通过一个场景案例图解的方式来详细逐条验证上述规则。一般来说，我们的行数据结构都为一下模式：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048524181-8e1e70d4-c0b1-49f5-8cb1-32e3dbbb4ed5.webp"></p>
<p><font style="color:black;">假设有一个事物【DB_TRX_ID &#x3D; 10】在表中插入了一条数据，则它的数据结构为为：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048524123-cd2cf78d-57d4-433c-a3d0-c4860e769979.webp"></p>
<ul>
<li><strong><font style="color:black;">【第一步】：假设现在有事务 A【DB_TRX_ID &#x3D; 20】 和事务 B 【DB_TRX_ID &#x3D; 30】并发执行</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">select name from user where id = 1;</span><br><span class="line">#事物B：</span><br><span class="line">update user set name = &#x27;edwin&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">事物开始后分别生成ReadView</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:black;&quot;&gt;事务A的ReadView ：m_ids=[20,30]，m_low_limit_id=20，m_up_limit_id=31，creator_trx_id=20。&lt;/font&gt;**
- **&lt;font style=&quot;color:black;&quot;&gt;事务B的ReadView ：m_ids=[20,30]，m_low_limit_id=20，m_up_limit_id=31，creator_trx_id=30。&lt;/font&gt;**
</code></pre>
<ul>
<li><strong><font style="color:black;">【第二步】：事物A开启事物之后通过版本链</font><strong><strong><font style="color:rgb(37, 132, 181);">第一次</font></strong></strong><font style="color:black;">读取数据，版本链中的DB_TRX_ID &#x3D; 10，小于事物A的【DB_TRX_ID &#x3D; 20】，说明DB_TRX_ID &#x3D; 10这条数据是事物A开启之前就已经写入，并提交了事物，所以事物A可以读取到。</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559781-c6ab3c4f-fc28-41fc-b4cf-25bf985a0d6b.webp"></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">【第三步】：事务 B 【DB_TRX_ID &#x3D; 30】修改数据，将name修改为Edwin，修改后写入Undo Log日志，</font><strong><strong><font style="color:rgb(37, 132, 181);">此时还没有提交事务B</font></strong></strong><font style="color:rgb(1, 1, 1);">。示意图如下：</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559736-8999a648-def3-46d1-8be3-ab48d174d901.webp"></p>
<ul>
<li><strong><font style="color:black;">【第四步】：事务A【DB_TRX_ID &#x3D; 20】</font><strong><strong><font style="color:rgb(37, 132, 181);">第二次</font></strong></strong><font style="color:black;">去读取数据</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">在 undo log版本链中，数据最新版本的事务id为30，这个值处于事务A的 ReadView 里 m_low_limit_id 和 m_up_limit_id 并且存在于m_ids 数组中，表示这个版本的数据是和自己同一时刻启动的事务修改的，因此这个版本的数据，数据 A 读取不到</font>****<font style="color:black;">。</font></strong></p>
<p><font style="color:black;">此时需要沿着 undo log 的版本链向前找，接着会找到该行数据的上一个版本db_trx_id&#x3D;10，由于db_trx_id&#x3D;10小于 m_low_limit_id的值，因此事务 A 能读取到该版本的值，即事务 A 读取到的值是星之码。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559623-6cee2ece-15a0-4afc-b749-8562c3693d60.webp"></p>
<ul>
<li><strong><font style="color:black;">【第五步】：现在事务 B 提交，此时系统中活跃的事务只有事物A，事物A</font><strong><strong><font style="color:rgb(37, 132, 181);">第三次</font></strong></strong><font style="color:black;">读取，读取到内容就有两种可能性：</font></strong></li>
</ul>
<p><strong><font style="color:black;">这里留一个问题一：造成这两种情况的原因是什么？</font></strong></p>
<p><strong><font style="color:black;">我们留到本文第三节【不同隔离级别MVCC实现原理】中说明，继续案例</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;读已提交（RC）隔离级别：读取到是事物B提交的Edwin&lt;/font&gt;****&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;可重复读（RR）隔离级别：读取到是原始数据提交的星河之码&lt;/font&gt;****&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;**
</code></pre>
<ul>
<li><strong><font style="color:black;">【第六步】：新的事物C【DB_TRX_ID &#x3D; 40】修改数据，将name修改为彬</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事物C：</span><br><span class="line">update user set name = &#x27;彬&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">执行脚本前生成的ReadView如下，执行脚本后，提交事物C。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">事务C的ReadView ：m_ids&#x3D;[20,40]，m_low_limit_id&#x3D;20，m_up_limit_id&#x3D;41，creator_trx_id&#x3D;40</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559795-7654eac6-debc-4019-867e-87fd9bd6fe0d.webp"></p>
<ul>
<li><strong><font style="color:black;">【第七步】：事务 A【DB_TRX_ID &#x3D; 20】</font><strong><strong><font style="color:rgb(37, 132, 181);">第四次</font></strong></strong><font style="color:black;">读取数据，</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时由于事物A，由于事物A的m_up_limit_id&#x3D;31，而日志中的DB_TRX_ID&#x3D;40，根据可见性判断规则可以知到，事物A不能读取到DB_TRX_ID&#x3D;40的记录，按照版本链的DB_POLL_PTR继续往上找，找到DB_TRX_ID&#x3D;30的记录，虽然30在事物A的的m_ids&#x3D;[20,30]，但是</font><strong><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID&#x3D;30不等于事物A的creator_trx_id&#x3D;20</font></strong></strong><font style="color:black;">，所以还是不能读取，继续往上找，最终读取到了DB_TRX_ID&#x3D;10的记录，name&#x3D;星河之码</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559686-29a20060-b95e-483a-8701-ba33a77ea3b2.webp"></p>
<p>:::tips<br><font style="color:black;">实际上，这里事务A在不同场景下也是可以读取到DB_TRX_ID&#x3D;40得数据的。</font></p>
<p><font style="color:black;">这里也留一个问题二：在什么场景下能够读取到DB_TRX_ID&#x3D;40得数据name&#x3D;彬呢？</font></p>
<p><font style="color:black;">我们留到本文第三节【不同隔离级别MVCC实现原理】中说明，继续案例</font></p>
<p>:::</p>
<ul>
<li><strong><font style="color:black;">【第八步】：事务 A【DB_TRX_ID &#x3D; 20】开始修改数据，将name 修改为 ‘法外狂徒张三’</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">update user set name = &#x27;法外狂徒张三&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">此时事务A还没有提交，但是已经写入了Undo 日志，新的版本链如下</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048833158-398a5518-357e-412b-914d-4790a49e8c93.webp"></p>
<ul>
<li><strong><font style="color:black;">【第九步】：事务 A</font><strong><strong><font style="color:rgb(37, 132, 181);">第五次</font></strong></strong><font style="color:black;">读取数据</font></strong></li>
</ul>
<p><strong><font style="color:black;">由于Undo日志中的最新数据DB_TRX_ID&#x3D;20等于事物A的creator_trx_id&#x3D;20，说明是自己修改的数据，可以查到，name&#x3D;法外狂徒张三</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048832921-a527647d-5789-49a2-bd67-24a5434a9466.webp"></p>
<p><font style="color:black;">通过以上九个步骤图解的方式，对读视图可见性判断规则做了分析，通过ReadView 和 undo log分析了MVCC 的实现原理，接下来结合事务的隔离级别，看看MVCC是怎么读取数据的。</font></p>
<h5 id="不同隔离级别MVCC实现原理"><a href="#不同隔离级别MVCC实现原理" class="headerlink" title="不同隔离级别MVCC实现原理"></a>不同隔离级别MVCC实现原理</h5><h6 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h6><p><font style="color:black;">通过上述对【Read View】的分析可以总结出：</font><strong><font style="color:rgb(37, 132, 181);">InnoDB 实现MVCC是通过</font><strong><strong><font style="color:rgb(30, 107, 184);"> </font></strong></strong><font style="color:rgb(30, 107, 184);">Read View与Undo Log</font><strong><strong><font style="color:rgb(37, 132, 181);"> </font></strong></strong><font style="color:rgb(37, 132, 181);">实现的，Undo Log 保存了历史快照，形成版版本链，Read View可见性规则判断当前版本的数据是否可见</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">InnnoDB执行查询语句的具体步骤为</font></strong><font style="color:black;">：</font></p>
<ul>
<li><strong><font style="color:black;">执行语句之前获取查询事务自己的事务Id，即事务版本号。</font></strong></li>
<li><strong><font style="color:black;">通过事务id获取Read View</font></strong></li>
<li><strong><font style="color:black;">查询存储的数据，将其事务Id与Read View中的事务版本号进行比较</font></strong></li>
<li><strong><font style="color:black;">不符合Read View的可见性规则，则读取Undo log中历史快照数据</font></strong></li>
<li><strong><font style="color:black;">找到当前事务能够读取的数据返回</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">而在实际的使用过程中，Read View在不同的隔离级别下是得工作方式是不一样</font></strong><font style="color:black;">。</font></p>
<h6 id="读已提交（RC）MVCC实现原理"><a href="#读已提交（RC）MVCC实现原理" class="headerlink" title="读已提交（RC）MVCC实现原理"></a>读已提交（RC）MVCC实现原理</h6><p><strong><font style="color:rgb(37, 132, 181);">在读已提交(Read committed)的隔离级别下实现MVCC，同一个事务里面，【每一次查询都会产生一个新的Read View副本】，这样可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">还是按照上述案例来说明一下：</font></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">【第一步】：准备一条原始数据</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717049082035-9b10eb14-bac6-4727-b729-554586cc0f3b.webp"></p>
<ul>
<li><strong><font style="color:black;">【第二步】：假设现在有事务 A【DB_TRX_ID &#x3D; 20】 和事务 B 【DB_TRX_ID &#x3D; 30】并发执行</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">select name from user where id = 1;</span><br><span class="line">#事物B：</span><br><span class="line">update user set name = &#x27;edwin&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">执行过程为</font></strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong><font style="color:rgb(1, 1, 1);">开始事务</font></strong></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 222, 203);">第一次查询：select name from user where id &#x3D; 1;</font></strong></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);">开始事务</font></strong></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 248, 248);">执行修改：update user set name &#x3D; ‘edwin’ where id &#x3D; 1;</font></strong></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);">   </font>****<font style="color:rgb(1, 1, 1);">提交事务</font></strong></td>
</tr>
<tr>
<td>6</td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 248, 248);">第二次查询：select name from user where id &#x3D; 1;</font></strong></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td><strong><font style="color:rgb(1, 1, 1);">提交事务</font></strong></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong><font style="color:black;">版本链为：</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717049340079-d389ca08-a8b4-47fb-a95e-1b69427149a0.webp"></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例结果分析</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">上述案例在</font><strong><font style="color:rgb(37, 132, 181);">在读已提交(Read committed)的隔离级别下实现，同一个事务里面，【每一次查询都会产生一个新的Read View副本】</font></strong><font style="color:black;">。所以第二步实际上产生了三个Read View</font></p>
<table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_ids</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_low_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_up_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">creator_trx_id</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">事务A：第一次查询Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>20</td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">事务B：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>30</td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">事务A：第二次查询Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>20</td>
</tr>
</tbody></table>
<p><font style="color:black;">通过可见性判断：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第一次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">日志事务Id【DB_TRX_ID &#x3D; 10】 &lt; 最小活跃事务ID【m_low_limit_id&#x3D;20】，因此可以读取到DB_TRX_ID &#x3D; 10这条版本链中的数据。即name &#x3D; 星河之码。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第二次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时事务B已经提交，版本链中最新版本为DB_TRX_ID &#x3D; 30，而可见性规则中虽然满足</font></strong></p>
<p><strong><font style="color:black;">【m_low_limit_id&#x3D;20】&#x3D;&lt;【DB_TRX_ID&#x3D;30】&lt;【m_up_limit_id&#x3D;31】但是【DB_TRX_ID&#x3D;30】不在m_ids集合[20]中，因此事务A的第二次查询可以读取【DB_TRX_ID&#x3D;30】的数据，即name &#x3D; edwin。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例总结</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">通过上述案例说明，</font><strong><font style="color:rgb(37, 132, 181);">同一个事务A的两个相同查询，第一次结果为星河之码，第二次结果为edwin，因此在读已提交（RC）隔离级别下，存在不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<h6 id="可重复读（RR）MVCC实现原理"><a href="#可重复读（RR）MVCC实现原理" class="headerlink" title="可重复读（RR）MVCC实现原理"></a>可重复读（RR）MVCC实现原理</h6><p><strong><font style="color:rgb(37, 132, 181);">在可重复读(Repeatable read)的隔离级别下实现MVCC，【同一个事务里面，多次查询，都只会产生一个共用Read View】，以此不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">案例与读已提交一样，这里就不重复赘述，可以再看一遍读已提交的【第一步】【第二步】，直接进行案例分析</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例结果分析</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">由于同一个事物只会产生一个共用Read View，所以可重复读的隔离级别下第二步只产生了两个Read View</font></p>
<p><font style="color:black;">上述案例在</font><strong><font style="color:rgb(37, 132, 181);">可重复读(Repeatable read)，【每一次查询都会产生一个新的Read View副本】</font></strong><font style="color:black;">。所以第二步实际上产生了三个Read View</font></p>
<table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_ids</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_low_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_up_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">creator_trx_id</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">事务A：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td><font style="color:rgb(0, 0, 0);">31</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">事务B：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td><font style="color:rgb(0, 0, 0);">31</font></td>
<td><font style="color:rgb(0, 0, 0);">30</font></td>
</tr>
</tbody></table>
<p><font style="color:black;">通过可见性判断：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第一次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">日志事务Id【DB_TRX_ID &#x3D; 10】 &lt; 最小活跃事务ID【m_low_limit_id&#x3D;20】，因此可以读取到DB_TRX_ID &#x3D; 10这条版本链中的数据。即name &#x3D; 星河之码。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第二次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时事务B已经提交，版本链中最新版本为DB_TRX_ID &#x3D; 30，而可见性规则中虽然满足</font></strong></p>
<p><strong><font style="color:black;">【m_low_limit_id&#x3D;20】&#x3D;&lt;【DB_TRX_ID&#x3D;30】&lt;【m_up_limit_id&#x3D;20】并且【DB_TRX_ID&#x3D;30】也在m_ids集合[20，30]中，但是【DB_TRX_ID&#x3D;30】不等于事物A的【creator_trx_id&#x3D;20】，说明</font><strong><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID&#x3D;30是同一时刻其他事物提交的，事物A不能读取到</font></strong></strong><font style="color:black;">，因此事物A只能按照版本链继续往上找，最终读取到【DB_TRX_ID&#x3D;10】的数据，即name &#x3D; 星河之码。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例总结</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">通过上述案例说明，</font><strong><font style="color:rgb(37, 132, 181);">同一个事务A的两个相同查询，结果都为星河之码，因此在可重复读（RR）隔离级别下，解决了不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<p>:::tips<br><font style="color:black;">其实读已经提交与可重复读的可见性判断的区别就在于事务A第二次查询时使用的Read View不同。</font></p>
<p>:::</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/2023/06/14/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p><font style="color:rgb(34, 34, 34);">MySQL官方对索引定义：是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护工作。</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">索引是物理数据页存储，在数据文件中（InnoDB，ibd文件），利用数据页(page)存储。</font></li>
<li><font style="color:rgb(34, 34, 34);">索引可以加快检索速度，但是同时也会降低增删改操作速度，索引维护需要代价。</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">索引涉及的理论知识：二分查找法、Hash和B+Tree。</font></p>
<span id="more"></span>
<h2 id="理论知识补充"><a href="#理论知识补充" class="headerlink" title="理论知识补充"></a><font style="color:rgb(34, 34, 34);">理论知识补充</font></h2><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a><font style="color:rgb(34, 34, 34);">二分查找法</font></h3><p><font style="color:rgb(34, 34, 34);">二分查找法也叫作折半查找法，它是在有序数组中查找指定数据的搜索算法。它的优点是等值查询、范围查询性能优秀，缺点是更新数据、新增数据、删除数据维护成本高。</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">首先定位left和right两个指针</font></li>
<li><font style="color:rgb(34, 34, 34);">计算(left+right)&#x2F;2</font></li>
<li><font style="color:rgb(34, 34, 34);">判断除2后索引位置值与目标值的大小比对</font></li>
<li><font style="color:rgb(34, 34, 34);">索引位置值大于目标值就-1，right移动；如果小于目标值就+1，left移动</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">举个例子，下面的有序数组有17 个值，查找的目标值是7，过程如下：</font><font style="color:rgb(34, 34, 34);">第一次查找：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582381776-4e840986-b812-4e5f-a60f-827f05d8e8c4.png"></p>
<p><font style="color:rgb(34, 34, 34);">第二次查找：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582381804-ca77fbb7-3dc6-4ca0-b733-e5408695b5c9.png"></p>
<h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a><font style="color:rgb(34, 34, 34);">Hash结构</font></h3><p><font style="color:rgb(34, 34, 34);">Hash底层实现是由Hash表来实现的，是根据键值 &lt;key,value&gt; 存储数据的结构。非常适合根据key查找value值，也就是单个key查询，或者说等值查询。其结构如下所示：</font></p>
<p><font style="color:rgb(34, 34, 34);">从上面结构可以看出，Hash索引可以方便的提供等值查询，但是对于范围查询就需要全表扫描了。</font><font style="color:rgb(34, 34, 34);">Hash索引在MySQL 中Hash结构主要应用在Memory原生的Hash索引 、InnoDB 自适应哈希索引。InnoDB自适应哈希索引是为了提升查询效率，InnoDB存储引擎会监控表上各个索引页的查询，当InnoDB注意到某些索引值访问非常频繁时，会在内存中基于B+Tree索引再创建一个哈希索引，使得内存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。</font><font style="color:rgb(34, 34, 34);">InnoDB自适应哈希索引：在使用Hash索引访问时，一次性查找就能定位数据，等值查询效率要优于B+Tree。</font><font style="color:rgb(34, 34, 34);">自适应哈希索引的建立使得InnoDB存储引擎能自动根据索引页访问的频率和模式自动地为某些热点页建立哈希索引来加速访问。另外InnoDB自适应哈希索引的功能，用户只能选择开启或关闭功能，无法进行人工干涉。</font></p>
<p><font style="color:rgb(34, 34, 34);">show engine innodb status \G; show variables like ‘%innodb_adaptive%’;</font></p>
<h3 id="B-Tree结构"><a href="#B-Tree结构" class="headerlink" title="B+Tree结构"></a><font style="color:rgb(34, 34, 34);">B+Tree结构</font></h3><p><font style="color:rgb(34, 34, 34);">MySQL数据库索引采用的是B+Tree结构，在B-Tree结构上做了优化改造。</font><strong><font style="color:rgb(34, 34, 34);">B-Tree结构：</font></strong></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">索引值和data数据分布在整棵树结构中</font></li>
<li><font style="color:rgb(34, 34, 34);">每个节点可以存放多个索引值及对应的data数据</font></li>
<li><font style="color:rgb(34, 34, 34);">树节点中的多个索引值从左到右升序排列</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582445512-084761dc-a43d-4fa7-a324-b486a9bd9f2c.png"></p>
<p><font style="color:rgb(34, 34, 34);">B树的搜索：从根节点开始，对节点内的索引值序列采用二分法查找，如果命中就结束查找。没有命中会进入子节点重复查找过程，直到所对应的的节点指针为空，或已经是叶子节点了才结束。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">B+Tree结构：</font></strong></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">非叶子节点不存储data数据，只存储索引值，这样便于存储更多的索引值</font></li>
<li><font style="color:rgb(34, 34, 34);">叶子节点包含了所有的索引值和data数据</font></li>
<li><font style="color:rgb(34, 34, 34);">叶子节点用指针连接，提高区间的访问性能</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582445510-500a20d8-3412-44cb-9757-1d2eb6059062.png"></p>
<p><font style="color:rgb(34, 34, 34);">相比B树，B+树进行范围查找时，只需要查找定位两个节点的索引值，然后利用叶子节点的指针进行遍历即可。而B树需要遍历范围内所有的节点和数据，显然B+Tree效率高。</font></p>
<h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a><font style="color:rgb(34, 34, 34);">索引基础</font></h2><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><pre><code>- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;索引减小了需要扫描的数据量，从而大大加快数据的检索速度（创建索引的最主要的原因）&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;可以加速表与表的连接&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;可以显著的减少查询中分组和排序的时间&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;索引可以帮助服务器避免排序和创建临时表&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;索引可以将随机IO变成顺序IO&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">索引既然有这么多优点，那为什么不对表中每个列都建一个索引呢，这样不是更加能提升性能吗，实际上这是不可取的，索引虽然有诸多优点，但是也有很多缺点</font></p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong><font style="color:rgb(1, 1, 1);">对表中的数据进行增、删、改的时候，索引也要动态的维护，降低了数据的写入速度</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">随着数据量的增加，创建索引和维护索引要耗费时间也会越来越长，影响性能</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">索引的存储需要占物理空间，每一个索引都要占用一定的物理空间</font></strong></li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><font style="color:black;">MySQL索引的类型其实只有五种，但是我们经常会听到很多种不同的索引，那其实是在不同维度划分的类型：</font></p>
<ul>
<li><strong><font style="color:black;">存储结构维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">B Tree索引、Hash索引、B + Tree索引</font></strong></p>
<ul>
<li><strong><font style="color:black;">应用层次维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">普通索引、唯一索引、主键索引、复合索引、全文索引，空间索引</font></strong></p>
<ul>
<li><strong><font style="color:black;">索引键值类型维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">主键索引、辅助索引（二级索引）</font></strong></p>
<ul>
<li><strong><font style="color:black;">数据存储和索引键值逻辑关系维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">聚集索引（聚簇索引）、非聚集索引（非聚簇索引）</font></strong></p>
<ul>
<li><strong><font style="color:black;">索引组成维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">组合索引（复合索引）、单一索引</font></strong></p>
<p><strong><font style="color:black;">因为只是分类的维度不同那我们以普通索引、唯一索引、主键索引、复合索引，空间索引为例</font></strong></p>
<h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a><font style="color:black;">普通索引</font></h4><p><font style="color:rgb(34, 34, 34);">这是最基本的索引类型，基于普通字段建立的索引，没有任何限制。是辅助索引的一种。对应逻辑关系中的非聚集索引。索引列单独保存，查询的时候根据索引查到数据后再从主键索引中将完整的数据取出，这个过程称为回表查询。创建普通索引的方法如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名);</span><br><span class="line">ALTER TABLE tablename ADD INDEX [索引的名字] (字段名);</span><br><span class="line">CREATE TABLE tablename ( [...], INDEX [索引的名字] (字段名) );</span><br></pre></td></tr></table></figure>

<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a><font style="color:black;">唯一索引</font></h4><p><font style="color:rgb(34, 34, 34);">与”普通索引”类似，不同的就是：索引字段的值必须唯一，但允许有空值 。在创建或修改表时追加唯一约束，就会自动创建对应的唯一索引。创建唯一索引的方法如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX &lt;索引的名字&gt; ON tablename (字段名);</span><br><span class="line">ALTER TABLE tablename ADD UNIQUE INDEX [索引的名字] (字段名);</span><br><span class="line">CREATE TABLE tablename ( [...], UNIQUE [索引的名字] (字段名) ;</span><br></pre></td></tr></table></figure>

<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a><font style="color:black;">主键索引</font></h4><p><font style="color:rgb(34, 34, 34);">它是一种特殊的唯一索引，不允许有空值。在创建或修改表时追加主键约束即可，每个表只能有一个主键。对应逻辑关系划分中的聚集索引。索引的数据和索引保存在一起</font></p>
<p><font style="color:rgb(34, 34, 34);">创建主键索引的方法如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tablename ( [...], PRIMARY KEY (字段名) );</span><br><span class="line">ALTER TABLE tablename ADD PRIMARY KEY (字段名);</span><br></pre></td></tr></table></figure>

<h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p><font style="color:rgb(34, 34, 34);">复合索引是普通索引的一种，单一索引是指索引列为一列的情况，即新建索引的语句只实施在一列上；用户可以在多个列上建立索引，这种索引叫做组复合索引（组合索引）。复合索引可以代替多个单一索引，相比多个单一索引复合索引所需的开销更小。索引同时有两个概念叫做窄索引和宽索引，窄索引是指索引列为1-2列的索引，宽索引也就是索引列超过2列的索引，设计索引的一个重要原则就是能用窄索引不用宽索引，因为窄索引往往比组合索引更有效。创建组合索引的方法如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名1，字段名2...);</span><br><span class="line">ALTER TABLE tablename ADD INDEX [索引的名字] (字段名1，字段名2...);</span><br><span class="line">CREATE TABLE tablename ( [...], INDEX [索引的名字] (字段名1，字段名2...) );</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(34, 34, 34);">复合索引使用注意事项：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">何时使用复合索引，要根据where条件建索引，注意不要过多使用索引，过多使用会对更新操作效率有很大影响。</font></li>
<li><font style="color:rgb(34, 34, 34);">如果表已经建立了(col1，col2)，就没有必要再单独建立（col1）；如果现在有(col1)索引，如果查询需要col1和col2条件，可以建立(col1,col2)复合索引，对于查询有一定提高。</font></li>
<li><font style="color:rgb(34, 34, 34);">复合索引在生效时OrderBy中有复合索引中的字段会增加查询速度</font></li>
<li><font style="color:rgb(34, 34, 34);">额外介绍一下覆盖索引：当查询结果需要的字段都在复合索引中就不需要回表查询</font></li>
</ul>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a><font style="color:black;">全文索引</font></h4><p><font style="color:rgb(34, 34, 34);">查询操作在数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果使用全文索引，查询速度会比like快很多倍。在MySQL 5.6 以前的版本，只有MyISAM存储引擎支持全文索引，从MySQL 5.6开始MyISAM和InnoDB存储引擎均支持。</font><font style="color:rgb(34, 34, 34);">创建全文索引的方法如下：</font></p>
<p><font style="color:rgb(0, 0, 0);">CREATE</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">FULLTEXT</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">INDEX</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(152, 26, 26);">&lt;</font><font style="color:rgb(0, 0, 0);">索引的名字</font><font style="color:rgb(152, 26, 26);">&gt;</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">ON</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 255);">tablename</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">(</font><font style="color:rgb(0, 0, 0);">字段名</font><font style="color:rgb(34, 34, 34);">);</font><font style="color:rgb(34, 34, 34);"><br></font><font style="color:rgb(0, 0, 0);">ALTER</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">TABLE</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">tablename</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">ADD</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">FULLTEXT</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">[</font><font style="color:rgb(0, 0, 0);">索引的名字</font><font style="color:rgb(34, 34, 34);">] (</font><font style="color:rgb(0, 0, 0);">字段名</font><font style="color:rgb(34, 34, 34);">);</font><font style="color:rgb(34, 34, 34);"><br></font><font style="color:rgb(0, 0, 0);">CREATE</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">TABLE</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 255);">tablename</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">( […],</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">FULLTEXT</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">KEY</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">[</font><font style="color:rgb(0, 0, 0);">索引的名字</font><font style="color:rgb(34, 34, 34);">] (</font><font style="color:rgb(0, 0, 0);">字段名</font><font style="color:rgb(34, 34, 34);">) ;</font></p>
<p><font style="color:rgb(34, 34, 34);">和常用的like模糊查询不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如</font></p>
<p><font style="color:rgb(34, 34, 34);">select * from user where match(name) against(‘aaa’);</font></p>
<p><font style="color:rgb(34, 34, 34);">全文索引使用注意事项：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">全文索引必须在字符串、文本字段上建立。</font></li>
<li><font style="color:rgb(34, 34, 34);">全文索引字段值必须在最小字符和最大字符之间的才会有效。（innodb：3-84；myisam：4-84）</font></li>
<li><font style="color:rgb(34, 34, 34);">全文索引字段值要进行切词处理，按syntax字符进行切割，例如b+aaa，切分成b和aaa</font></li>
<li><font style="color:rgb(34, 34, 34);">全文索引匹配查询，默认使用的是等值匹配，例如a匹配a，不会匹配ab,ac。如果想匹配可以在布尔模式下搜索a*</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">select * from user where match(name) against(‘a*’ in boolean mode);</font></p>
<h3 id="索引创建准则"><a href="#索引创建准则" class="headerlink" title="索引创建准则"></a>索引创建准则</h3><p><font style="color:rgb(0, 0, 0);">基于以上索引的介绍，我们知道索引优缺点都很明显，</font><strong><font style="color:rgb(37, 132, 181);">我们不能在表数据中所有的列都添加索引，需要根据具体场景选择创建索引的列与类型</font></strong><font style="color:rgb(0, 0, 0);">。那么具体应该在那些列中添加索引，那些列中不能添加索引呢？</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">能创建索引的列</font></strong><ul>
<li><strong><font style="color:rgb(1, 1, 1);">主键索引，在MySQL中，主键列会默认的当成唯一性索引</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">在业务场景中被【</font><strong><strong><font style="color:rgb(37, 132, 181);">当成条件查询的列</font></strong></strong><font style="color:rgb(1, 1, 1);">】创建索引，可以提高查询效率</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">外键索引，比如需要【</font><strong><strong><font style="color:rgb(37, 132, 181);">用于JOIN的列</font></strong></strong><font style="color:rgb(1, 1, 1);">】创建索引，可以提高连接的速度</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">由于索引是已经排序的，所以在经常【</font><strong><strong><font style="color:rgb(37, 132, 181);">用于范围查询的列</font></strong></strong><font style="color:rgb(1, 1, 1);">】和需要【</font><strong><strong><font style="color:rgb(37, 132, 181);">排序的列</font></strong></strong><font style="color:rgb(1, 1, 1);">】创建索引，可以避免排序，提高查询效率</font></strong></li>
</ul>
</li>
<li><strong><font style="color:rgb(37, 132, 181);">不能创建索引的列</font></strong><ul>
<li><strong><font style="color:rgb(1, 1, 1);">经常用于计算的列</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">数据值很少或者大量重复的列</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">大字段的列</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">经常修改的列</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">很少使用的字段</font></strong></li>
</ul>
</li>
</ul>
<p>:::tips<br><strong><font style="color:rgb(0, 0, 0);">以上几种情况的列，一般不建议创建索引，非但不能提高查询速度，反而增加索引后提高了数据的维护时间成本和空间成本。</font></strong></p>
<p>:::</p>
<h3 id="索引创建与删除"><a href="#索引创建与删除" class="headerlink" title="索引创建与删除"></a>索引创建与删除</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><strong><font style="color:rgb(0, 0, 0);">索引的创建方式有三种：建表时创建索引，已存在的表上直接创建索引，已存在的表上新增列并创建索引</font></strong></p>
<h5 id="建表时创建索引："><a href="#建表时创建索引：" class="headerlink" title="建表时创建索引："></a>建表时创建索引：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">    字段名1  数据类型 [完整性约束条件…],</span><br><span class="line">    字段名2  数据类型 [完整性约束条件…],</span><br><span class="line">    [NORMAL | UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY</span><br><span class="line">    [索引名]  (字段名[(长度)]  [ASC | DE</span><br></pre></td></tr></table></figure>

<h5 id="已存在的表上直接创建索引"><a href="#已存在的表上直接创建索引" class="headerlink" title="已存在的表上直接创建索引"></a><font style="color:rgb(0, 0, 0);">已存在的表上直接创建索引</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE  [NORMAL | UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名  ON 表名 (字段名[(长度)]  [ASC | DESC]) </span><br></pre></td></tr></table></figure>

<h5 id="已存在的表上新增列并创建索引（修改表结构）"><a href="#已存在的表上新增列并创建索引（修改表结构）" class="headerlink" title="已存在的表上新增列并创建索引（修改表结构）"></a><font style="color:rgb(0, 0, 0);">已存在的表上新增列并创建索引（修改表结构）</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD  [NORMAL | UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)]  [ASC | DESC]) ;</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li><strong><font style="color:black;">NORMAL | UNIQUE | FULLTEXT | SPATIAL</font></strong></li>
</ul>
<p><strong><font style="color:black;">可选参数，Normal 普通索引，Unique 唯一索引，Full Text 全文索引，SPATIAL 空间索引</font></strong></p>
<ul>
<li><strong><font style="color:black;">INDEX | KEY</font></strong></li>
</ul>
<p><strong><font style="color:black;">同义词，作用相同，用来指定创建索引</font></strong></p>
<ul>
<li><strong><font style="color:black;">ASC | DESC</font></strong></li>
</ul>
<p><strong><font style="color:black;">指定升序或降序的索引值存储</font></strong></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX 索引名 ON 表名字;</span><br></pre></td></tr></table></figure>

<h3 id="相关SQL"><a href="#相关SQL" class="headerlink" title="相关SQL"></a>相关SQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看表结构</span><br><span class="line">desc table_name;</span><br><span class="line"></span><br><span class="line">//查看生成表的SQL</span><br><span class="line">show create table table_name;</span><br><span class="line"></span><br><span class="line">//查看索引结构信息</span><br><span class="line">show index from  table_name;</span><br><span class="line"></span><br><span class="line">//查看SQL执行时间</span><br><span class="line">set profiling = 1;</span><br><span class="line">select * from user where id=1; </span><br><span class="line">show profiles;</span><br></pre></td></tr></table></figure>







<p><font style="color:rgb(34, 34, 34);"></font></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>索引分析与优化</title>
    <url>/2023/06/15/%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a><font style="color:rgb(34, 34, 34);">EXPLAIN</font></h3><p><font style="color:rgb(34, 34, 34);">MySQL 提供了一个 EXPLAIN 命令，它可以对 SELECT 语句进行分析，并输出 SELECT 执行的详细信息，供开发人员有针对性的优化。例如：</font></p>
<p><font style="color:rgb(34, 34, 34);">EXPLAIN SELECT * from user WHERE id &lt; 3;</font></p>
<p><font style="color:rgb(34, 34, 34);">EXPLAIN 命令的输出内容大致如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582561774-3eca4d5a-9d80-402a-9bf5-941d77d94c23.png"></p>
<span id="more"></span>
<p><strong><font style="color:rgb(34, 34, 34);">1. select_type</font></strong><font style="color:rgb(34, 34, 34);">:</font><font style="color:rgb(34, 34, 34);">表示查询的类型。常用的值如下：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">SIMPLE ： 表示查询语句不包含子查询或union</font></li>
<li><font style="color:rgb(34, 34, 34);">PRIMARY：表示此查询是最外层的查询</font></li>
<li><font style="color:rgb(34, 34, 34);">UNION：表示此查询是UNION的第二个或后续的查询</font></li>
<li><font style="color:rgb(34, 34, 34);">DEPENDENT UNION：UNION中的第二个或后续的查询语句，使用了外面查询结果</font></li>
<li><font style="color:rgb(34, 34, 34);">UNION RESULT：UNION的结果</font></li>
<li><font style="color:rgb(34, 34, 34);">SUBQUERY：SELECT子查询语句</font></li>
<li><font style="color:rgb(34, 34, 34);">DEPENDENT SUBQUERY：SELECT子查询语句依赖外层查询的结果。</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">最常见的查询类型是SIMPLE，表示我们的查询没有子查询也没用到UNION查询。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">2.type</font></strong><font style="color:rgb(34, 34, 34);">表示存储引擎查询数据时采用的方式。比较重要的一个属性，通过它可以判断出查询是全表扫描还是基于索引的部分扫描。常用属性值如下，从上至下效率依次增强。</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">ALL：表示全表扫描，性能最差。</font></li>
<li><font style="color:rgb(34, 34, 34);">index：表示基于索引的全表扫描，先扫描索引再扫描全表数据。</font></li>
<li><font style="color:rgb(34, 34, 34);">range：表示使用索引范围查询。使用&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、in等等。</font></li>
<li><font style="color:rgb(34, 34, 34);">ref：表示使用非唯一索引进行单值查询。</font></li>
<li><font style="color:rgb(34, 34, 34);">eq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录，都只能匹配后面表的一行结果。</font></li>
<li><font style="color:rgb(34, 34, 34);">const：表示使用主键或唯一索引做等值查询，常量查询。</font></li>
<li><font style="color:rgb(34, 34, 34);">NULL：表示不用访问表，速度最快。</font></li>
</ul>
<p><strong><font style="color:rgb(34, 34, 34);">3. possible_keys</font></strong><font style="color:rgb(34, 34, 34);">表示查询时能够使用到的索引。注意并不一定会真正使用，显示的是索引名称。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">4. key</font></strong><font style="color:rgb(34, 34, 34);">表示查询时真正使用到的索引，显示的是索引名称。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">5. rows</font></strong><font style="color:rgb(34, 34, 34);">MySQL查询优化器会根据统计信息，估算SQL要查询到结果需要扫描多少行记录。原则上rows是越少效率越高，可以直观的了解到SQL效率高低。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">6. key_len</font></strong><font style="color:rgb(34, 34, 34);">表示查询使用了索引的字节数量。可以判断是否全部使用了组合索引。key_len的计算规则如下：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">字符串类型</font><font style="color:rgb(34, 34, 34);">字符串长度跟字符集有关：latin1&#x3D;1、gbk&#x3D;2、utf8&#x3D;3、utf8mb4&#x3D;4</font><font style="color:rgb(34, 34, 34);">char(n)：n*字符集长度</font><font style="color:rgb(34, 34, 34);">varchar(n)：n * 字符集长度 + 2字节</font></li>
<li><font style="color:rgb(34, 34, 34);">数值类型</font><font style="color:rgb(34, 34, 34);">TINYINT：1个字节</font><font style="color:rgb(34, 34, 34);">SMALLINT：2个字节</font><font style="color:rgb(34, 34, 34);">MEDIUMINT：3个字节</font><font style="color:rgb(34, 34, 34);">INT、FLOAT：4个字节</font><font style="color:rgb(34, 34, 34);">BIGINT、DOUBLE：8个字节</font></li>
<li><font style="color:rgb(34, 34, 34);">时间类型</font><font style="color:rgb(34, 34, 34);">DATE：3个字节</font><font style="color:rgb(34, 34, 34);">TIMESTAMP：4个字节</font><font style="color:rgb(34, 34, 34);">DATETIME：8个字节</font></li>
<li><font style="color:rgb(34, 34, 34);">字段属性</font><font style="color:rgb(34, 34, 34);">NULL属性占用1个字节，如果一个字段设置了NOT NULL，则没有此项。</font></li>
</ul>
<p><strong><font style="color:rgb(34, 34, 34);">7. Extra</font></strong><font style="color:rgb(34, 34, 34);">Extra表示很多额外的信息，各种操作会在Extra提示相关信息，常见几种如下：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">Using where</font><font style="color:rgb(34, 34, 34);">表示查询需要通过索引回表查询数据。</font></li>
<li><font style="color:rgb(34, 34, 34);">Using index</font><font style="color:rgb(34, 34, 34);">表示查询需要通过索引，索引就可以满足所需数据。</font></li>
<li><font style="color:rgb(34, 34, 34);">Using filesort</font><font style="color:rgb(34, 34, 34);">表示查询出来的结果需要额外排序，数据量小在内存，大的话在磁盘，因此有Using filesort建议优化。</font></li>
<li><font style="color:rgb(34, 34, 34);">Using temprorary查询使用到了临时表，一般出现于去重、分组等操作。</font></li>
</ul>
<h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a><font style="color:rgb(34, 34, 34);">回表查询</font></h3><p><font style="color:rgb(34, 34, 34);">InnoDB索引有聚簇索引和辅助索引。聚簇索引的叶子节点存储行记录，InnoDB必须要有，且只有一个。辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记录，通常情况下，需要扫码两遍索引树。先通过辅助索引定位主键值，然后再通过聚簇索引定位行记录，这就叫做</font><strong><font style="color:rgb(34, 34, 34);">回表查询</font></strong><font style="color:rgb(34, 34, 34);">，它的性能比扫一遍索引树低。总结：通过索引查询主键值，然后再去聚簇索引查询记录信息</font></p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><font style="color:rgb(34, 34, 34);">覆盖索引</font></h3><p><font style="color:rgb(34, 34, 34);">在MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为Using</font><font style="color:rgb(34, 34, 34);">index时，能够触发索引覆盖。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582583684-130fc794-b0d8-4a44-b0c4-995a7b1499ea.png"></p>
<p><strong><font style="color:rgb(34, 34, 34);">只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫做索引覆盖</font></strong><font style="color:rgb(34, 34, 34);">。实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。</font></p>
<p><font style="color:rgb(34, 34, 34);"></font></p>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a><strong><font style="color:black;">最左前缀原则</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「组合索引使用时遵循最左前缀原则，最左前缀顾名思义，就是最左优先，即查询中使用到最左边的列， 那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717061817669-5ea5e340-a576-4631-9ab0-5af75552ac2b.webp"></p>
<h3 id="索引与排序"><a href="#索引与排序" class="headerlink" title="索引与排序"></a><font style="color:rgb(34, 34, 34);">索引与排序</font></h3><p><font style="color:rgb(34, 34, 34);">MySQL查询支持filesort和index两种方式的排序，</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">filesort是先把结果查出，然后在缓存或磁盘进行排序操作，效率较低。</font></li>
<li><font style="color:rgb(34, 34, 34);">index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。</font></li>
</ul>
<h4 id="排序方式的选择"><a href="#排序方式的选择" class="headerlink" title="排序方式的选择"></a><font style="color:black;">排序方式的选择</font></h4><h5 id="使用index排序的场景"><a href="#使用index排序的场景" class="headerlink" title="使用index排序的场景"></a>使用<font style="color:rgb(34, 34, 34);">index排序的场景</font></h5><p><font style="color:black;">ORDER BY 子句索引列组合满足索引最左前列</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select id from user order by id; //对应(id)、(id,name)索引有效</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">WHERE子句+ORDER BY子句索引列组合满足索引最左前缀</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age,name)组合索引</span><br><span class="line">explain select id from user where age=18 order by name;</span><br></pre></td></tr></table></figure>

<h5 id="使用filesort方式的排序的场景"><a href="#使用filesort方式的排序的场景" class="headerlink" title="使用filesort方式的排序的场景"></a>使用filesort方式的排序的场景</h5><p><font style="color:black;">对索引列</font>同时使用了<font style="color:black;">ASC和DESC</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age,name)组合索引</span><br><span class="line">explain select id from user order by age asc,name desc;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">WHERE子句和ORDER BY子句满足最左前缀，但where子句使用了范围查询（例如&gt;、&lt;、in 等）</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age,name)组合索引</span><br><span class="line">explain select id from user where age&gt;10 order by name;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">ORDER BY或者WHERE+ORDER BY索引列没有满足索引最左前缀</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age,name)组合索引</span><br><span class="line">explain select id from user order by name;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">使用了不同的索引，MySQL每次只采用一个索引，ORDER BY涉及了两个索引</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(name)、(age)两个索引</span><br><span class="line">explain select id from user order by name,age;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">WHERE子句与ORDER BY子句，使用了不同的索引</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(name)、(age)索引</span><br><span class="line">explain select id from user where name=&#x27;tom&#x27; order by age;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">WHERE子句或者ORDER BY子句中索引列使用了表达式，包括函数表达式</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age)索引</span><br><span class="line">explain select id from user order by abs(age);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(0, 0, 0);"></font></p>
<h4 id="filesort排序"><a href="#filesort排序" class="headerlink" title="filesort排序"></a><font style="color:rgb(34, 34, 34);">filesort排序</font></h4><p><strong><font style="color:rgb(34, 34, 34);">filesort有两种排序算法：双路排序和单路排序。</font></strong></p>
<h5 id="双路排序"><a href="#双路排序" class="headerlink" title="双路排序"></a><font style="color:rgb(34, 34, 34);">双路排序</font></h5><p><font style="color:rgb(34, 34, 34);">需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序；第二次去读取其他字段数据。</font></p>
<h5 id="单路排序"><a href="#单路排序" class="headerlink" title="单路排序"></a><font style="color:rgb(34, 34, 34);">单路排序</font></h5><p><font style="color:rgb(34, 34, 34);">从磁盘查询所需的所有列数据，然后在内存排序将结果返回。</font></p>
<p><font style="color:rgb(34, 34, 34);"></font></p>
<p><font style="color:rgb(34, 34, 34);">如果查询数据超出缓存sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。</font></p>
<p><font style="color:rgb(34, 34, 34);">解决方案：少使用select *；增加sort_buffer_size容量和max_length_for_sort_data容量。</font></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>索引失效场景</title>
    <url>/2023/06/11/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<ol>
<li>没有遵从最左原则：因为常用的索引是B+树结构的，而B+树是有序的，而这个有序是根据索引最左边的字段排序的，所以相对的组合索引中其他的字段并不是有序的</li>
<li>范围查询放在最后（这里需要注意并不是在写语句的时候讲范围查询放在最后，而是将索引字段中可能出现范围查询的字段放在最后）</li>
<li>使用select  from table 聚合索引和非聚合索引的差距就在于聚合索引的根保存的是完整的数据，而非聚合索引保存的是索引的值+聚合索引的Key，所以这里就引出了覆盖索引的概念，当你搜索的值都是索引列，就会用到覆盖索引，直接返回结果，不用再使用聚合索引的key去回表查询，效率就会有所提高。select * 大概率是要回表的。</li>
<li>索引列上有计算。+ - 等</li>
<li>索引列上使用了函数  sum  cover</li>
<li>索引列是字符串的搜索的时候没有加’’ 比如 123 - ‘123’</li>
<li>在不可为空列中使用is null 和 is not null</li>
<li>like 左边有%</li>
<li>or两边的列不一致会导致索引实现  可以使用union</li>
</ol>
<span id="more"></span>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/06/%E9%94%81/</url>
    <content><![CDATA[<p><font style="color:rgb(0, 0, 0);">MySQL中的锁有很多种，各种锁应用在不同的地方。</font><strong><font style="color:rgb(145, 109, 213);">「MySQL依靠锁机制可以让多个事务更新一行数据的时候串行化」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h3 id="MySQL中锁总的来说有两种概念：Lock和Latch"><a href="#MySQL中锁总的来说有两种概念：Lock和Latch" class="headerlink" title="MySQL中锁总的来说有两种概念：Lock和Latch"></a><font style="color:black;">MySQL中锁总的来说有两种概念：Lock和Latch</font></h3><h4 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a><font style="color:black;">Latch</font></h4><p><font style="color:black;">称为闩锁（轻量级的锁），因为Latch要求锁定的时间非常短。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。在InnoDB引擎中，Latch又分为mutex（互斥量）和rwlock（读写锁）。</font></p>
<p><font style="color:black;">mutex：互斥量；有时候有些资源需要共享和并发，但是又不是分频繁，所以向操作系统申请一个mutex，mutex都是排他的。</font></p>
<p><font style="color:black;"> RW-LATCH : 读写锁</font></p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><font style="color:black;">Lock</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「Lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行」</font></strong><font style="color:black;">。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。</font></p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a><font style="color:black;">锁的分类</font></h3><p><font style="color:rgb(0, 0, 0);">实际上MySQL的锁在不同的维度上划分是多种多样的，在特地的场景下，发挥不一样的作用，下面来看看锁的分类。</font></p>
<h3 id="按照粒度划分："><a href="#按照粒度划分：" class="headerlink" title="按照粒度划分："></a>按照粒度划分：</h3><h4 id="全局锁："><a href="#全局锁：" class="headerlink" title="全局锁："></a>全局锁：</h4><p><strong><font style="color:rgb(145, 109, 213);">「全局锁，即对整个数据库实例加锁」</font></strong><font style="color:rgb(0, 0, 0);">。一般当我们需要让整个库处于只读状态的时候，可以给数据库加上全局锁。</font><strong><font style="color:rgb(145, 109, 213);">「加上全局锁之后其他线程的：数据更新语句（增删改）、数据定义语句（包括建表、修改表结构等）都会被阻塞」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h4 id="表级锁（粒度大，性能开销小，并发量小）："><a href="#表级锁（粒度大，性能开销小，并发量小）：" class="headerlink" title="表级锁（粒度大，性能开销小，并发量小）："></a>表级锁（粒度大，性能开销小，并发量小）：</h4><p><strong><font style="color:rgb(145, 109, 213);">「表级别的锁定是MySQL各【存储引擎中】最大颗粒度的锁定机制」</font></strong><font style="color:rgb(0, 0, 0);">。由于直接锁定一张表，所以获取锁和释放锁的速度很快，避免了死锁问题，但是出现锁定资源争用的概率也最高，并发量降低。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「表锁的加锁语法」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#隐式上锁（默认，自动加锁自动释放</span><br><span class="line">insert、update、delete //上写锁</span><br><span class="line">#显式上锁（手动）</span><br><span class="line">lock table tableName read;//读锁</span><br><span class="line">lock table tableName write;//写锁</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「表锁的释放锁语法」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">客户端断开的时候也会自动释放锁。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「查看表上加过的锁」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show open tables;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「MyISAM引擎默认的锁是表锁」</font></strong><font style="color:rgb(0, 0, 0);">。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。</font></p>
<h5 id="「表级读锁」"><a href="#「表级读锁」" class="headerlink" title="「表级读锁」"></a><font style="color:rgb(145, 109, 213);">「表级读锁」</font></h5><p><font style="color:rgb(0, 0, 0);">当前表加read锁，当前连接和其他的连接都可以读操作；但是当前连接写操作会报错，其他连接写操作会被阻塞。</font></p>
<h5 id="「表级写锁」"><a href="#「表级写锁」" class="headerlink" title="「表级写锁」"></a><font style="color:rgb(145, 109, 213);">「表级写锁」</font></h5><p><font style="color:rgb(0, 0, 0);">当前表加write锁，当前连接可以对表做读写操作，其他连接对该表所有操作（读写操作）都被阻塞。</font></p>
<h5 id="「意向锁」"><a href="#「意向锁」" class="headerlink" title="「意向锁」"></a><font style="color:rgb(145, 109, 213);">「意向锁」</font></h5><h6 id="意向锁是什么"><a href="#意向锁是什么" class="headerlink" title="意向锁是什么"></a><font style="color:black;">意向锁是什么</font></h6><p><strong><font style="color:rgb(145, 109, 213);">「意向锁（Intention Lock）简称I锁，是一种表级锁」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB 实现了标准的行级锁，包括：共享锁（S锁）、排它锁（X锁）」</font></strong><font style="color:black;">，那么为什么需要引入意向锁呢？意向锁解决了什么问题？</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">假设，事务A获取了某一行记录的排它锁，事物A尚未提交,事务B想要获取表锁时，则事物B必须要确认表的每一行都不存在排他锁，需要进行全表扫描，效率很低，此时就引入意向锁</font></p>
<p>:::</p>
<ul>
<li><font style="color:rgb(1, 1, 1);">如果事务A获取了某一行记录的排它锁，实际此时表存在两种锁，行记录的排他锁和表上的意向排他锁。</font></li>
<li><font style="color:rgb(1, 1, 1);">如果事务B试图在该表加表级锁时，则会被意向锁阻塞，因此事物B不必检查各个页锁或行锁，而只需检查表上的意向即可。</font></li>
</ul>
<p><font style="color:rgb(0, 0, 0);">如上，数据库中存储数据，范围由大到小：表–&gt;页–&gt;行，加锁也是分别加在表–&gt;页–&gt;行中，当我们把锁加在更大一级范围时，也就不需要全表扫描下一级的某些锁，可以很大程度提升性能。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，即意向锁」</font></strong></p>
<p><font style="color:black;">通过上述描述我们知道</font><strong><font style="color:rgb(145, 109, 213);">「意向锁是加在表上，用于防止全表扫描的一种锁，即意向锁是表锁」</font></strong><font style="color:black;">。意向锁分为两种类型：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「意向共享锁（intention shared lock）」</font></strong><font style="color:rgb(1, 1, 1);">简称IS锁，事务想要给某一个数据行加行级共享锁（S锁）之前必须先获取该表的IS锁（表级锁）</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「意向排他锁（intention exclusive lock）」</font></strong><font style="color:rgb(1, 1, 1);">简称IX锁，事务想要给某一个数据行加行级排他锁（X锁）之前必须先获取该表的IX锁（表级锁）</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「【意向锁都是InnoDB存储引擎自己维护的,用户是无法操作意向锁的】」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「在为数据行加共享锁&#x2F;排他锁之前，InooDB会先获取该数据行所在在数据表的对应意向锁(表级锁)」</font></strong><font style="color:black;">，如果没有获取到，否则等待innodb_lock_wait_timeout超时后根据innodb_rollback_on_timeout决定是否回滚事务。</font></p>
<p>:::tips<br><font style="color:black;">从锁粒度角度：InnoDB 允许行级锁与表级锁共存,而意向锁是表锁；</font></p>
<p><font style="color:black;">从锁模式角度：意向锁是一种独立类型，辅助解决记录锁效率不及的问题；</font></p>
<p><font style="color:black;">从兼容性角度：意向锁包含了共享&#x2F;排他两种。</font></p>
<p>:::</p>
<h6 id="意向锁的兼容互斥性"><a href="#意向锁的兼容互斥性" class="headerlink" title="意向锁的兼容互斥性"></a><font style="color:black;">意向锁的兼容互斥性</font></h6><ul>
<li><font style="color:rgb(1, 1, 1);">意向锁之间的兼容互斥性：意向锁之间是互相兼容的</font></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:black;">   </font></strong></th>
<th align="left"><strong><font style="color:black;">意向共享锁（IS）</font></strong></th>
<th align="left"><strong><font style="color:black;">意向排他锁（IX）</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:black;">意向共享锁（IS）</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
</tr>
<tr>
<td align="left"><font style="color:black;">意向排他锁（IX）</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
</tr>
</tbody></table>
<ul>
<li><font style="color:rgb(1, 1, 1);">意向锁与其他锁兼容互斥性：意向锁与普通的排他锁&#x2F;共享锁互斥</font></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:black;">   </font></strong></th>
<th align="left"><strong><font style="color:black;">意向共享锁（IS）</font></strong></th>
<th align="left"><strong><font style="color:black;">意向排他锁（IX）</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:black;">表级共享锁（S）</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
<td align="left"><font style="color:black;">互斥</font></td>
</tr>
<tr>
<td align="left"><font style="color:black;">表级排他锁（X）</font></td>
<td align="left"><font style="color:black;">互斥</font></td>
<td align="left"><font style="color:black;">互斥</font></td>
</tr>
</tbody></table>
<p><strong><font style="color:rgb(145, 109, 213);">「上述的排他锁（X锁）共享锁（S锁）指的都是表锁，意向锁不会与行级的共享锁&#x2F;排他锁互斥」</font></strong></p>
<h5 id="「自增锁」"><a href="#「自增锁」" class="headerlink" title="「自增锁」"></a><font style="color:rgb(145, 109, 213);">「自增锁」</font></h5><p>所有插入数据的方式总共分三类，分别是：</p>
<ul>
<li>Simple inserts （简单插入），可以预先确定要插入的行数。</li>
<li>Bulk inserts (批量插入)，事先不知道要插入的行数。</li>
<li>Mixed-mode-inserts (混合模式插入)，只指定了部分id的值，还有未知id。</li>
</ul>
<p>在插入时，mysql采用自增锁的方式来实现。当向使用auto_increment列插入数据时需要获取一种特殊的表级锁，在插入语句时加一个自增锁。然后再语句执行后，再把自增锁释放掉。一个事务再持有锁时，其他事务的插入语句都要被阻塞，所以并发性并不高。所以innodb通过innodb_autoinc_lock_mode的不同取值来提供不同的锁定机制。</p>
<p>0 （传统锁定模式），并发差，就如上面所说的流程。</p>
<p>1 （连续锁定模式） ，mysql8.0之前默认的模式。对于插入数量已知情况下，只在分配过程中保持，而不是直到语句完成。</p>
<p>2 （交错锁定模式），在这种模式下，所有类insert语句都不会使用表级自增锁。自动递增保证在所有并发执行中是唯一且单调递增的。但是可能存在间隙。</p>
<h5 id="「元数据锁」"><a href="#「元数据锁」" class="headerlink" title="「元数据锁」"></a><font style="color:rgb(145, 109, 213);">「元数据锁」</font></h5><p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">当我们查询查询一个表中的数据时，另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构就不一致了，这肯定是允许。这里就用到了元数据锁</font></p>
<p>:::</p>
<p><font style="color:black;">在MySQL 5.5版本中引入了MDL，</font><strong><font style="color:rgb(145, 109, 213);">「元数据锁(MDL) 不需要显式使用，在访问一个表的时候会被自动加上」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「当对一个表做增删改查的时候会加上【MDL读锁】」</font></strong></li>
</ul>
<p><font style="color:black;">读锁之间不互斥，因此可以有多个线程同时对一张表增删改查操作。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「当对一个表做结构变更的时候会加上【MDL写锁】」</font></strong></li>
</ul>
<p><font style="color:black;">读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。</font></p>
<h4 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h4><p><strong><font style="color:rgb(145, 109, 213);">「每次锁定相邻的一组记录」</font></strong><font style="color:black;">，锁定粒度、开销和加锁时间都界于表锁和行锁之间，并发度一般。</font></p>
<p><font style="color:black;">应用在BDB 存储引擎中</font></p>
<h4 id="行级锁（粒度小，加锁开销大，并发量好）："><a href="#行级锁（粒度小，加锁开销大，并发量好）：" class="headerlink" title="行级锁（粒度小，加锁开销大，并发量好）："></a>行级锁（粒度小，加锁开销大，并发量好）：</h4><p><strong><font style="color:rgb(145, 109, 213);">「行锁顾名思义就是对数据行进行加锁。行锁的锁定颗粒度在 MySQL中是最细的，应用于 InnoDB 存储引擎，通过对索引数据页上的记录加锁实现的【即行锁是针对索引加锁】」</font></strong></p>
<h5 id="「行锁的优缺点」"><a href="#「行锁的优缺点」" class="headerlink" title="「行锁的优缺点」"></a><font style="color:rgb(145, 109, 213);">「行锁的优缺点」</font></h5><p><font style="color:rgb(0, 0, 0);">并发情况下，产生锁等待的概率较低，支持较大的并发数，但开销大，加锁慢，而且会出现死锁。</font></p>
<h5 id="「行锁的前提条件」"><a href="#「行锁的前提条件」" class="headerlink" title="「行锁的前提条件」"></a><font style="color:rgb(145, 109, 213);">「行锁的前提条件」</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「检索数据时需要通过索引，【因为 InnoDB 是通过给索引的索引项加锁来实现行锁的】」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">在不通过索引条件查询的时候，InnoDB 会使用表锁，表锁会产生锁冲突</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「行锁是针对索引加锁」</font></strong><font style="color:rgb(1, 1, 1);">，所以即使访问的不同记录，只要使用的是同一索引项，也可能会出现锁冲突。</font></li>
</ul>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">MySQL会比较不同执行计划，当全表扫描比索引效率更高时，InnoDB就使用表锁。因此不一定使用了索引就一定会使用行锁，也有可能使用表锁。</font></p>
<p>:::</p>
<h5 id="「行锁会产生死锁」"><a href="#「行锁会产生死锁」" class="headerlink" title="「行锁会产生死锁」"></a><font style="color:rgb(145, 109, 213);">「行锁会产生死锁」</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「实际上InnoDB 的行锁也是分为两步获得的：锁住主键索引，锁住非主键索引」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p>:::tips<br><font style="color:black;">当两个事务同时执行时，</font></p>
<p><font style="color:black;">一个锁住了主键索引，在等待其他索引；</font></p>
<p><font style="color:black;">另一个锁住了非主键索引，在等待主键索引，</font></p>
<p><font style="color:black;">这样就可能会发生死锁。</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB可以检测到这种死锁，检测到后会让其中一个事务释放锁回退，另一个获取锁完成事务」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h5 id="「行锁的实现算法」"><a href="#「行锁的实现算法」" class="headerlink" title="「行锁的实现算法」"></a><font style="color:rgb(145, 109, 213);">「行锁的实现算法」</font></h5><p><font style="color:black;">前面讲到</font><strong><font style="color:rgb(145, 109, 213);">「InnoDB行锁是通过对 索引数据页上的记录加锁实现的」</font></strong><font style="color:black;">，接下来看看它具体是怎么实现，</font></p>
<p><font style="color:black;">InnoDB存储引擎有3种实现行锁的算法：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「【Record Lock】：记录锁，单个行记录上的锁」</font></strong></li>
</ul>
<p><font style="color:black;">RC、RR隔离级别都支持，如果表中没有主键和任何一个索引，那InnoDB会使用隐式的主键来进行锁定。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「【Gap Lock】：间隙锁，锁定一个范围，但不包含记录本身」</font></strong></li>
</ul>
<p><font style="color:black;">范围锁，锁定索引记录范围，确保索引记录的间隙不变，RR隔离级别支持</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「【Next-Key Lock】：Gap Lock与Record Lock的组合」</font></strong></li>
</ul>
<p><font style="color:black;">锁定数据前后范围，并且锁定记录本身，RR隔离级别支持</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「在RR隔离级别，InnoDB对于行的查询都是采用【Next-Key Lock】的组合锁定算法」</font></strong><font style="color:black;">，但是</font><strong><font style="color:rgb(145, 109, 213);">「在查询的列是唯一索引（包含主键索引）的情况下，Next-key Lock会降级为Record Lock，仅锁住索引本身而非范围」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:rgb(0, 0, 0);">下面具体看下针对不同的sql语句采用的是那种加锁方式：</font></p>
<p><font style="color:rgb(0, 0, 0);">查询语句类型一</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... from  ...</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「对于普通的select语句，InnoDB引擎采用MVCC机制实现非阻塞读，【InnoDB引擎不加锁】」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">查询语句类型二</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... from ... lock in share mode</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「添加共享锁，InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">查询语句类型三</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... from ... for update</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「添加排他锁，InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">修改语句</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update ... from ... where  ...</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">删除语句</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete ... from ... where</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">插入语句</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert ... from  ...</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB会在将要插入的那一行设置一个排他的RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h5 id="「行锁的分类」"><a href="#「行锁的分类」" class="headerlink" title="「行锁的分类」"></a><font style="color:rgb(145, 109, 213);">「行锁的分类」</font></h5><h6 id="「共享锁（Shared-Lock）又称为读锁，简称S锁，是一种行级锁」"><a href="#「共享锁（Shared-Lock）又称为读锁，简称S锁，是一种行级锁」" class="headerlink" title="「共享锁（Shared Lock）又称为读锁，简称S锁，是一种行级锁」"></a><font style="color:rgb(145, 109, 213);">「共享锁（Shared Lock）又称为读锁，简称S锁，是一种行级锁」</font><font style="color:rgb(0, 0, 0);"></font></h6><p><font style="color:rgb(0, 0, 0);">顾名思义：</font><strong><font style="color:rgb(145, 109, 213);">「共享锁就是多个事务对于同一数据共享一把锁，都能访问到数据，但是只能读不能修改」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「加锁方式」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... from ... lock in share mode</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「释放方式」</font></strong><font style="color:black;">：</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「共享锁工作原理」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「一个事务获取了一条记录的共享锁后，其他事务也能获得该记录对应的共享锁，但不能获得排他锁」</font></strong><font style="color:black;">。即一个事务使用了共享锁（读锁），其他事务只能读取，不能写入，写操作被阻塞。</font></p>
<h6 id="「排他锁（EXclusive-Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」"><a href="#「排他锁（EXclusive-Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」" class="headerlink" title="「排他锁（EXclusive Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」"></a><font style="color:rgb(145, 109, 213);">「排他锁（EXclusive Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」</font></h6><p><font style="color:black;">顾名思义：</font><strong><font style="color:rgb(145, 109, 213);">「排他锁就是不能与其他锁并存，即当前写操作没有完成前，会阻断其他写锁和读锁」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「加锁方式」</font></strong></li>
</ul>
<p><font style="color:black;">innodb引擎默认会在update，delete语句加上 for update</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ...  # 排他锁</span><br><span class="line">DELETE FROM student WHERE ...  # 排他锁</span><br><span class="line">UPDATE student SET ...  # 排他锁</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「释放方式」</font></strong><font style="color:black;">：</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「共享锁工作原理」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「如一个事务获取了一条记录的排他锁，其他事务就不能对该行记录做其他操作，也不能获取该行的锁（共享锁、排他锁），但是获取到排他锁的事务可以对数据进行读写操作」</font></strong><font style="color:black;">。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">这里要注意一下，其他事务不加锁的读是不会被阻塞的，阻塞的是加锁的读</font></p>
<p>:::</p>
<h6 id="「间隙锁-Gap-Locks」"><a href="#「间隙锁-Gap-Locks」" class="headerlink" title="「间隙锁 Gap Locks」"></a><font style="color:rgb(145, 109, 213);">「间隙锁 </font><a href="https://so.csdn.net/so/search?q=Gap&spm=1001.2101.3001.7020"><font style="color:rgb(145, 109, 213);">Gap</font></a><font style="color:rgb(145, 109, 213);"> Locks」</font></h6><p>间隙锁（Gap Locks）是数据库中用于锁定索引范围的一种锁。它们的主要目的是防止其他事务在给定范围内插入新的数据，保证范围内数据的一致性和避免幻读现象。</p>
<p>:::tips<br><strong><font style="color:rgb(25, 27, 31);">间隙锁的锁定范围是指在索引范围之间的间隙</font></strong></p>
<p>:::</p>
<p><font style="color:rgb(25, 27, 31);">举个简单例子来说明：</font></p>
<p><font style="color:rgb(25, 27, 31);">假设有一个名为</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">products</font><font style="color:rgb(25, 27, 31);">的表，其中有一个整型列</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">product_id</font><font style="color:rgb(25, 27, 31);">作为主键索引。现在有两个并发事务：事务A和事务B。</font></p>
<p><font style="color:rgb(25, 27, 31);">事务A执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM `products` WHERE `product_id` BETWEEN 100 and 200 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">事务B执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">INSERT INTO `products` (`product_id`, `name`) VALUES (150, &#x27;Product 150&#x27;);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">在这种情况下，事务A会在</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">products</font><font style="color:rgb(25, 27, 31);">表中</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">product_id</font><font style="color:rgb(25, 27, 31);">值在 100 和 200 之间的范围上设置间隙锁。因此，在事务A运行期间，其他事务无法在这个范围内插入新的数据，在事务B尝试插入</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">product_id</font><font style="color:rgb(25, 27, 31);">为150的记录时，由于该记录位于事务A锁定的间隙范围内，事务B将被阻塞，直到事务A释放间隙锁为止。</font></p>
<p><font style="color:rgb(25, 27, 31);">触发条件：</font></p>
<p><font style="color:rgb(25, 27, 31);">在可重复读（Repeatable Read）事务隔离级别下，以下情况会产生间隙锁：</font></p>
<ul>
<li><font style="color:rgb(25, 27, 31);">使用普通索引锁定：当一个事务使用普通索引进行条件查询时，MySQL会在满足条件的索引范围之间的间隙上生成间隙锁。</font></li>
<li><font style="color:rgb(25, 27, 31);">使用多列唯一索引：如果一个表存在多列组成的唯一索引，并且事务对这些列进行条件查询时，MySQL会在满足条件的索引范围之间的间隙上生成间隙锁。</font></li>
<li><font style="color:rgb(25, 27, 31);">使用唯一索引锁定多行记录：当一个事务使用唯一索引来锁定多行记录时，MySQL会在这些记录之间的间隙上生成间隙锁，以确保其他事务无法在这个范围内插入新的数据。</font></li>
</ul>
<p><font style="color:rgb(25, 27, 31);">需要注意的是，上述情况仅在可重复读隔离级别下才会产生间隙锁。在其他隔离级别下，如读提交（Read Committed）隔离级别，MySQL可能会使用临时的意向锁来避免并发问题，而不是生成真正的间隙锁。</font></p>
<p><font style="color:rgb(25, 27, 31);">为什么这里强调的是普通索引呢？因为对唯一索引锁定并不会触发间隙锁，请看下面这个例子：</font></p>
<p><font style="color:rgb(25, 27, 31);">假设我们有一个名为</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">students</font><font style="color:rgb(25, 27, 31);">的表，其中有两个字段：id 和 name。id是主键，现在有两个事务同时进行操作：</font></p>
<p><font style="color:rgb(25, 27, 31);">事务A执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM students WHERE id = 1 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">事务B执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO students (id, name) VALUES (2, &#x27;John&#x27;);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">由于事务A使用了唯一索引锁定，它会锁定id为1的记录，不会触发间隙锁。同时，在事务B中插入id为2的记录也不会受到影响。这是因为唯一索引只会锁定匹配条件的具体记录，而不会锁定不存在的记录（如间隙）。</font></p>
<p><strong><font style="color:rgb(25, 27, 31);">当使用唯一索引锁定一条存在的记录时，会使用记录锁，而不是间隙锁</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">但是当搜索条件仅涉及到多列唯一索引的一部分列时，可能会产生间隙锁。以下是一个例子：</font></p>
<p><font style="color:rgb(25, 27, 31);">假设</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">students</font><font style="color:rgb(25, 27, 31);">表，包含三个列：id、name和age。我们在(name, age)上创建了一个唯一索引。</font></p>
<p><font style="color:rgb(25, 27, 31);">现在有两个事务同时进行操作：</font></p>
<p><font style="color:rgb(25, 27, 31);">事务A执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM students WHERE name = &#x27;John&#x27; FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">事务B执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO students (id, name, age) VALUES (2, &#x27;John&#x27;, 25);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">在这种情况下，事务A搜索的条件只涉及到了唯一索引的一部分列（name），而没有涉及到完整的索引列（name, age）。因此，MySQL会对匹配的记录加上行锁，并且还会对与该条件范围相邻的间隙加上间隙锁。</font></p>
<p><font style="color:rgb(25, 27, 31);">间隙锁加锁规则：</font></p>
<p><font style="color:rgb(25, 27, 31);">间隙锁有以下加锁规则：</font></p>
<ul>
<li><font style="color:rgb(25, 27, 31);">规则1：加锁的基本单位是 Next-Key Lock，左开右闭区间。</font></li>
<li><font style="color:rgb(25, 27, 31);">规则2：查找过程中访问到的对象才会加锁。</font></li>
<li><font style="color:rgb(25, 27, 31);">规则3：唯一索引上的范围查询会上锁到不满足条件的第一个值为止。</font></li>
<li><font style="color:rgb(25, 27, 31);">规则4：唯一索引等值查询，并且记录存在，Next-Key Lock 退化为行锁。</font></li>
<li><font style="color:rgb(25, 27, 31);">规则5：索引上的等值查询，会将距离最近的左边界和右边界作为锁定范围，如果索引不是唯一索引还会继续向右匹配，直到遇见第一个不满足条件的值，如果最后一个值不等于查询条件，Next-Key Lock 退化为间隙锁。</font></li>
</ul>
<p><font style="color:rgb(25, 27, 31);">案例演示</font></p>
<p><font style="color:rgb(25, 27, 31);">环境：MySQL，InnoDB，RR隔离级别。</font></p>
<p><font style="color:rgb(25, 27, 31);">数据表：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `age` int DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">   KEY `age` (`age`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">数据：</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">id</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">age</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">name</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">小明</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">小王</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">7</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">7</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">小张</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">11</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">11</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">小陈</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">在进行测试之前，我们先来看看 user 表中存在的隐藏间隙：</font></p>
<ul>
<li><font style="color:rgb(25, 27, 31);">(-∞, 1]</font></li>
<li><font style="color:rgb(25, 27, 31);">(1, 5]</font></li>
<li><font style="color:rgb(25, 27, 31);">(5, 7]</font></li>
<li><font style="color:rgb(25, 27, 31);">(7, 11]</font></li>
<li><font style="color:rgb(25, 27, 31);">(11, +∞]</font></li>
</ul>
<p><font style="color:rgb(25, 27, 31);">案例一：唯一索引等值锁定存在的数据</font></p>
<p><font style="color:rgb(25, 27, 31);">如下是事务A和事务B执行的顺序：</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &#x3D; 5 for update</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(3,3,”小黑”) —不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(6,6,”小蓝”) —不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">根据规则4，加的是记录锁，不会使用间隙锁，所以只会锁定 5 这一行记录。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例二：索引等值锁定</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &#x3D; 3 for update — 不存在的数据</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(6,6,”小蓝”) — 不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(2,2,”小黄”) — 阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">这是一个索引等值查询，根据规则1和规则5，加锁范围是（ 1，5 ] ，又由于向右遍历时最后一个值 5 不满足查询需求，Next-Key Lock 退化为间隙锁。也就是最终锁定范围区间是 （ 1，5 ）。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例三：唯一索引范围锁定</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &gt;&#x3D; 5 and id&lt;6 for update</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(7,7,”小赵”) — 阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">根据规则3，会上锁到不满足条件的第一个值为止，也就是7，所以最终加锁范围是 [ 5，7 ]。</font></p>
<p><font style="color:rgb(25, 27, 31);">其实这里可以分为两个步骤，第一次用 id&#x3D;5 定位记录的时候，其实加上了间隙锁 （ 1，5 ]，又因为是唯一索引等值查询，所以退化为了行锁，只锁定 5。</font></p>
<p><font style="color:rgb(25, 27, 31);">第二次用 id&lt;6 定位记录的时候，其实加上了间隙锁（ 5，7 ]，所以最终合起来锁定区间是 [ 5，7 ]。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例四：非唯一索引范围锁定</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where age &gt;&#x3D; 5 and age&lt;6 for update</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(8,8,”小青”) — 不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(2,2,”小黄”) — 阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">参考上面那个例子。</font></p>
<p><font style="color:rgb(25, 27, 31);">第一次用 age &#x3D;5 定位记录的时候，加上了间隙锁 （ 1，5 ]，不是唯一索引，所以不会退化为行锁，根据规则5，会继续向右匹配，所以最终合起来锁定区间是 （ 1，7 ]。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例五：间隙锁死锁</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &#x3D; 3 for update</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &#x3D; 4 for update</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(2,2,”小黄”) — 阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(4,4,”小紫”) — 阻塞</font></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">间隙锁之间不是互斥的，如果一个事务A获取到了（ 1,5 ] 之间的间隙锁，另一个事务B仍然可以获取到（ 1,5 ] 之间的间隙锁。这时就可能会发生死锁问题。</font></p>
<p><font style="color:rgb(25, 27, 31);">在事务A事务提交，间隙锁释放之前，事务B也获取到了间隙锁（ 1,5 ] ，这时两个事务就处于死锁状态。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例六：limit对加锁的影响</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">deletet user where age &#x3D; 6 limt 1</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(7,7,”小赵”) — 不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">根据规则5，锁定区间应该是 ( 5，7 ]，但是因为加了 limit 1 的限制，因此在遍历到 age&#x3D;6 这一行之后，循环就结束了。</font></p>
<p><font style="color:rgb(25, 27, 31);">根据规则2，查找过程中访问到的对象才会加锁，所以最终锁定区间应该是：( 5，6 ]。</font></p>
<p><font style="color:rgb(25, 27, 31);">总结</font></p>
<p><font style="color:rgb(25, 27, 31);">在本文中，我们讨论了间隙锁的加锁规则。间隙锁是MySQL中用于保护范围查询和防止并发问题的重要机制，了解间隙锁的加锁规则对于优化数据库性能、减少数据冲突以及提高并发性能非常重要。</font></p>
<h6 id="「临界锁-Next-Key-locks」"><a href="#「临界锁-Next-Key-locks」" class="headerlink" title="「临界锁 Next-Key locks」"></a><font style="color:rgb(145, 109, 213);">「临界锁 Next-Key locks」</font></h6><p>临界锁是记录锁和该记录之前间隙锁的组合。</p>
<p>当InnoDB在查询或者遍历一个索引时，它会给所有遍历的行添加共享锁或者排它锁，这就是行级锁。因此，行级锁就是记录锁。临界锁(Next-key lock)就是记录锁加上该记录前的间隙锁。如果一个会话在R记录上持有共享锁或者排它锁，另一个会话不能在R之前的间隙插入数据。加入一个索引包含值为10,11,13,20，那么可能得临界锁范围是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">小括号表示不包含该值，大括号表示包含该值</font><strong><font style="color:rgb(77, 77, 77);">左开右闭</font></strong><font style="color:rgb(77, 77, 77);">。InnoDB默认使用可重复读(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">REPEATABLE READ</font><font style="color:rgb(77, 77, 77);">)的隔离级别，且使用临界锁防止幻读(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Phantom rows</font><font style="color:rgb(77, 77, 77);">)</font></p>
<p><font style="color:rgb(77, 77, 77);">临界锁在事务数据中的表现为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`</span><br><span class="line">trx id 10080 lock_mode X</span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>



<h6 id="「插入意向锁-Insert-Intention-Locks-」"><a href="#「插入意向锁-Insert-Intention-Locks-」" class="headerlink" title="「插入意向锁(Insert Intention Locks)」"></a><font style="color:rgb(145, 109, 213);">「插入意向锁(Insert Intention Locks)」</font></h6><p>插入意向锁是INSERT语句中，在行写入之前添加的一种间隙锁。多个事务在写入同一个索引间隙时，如果他们插入的不是同一个位置，那么就不会相互阻塞。比如有两个索引记录为4和7，不同的事务分别准备写入数据5和6，他们都会在4-7上增加插入意向锁锁住这个间隙，但是不会相互阻塞，因为他们写入的是不同的行。</p>
<p><font style="color:rgb(77, 77, 77);">下面这个例子表明，事务在获取排它锁之前会先获取插入意向锁。ClientA新建两条行记录90和102</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;</span><br><span class="line">mysql&gt; INSERT INTO child (id) values (90),(102);</span><br><span class="line"></span><br><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</span><br><span class="line">+-----+</span><br><span class="line">| id  |</span><br><span class="line">+-----+</span><br><span class="line">| 102 |</span><br><span class="line">+-----+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">此时ClientA使用排它间隙锁锁住了(100, 102]。ClientB开启一个事务，并尝试插入101。ClientB会被ClientA的间隙阻塞，等待获取排它锁。这个时候，ClientB获取了插入意向锁。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; INSERT INTO child (id) VALUES (101);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">插入意向锁在事务数据中的表现为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`</span><br><span class="line">trx id 8731 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000066; asc    f;;</span><br><span class="line"> 1: len 6; hex 000000002215; asc     &quot; ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure>

<h3 id="按照情绪情况来划分："><a href="#按照情绪情况来划分：" class="headerlink" title="按照情绪情况来划分："></a>按照情绪情况来划分：</h3><p><strong><font style="color:rgb(145, 109, 213);">「乐观锁&#x2F;悲观锁其实都是概念上的，只是在并发下防止数据被修改的一种加锁形式」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><font style="color:rgb(0, 0, 0);">悲观锁</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「对数据的修改抱有悲观态度的一种并发控制方式，悲观的认为自己(当前线程)拿到的数据是被修改过的，所以在操作数据之前先加锁」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「悲观锁的形式（类型）」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「数据库的行锁、表锁、读锁、写锁、共享锁、排他锁等，以及syncronized 实现的锁都是悲观锁的范畴」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25873401/1717493025735-21d37d3d-d44f-4630-9c74-164d49c9a0a5.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「优点」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「可以保证数据的独占性和正确性」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「缺点」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「每次请求都需要加锁、释放锁，这个过程会降低系统性能」</font></strong><font style="color:black;">。</font></p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><font style="color:black;">乐观锁</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「乐观锁是对于数据冲突保持一种乐观态度，每次读取数据的时都认为其他线程不会修改数据，所以不上锁，只是在数据修改后提交时才通过【版本号机制或者CAS算法】来验证数据是否被其他线程更新」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:black;">因为乐观锁中并没有【加锁和解锁】操作，因此乐观锁策略也被称为</font><strong><font style="color:rgb(145, 109, 213);">「无锁编程」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「乐观锁实现的关键点」</font></strong><font style="color:black;">：检测冲突</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「乐观锁实现方式」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">版本号机制（常用）</font></li>
<li><font style="color:rgb(1, 1, 1);">CAS算法实现</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「优点」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「没有加锁和解锁操作，可以提高吞吐量」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「缺点」</font></strong></li>
</ul>
<p><font style="color:black;">乐观锁需要自己实现，且外部系统不受控制</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「乐观锁的应用」</font></strong></li>
</ul>
<p><font style="color:black;">在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「适用场景」</font></strong><font style="color:black;">：读多写少</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「注意」</font></strong></li>
</ul>
<p><font style="color:black;">乐观锁不是数据库提供的功能，需要开发者自己去实现。</font></p>
<p>:::tips<br><font style="color:black;">除了开发者自己手动实现乐观锁之外，很多数据库访问框架也封装了乐观锁的实现</font></p>
<p><font style="color:black;">比如 hibernate框架，MyBatis框架的OptimisticLocker插件。</font></p>
<p>:::</p>
<h5 id="版本号机制实现乐观锁"><a href="#版本号机制实现乐观锁" class="headerlink" title="版本号机制实现乐观锁"></a><font style="color:black;">版本号机制实现乐观锁</font></h5><p><font style="color:black;">版本号机制有两种方式：使用版本字段（version）和使用时间戳（Timestamp），两者实现原理是一样的。</font></p>
<p><font style="color:black;">前文中提到</font><strong><font style="color:rgb(145, 109, 213);">「乐观锁需要开发者自己去实现，所以版本号实现时通过在表中加字段的形式实现的」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「使用版本字段（version）」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「在数据表增加一个版本(version) 字段，每操作一次，将那条记录的版本号加 1」</font></strong><font style="color:black;">。version 是用来查看被读的记录有无变化，防止记录在业务处理期间被其他事务修改。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「使用时间戳（Timestamp）」</font></strong></li>
</ul>
<p><font style="color:black;">与使用version版本字段基本一致，</font><strong><font style="color:rgb(145, 109, 213);">「同样需要给在数据表增加一个字段，字段类型使用timestamp时间戳，通过时间戳比较数据版本」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25873401/1717493194895-993157fd-0135-475f-9273-d775d95f816d.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「乐观锁实现案例」</font></strong></li>
</ul>
<p><font style="color:black;">修改用户表中Id为1的用户姓名</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;第一步：查询记录信息&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用版本字段（version)</span><br><span class="line">select name,version from user where id=1;</span><br><span class="line">#使用时间戳（Timestamp）</span><br><span class="line">select name,timestamp from user where id=1;</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;第二步：逻辑处理之后，修改姓名为张三&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用版本字段（version)</span><br><span class="line">update user set name = &#x27;张三&#x27;,version=version+1 where id=1 and version = #&#123;version&#125;;#version 为第一步查询的值</span><br><span class="line"></span><br><span class="line">#使用时间戳（timestamp）</span><br><span class="line">update user set name = &#x27;张三&#x27;,timestamp=now() where id=1 and time</span><br></pre></td></tr></table></figure>

<h5 id="CAS算法实现乐观锁"><a href="#CAS算法实现乐观锁" class="headerlink" title="CAS算法实现乐观锁"></a><font style="color:black;">CAS算法实现乐观锁</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是无锁编程」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「特点」</font></strong></li>
</ul>
<p><font style="color:black;">不加锁，即使没有线程被阻塞的情况下实现变量的同步，也叫非阻塞同步</font></p>
<p><font style="color:black;">CAS算法涉及到三个操作数</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作」</font></strong><font style="color:black;">（比较和替换是一个原子操作），一般情况下是一个自旋操作，即不断的重试。</font></p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/webp/25873401/1717493323068-f9450a45-f4b2-4fc6-89bc-22581c433220.webp"><ul>
<li><font style="color:rgb(1, 1, 1);">变量当前内存值 V</font></li>
<li><font style="color:rgb(1, 1, 1);">旧的预期值 A</font></li>
<li><font style="color:rgb(1, 1, 1);">要写入的新值 B</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「CAS缺点」</font></strong><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「ABA问题」</font></strong></li>
</ul>
</li>
</ul>
<p>:::tips<br><font style="color:black;background-color:rgb(244, 238, 255);">当线程1读到某变量的值为A，在其逻辑处理的过程中，另外一个线程2将该变量的值从A先修改为B、然后又将其从B修改回A。此时，当线程1通过CAS操作进行新值写入虽然可以成功，而实际上线程1执行CAS操作时预期值的A 和读取该变量当前值的A已经不是同一个了，后者是线程2修改的</font></p>
<p>:::</p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「CPU开销大」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">虽然CAS算法是非阻塞的，但如果CAS操作一直不成功不断循环，会浪费CPU资源</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「只能保证一个共享变量的原子性」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">当对多个变量进行操作时，CAS算法无法保证原子性。</font></p>
<p>:::tips<br><font style="color:black;background-color:rgb(244, 238, 255);">可以将多个变量封装为一个对象再使用CAS算法（Java中的AtomicReference）</font></p>
<p>:::</p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a><font style="color:black;">死锁和死锁检测</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「死锁是指两个或两个以上的事务在执行过程等中，因争夺资源而造成的一种相互等待的现象」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「死锁产生本质原因」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">系统资源有限</font></li>
<li><font style="color:rgb(1, 1, 1);">进程推进顺序不合理</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「死锁产生的4个必要条件」</font></strong><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「互斥条件（Mutual exclusion，简称Mutex）」</font></strong><font style="color:rgb(1, 1, 1);">资源要么被一个线程占用,要么是可用状态</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「不可抢夺（No preemption）」</font></strong><font style="color:rgb(1, 1, 1);">资源被占用后,除非占有线程主动释放,其他线程不能把它从该线程占用中抢夺</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「占有和等待（Hold and wait）」</font></strong><font style="color:rgb(1, 1, 1);">一个进程必须占有至少一个资源，并等待另一资源，而该资源被其他进程占用</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「循环等待（Circular wait）」</font></strong><font style="color:rgb(1, 1, 1);">一组等待进程{P0, P1…Pn-1, Pn}，P0等待资源被P1占有，P1等待资源被P2占有，Pn-1等待资源被Pn占有，Pn等待资源被P0占有，循环等待，则形成环形结构。</font></li>
</ul>
</li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「死锁发生的以上四个条件缺一都无法导致死锁，而由于互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，所以恢复死锁主要是破坏产生死锁的其他三个条件」</font></strong><font style="color:black;">。</font></p>
<h4 id="常见死锁现象和解决方案"><a href="#常见死锁现象和解决方案" class="headerlink" title="常见死锁现象和解决方案"></a><font style="color:black;">常见死锁现象和解决方案</font></h4><h5 id="表级锁死锁"><a href="#表级锁死锁" class="headerlink" title="表级锁死锁"></a><font style="color:black;">表级锁死锁</font></h5><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「案例」</font></strong></li>
</ul>
<p><font style="color:black;">有线程A、B分别需要访问用户表与订单表，访问表的时候都会加表级锁。线程A访用户表，并对用户表加锁（线程A锁住了用户表），然后又访问订单表；此时线程B先访问订单表，并对订单表加锁（线程B锁住了订单表），然后线程想访问用户表。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「产生原因」</font></strong></p>
<p><font style="color:black;">上述案例由于线程B已经锁住订单表，线程A必须等待线程B释放订单表能继续，同样线程B要等线程A释放用户表才能继续，</font><strong><font style="color:rgb(145, 109, 213);">「线程A、B相互等待对方释放锁，就产生了死锁」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/webp/25873401/1717493783109-fa03c60a-317e-44b3-a7ba-fe41d1efa5f4.webp"></li>
<li><strong><font style="color:rgb(145, 109, 213);">「解决方案」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「这种死锁是由于程序的BUG产生的，比较常见，只能通过调整程序的逻辑来解决」</font></strong><font style="color:black;">。</font></p>
<h5 id="行级锁死锁"><a href="#行级锁死锁" class="headerlink" title="行级锁死锁"></a><font style="color:black;">行级锁死锁</font></h5><p><font style="color:black;">行级锁产生死锁有两种情况，一直是资源争夺，一种是行级锁升级为表级锁</font></p>
<ul>
<li><font style="color:black;">资源争夺</font><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「产生原因」</font></strong></li>
</ul>
</li>
</ul>
<p><font style="color:black;">当事务中某个查询没有走索引时，就会走全表扫描，把行级锁上升为全表记录锁定（等价于表级锁），并发下多个线程同时执行，就可能会产生死锁和阻塞</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「解决方案」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">SQL语句中尽量不要有太复杂的多表关联查询，并通过执行对SQL语句进行分析，建立索引优化，避免全表扫描和全表锁定。</font></p>
<ul>
<li><font style="color:black;">行级锁升级为表级锁</font></li>
</ul>
<font style="color:rgb(1, 1, 1);">  
</font>

<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「产生原因」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25873401/1717494031661-8f50afb4-dfd1-4c3f-b5b8-1ad2bfcd08aa.webp"></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「解决方案」&lt;/font&gt;**
    * &lt;font style=&quot;color:black;&quot;&gt;在同一个事务中，尽量一次锁定需要的所有资源&lt;/font&gt;
    * &lt;font style=&quot;color:black;&quot;&gt;将每个资源编号，通过资源编号的线性顺序来预防死锁，当一个进程占有编号为i的资源时，那么它下一次只能申请编号大于i的资源。&lt;/font&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25873401/1717494031436-fb63f286-d50a-441e-86d4-258f1846b377.webp"></p>
<h5 id="共享锁转换为排他锁"><a href="#共享锁转换为排他锁" class="headerlink" title="共享锁转换为排他锁"></a><font style="color:black;">共享锁转换为排他锁</font></h5><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「案例」</font></strong></li>
</ul>
<p><font style="color:black;">事务A有两个操作，首先查询一条纪录M，然后更新纪录M；此时事务B在事物A查询之后更新之前去更新纪录M，此时事物A获取了记录M的共享锁，事物B获取了记录M的排他锁， 事务B的排他锁由于事务A有共享锁，必须等A释放共享锁后才可以获取，事物B只能排队等待。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「产生原因」</font></strong></li>
</ul>
<p><font style="color:black;">案例中事物B已经进入等待，事物A更新M需要排他锁，而此时事务B已经有一个排他锁请求，并且正在等待事务A释放其共享锁，因此无法给事物A授予排他锁锁请求，事物A也进入排队等待</font></p>
<p>:::tips<br>注意：这里事物B还没有拿到M的排它锁，只是进入排队等到状态</p>
<p>:::</p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「解决方案」</font></strong></li>
</ul>
<p><font style="color:black;">通过</font><strong><font style="color:rgb(145, 109, 213);">「手动实现乐观锁」</font></strong><font style="color:black;">进行控制，乐观锁的无锁机制可以避免长事务中的数据库加锁开销，增大并发量，提升系统性能。</font></p>
<h5 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a><font style="color:black;">死锁排查</font></h5><p><font style="color:rgb(0, 0, 0);">MySQL提供了几个与锁有关的参数和命令，可以辅助我们优化锁操作，减少死锁发生。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看近期死锁日志信息」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25873401/1717494286146-4dc235b7-cb95-4295-8a6b-9ab2efae8976.webp"></p>
<p><font style="color:black;">通过以上命令查看近期死锁日志信息，然后使用执行计划进行SQL优化</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看锁状态变量」</font></strong></li>
</ul>
<p><font style="color:black;">通过以下命令可以检查锁状态变量，从而分析系统中的行锁的争夺情况</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show status like&#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/25873401/1717494286117-bd00a4e5-f604-4a47-ba66-6b8816e34a52.webp"></p>
<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_current_waits：当前正在等待锁的数量&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_time：从系统启动到现在锁定总时间长度&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_time_avg：每次等待锁的平均时间&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_waits：系统启动后到现在总共等待的次数&lt;/font&gt;
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「如果等待次数高，而且每次等待时间长，则需要对其进行分析优化」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1717494286096-e778a408-9b71-4257-be1e-b5ee19f36a64.png"></p>
<p><strong>星河之码</strong></p>
<p>不惟有超世之才，亦必有坚忍不拔之志。</p>
<p>94篇原创内容</p>
<p>公众号</p>
<p><strong><font style="color:rgb(145, 109, 213);"><br></font></strong></p>
]]></content>
  </entry>
  <entry>
    <title>项目可用性提升思考</title>
    <url>/2024/10/19/%E9%A1%B9%E7%9B%AE%E5%8F%AF%E7%94%A8%E6%80%A7%E6%8F%90%E5%8D%87%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>项目是一个在运营中的项目，在后续新功能开发的时候线上总是出现各种问题，让客户对项目的信任度降低很多，也对公司造成了经济损失。于是就有了一个任务，提高项目的可用性。经过一段时间的实践，总结出来了一个公式</p>
<p>:::info<br><strong>提升系统的稳定性&#x3D;减少故障的数量+提升发现速度+提升恢复速度</strong></p>
<p>:::</p>
<h3 id="减少故障的数量"><a href="#减少故障的数量" class="headerlink" title="减少故障的数量"></a>减少故障的数量</h3><p>线上的故障主要分为依赖类故障、变更类故障、容量类故障、固件类故障</p>
<h4 id="依赖类故障"><a href="#依赖类故障" class="headerlink" title="依赖类故障"></a>依赖类故障</h4><p><font style="color:rgba(0, 0, 0, 0.9);">在现在分布式架构盛行的背景下，一个微服务的直接和间接依赖是非常多的。下游的某个服务、缓存、DB如果挂了，自己就会被“牵连”，无法提供正常服务。</font></p>
<span id="more"></span>
<h5 id="下游服务异常"><a href="#下游服务异常" class="headerlink" title="下游服务异常"></a><font style="color:rgba(0, 0, 0, 0.9);">下游服务异常</font></h5><p>下游服务异常的时候会造成服务异常，那我们可以通过降级和流控来处理</p>
<p>可以使用Sentinel来进行降级和流控，Sentinel是面向分布式服务框架的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。</p>
<p>Sentinel具有以下特征：</p>
<p>（1）丰富的运用场景</p>
<p>（2）完备的实时监控</p>
<p>（3）广泛的开源生态</p>
<p>（4）完善的SPI扩展点</p>
<h6 id="降级Degrade"><a href="#降级Degrade" class="headerlink" title="降级Degrade"></a>降级Degrade</h6><p><font style="color:rgba(0, 0, 0, 0.9);">所谓【降级】，就是</font><strong><font style="color:rgb(0, 82, 255);">对下游的依赖从强依赖变成弱依赖</font></strong><font style="color:rgba(0, 0, 0, 0.9);">。</font></p>
<p>熔断策略</p>
<ul>
<li>慢调用比例（平均响应时间）：选择以慢调用比例作为阈值，需要设置允许的慢调用RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。档单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测回复状态（HALF-OPEN状态），若接下来的一个请求响应时间小于设置的慢调用RT则结束熔断，若大于设置的慢调用RT则会再次被熔断。</li>
<li>异常比例（ERROR_RATIO）：当单位统计时长（satIntervalMs）内请求数且大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是[0.0,1.0]，代表0%-100%。</li>
<li>异常数（ERROR_COUNT）：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li>
</ul>
<h6 id="流控SentinelResource"><a href="#流控SentinelResource" class="headerlink" title="流控SentinelResource"></a>流控SentinelResource</h6><p>流控又分为限流，以及控流。</p>
<h6 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h6><h6 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h6><p>限流的定义就是只允许指定的流量通过，举个例子就是有50个苹果，一天只能吃10个，把剩下丢掉就是限流</p>
<p><font style="color:rgba(0, 0, 0, 0.9);">常见的实现方式包括【令牌桶限流】【计数限流】【线程池控制】等。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.9);">令牌桶限流 每分钟生成多少个令牌，拿到令牌的请求就继续，没有获得到令牌的直接抛弃掉</font></li>
<li><font style="color:rgba(0, 0, 0, 0.9);">计数限流  期初设置一个阈值比如5，来一个请求先判断这个值是否大于0，大于0则-1，等于0则抛弃请求，处理完了+1。集群计数就面临着网络开销，就算中间件再快，网络总在那里。作为一个计数服务，可想而知请求量是怎样的。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.9);">线程池控制 类似计数限流，用的时候取一个，用完还回来。相信大家对线程池都比较了解了，就不再往下细说。</font></li>
</ul>
<p><font style="color:rgba(0, 0, 0, 0.9);">【计数限流】和【线程池控制】本质上是控制并发。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">假设每个请求平均是10ms返回，线程池设置的数量是5。1秒钟&#x3D;100个10ms，每个10ms有5个线程可以处理5个请求，那1秒就可以处理100 * 5 &#x3D; 500个请求，qps&#x3D;500。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">所以，控制计数和线程池本质上是控制并发，不要和QPS搞混了。</font></p>
<h6 id="控流"><a href="#控流" class="headerlink" title="控流"></a>控流</h6><p>控流的定义就是允许流量通过一定的速度通过。举个例子就是有50个苹果，一天只能吃10个，把剩下的存起来分5天吃，常见的队列就是这种形式</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>这样就可以很明显的看到限流和控流的差别，限流直接将多余的流量抛弃，而流控是将多余的流量保存起来，慢慢处理。所以使用限流还是控流可以按照业务场景来进行选择，如果业务的请求可以直接抛弃就用限流，如果类似于转账之类的关乎到收入的业务还是选择控流更合适</p>
<h5 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a><font style="color:rgba(0, 0, 0, 0.9);">缓存异常</font></h5><p>限流防止穿透，集群防止雪崩。</p>
<h5 id="DB宕机"><a href="#DB宕机" class="headerlink" title="DB宕机"></a><font style="color:rgba(0, 0, 0, 0.9);">DB宕机</font></h5><p>对DB进行高可用建设，</p>
<h4 id="变更类故障"><a href="#变更类故障" class="headerlink" title="变更类故障"></a>变更类故障</h4><p><font style="color:rgba(0, 0, 0, 0.9);">变更不只是【代码变更】，还包括【配置变更】和【数据变更】。这些变更，无论是参数改错了，还是DB数据订正错了，都可能导致严重的故障。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">在各种系统中有大部分是变更类故障，而变更类故障各式各样，解决起来也不能使用同一种方案处理，并且无法根本解决，下面从代码、配置、数据这三个方面讲一下我们要怎么做</font></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a><font style="color:rgba(0, 0, 0, 0.9);">代码</font></h5><p>代码的变更基本上每个需求的更新都会产生，在刚到公司的时候最怕的就是变更，每次总是会出现各种的问题，代码版本问题，发布的代码版本不对，甚至出现过线上跑的版本落后现有版本1年的情况。通过观察发现出现这些情况的原因有手工发布代码，代码提交混乱，代码冲突，新旧版本兼容度问题。于是通过制定代码管理规范、自动发布，加强测试规范，对接口进行兼容性硬性规定来处理这些问题</p>
<h6 id="代码管理规范"><a href="#代码管理规范" class="headerlink" title="代码管理规范"></a>代码管理规范</h6><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1718354954470-2c43f0b4-d1c5-4d19-a7bf-ef60171c8ae1.png"></p>
<p>首先是对代码分支的管理，避免出现线上代码分支不对的情况，也防止测试代码和实际发布代码不一致的问题出现</p>
<h6 id="自动发布"><a href="#自动发布" class="headerlink" title="自动发布"></a>自动发布</h6><p>在比较常见的问题中有一个手工打包，复制到服务器并启动，每个人理解不一样及时有sh脚本辅助也难免会出现打包打错了，目录放错了等问题出现，为了避免出现类似的问题，引入Jenkins来做自动构建发布部署。</p>
<p>Jenkins可以最大程度的保证每次打包的环境一致性，以及可以提供快捷的回滚</p>
<h6 id="加强测试规范"><a href="#加强测试规范" class="headerlink" title="加强测试规范"></a>加强测试规范</h6><p>从测试目的来看，测试的目的有三块【测试新功能是否正常】【测试老功能是否正常】【测试服务的兼容性】，针对目的可以得出测试其实可以分为三大块</p>
<ul>
<li>功能测试  <font style="color:rgba(0, 0, 0, 0.9);">针对这次新增或修改的功能。</font></li>
<li>回归测试 <font style="color:rgba(0, 0, 0, 0.9);">针对老功能的验证</font></li>
<li>兼容性测试 <font style="color:rgba(0, 0, 0, 0.9);">验证新旧功能同时存在时的正确性。为什么要做兼容性测试，当程序发布出现异常时需要回滚如果没有兼容性那就会在发布时出现异常，还有当程序发布时程序没有兼容性就需要按照固定的顺序来发布如果出现循环依赖那在发布时就会出现异常</font></li>
</ul>
<h5 id="代码审核"><a href="#代码审核" class="headerlink" title="代码审核"></a>代码审核</h5><p>代码审核的目的是**<font style="color:rgb(51, 51, 51);">找出安全、性能、依赖和兼容性等测试不易发现的问题。及时识别出代码设计的缺陷，找到需要重构的地方</font>**</p>
<p><font style="color:rgb(51, 51, 51);">防止出现一些常见的错误写法导致泄漏问题的出现。</font></p>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><font style="color:rgba(0, 0, 0, 0.9);">配置文件</font></h5><p>是不是经常听到：测试环境就可以呀，为什么到了线上就不行了。当你听到这句话的时候大概率就是配置文件在作祟了 。</p>
<p>配置文件的问题在开发周期长的项目中尤其容易出现。在避免出现配置文件出现问题这个到现在也没有找到100%避免的方法，是能通过流程来尽量的避免问题的出现。</p>
<ol>
<li>要求开发写需求的上线文档，在文档中标注上线服务的前后顺序，配置文件，需要执行的sql</li>
<li>在提测时要求测试按照开发写的文档对测试环境的配置文件进行配置</li>
<li>功能测试完毕后，预发布环境按照文档再次进行配置</li>
<li>上线的前一天开上线大会对上线文档进行复盘</li>
</ol>
<p>通过多次的确认来防止配置异常的问题。</p>
<h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a><font style="color:rgba(0, 0, 0, 0.9);">数据</font></h5><p>主要是Flyway来做数据库管理，Flyway 是一款开源的数据库版本管理工具，它更倾向于规约优于配置的方式。Flyway 可以独立于应用实现管理并跟踪数据库变更，支持数据库版本自动升级，并且有一套默认的规约，不需要复杂的配置，Migrations 可以写成 SQL 脚本，也可以写在 Java 代码中，不仅支持 Command Line 和 Java API，还支持 Build 构建工具和 Spring Boot 等，同时在分布式环境下能够安全可靠地升级数据库，同时也支持失败恢复。主要步骤为</p>
<ol>
<li>开发编写脚本，并分别拷贝到dev，test，prod三个配置文件中指定的文件夹下，并需要根据配置文件中的语句在上线文档中预留回滚脚本</li>
<li>测试在部署时会验证一次语句的正确性</li>
<li>在上线大会对prod进行一次确认</li>
</ol>
<p>通过工具+人工验证来保证正确性</p>
<p>具体可以参考</p>
<p><a href="https://www.yuque.com/u25495771/leupuu/ki0b7wfp37nm2z35">Flyway</a></p>
<h4 id="容量类故障"><a href="#容量类故障" class="headerlink" title="容量类故障"></a>容量类故障</h4><p>容量指的是服务器的磁盘  cpu  内存 各种连接池因不同的原因满足不了业务的需求，比如业务流量突然增加，线上队列数据堆积，日志输出增加、图片数量堆积等都可以造成故障，使服务无法提供正常的服务，在主流程的接口或者方法需要修改时一定要注意兼容性的问题.</p>
<h6 id="业务流量的突然增加："><a href="#业务流量的突然增加：" class="headerlink" title="业务流量的突然增加："></a>业务流量的突然增加：</h6><p>日常中并不是很常见，一般只有做类似于秒杀场景的时候可能会遇到，遇到类似的情况我们需要及时的做好压测，做好容量评估。上线后对服务器进行监控</p>
<h6 id="线上队列数据堆积："><a href="#线上队列数据堆积：" class="headerlink" title="线上队列数据堆积："></a>线上队列数据堆积：</h6><p>线上数据堆积也可能会出现磁盘被占满的情况，可以调整队列配置，设置合理的磁盘空间，并监控队列的使用情况，并及时的报警。队列的堆积很大的可能是因为下游消费端出现了问题，早日报警由人员的介入可以早日解决问题。</p>
<h6 id="日志输出增加、图片数量堆积："><a href="#日志输出增加、图片数量堆积：" class="headerlink" title="日志输出增加、图片数量堆积："></a>日志输出增加、图片数量堆积：</h6><p>当我们使用docker的时候如果docker的日志文件并未做限制的时候，经过时间的更迭，docker容器占用的磁盘会越来越多。要解决这个问题需要限制docker容器的日志大小，如果应用需要留存日志等文件，可以通过挂载的形式将文件挂载到宿主机。</p>
<p>图片或者上传文件的问题，可以通过分布式存储模式把文件分片存储防止出现类似问题</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>容量类故障可以通过运维手段来进行缓解，但是主体还是需要做好监控告警，并对可以预想到的问题进行充足的压测，并预留好容量</p>
<h4 id="固件类故障"><a href="#固件类故障" class="headerlink" title="固件类故障"></a>固件类故障</h4><p>在现实社会中总是充满着意外，网络有可能会中断，服务器硬件可能会损坏。多机备份是解决这类问题的办法，经验不多，这里就不深聊此类问题</p>
<h3 id="提升发现速度"><a href="#提升发现速度" class="headerlink" title="提升发现速度"></a>提升发现速度</h3><p>提升发现速度主要是通过监控，监控又可以分为运维监控和变更监控</p>
<h4 id="运维监控"><a href="#运维监控" class="headerlink" title="运维监控"></a>运维监控</h4><p>运维监控告警可以通过Prometheus+Grafana来实现，而做好监控要从不同的维度进行</p>
<h5 id="机器维度："><a href="#机器维度：" class="headerlink" title="机器维度："></a>机器维度：</h5><p>机器维度的监控指标包括CPU、Load、内存、网络、IO、磁盘等相关指标，可以通过设定这些指标的异常值，通过触发来进行告警。</p>
<h5 id="应用维度："><a href="#应用维度：" class="headerlink" title="应用维度："></a>应用维度：</h5><p>  应用维度的监控指标包括JVM使用情况、线程池使用情况：JVM情况主要包括YGC次数、时间，FullGC次数、时间，新生代老年代占比；线程池情况主要包括的线程池大小、最大线程数、活跃线程数、队列大小等。</p>
<h5 id="服务维度"><a href="#服务维度" class="headerlink" title="服务维度"></a>服务维度</h5><p>服务维度的监控指标包括error日志报错情况、服务接口调用量、耗时、成功率，调用接口调用量、耗时、成功率，dal层操作调用量、耗时、成功率。</p>
<h5 id="外部依赖维度"><a href="#外部依赖维度" class="headerlink" title="外部依赖维度"></a>外部依赖维度</h5><p> 外部依赖维度主要指应用系统常见的外部依赖的监控情况，主要包括数据库、缓存、消息队列等，这些一般情况都会独立进行部署，对应的机器监控同上面列举的机器维度监控；另外数据库还需要关注连接数、内存使用、SQL调用量、耗时、成功率，慢SQL等；缓存需要关注调用量、成功率，命中率、内存使用等；消息队列需要关注调用量、成功率，队列积压情况、死信队列等</p>
<h4 id="变更监控"><a href="#变更监控" class="headerlink" title="变更监控"></a>变更监控</h4><p>变更监控可以更加细分一下分为【对旧：观察异常运行情况】、【对新：观察更新是够生效】</p>
<h6 id="对旧：观察异常运行情况"><a href="#对旧：观察异常运行情况" class="headerlink" title="对旧：观察异常运行情况"></a>对旧：观察异常运行情况</h6><p>实现观察异常运行情况主要是观察变更之后，没有变更的服务是否有心得异常发生，可以通过日志埋点，关键业务逻辑检测，接口埋点的情况，通过规则判断是否受到影响，如果有影响需要尽快的修复</p>
<h6 id="对新：观察更新是够生效"><a href="#对新：观察更新是够生效" class="headerlink" title="对新：观察更新是够生效"></a>对新：观察更新是够生效</h6><p>观察更新是否生效可以从检测新接口的各项指标。新接口打点的日志输出情况来确认，因为功能的大小，无法有效的指定详细的规则，一般会通过人工对频率和异常进行分析最后得出结论</p>
<h4 id="慢查询监控"><a href="#慢查询监控" class="headerlink" title="慢查询监控"></a>慢查询监控</h4><p>在运维监控中其实是包含了慢查询监控的，但是这里还是需要强调一下，服务运行中，当数据慢慢增多出现慢查询的可能性逐步增大，日常中需要进行优化的地方多出现在这里。所以在日常中更需要对慢查询格外的关注，根据不同的数据库有不同的统计方法，mysql可以通过配置开启慢查询监控</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在监控告警中有一个问题需要特别的注意，就是告警疲劳，狼来了的故事告诉我们只有真正发生了问题才应该告警，而不是频繁的告警当真正的问题出现时无法正确的处理</p>
<h3 id="提升恢复速度"><a href="#提升恢复速度" class="headerlink" title="提升恢复速度"></a>提升恢复速度</h3><p>借用蚂蚁的<font style="color:rgba(0, 0, 0, 0.9);">变更三板斧【变更可监控】【变更可回滚】【变更可灰度】，其中变更可监控是用来提升发现速度的，而提升恢复速度主要是变更可回滚。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">提升恢复速度也可以分为运维期恢复，变更期恢复</font></p>
<h5 id="运维期恢复"><a href="#运维期恢复" class="headerlink" title="运维期恢复"></a><font style="color:rgba(0, 0, 0, 0.9);">运维期恢复</font></h5><h6 id="应急处理"><a href="#应急处理" class="headerlink" title="应急处理"></a>应急处理</h6><p>运维期间的恢复在排除容量类问题，大部分是可以通过对应用进行重启来解决的，所以定时探测+脚本重启服务可以作为一种应急的处理方法，可以自己手写脚本，也可以使用k8s。</p>
<h6 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h6><p>也可以启动多份服务，当一个服务因为一场原因宕机后，将流量打入其他存活的服务中</p>
<h5 id="变更期恢复"><a href="#变更期恢复" class="headerlink" title="变更期恢复"></a><font style="color:rgba(0, 0, 0, 0.9);">变更期恢复</font></h5><h6 id="变更可回滚"><a href="#变更可回滚" class="headerlink" title="变更可回滚"></a>变更可回滚</h6><p><font style="color:rgba(0, 0, 0, 0.9);">大家可能会问：</font><em><font style="color:rgba(0, 0, 0, 0.9);">回滚不就是用原来的代码重新部署一遍就行了吗？</font></em></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">回顾上面的更新故障解决部分的时候，可以看到很多回滚的字样，整理一下回滚中可能存在的问题，并思考一下怎么解决</font></p>
<h6 id="发布依赖"><a href="#发布依赖" class="headerlink" title="发布依赖"></a><font style="color:rgba(0, 0, 0, 0.9);">发布依赖</font></h6><p>当我们需要考虑发布顺序的时候，就会遇到发布依赖的问题。当服务A更新完之后才能更新服务B时，回滚就需要服务B回滚完毕然后再回滚服务A，这时服务A就无法快速回滚了。</p>
<h6 id="数据异常"><a href="#数据异常" class="headerlink" title="数据异常"></a><font style="color:rgba(0, 0, 0, 0.9);">数据异常</font></h6><p>当变更有数据结构变更的时候，这时老的系统如果不兼容现有的数据结构就会阻碍回滚，在更新故障解决部分我们要求更新时提供数据库回滚语句的原因就是这个，但是回滚了数据结构后，在回滚期间还是会产生脏数据，这些脏数据可以处理但是需要时间，这就无法实现快速回滚的诉求了</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a><font style="color:rgba(0, 0, 0, 0.9);">解决</font></h6><p><strong><font style="color:rgba(0, 0, 0, 0.9);">【新数据在旧代码中兼容】</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">更好的兼容性设计，在设计新功能的数据库变更的时候要考虑到旧版本对新版本的数据结构支持，比如新增功能与原来功能关联时新增关联表，需要修改表内容时增加列冗余</font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.9);">【使用开关控制回滚】</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">“部署”与“生效”分离。</font><font style="color:rgba(0, 0, 0, 0.9);">相比代码</font><font style="color:rgba(0, 0, 0, 0.9);">回滚，</font><font style="color:rgba(0, 0, 0, 0.9);">使用开关回滚会快很多。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">此外，使用开关回滚的方案，也可以解决上线代码被多次覆盖后不可回滚的问题。</font></p>
<h6 id="变更可灰度"><a href="#变更可灰度" class="headerlink" title="变更可灰度"></a>变更可灰度</h6><p>在使用开关控制回滚提到了部署与生效隔离，灰度就是分离很有效的手段。当服务A和服务B上线时我们在灰度环境中部署一套新版本的服务A和服务B，这时我们可以设置公司内部环境为灰度环境，当我们测试有异常时我们可以将灰度关闭，这样流量就不会进入灰度环境，以实现快速回滚。同样的例子我们可以把灰度服务逐步开放，一旦发现服务异常可以直接关闭灰度环境实现快速回滚。</p>
<p>而且可灰度还可以分开观察新版本和老版本的差异，</p>
<p>多次修改后的系统也可以回滚，如果单纯的代码回滚如果更新多次的服务可能就无法回滚了</p>
]]></content>
      <categories>
        <category>架构思想</category>
      </categories>
      <tags>
        <tag>可用性</tag>
        <tag>架构</tag>
      </tags>
  </entry>
</search>
