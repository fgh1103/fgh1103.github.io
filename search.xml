<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Canal</title>
    <url>/2022/06/11/Canal/</url>
    <content><![CDATA[<h2 id="什么是Canal"><a href="#什么是Canal" class="headerlink" title="什么是Canal"></a>什么是Canal</h2><p>canal译意为水道&#x2F;管道&#x2F;沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。<br>从这句话理解到了什么？<br>基于MySQL，并且通过MySQL日志进行的增量解析，这也就意味着对原有的业务代码完全是无侵入性的。</p>
<span id="more"></span>
<p><strong>工作原理</strong>：解析MySQL的binlog日志，提供增量数据。</p>
<h2 id="Canal能做什么"><a href="#Canal能做什么" class="headerlink" title="Canal能做什么"></a>Canal能做什么</h2><p>基于日志增量订阅和消费的业务包括</p>
<ul>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护(拆分异构索引、倒排索引等)</li>
<li>业务 cache 刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ul>
<p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。<br>官方文档：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h2 id="Canal数据如何传输？"><a href="#Canal数据如何传输？" class="headerlink" title="Canal数据如何传输？"></a>Canal数据如何传输？</h2><p>先来一张官方图：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650355686553-164622a0-3c7c-4356-82f8-3778ee9975a6.png#averageHue=%23f3f2f2&clientId=ub5d898f2-92c2-4&from=paste&id=ub5e1132e&originHeight=569&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua4319a32-b052-48db-a60d-bc7965ab4c2&title="><br>Canal分为服务端和客户端，这也是阿里常用的套路：</p>
<ul>
<li>服务端：负责解析MySQL的binlog日志，传递增量数据给客户端或者消息中间件</li>
<li>客户端：负责解析服务端传过来的数据，然后定制自己的业务处理。</li>
</ul>
<p>目前为止支持的消息中间件很全面了，比如Kafka、RocketMQ，RabbitMQ。</p>
<h2 id="数据同步还有其他中间件吗？"><a href="#数据同步还有其他中间件吗？" class="headerlink" title="数据同步还有其他中间件吗？"></a>数据同步还有其他中间件吗？</h2><p>有，当然有，还有一些开源的中间件也是相当不错的，比如Bifrost。<br>常见的几款中间件的区别如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/jpeg/25873401/1650355699488-47931f43-dbf5-4368-94c1-4c0df391ca21.jpeg#averageHue=%23e78379&clientId=ub5d898f2-92c2-4&from=paste&id=u0c2ffed1&originHeight=265&originWidth=640&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4e2a647e-3eb9-4b25-ac5c-8ed1645131d&title="><br>当然要我选择的话，首选阿里的中间件Canal。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Canal的实战，集成到SpringBoot"><a href="#Canal的实战，集成到SpringBoot" class="headerlink" title="Canal的实战，集成到SpringBoot"></a>Canal的实战，集成到SpringBoot</h2><h3 id="Canal服务端安装"><a href="#Canal服务端安装" class="headerlink" title="Canal服务端安装"></a>Canal服务端安装</h3><p>服务端需要下载压缩包，下载地址：<a href="https://github.com/alibaba/canal/releases">https://github.com/alibaba/canal/releases</a><br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356266972-8003453b-8323-4e12-85a7-4af4f9de6e64.png#averageHue=%23fefdfd&clientId=ub5d898f2-92c2-4&from=paste&height=858&id=uc284655e&name=image.png&originHeight=858&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87200&status=done&style=none&taskId=u56ed93ae-9eb9-4a89-a9d3-10c32925cfe&title=&width=867" alt="image.png"><br>下载稳定版本v1.1.5<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356447084-372caebe-0c97-466d-820b-e231d9421234.png#averageHue=%23fefaf9&clientId=ub5d898f2-92c2-4&from=paste&height=326&id=u7de74c62&name=image.png&originHeight=326&originWidth=863&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26771&status=done&style=none&taskId=ub0e23bb0-04b7-4b3c-bc70-ae83c9bc074&title=&width=863" alt="image.png"><br>下载完成解压，目录如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356460373-1b23ca59-a31d-4651-8c65-6457e88c3399.png#averageHue=%23fefdfd&clientId=ub5d898f2-92c2-4&from=paste&id=ubfec025c&originHeight=223&originWidth=985&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8473ca90-4285-446d-8011-ee8cb593e37&title="><br>本文使用<strong>Canal+RabbitMQ</strong>进行数据的同步，因此下面步骤完全按照这个base进行。</p>
<h3 id="打开MySQL的binlog日志"><a href="#打开MySQL的binlog日志" class="headerlink" title="打开MySQL的binlog日志"></a>打开MySQL的binlog日志</h3><p>请参考<a href="https://www.yuque.com/u25495771/yqh657/cv1548">https://www.yuque.com/u25495771/yqh657/cv1548</a></p>
<h3 id="设置MySQL的配置"><a href="#设置MySQL的配置" class="headerlink" title="设置MySQL的配置"></a>设置MySQL的配置</h3><p>需要设置服务端配置文件中的MySQL配置，这样Canal才能知道需要监听哪个库、哪个表的日志文件。<br>一个 Server 可以配置多个实例监听 ，Canal 功能默认自带的有个 example 实例，本篇就用 example 实例 。如果增加实例，复制 example 文件夹内容到同级目录下，然后在 canal.properties 指定添加实例的名称。<br>修改canal.deployer-1.1.5\conf\example\instance.properties配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># url</span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line"># username/password</span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=root</span><br><span class="line"># 监听的数据库</span><br><span class="line">canal.instance.defaultDatabaseName=test</span><br><span class="line"></span><br><span class="line"># 监听的表，可以指定，多个用逗号分割，这里正则是监听所有</span><br><span class="line">canal.instance.filter.regex=.*\\..*</span><br></pre></td></tr></table></figure>
<h3 id="设置RabbitMQ的配置"><a href="#设置RabbitMQ的配置" class="headerlink" title="设置RabbitMQ的配置"></a>设置RabbitMQ的配置</h3><p>服务端默认的传输方式是tcp，需要在配置文件中设置MQ的相关信息。<br>这里需要修改两处配置文件，如下；</p>
<ol>
<li>canal.deployer-1.1.5\conf\canal.properties</li>
</ol>
<p>这个配置文件主要是设置MQ相关的配置，比如URL，用户名、密码…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 传输方式：tcp, kafka, rocketMQ, rabbitMQ</span><br><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line">##################################################</span><br><span class="line">######### 		RabbitMQ	 #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host = 127.0.0.1</span><br><span class="line">rabbitmq.virtual.host =/</span><br><span class="line"># exchange</span><br><span class="line">rabbitmq.exchange =canal.exchange</span><br><span class="line"># 用户名、密码</span><br><span class="line">rabbitmq.username =guest</span><br><span class="line">rabbitmq.password =guest</span><br><span class="line">## 是否持久化</span><br><span class="line">rabbitmq.deliveryMode = 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>canal.deployer-1.1.5\conf\example\instance.properties</li>
</ol>
<p>这个文件设置MQ的路由KEY，这样才能路由到指定的队列中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canal.mq.topic=canal.routing.key</span><br></pre></td></tr></table></figure>
<h3 id="RabbitMQ新建exchange和Queue"><a href="#RabbitMQ新建exchange和Queue" class="headerlink" title="RabbitMQ新建exchange和Queue"></a>RabbitMQ新建exchange和Queue</h3><p>在RabbitMQ中需要新建一个canal.exchange（必须和配置中的相同）的exchange和一个名称为 canal.queue（名称随意）的队列。<br>其中绑定的路由KEY为：canal.routing.key（必须和配置中的相同），如下图：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356683237-bd7aa4dd-0249-4367-a4f1-d18fd642b151.png#averageHue=%23f8f7f7&clientId=ue7f6981a-5aa6-4&from=paste&id=u84bc14bb&originHeight=242&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub5a2273f-91e8-454f-82f8-f436dcbfb34&title="></p>
<h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>点击bin目录下的脚本，windows直接双击startup.bat，启动成功如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356701506-8b6915b7-a13c-4bf4-b2b8-be891699bd1a.png#averageHue=%232e2c2a&clientId=ue7f6981a-5aa6-4&from=paste&id=uc58fbd70&originHeight=315&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u899d291e-03ac-4e87-9905-4a09ece2ef3&title="></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在本地数据库test中的oauth_client_details插入一条数据，如下：<br>INSERT INTO <code>oauth_client_details</code> VALUES (‘myjszl’, ‘res1’, ‘$2a$10$F1tQdeb0SEMdtjlO8X&#x2F;0wO6Gqybu6vPC&#x2F;Xg8OmP9&#x2F;TL1i4beXdK9W’, ‘all’, ‘password,refresh_token,authorization_code,client_credentials,implicit’, ‘<a href="http://www.baidu.com/">http://www.baidu.com</a>‘, NULL, 1000, 1000, NULL, ‘false’);</p>
<p>此时查看MQ中的canal.queue已经有了数据，如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356727749-58f14d0b-4d67-4390-b426-8c4f12bda6a6.png#averageHue=%23fcfcfc&clientId=ue7f6981a-5aa6-4&from=paste&id=u20a8b6dd&originHeight=164&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucc2b654f-0461-4176-96b2-09bb8aae423&title=">其实就是一串JSON数据，这个JSON如下：<br>{<br> “data”: [{<br>  “client_id”: “myjszl”,<br>  “resource_ids”: “res1”,<br>  “client_secret”: “$2a$10$F1tQdeb0SEMdtjlO8X&#x2F;0wO6Gqybu6vPC&#x2F;Xg8OmP9&#x2F;TL1i4beXdK9W”,<br>  “scope”: “all”,<br>  “authorized_grant_types”: “password,refresh_token,authorization_code,client_credentials,implicit”,<br>  “web_server_redirect_uri”: “<a href="http://www.baidu.com/">http://www.baidu.com</a>“,<br>  “authorities”: null,<br>  “access_token_validity”: “1000”,<br>  “refresh_token_validity”: “1000”,<br>  “additional_information”: null,<br>  “autoapprove”: “false”<br> }],<br> “database”: “test”,<br> “es”: 1640337532000,<br> “id”: 7,<br> “isDdl”: false,<br> “mysqlType”: {<br>  “client_id”: “varchar(48)”,<br>  “resource_ids”: “varchar(256)”,<br>  “client_secret”: “varchar(256)”,<br>  “scope”: “varchar(256)”,<br>  “authorized_grant_types”: “varchar(256)”,<br>  “web_server_redirect_uri”: “varchar(256)”,<br>  “authorities”: “varchar(256)”,<br>  “access_token_validity”: “int(11)”,<br>  “refresh_token_validity”: “int(11)”,<br>  “additional_information”: “varchar(4096)”,<br>  “autoapprove”: “varchar(256)”<br> },<br> “old”: null,<br> “pkNames”: [“client_id”],<br> “sql”: “”,<br> “sqlType”: {<br>  “client_id”: 12,<br>  “resource_ids”: 12,<br>  “client_secret”: 12,<br>  “scope”: 12,<br>  “authorized_grant_types”: 12,<br>  “web_server_redirect_uri”: 12,<br>  “authorities”: 12,<br>  “access_token_validity”: 4,<br>  “refresh_token_validity”: 4,<br>  “additional_information”: 12,<br>  “autoapprove”: 12<br> },<br> “table”: “oauth_client_details”,<br> “ts”: 1640337532520,<br> “type”: “INSERT”<br>}</p>
<p>每个字段的意思已经很清楚了，有表名称、方法、参数、参数类型、参数值…..<br>客户端要做的就是监听MQ获取JSON数据，然后将其解析出来，处理自己的业务逻辑。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>打开IDEA创建项目canal-toos<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650357369053-2135bca0-7417-422d-a9ae-23ced9f4a203.png#averageHue=%233d4143&clientId=ue7f6981a-5aa6-4&from=paste&height=779&id=u1ae9689a&name=image.png&originHeight=779&originWidth=818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63356&status=done&style=none&taskId=uea85711c-4dbe-4e2d-9f1a-6889877ef0a&title=&width=818" alt="image.png"><br>引用POM文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!-- Mybatis plus代码生产插件 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- Mybatisplus代码生成模板 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- Mybatis基础依赖 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--mybatisplus 依赖插件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--mysql依赖插件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.38&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">   &lt;!-- rabbitmq 服务调用依赖 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- jackosn基础依赖 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.9&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="创建消息实体类"><a href="#创建消息实体类" class="headerlink" title="创建消息实体类"></a>创建消息实体类</h3><p>MQ传递过来的是JSON数据，当然要创建个实体类接收数据，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Canal消息接收实体类</span><br><span class="line"> */</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class CanalMessage&lt;T&gt; &#123;</span><br><span class="line">    @JsonProperty(&quot;type&quot;)</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;table&quot;)</span><br><span class="line">    private String table;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;data&quot;)</span><br><span class="line">    private List&lt;T&gt; data;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;database&quot;)</span><br><span class="line">    private String database;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;es&quot;)</span><br><span class="line">    private Long es;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;id&quot;)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;isDdl&quot;)</span><br><span class="line">    private Boolean isDdl;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;old&quot;)</span><br><span class="line">    private List&lt;T&gt; old;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;pkNames&quot;)</span><br><span class="line">    private List&lt;String&gt; pkNames;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;sql&quot;)</span><br><span class="line">    private String sql;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;ts&quot;)</span><br><span class="line">    private Long ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加RabbitMQ消费端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cn.hutool.json.JSONUtil;</span><br><span class="line">import cn.myjszl.middle.ware.canal.mq.rabbit.model.CanalMessage;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 监听MQ获取Canal增量的数据消息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class CanalRabbitMQListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings = &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value = @Queue(value = &quot;canal.queue&quot;, durable = &quot;true&quot;),</span><br><span class="line">                    exchange = @Exchange(value = &quot;canal.exchange&quot;),</span><br><span class="line">                    key = &quot;canal.routing.key&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void handleDataChange(String message) &#123;</span><br><span class="line">        //将message转换为CanalMessage</span><br><span class="line">        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class);</span><br><span class="line">        String tableName = canalMessage.getTable();</span><br><span class="line">        log.info(&quot;Canal 监听 &#123;&#125; 发生变化；明细：&#123;&#125;&quot;, tableName, message);</span><br><span class="line">        String tableName =canalMessage.getTable();</span><br><span class="line">        if (canalMessage.getData()!=null)&#123;</span><br><span class="line">                for (int i=0;i&lt;canalMessage.getData().size();i++ ) &#123;</span><br><span class="line">                Map&lt;String,Object&gt; map= mapper.readValue(canalMessage.getData().get(i).toString(),Map.class);</span><br><span class="line"></span><br><span class="line">                if (canalMessage.getType().contains(&quot;INSERT&quot;))&#123;</span><br><span class="line">                    sava(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (canalMessage.getType().contains(&quot;UPDATE&quot;))&#123;</span><br><span class="line">                    update(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (canalMessage.getType().contains(&quot;DELETE&quot;))&#123;</span><br><span class="line">                    delect(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public  String underlineToHump(String str) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(str))&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //正则匹配下划线及后一个字符，删除下划线并将匹配的字符转成大写</span><br><span class="line">        Matcher matcher = UNDERLINE_PATTERN.matcher(str);</span><br><span class="line">        StringBuffer sb = new StringBuffer(str);</span><br><span class="line">        if (matcher.find()) &#123;</span><br><span class="line">            sb = new StringBuffer();</span><br><span class="line">            //将当前匹配的子串替换成指定字符串，并且将替换后的子串及之前到上次匹配的子串之后的字符串添加到StringBuffer对象中</span><br><span class="line">            //正则之前的字符和被替换的字符</span><br><span class="line">            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());</span><br><span class="line">            //把之后的字符串也添加到StringBuffer对象中</span><br><span class="line">            matcher.appendTail(sb);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //去除除字母之外的前面带的下划线</span><br><span class="line">            return sb.toString().replaceAll(&quot;_&quot;, &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return underlineToHump(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    public void sava(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line">        Object tableObjet = tableClass.newInstance();</span><br><span class="line">        for (String key :oldTable.keySet())&#123;</span><br><span class="line">            Method[] methods =  tableObjet.getClass().getMethods();</span><br><span class="line">            Object mapValue=oldTable.get(key);</span><br><span class="line"></span><br><span class="line">            String methodName = underlineToHump(&quot;set&quot;+upperFirstCase(key.toLowerCase()));</span><br><span class="line">            for (Method method:methods)&#123;</span><br><span class="line">                if (method.getName().equals(methodName))&#123;</span><br><span class="line">                    if (method.getParameterTypes()[0].equals(String.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            mapValue =&quot; &quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, mapValue.toString());</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Date.class)|| method.getParameterTypes()[0].equals(LocalDateTime.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                        method.invoke(tableObjet, LocalDateTime.parse(mapValue.toString(),formatter));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Integer.class)||method.getParameterTypes()[0].equals(int.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Integer.parseInt(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Long.class)||method.getParameterTypes()[0].equals(long.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Long.parseLong(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Double.class)||method.getParameterTypes()[0].equals(double.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Double.parseDouble(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Boolean.class)||method.getParameterTypes()[0].equals(boolean.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Boolean.parseBoolean(mapValue.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Object pojo = mapper.readValue(mapper.writeValueAsString(oldTable), tableClass.getClass());</span><br><span class="line"></span><br><span class="line">        String newTable= lowerFirstCase(tableName+&quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line"></span><br><span class="line">        service.save(tableObjet);</span><br><span class="line">    &#125;</span><br><span class="line">        public void update(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, IOException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException &#123;</span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line">        Object tableObjet = tableClass.newInstance();</span><br><span class="line">        for (String key :oldTable.keySet()) &#123;</span><br><span class="line">            Method[] methods = tableObjet.getClass().getMethods();</span><br><span class="line">            Object mapValue = oldTable.get(key);</span><br><span class="line">            if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String methodName = underlineToHump(&quot;set&quot; + upperFirstCase(key.toLowerCase()));</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                if (method.getName().equals(methodName)) &#123;</span><br><span class="line">                    if (method.getParameterTypes()[0].equals(String.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, mapValue.toString());</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Date.class) || method.getParameterTypes()[0].equals(LocalDateTime.class)) &#123;</span><br><span class="line">                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                        method.invoke(tableObjet, LocalDateTime.parse(mapValue.toString(), formatter));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Integer.class) || method.getParameterTypes()[0].equals(int.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Integer.parseInt(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Long.class) || method.getParameterTypes()[0].equals(long.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Long.parseLong(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Double.class) || method.getParameterTypes()[0].equals(double.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Double.parseDouble(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Boolean.class) || method.getParameterTypes()[0].equals(boolean.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Boolean.parseBoolean(mapValue.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    //method.invoke(tableObjet,oldTable.get(key));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newTable = lowerFirstCase(tableName + &quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line">        service.updateById(tableObjet);</span><br><span class="line">    &#125;</span><br><span class="line">    public void delect(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, IOException &#123;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line"></span><br><span class="line">        QueryWrapper wrapper = new QueryWrapper();</span><br><span class="line">        wrapper.eq(&quot;ID&quot;,oldTable.get(&quot;ID&quot;));</span><br><span class="line">        String newTable= lowerFirstCase(tableName+&quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line">        service.remove(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>springboot</tag>
        <tag>canal</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>安装RabbitMQ</title>
    <url>/2022/01/11/%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h2 id="参照官网："><a href="#参照官网：" class="headerlink" title="参照官网："></a>参照官网：</h2><p><a href="https://www.rabbitmq.com/install-rpm.html#package-cloud">https://www.rabbitmq.com/install-rpm.html#package-cloud</a></p>
<span id="more"></span>
<h2 id="添加yum存储库信息"><a href="#添加yum存储库信息" class="headerlink" title="添加yum存储库信息"></a>添加yum存储库信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">touch rabbitmq.repo</span><br><span class="line">vi rabbitmq.repo</span><br></pre></td></tr></table></figure>
<p>rabbitmq.repo中添加文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#In /etc/yum.repos.d/rabbitmq.repo</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## Zero dependency Erlang</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq_erlang</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[rabbitmq_server]</span><br><span class="line">name=rabbitmq_server</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h2><p>使用命令：yum install rabbitmq-server</p>
<p>最后修改一直选y<br>将会自动下载安装对应的<a href="https://so.csdn.net/so/search?q=erlang&spm=1001.2101.3001.7020">erlang</a>版本、rabbitmq版本、keys等。<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644656259455-3fe11f75-b3a3-40b7-92ae-521df1e6b76c.png#clientId=u99af809c-8097-4&from=paste&height=529&id=ubb7d3f11&name=image.png&originHeight=529&originWidth=1887&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73715&status=done&style=none&taskId=u5df5f38f-98fd-4151-826f-39030d372c6&title=&width=1887" alt="image.png"></p>
<h2 id="修改登录拦截"><a href="#修改登录拦截" class="headerlink" title="修改登录拦截"></a>修改登录拦截</h2><p>rabbitmq 3.3.0开始禁用除localhost外的地址采取guest登录，所以此处需要将拦截去除。<br>找到安装目录<br>vi rabbit.app<br>将其中loopback_users, [&lt;&lt;”guest”&gt;&gt;]字段中的数据修改成下列方式：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659808980-04bf71e4-c7ae-4346-8be6-47d62ebd8a85.png#clientId=u99af809c-8097-4&from=paste&id=ub3d16f82&name=image.png&originHeight=563&originWidth=501&originalType=url&ratio=1&rotation=0&showTitle=false&size=46996&status=done&style=none&taskId=u28d72f30-d720-4c4c-a149-eb0933f0eaa&title=" alt="image.png"></p>
<h2 id="启动rabbitmq"><a href="#启动rabbitmq" class="headerlink" title="启动rabbitmq"></a>启动rabbitmq</h2><p>service rabbitmq-server start</p>
<h2 id="开启图形化"><a href="#开启图形化" class="headerlink" title="开启图形化"></a>开启图形化</h2><p>rabbitmq-plugins enable rabbitmq_management<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659826635-8d068b00-e708-46c4-bd51-2e4b9f9e86dd.png#clientId=u99af809c-8097-4&from=paste&id=u225e2c08&name=image.png&originHeight=186&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&size=19642&status=done&style=none&taskId=u9402a1a4-793f-49ae-8461-428aa7895c5&title=" alt="image.png"></p>
<h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><p>rabbitmqctl status</p>
<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><p>使用命令rabbitmqctl add_user username password进行添加新用户。<br>rabbitmqctl add_user xiangjiao bunana<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659924599-bc6befcb-314f-48c0-aaf1-12ede71381d9.png#clientId=u99af809c-8097-4&from=paste&id=ub67c24ee&name=image.png&originHeight=45&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&size=8623&status=done&style=none&taskId=uc663062d-0c58-4570-ad64-e364a76c652&title=" alt="image.png"></p>
<h2 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h2><p>使用命令rabbitmqctl set_user_tags username administrator设置用户tag。<br>rabbitmqctl set_user_tags xiangjiao administrator<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659930697-fc18293d-a7cb-42b9-86a0-9f001f700899.png#clientId=u99af809c-8097-4&from=paste&id=u9bac882c&name=image.png&originHeight=27&originWidth=669&originalType=url&ratio=1&rotation=0&showTitle=false&size=4718&status=done&style=none&taskId=u396a0295-cbf2-4cc0-92a4-f1308d063cb&title=" alt="image.png"></p>
<h1 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659937730-5b420d6a-2d54-4b74-a5d8-1714df1188f0.png#clientId=u99af809c-8097-4&from=paste&id=u26e58c6c&name=image.png&originHeight=253&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&size=16836&status=done&style=none&taskId=u93fc0373-469d-436c-a3ea-67a98f50a61&title=" alt="image.png"></p>
<p> <img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659947739-f1582562-2b4e-48ce-8ee5-e63aa60ddba1.png#clientId=u99af809c-8097-4&from=paste&id=u90593ccb&name=image.png&originHeight=740&originWidth=1457&originalType=url&ratio=1&rotation=0&showTitle=false&size=67428&status=done&style=none&taskId=uc63ffb4a-3243-4c60-9c35-1f499430c7f&title=" alt="image.png"></p>
<h1 id="命令拓展"><a href="#命令拓展" class="headerlink" title="命令拓展"></a>命令拓展</h1><h2 id="卸载rabbitmq"><a href="#卸载rabbitmq" class="headerlink" title="卸载rabbitmq"></a>卸载rabbitmq</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–卸载</span><br><span class="line">–停止服务</span><br><span class="line">rabbitmqctl app_stop</span><br><span class="line">yum list | grep rabbitmq</span><br><span class="line">yum -y remove rabbitmq-server.noarch</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="卸载erlang支持"><a href="#卸载erlang支持" class="headerlink" title="卸载erlang支持"></a>卸载erlang支持</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list | grep erlang</span><br><span class="line">yum -y remove erlang-*</span><br><span class="line">yum remove erlang.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig rabbitmq-server on # 添加开机启动RabbitMQ服务</span><br><span class="line">/sbin/service rabbitmq-server start # 启动服务</span><br><span class="line">/sbin/service rabbitmq-server status # 查看服务状态</span><br><span class="line">/sbin/service rabbitmq-server stop # 停止服务</span><br><span class="line">rabbitmqctl list_users #查看用户列表信息和权限信息</span><br><span class="line">rabbitmqctl list_user_permissions xxxxx #查看指定用户的权限信息</span><br><span class="line">rabbitmqctl delete_user guest #删除guest用户</span><br><span class="line">rabbitmqctl add_user username password #添加新用户</span><br><span class="line">rabbitmqctl set_user_tags username administrator #设置用户tag</span><br><span class="line">rabbitmqctl set_permissions -p / username “.&quot; &quot;.” “.*” #赋予用户默认vhost的全部操作权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义用户信息</title>
    <url>/2024/03/11/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在集成Oauth2.1认证中心，采用默认的数据结构实现了认证，但是大部分时候默认的用户结构并不能满足生产的需要，所以接下来以RBAC权限设计来实现用户</p>
<span id="more"></span>
<h2 id="基于RBAC的权限设计"><a href="#基于RBAC的权限设计" class="headerlink" title="基于RBAC的权限设计"></a>基于RBAC的权限设计</h2><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE system_user(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36)    COMMENT &#x27;租户号&#x27; ,</span><br><span class="line">    USER_ID VARCHAR(36) NOT NULL   COMMENT &#x27;用户编号&#x27; ,</span><br><span class="line">    DEPT_ID VARCHAR(36)    COMMENT &#x27;部门编号&#x27; ,</span><br><span class="line">    USER_NAME VARCHAR(100) NOT NULL   COMMENT &#x27;用户账号&#x27; ,</span><br><span class="line">    NICK_NAME VARCHAR(100)    COMMENT &#x27;用户昵称&#x27; ,</span><br><span class="line">    EMAIL VARCHAR(100)    COMMENT &#x27;用户邮箱&#x27; ,</span><br><span class="line">    PHONE_NUMBER VARCHAR(100)    COMMENT &#x27;用户手机号&#x27; ,</span><br><span class="line">    SEX INT    COMMENT &#x27;性别&#x27; ,</span><br><span class="line">    AVATAR VARCHAR(100)    COMMENT &#x27;头像地址&#x27; ,</span><br><span class="line">    PASSWORD VARCHAR(100) NOT NULL   COMMENT &#x27;密码&#x27; ,</span><br><span class="line">    STATUS INT NOT NULL   COMMENT &#x27;用户状态&#x27; ,</span><br><span class="line">    DEL_FLAG INT NOT NULL   COMMENT &#x27;删除标志（0代表存在 2代表删除）&#x27; ,</span><br><span class="line">    REVISION INT NOT NULL  COMMENT &#x27;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(100)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(100)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户表&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE system_role(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36)    COMMENT &#x27;角色编号;角色编号&#x27; ,</span><br><span class="line">    ROLE_NAME VARCHAR(100)    COMMENT &#x27;角色名称;角色名称&#x27; ,</span><br><span class="line">    ROLE_KEY VARCHAR(100)    COMMENT &#x27;角色权限字符串;角色权限字符串&#x27; ,</span><br><span class="line">    ROLE_SORT INT    COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    DATA_SCOPE VARCHAR(100)    COMMENT &#x27;数据范围;数据范围（1：全部数据权限 2：自定数据权限 3：本部门数据权限 4：本部门及以下数据权限）&#x27; ,</span><br><span class="line">    MENU_CHECK_STRICTLY VARCHAR(1)    COMMENT &#x27;菜单树选择项是否关联显示;菜单树选择项是否关联显示&#x27; ,</span><br><span class="line">    DEPT_CHECK_STRICTLY VARCHAR(1)    COMMENT &#x27;部门树选择项是否关联显示;部门树选择项是否关联显示&#x27; ,</span><br><span class="line">    STATUS VARCHAR(1)    COMMENT &#x27;角色状态（0正常 1停用）;角色状态（0正常 1停用）&#x27; ,</span><br><span class="line">    DEL_FLAG VARCHAR(1)    COMMENT &#x27;删除标志（0代表存在 2代表删除）;删除标志（0代表存在 2代表删除）&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36)    COMMENT &#x27;租户号;租户号&#x27; ,</span><br><span class="line">    REVISION INT  NOT NULL    COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(36)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(36)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_menu(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID&#x27; ,</span><br><span class="line">    MENU_ID VARCHAR(36) NOT NULL   COMMENT &#x27;菜单编号;菜单编号&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36) NOT NULL   COMMENT &#x27;租户号;租户号&#x27; ,</span><br><span class="line">    MENU_NAME VARCHAR(100) NOT NULL   COMMENT &#x27;菜单名称;菜单名称&#x27; ,</span><br><span class="line">    PARENT_ID VARCHAR(36)    COMMENT &#x27;父菜单ID;父菜单ID&#x27; ,</span><br><span class="line">    ORDER_NUM INT    COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    PATH VARCHAR(100)    COMMENT &#x27;路由地址;路由地址&#x27; ,</span><br><span class="line">    COMPONENT VARCHAR(100)    COMMENT &#x27;组件路径;组件路径&#x27; ,</span><br><span class="line">    QUERY VARCHAR(100)    COMMENT &#x27;路由参数;路由参数&#x27; ,</span><br><span class="line">    IS_FRAME VARCHAR(1)    COMMENT &#x27;是否为外链（0是 1否）;是否为外链（0是 1否）&#x27; ,</span><br><span class="line">    IS_CACHE VARCHAR(1)    COMMENT &#x27;是否缓存（0缓存 1不缓存）;是否缓存（0缓存 1不缓存）&#x27; ,</span><br><span class="line">    MENU_TYPE VARCHAR(32)    COMMENT &#x27;菜单类型（M目录 C菜单 F按钮）;菜单类型（M目录 C菜单 F按钮）&#x27; ,</span><br><span class="line">    VISIBLE VARCHAR(100)    COMMENT &#x27;菜单状态（0显示 1隐藏）;菜单状态（0显示 1隐藏）&#x27; ,</span><br><span class="line">    STATUS VARCHAR(100)    COMMENT &#x27;菜单状态（0正常 1停用）;菜单状态（0正常 1停用）&#x27; ,</span><br><span class="line">    PERMS VARCHAR(100)    COMMENT &#x27;权限标识;权限标识&#x27; ,</span><br><span class="line">    ICON VARCHAR(100)    COMMENT &#x27;菜单图标;菜单图标&#x27; ,</span><br><span class="line">    REVISION INT NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(100)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(100)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID,MENU_ID)</span><br><span class="line">)  COMMENT = &#x27;菜单权限表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_user_role(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    USER_ID VARCHAR(36) NOT NULL   COMMENT &#x27;用户ID;用户ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36) NOT NULL   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色关联表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_role_menu(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36) NOT NULL   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    MENU_ID VARCHAR(36) NOT NULL   COMMENT &#x27;菜单ID;菜单ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;角色权限菜单表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自定义用户实现"><a href="#自定义用户实现" class="headerlink" title="自定义用户实现"></a><font style="color:rgb(0, 0, 0);">自定义用户实现</font></h3><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>改造网关实现授权</title>
    <url>/2024/03/14/%E6%94%B9%E9%80%A0%E7%BD%91%E5%85%B3%E5%AE%9E%E7%8E%B0%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>先看下认证授权的过程，认证客户端的认证是最先被认证的，只有先认证客户端可会进行token的认证，而我们不应该把客户端的信息暴漏在外面所以客户端的信息只能通过网关转发的时候注入到请求中</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/27343190/1667726854430-5c1f32f8-d71b-4c75-815c-c75de9cac331.png"></p>
<span id="more"></span>

<h2 id="直接请求认证服务器的流程"><a href="#直接请求认证服务器的流程" class="headerlink" title="直接请求认证服务器的流程"></a>直接请求认证服务器的流程</h2><p>请求<font style="color:rgb(33, 33, 33);">&#x2F;oauth2&#x2F;token 输入表单信息</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132164269-3335ac9d-d4a6-4464-81aa-b9753aae6360.png"></p>
<p><font style="color:rgb(107, 107, 107);"> </font>Authorization设置为Basic Auth</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132230680-00619d4b-b0be-436a-8431-cf863ddfb67c.png"></p>
<p>获得结果</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132311409-b4aac947-0f53-4d41-a529-549fadb993b5.png"></p>
<p>使用网关转发请求和注入服务的时候，当客户端不能直接提供客户端信息的时候，需要在网关转发时注入</p>
<h2 id="改造网关"><a href="#改造网关" class="headerlink" title="改造网关"></a>改造网关</h2><h3 id="增加局部过滤器"><a href="#增加局部过滤器" class="headerlink" title="增加局部过滤器"></a>增加局部过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoginFilter extends AbstractGatewayFilterFactory&lt;LoginFilter.Config&gt; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private  ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientProperties clientProperties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LoginFilter() &#123;</span><br><span class="line">        super(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Token URL 标识</span><br><span class="line">     */</span><br><span class="line">    private static final String TOKEN_URL_IDENTIFY = &quot;oauth2/token&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public GatewayFilter apply(Config config) &#123;</span><br><span class="line">        return (exchange, chain) -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">                //判断是否是请求token</span><br><span class="line">                String path = request.getURI().getPath();</span><br><span class="line">                if (!StrUtil.containsIgnoreCase(path, TOKEN_URL_IDENTIFY)) &#123;</span><br><span class="line">                    return chain.filter(exchange);</span><br><span class="line">                &#125;</span><br><span class="line">                //TODO:后续可以增加验证码验证</span><br><span class="line">                //注入客户端信息</span><br><span class="line">                ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">                String clientStr =String.format(&quot;%s:%s&quot;,clientProperties.getClientId(),clientProperties.getClientSecret());</span><br><span class="line">                String base = Base64.encode(clientStr);</span><br><span class="line">                addHeader(mutate,&quot;Authorization&quot;,String.format(&quot;Basic %s&quot;,base));</span><br><span class="line">            &#125;catch (UnauthorizedException ex)&#123;</span><br><span class="line">                getErrResponse(exchange, AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED,ex.getMessage()));</span><br><span class="line">            &#125;catch (Exception e) &#123;</span><br><span class="line">                return getErrResponse(exchange, AjaxResult.error(ResponseStatusEnum.SYS_ERROR, e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class Config &#123;</span><br><span class="line">        // 在这里可以定义配置属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addHeader(ServerHttpRequest.Builder mutate, String name, Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueStr = value.toString();</span><br><span class="line">        String valueEncode = valueStr;</span><br><span class="line">        mutate.header(name, valueEncode);</span><br><span class="line">    &#125;</span><br><span class="line">    private Mono&lt;Void&gt; getErrResponse(ServerWebExchange exchange, Object errInfo) &#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">        return response.writeWith(Mono.create(monoSink -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] bytes = objectMapper.writeValueAsBytes(errInfo);</span><br><span class="line">                DataBuffer dataBuffer = response.bufferFactory().wrap(bytes);</span><br><span class="line">                monoSink.success(dataBuffer);</span><br><span class="line">            &#125; catch (JsonProcessingException jsonProcessingException) &#123;</span><br><span class="line">                log.error(jsonProcessingException.getMessage());</span><br><span class="line">                monoSink.error(jsonProcessingException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置客户端信息"><a href="#配置客户端信息" class="headerlink" title="配置客户端信息"></a>配置客户端信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RefreshScope</span><br><span class="line">@ConfigurationProperties(prefix = &quot;security.client&quot;)</span><br><span class="line">public class ClientProperties &#123;</span><br><span class="line">    private String clientId;</span><br><span class="line">    private String clientSecret;</span><br><span class="line"></span><br><span class="line">    public String getClientId() &#123;</span><br><span class="line">        return clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClientId(String clientId) &#123;</span><br><span class="line">        this.clientId = clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getClientSecret() &#123;</span><br><span class="line">        return clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClientSecret(String clientSecret) &#123;</span><br><span class="line">        this.clientSecret = clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">  client:</span><br><span class="line">    clientId: messaging-client</span><br><span class="line">    clientSecret: secret</span><br></pre></td></tr></table></figure>

<h3 id="路由中添加过滤器"><a href="#路由中添加过滤器" class="headerlink" title="路由中添加过滤器"></a>路由中添加过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- id: luck-auth</span><br><span class="line">  uri: lb://luck-auth</span><br><span class="line">  predicates:</span><br><span class="line">    - Path=/auth/**</span><br><span class="line">  filters:</span><br><span class="line">    - StripPrefix=1</span><br><span class="line">    - CacheRequestFilter</span><br><span class="line">    - LoginFilter</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133263303-ffd2f328-09fa-4bd4-9a53-9c5ded039cf4.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133272368-1c2b04a7-f9b0-49ac-90e4-dce9298e5f8d.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133290397-da9266f6-dd79-4b06-ac87-736203474128.png"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Authorization设置为Basic Auth 的实际操作为在Header中新增一个key为Authorization value为 Basic +base64({clientId}:{clientSecret}) 。这里Basic后面是有一个空格的需要注意。</p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>资源服务器鉴权处理</title>
    <url>/2024/03/15/%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>在oauth2中授权服务器颁发过令牌后，用户就可以对资源进行访问，这时会有一个问题就是需要验证令牌，而前边文章中令牌使用的jwt格式，所以需要一个统一的资源管理器来验证令牌解析令牌</p>
<span id="more"></span>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class BearerTokenAuthenticationFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">	private final AuthenticationManagerResolver&lt;HttpServletRequest&gt; authenticationManagerResolver;</span><br><span class="line"></span><br><span class="line">	private AuthenticationEntryPoint authenticationEntryPoint = new BearerTokenAuthenticationEntryPoint();</span><br><span class="line"></span><br><span class="line">	private AuthenticationFailureHandler authenticationFailureHandler = (request, response, exception) -&gt; &#123;</span><br><span class="line">		if (exception instanceof AuthenticationServiceException) &#123;</span><br><span class="line">			throw exception;</span><br><span class="line">		&#125;</span><br><span class="line">		this.authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	private BearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();</span><br><span class="line"></span><br><span class="line">	private AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = new WebAuthenticationDetailsSource();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Construct a &#123;@code BearerTokenAuthenticationFilter&#125; using the provided parameter(s)</span><br><span class="line">	 * @param authenticationManagerResolver</span><br><span class="line">	 */</span><br><span class="line">	public BearerTokenAuthenticationFilter(</span><br><span class="line">			AuthenticationManagerResolver&lt;HttpServletRequest&gt; authenticationManagerResolver) &#123;</span><br><span class="line">		Assert.notNull(authenticationManagerResolver, &quot;authenticationManagerResolver cannot be null&quot;);</span><br><span class="line">		this.authenticationManagerResolver = authenticationManagerResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Construct a &#123;@code BearerTokenAuthenticationFilter&#125; using the provided parameter(s)</span><br><span class="line">	 * @param authenticationManager</span><br><span class="line">	 */</span><br><span class="line">	public BearerTokenAuthenticationFilter(AuthenticationManager authenticationManager) &#123;</span><br><span class="line">		Assert.notNull(authenticationManager, &quot;authenticationManager cannot be null&quot;);</span><br><span class="line">		this.authenticationManagerResolver = (request) -&gt; authenticationManager;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Extract any</span><br><span class="line">	 * &lt;a href=&quot;https://tools.ietf.org/html/rfc6750#section-1.2&quot; target=&quot;_blank&quot;&gt;Bearer</span><br><span class="line">	 * Token&lt;/a&gt; from the request and attempt an authentication.</span><br><span class="line">	 * @param request</span><br><span class="line">	 * @param response</span><br><span class="line">	 * @param filterChain</span><br><span class="line">	 * @throws ServletException</span><br><span class="line">	 * @throws IOException</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		String token;</span><br><span class="line">		try &#123;</span><br><span class="line">			token = this.bearerTokenResolver.resolve(request);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (OAuth2AuthenticationException invalid) &#123;</span><br><span class="line">			this.logger.trace(&quot;Sending to authentication entry point since failed to resolve bearer token&quot;, invalid);</span><br><span class="line">			this.authenticationEntryPoint.commence(request, response, invalid);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (token == null) &#123;</span><br><span class="line">			this.logger.trace(&quot;Did not process request since did not find bearer token&quot;);</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BearerTokenAuthenticationToken authenticationRequest = new BearerTokenAuthenticationToken(token);</span><br><span class="line">		authenticationRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			AuthenticationManager authenticationManager = this.authenticationManagerResolver.resolve(request);</span><br><span class="line">			Authentication authenticationResult = authenticationManager.authenticate(authenticationRequest);</span><br><span class="line">			SecurityContext context = SecurityContextHolder.createEmptyContext();</span><br><span class="line">			context.setAuthentication(authenticationResult);</span><br><span class="line">			SecurityContextHolder.setContext(context);</span><br><span class="line">			if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">				this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authenticationResult));</span><br><span class="line">			&#125;</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (AuthenticationException failed) &#123;</span><br><span class="line">			SecurityContextHolder.clearContext();</span><br><span class="line">			this.logger.trace(&quot;Failed to process authentication request&quot;, failed);</span><br><span class="line">			this.authenticationFailureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link BearerTokenResolver&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link DefaultBearerTokenResolver&#125;.</span><br><span class="line">	 * @param bearerTokenResolver the &#123;@code BearerTokenResolver&#125; to use</span><br><span class="line">	 */</span><br><span class="line">	public void setBearerTokenResolver(BearerTokenResolver bearerTokenResolver) &#123;</span><br><span class="line">		Assert.notNull(bearerTokenResolver, &quot;bearerTokenResolver cannot be null&quot;);</span><br><span class="line">		this.bearerTokenResolver = bearerTokenResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationEntryPoint&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link BearerTokenAuthenticationEntryPoint&#125;.</span><br><span class="line">	 * @param authenticationEntryPoint the &#123;@code AuthenticationEntryPoint&#125; to use</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationEntryPoint(final AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">		Assert.notNull(authenticationEntryPoint, &quot;authenticationEntryPoint cannot be null&quot;);</span><br><span class="line">		this.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationFailureHandler&#125; to use. Default implementation invokes</span><br><span class="line">	 * &#123;@link AuthenticationEntryPoint&#125;.</span><br><span class="line">	 * @param authenticationFailureHandler the &#123;@code AuthenticationFailureHandler&#125; to use</span><br><span class="line">	 * @since 5.2</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationFailureHandler(final AuthenticationFailureHandler authenticationFailureHandler) &#123;</span><br><span class="line">		Assert.notNull(authenticationFailureHandler, &quot;authenticationFailureHandler cannot be null&quot;);</span><br><span class="line">		this.authenticationFailureHandler = authenticationFailureHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationDetailsSource&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link WebAuthenticationDetailsSource&#125;.</span><br><span class="line">	 * @param authenticationDetailsSource the &#123;@code AuthenticationConverter&#125; to use</span><br><span class="line">	 * @since 5.5</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationDetailsSource(</span><br><span class="line">			AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource) &#123;</span><br><span class="line">		Assert.notNull(authenticationDetailsSource, &quot;authenticationDetailsSource cannot be null&quot;);</span><br><span class="line">		this.authenticationDetailsSource = authenticationDetailsSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JwtAuthenticationProvider的  jwt的主流程处理中心</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class JwtAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line"></span><br><span class="line">	private final Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">	private final JwtDecoder jwtDecoder;</span><br><span class="line"></span><br><span class="line">	private Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt; jwtAuthenticationConverter = new JwtAuthenticationConverter();</span><br><span class="line"></span><br><span class="line">	public JwtAuthenticationProvider(JwtDecoder jwtDecoder) &#123;</span><br><span class="line">		Assert.notNull(jwtDecoder, &quot;jwtDecoder cannot be null&quot;);</span><br><span class="line">		this.jwtDecoder = jwtDecoder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Decode and validate the</span><br><span class="line">	 * &lt;a href=&quot;https://tools.ietf.org/html/rfc6750#section-1.2&quot; target=&quot;_blank&quot;&gt;Bearer</span><br><span class="line">	 * Token&lt;/a&gt;.</span><br><span class="line">	 * @param authentication the authentication request object.</span><br><span class="line">	 * @return A successful authentication</span><br><span class="line">	 * @throws AuthenticationException if authentication failed for some reason</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">		BearerTokenAuthenticationToken bearer = (BearerTokenAuthenticationToken) authentication;</span><br><span class="line">		Jwt jwt = getJwt(bearer);</span><br><span class="line">		AbstractAuthenticationToken token = this.jwtAuthenticationConverter.convert(jwt);</span><br><span class="line">		token.setDetails(bearer.getDetails());</span><br><span class="line">		this.logger.debug(&quot;Authenticated token&quot;);</span><br><span class="line">		return token;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Jwt getJwt(BearerTokenAuthenticationToken bearer) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return this.jwtDecoder.decode(bearer.getToken());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BadJwtException failed) &#123;</span><br><span class="line">			this.logger.debug(&quot;Failed to authenticate since the JWT was invalid&quot;);</span><br><span class="line">			throw new InvalidBearerTokenException(failed.getMessage(), failed);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (JwtException failed) &#123;</span><br><span class="line">			throw new AuthenticationServiceException(failed.getMessage(), failed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">		return BearerTokenAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setJwtAuthenticationConverter(</span><br><span class="line">			Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt; jwtAuthenticationConverter) &#123;</span><br><span class="line">		Assert.notNull(jwtAuthenticationConverter, &quot;jwtAuthenticationConverter cannot be null&quot;);</span><br><span class="line">		this.jwtAuthenticationConverter = jwtAuthenticationConverter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析doFilterInternal方法我们可知：</p>
<ul>
<li>请求会被 BearerTokenAuthenticationFilter 拦截器拦截，通过bearerTokenResolver解析出token字符串如果没有解析出来，则由下一个过滤器处理。如果失败将被AuthenticationEntryPoint统一拦截处理</li>
<li>解析出来则构建一个BearerTokenAuthenticationToken对象。</li>
<li>将HttpServletRequest传递给AuthenticationManagerResolver对象，由它选择出AuthenticationManager对象，然后将 BearerTokenAuthenticationToken传递给AuthenticationManager对象进行认证。AuthenticationManager对象的实现，取决于我们的token对象是JWT还是opaque token</li>
<li>在AuthenticationManager由多个Provider对Authentication进行处理最终返回结果，当对象为jwt时处理对象为JwtAuthenticationProvider，在JwtAuthenticationProvider会先通过jwtDecoder解析jwt字符串，最终对JwtAuthenticationConverter将jwt字符串处理的为AbstractAuthenticationToken</li>
<li>验证失败<ul>
<li>清空 SecurityContextHolder 对象。</li>
<li>交由AuthenticationFailureHandler对象处理。</li>
</ul>
</li>
<li>验证成功<ul>
<li>将 Authentication对象设置到SecurityContextHolder中。</li>
<li>交由余下的过滤器继续处理。</li>
</ul>
</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>pom文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>ResourceServerConfiguration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableMethodSecurity</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class ResourceServerConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line"></span><br><span class="line">    private final HttpSecurity http;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityFilterChain filterChain() throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .antMatchers(&quot;/actuator/**&quot;, &quot;/v3/api-docs/**&quot;, &quot;/swagger-ui/**&quot;,</span><br><span class="line">                                &quot;/swagger-ui.html&quot;).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                .oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">                        .authenticationEntryPoint(luckAuthenticationEntryPoint())</span><br><span class="line">                        .bearerTokenResolver(new LuckBearerTokenResolver(redisService))</span><br><span class="line">                        .jwt());</span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationConverter jwtAuthenticationConverter() &#123;</span><br><span class="line">        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();</span><br><span class="line">        grantedAuthoritiesConverter.setAuthorityPrefix(&quot;&quot;);</span><br><span class="line">        grantedAuthoritiesConverter.setAuthoritiesClaimName(&quot;authorities&quot;);</span><br><span class="line"></span><br><span class="line">        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();</span><br><span class="line">        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);</span><br><span class="line">        return jwtAuthenticationConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LuckAuthenticationEntryPoint luckAuthenticationEntryPoint() &#123;</span><br><span class="line">        return new LuckAuthenticationEntryPoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return PasswordEncoderFactories.createDelegatingPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;pms&quot;)</span><br><span class="line">    public PermissionHandler permissionHandler() &#123;</span><br><span class="line">        return new PermissionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>异常定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public class LuckAuth2AuthencticationException extends OAuth2AuthenticationException &#123;</span><br><span class="line">    private final String code;</span><br><span class="line"></span><br><span class="line">    public LuckAuth2AuthencticationException(ResponseStatusEnum status) &#123;</span><br><span class="line">        super(new OAuth2Error(status.getMsg()), status.getMsg());</span><br><span class="line">        this.code = status.getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查异常处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LuckAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line">        ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);</span><br><span class="line">        AjaxResult&lt;?&gt; error;</span><br><span class="line">        if(authException instanceof InvalidBearerTokenException)&#123;</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.FAILED_DEPENDENCY);</span><br><span class="line">            error = AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, authException.getMessage());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            error = AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED, authException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpEndpointUtils.writeWithMessageConverters(error, servletServerHttpResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令牌适配器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class LuckBearerTokenResolver implements BearerTokenResolver &#123;</span><br><span class="line"></span><br><span class="line">    private final RedisService redisService;</span><br><span class="line"></span><br><span class="line">    private static final Pattern AUTHORIZATION_PATTERN = Pattern.compile(&quot;^Bearer (?&lt;token&gt;[a-zA-Z0-9-._~+/]+=*)$&quot;,</span><br><span class="line">            Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line">    private boolean allowFormEncodedBodyParameter = false;</span><br><span class="line"></span><br><span class="line">    private boolean allowUriQueryParameter = false;</span><br><span class="line"></span><br><span class="line">    private String bearerTokenHeaderName = HttpHeaders.AUTHORIZATION;</span><br><span class="line"></span><br><span class="line">//    public  LuckBearerTokenResolver(RedisService redisService)&#123;</span><br><span class="line">//        this.redisService = redisService;</span><br><span class="line">//    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String resolve(HttpServletRequest request) &#123;</span><br><span class="line">            final String authorizationHeaderToken = resolveFromAuthorizationHeader(request);</span><br><span class="line">            final String parameterToken = isParameterTokenSupportedForRequest(request)</span><br><span class="line">                    ? resolveFromRequestParameters(request) : null;</span><br><span class="line">            if (authorizationHeaderToken != null) &#123;</span><br><span class="line">                if (parameterToken != null) &#123;</span><br><span class="line">                    final BearerTokenError error = BearerTokenErrors</span><br><span class="line">                            .invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);</span><br><span class="line">                    throw new OAuth2AuthenticationException(error);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return authorizationHeaderToken;</span><br><span class="line">            &#125;</span><br><span class="line">            if (parameterToken != null &amp;&amp; isParameterTokenEnabledForRequest(request)) &#123;</span><br><span class="line">                return parameterToken;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Set if transport of access token using form-encoded body parameter is supported.</span><br><span class="line">     * Defaults to &#123;@code false&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param allowFormEncodedBodyParameter if the form-encoded body parameter is</span><br><span class="line">     *                                      supported</span><br><span class="line">     */</span><br><span class="line">    public void setAllowFormEncodedBodyParameter(boolean allowFormEncodedBodyParameter) &#123;</span><br><span class="line">        this.allowFormEncodedBodyParameter = allowFormEncodedBodyParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set if transport of access token using URI query parameter is supported. Defaults</span><br><span class="line">     * to &#123;@code false&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The spec recommends against using this mechanism for sending bearer tokens, and</span><br><span class="line">     * even goes as far as stating that it was only included for completeness.</span><br><span class="line">     *</span><br><span class="line">     * @param allowUriQueryParameter if the URI query parameter is supported</span><br><span class="line">     */</span><br><span class="line">    public void setAllowUriQueryParameter(boolean allowUriQueryParameter) &#123;</span><br><span class="line">        this.allowUriQueryParameter = allowUriQueryParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set this value to configure what header is checked when resolving a Bearer Token.</span><br><span class="line">     * This value is defaulted to &#123;@link HttpHeaders#AUTHORIZATION&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This allows other headers to be used as the Bearer Token source such as</span><br><span class="line">     * &#123;@link HttpHeaders#PROXY_AUTHORIZATION&#125;</span><br><span class="line">     *</span><br><span class="line">     * @param bearerTokenHeaderName the header to check when retrieving the Bearer Token.</span><br><span class="line">     * @since 5.4</span><br><span class="line">     */</span><br><span class="line">    public void setBearerTokenHeaderName(String bearerTokenHeaderName) &#123;</span><br><span class="line">        this.bearerTokenHeaderName = bearerTokenHeaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String resolveFromAuthorizationHeader(HttpServletRequest request) &#123;</span><br><span class="line">        String authorization = request.getHeader(this.bearerTokenHeaderName);</span><br><span class="line">        if (!StringUtils.startsWithIgnoreCase(authorization, &quot;bearer&quot;)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization);</span><br><span class="line">        if (!matcher.matches()) &#123;</span><br><span class="line">            BearerTokenError error = BearerTokenErrors.invalidToken(&quot;Bearer token is malformed&quot;);</span><br><span class="line">            throw new OAuth2AuthenticationException(error);</span><br><span class="line">        &#125;</span><br><span class="line">        return matcher.group(&quot;token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String resolveFromRequestParameters(HttpServletRequest request) &#123;</span><br><span class="line">        String[] values = request.getParameterValues(&quot;access_token&quot;);</span><br><span class="line">        if (values == null || values.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (values.length == 1) &#123;</span><br><span class="line">            return values[0];</span><br><span class="line">        &#125;</span><br><span class="line">        BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);</span><br><span class="line">        throw new OAuth2AuthenticationException(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isParameterTokenSupportedForRequest(final HttpServletRequest request) &#123;</span><br><span class="line">        return ((&quot;POST&quot;.equals(request.getMethod())</span><br><span class="line">                &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED_VALUE.equals(request.getContentType()))</span><br><span class="line">                || &quot;GET&quot;.equals(request.getMethod()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isParameterTokenEnabledForRequest(final HttpServletRequest request) &#123;</span><br><span class="line">        return ((this.allowFormEncodedBodyParameter &amp;&amp; &quot;POST&quot;.equals(request.getMethod())</span><br><span class="line">                &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED_VALUE.equals(request.getContentType()))</span><br><span class="line">                || (this.allowUriQueryParameter &amp;&amp; &quot;GET&quot;.equals(request.getMethod())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建 token key</span><br><span class="line">     * @param token token</span><br><span class="line">     * @return token key</span><br><span class="line">     */</span><br><span class="line">    private String buildKey(String token) &#123;</span><br><span class="line">        return String.format(&quot;%s:%s:%s&quot;, CacheConstants.TOKEN, OAuth2ParameterNames.ACCESS_TOKEN, token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    oauth2:</span><br><span class="line">      resourceserver:</span><br><span class="line">        jwt:</span><br><span class="line">          issuer-uri: http://192.168.1.186:1067</span><br></pre></td></tr></table></figure>



<h2 id="服务引用统一的资源服务器配置："><a href="#服务引用统一的资源服务器配置：" class="headerlink" title="服务引用统一的资源服务器配置："></a>服务引用统一的资源服务器配置：</h2><p>pom:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.luck.sugar&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;luck-common-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HomeController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;test&quot;)</span><br><span class="line">    @PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;)&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p>先到授权服务器获取token</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304403339-c483e02f-5dc0-44ee-ab67-dd137794d4f8.png"></p>
<p>然后在资源服务器中添加key为<font style="color:rgb(33, 33, 33);">Authorization的headers</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304459217-12582e36-cc83-4a25-80db-d973ec10e1c7.png">接着在token后面加数字1</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304562201-a7dc64ca-0218-438a-9a16-003074b4e014.png"></p>
<p>抛出异常An error occurred while attempting to decode the Jwt: Signed JWT rejected: Invalid signature</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在资源服务器的流程中有多个扩展点必须的扩展点为</p>
<p>jwtAuthenticationConverter  他定义了权限信息从jwt的那个Claims下取出，之前的授权服务器中将权限信息放入了authorities 所以上面的的例子定义了权限信息从authorities中获取</p>
<p>BearerTokenResolver：提取令牌</p>
<p>AuthenticationManagerResolver ：获取认证中心，一般使用默认的AuthenticationManager</p>
<p>JwtDecoder：他定义了jwt解析，可以结合jwtAuthenticationConverter 完成从缓存中获取权限信息</p>
<p>AuthenticationProvider：身份验证实现，如果身份验证有特殊处理可以增加</p>
<p>AuthenticationEntryPoint:BearerTokenResolver 获取失败的错误提示处理</p>
<p>AuthenticationFailureHandler: 授权失败错误处理</p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>集成Oauth2.1认证中心</title>
    <url>/2024/03/11/%E9%9B%86%E6%88%90Oauth2.1%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>新版本中的springcloud已经将springcloudoauth2包取消掉，oauth2新增了一个spring-authorization-server的项目，在spring-authorization-server下现在已经有3个可用版本，其中0.3.0对应的是jdk11版本， 0.4.0对应的是jdk8版本，1.0版本对应的是jdk17。以下的实例是以jdk11为例</p>
<span id="more"></span>
<h2 id="建立授权服务"><a href="#建立授权服务" class="headerlink" title="建立授权服务"></a>建立授权服务</h2><p>创建服务的过程这里不做赘述，项目需要的pom文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--jdbc--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;!--auth --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">Spring authorization Server</font><font style="color:rgb(18, 18, 18);">的建表文件在：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org/springframework/security/oauth2/server/authorization/oauth2-authorization-consent-schema.sql</span><br><span class="line"></span><br><span class="line">org/springframework/security/oauth2/server/authorization/oauth2-authorization-schema.sql</span><br><span class="line"></span><br><span class="line">org/springframework/security/oauth2/server/authorization/client/oauth2-registered-client-schema.sql</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">Spring Security</font><font style="color:rgb(18, 18, 18);">的建表语句在</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org/springframework/security/core/userdetails/jdbc/users.ddl</span><br></pre></td></tr></table></figure>

<p>总共5张表，这里放出0.3.0版本的sql其他版本需要自己找一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE oauth2_authorization_consent (</span><br><span class="line">    registered_client_id varchar(100) NOT NULL,</span><br><span class="line">    principal_name varchar(200) NOT NULL,</span><br><span class="line">    authorities varchar(1000) NOT NULL,</span><br><span class="line">    PRIMARY KEY (registered_client_id, principal_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">IMPORTANT:</span><br><span class="line">    If using PostgreSQL, update ALL columns defined with &#x27;blob&#x27; to &#x27;text&#x27;,</span><br><span class="line">    as PostgreSQL does not support the &#x27;blob&#x27; data type.</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE oauth2_authorization (</span><br><span class="line">    id varchar(100) NOT NULL,</span><br><span class="line">    registered_client_id varchar(100) NOT NULL,</span><br><span class="line">    principal_name varchar(200) NOT NULL,</span><br><span class="line">    authorization_grant_type varchar(100) NOT NULL,</span><br><span class="line">    attributes blob DEFAULT NULL,</span><br><span class="line">    state varchar(500) DEFAULT NULL,</span><br><span class="line">    authorization_code_value blob DEFAULT NULL,</span><br><span class="line">    authorization_code_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    authorization_code_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    authorization_code_metadata blob DEFAULT NULL,</span><br><span class="line">    access_token_value blob DEFAULT NULL,</span><br><span class="line">    access_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    access_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    access_token_metadata blob DEFAULT NULL,</span><br><span class="line">    access_token_type varchar(100) DEFAULT NULL,</span><br><span class="line">    access_token_scopes varchar(1000) DEFAULT NULL,</span><br><span class="line">    oidc_id_token_value blob DEFAULT NULL,</span><br><span class="line">    oidc_id_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    oidc_id_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    oidc_id_token_metadata blob DEFAULT NULL,</span><br><span class="line">    refresh_token_value blob DEFAULT NULL,</span><br><span class="line">    refresh_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    refresh_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    refresh_token_metadata blob DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE oauth2_registered_client (</span><br><span class="line">    id varchar(100) NOT NULL,</span><br><span class="line">    client_id varchar(100) NOT NULL,</span><br><span class="line">    client_id_issued_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,</span><br><span class="line">    client_secret varchar(200) DEFAULT NULL,</span><br><span class="line">    client_secret_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    client_name varchar(200) NOT NULL,</span><br><span class="line">    client_authentication_methods varchar(1000) NOT NULL,</span><br><span class="line">    authorization_grant_types varchar(1000) NOT NULL,</span><br><span class="line">    redirect_uris varchar(1000) DEFAULT NULL,</span><br><span class="line">    scopes varchar(1000) NOT NULL,</span><br><span class="line">    client_settings varchar(2000) NOT NULL,</span><br><span class="line">    token_settings varchar(2000) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    username varchar(50)  not null</span><br><span class="line">        primary key,</span><br><span class="line">    password varchar(500) not null,</span><br><span class="line">    enabled  tinyint(1)   not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table authorities</span><br><span class="line">(</span><br><span class="line">    username  varchar(50) not null,</span><br><span class="line">    authority varchar(50) not null,</span><br><span class="line">    constraint ix_auth_username</span><br><span class="line">        unique (username, authority),</span><br><span class="line">    constraint fk_authorities_users</span><br><span class="line">        foreign key (username) references users (username)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1067</span><br><span class="line">spring:</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/oauth2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure>

<h2 id="自定义授权服务器"><a href="#自定义授权服务器" class="headerlink" title="自定义授权服务器"></a>自定义授权服务器</h2><p>在springsecurity5.6以后配置文件为新建Configuration，然后覆盖Bean的形式进行配置，所以这里我们创建配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class AuthorizationServerConfig &#123;</span><br><span class="line">    @Autowired()</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Autowired()</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个Spring security 的过滤器链，默认会配置</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Introspection endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Revocation endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization Server Metadata endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * JWK Set endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 Provider Configuration endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 UserInfo endpoint</span><br><span class="line">     * 这些协议端点，只有配置了他才能够访问的到接口地址（类似mvc的controller）。</span><br><span class="line">     *</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(1)</span><br><span class="line">    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);</span><br><span class="line">        http</span><br><span class="line">                // Redirect to the login page when not authenticated from the</span><br><span class="line">                // authorization endpoint</span><br><span class="line">                .exceptionHandling((exceptions) -&gt; exceptions</span><br><span class="line">                        .authenticationEntryPoint(</span><br><span class="line">                                new LoginUrlAuthenticationEntryPoint(&quot;/login&quot;))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个也是个Spring Security的过滤器链，用于Spring Security的身份认证。</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(2)</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                // Form login handles the redirect to the login page from the</span><br><span class="line">                // authorization server filter chain</span><br><span class="line">                .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置用户信息，或者配置用户数据来源，主要用于用户的检索。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">//        UserDetails userDetails = User.withDefaultPasswordEncoder()</span><br><span class="line">//                .username(&quot;user&quot;)</span><br><span class="line">//                .password(&quot;password&quot;)</span><br><span class="line">//                .roles(&quot;USER&quot;)</span><br><span class="line">//                .build();</span><br><span class="line">//       return new InMemoryUserDetailsManager();</span><br><span class="line"></span><br><span class="line">        return new JdbcUserDetailsManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * oauth2 用于第三方认证，RegisteredClientRepository 主要用于管理第三方（每个第三方就是一个客户端）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RegisteredClientRepository registeredClientRepository() &#123;</span><br><span class="line">//        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">//                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">//                .clientSecret(&quot;&#123;noop&#125;secret&quot;)</span><br><span class="line">//                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/authorized&quot;)</span><br><span class="line">//                .scope(OidcScopes.OPENID)</span><br><span class="line">//                .scope(&quot;message.read&quot;)</span><br><span class="line">//                .scope(&quot;message.write&quot;)</span><br><span class="line">//                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">//                .build();</span><br><span class="line">//</span><br><span class="line">//        return new InMemoryRegisteredClientRepository(registeredClient);</span><br><span class="line">        return new JdbcRegisteredClientRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于给access_token签名使用。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JWKSource&lt;SecurityContext&gt; jwkSource() &#123;</span><br><span class="line">        KeyPair keyPair = generateRsaKey();</span><br><span class="line">        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        RSAKey rsaKey = new RSAKey.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        JWKSet jwkSet = new JWKSet(rsaKey);</span><br><span class="line">        return new ImmutableJWKSet&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成秘钥对，为jwkSource提供服务。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static KeyPair generateRsaKey() &#123;</span><br><span class="line">        KeyPair keyPair;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            keyPairGenerator.initialize(2048);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationService authorizationService() &#123;</span><br><span class="line">        return new JdbcOAuth2AuthorizationService(jdbcTemplate, registeredClientRepository());</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationConsentService authorizationConsentService() &#123;</span><br><span class="line">        return new JdbcOAuth2AuthorizationConsentService(jdbcTemplate, registeredClientRepository());</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 配置Authorization Server实例</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ProviderSettings providerSettings() &#123;</span><br><span class="line">        return ProviderSettings.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在spring-authorization-server中实现了jdbc模式的可以直接链接数据库进行操作</p>
<h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsManager userDetailsManager;</span><br><span class="line">  @Test</span><br><span class="line">void testSaveUser() &#123;</span><br><span class="line">        UserDetails userDetails = User.builder().passwordEncoder(s -&gt; &quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(s))</span><br><span class="line">                .username(&quot;user&quot;)</span><br><span class="line">                .password(&quot;password&quot;)</span><br><span class="line">                .roles(&quot;ADMIN&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        userDetailsManager.createUser(userDetails);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 UserDetailsManager 创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private RegisteredClientRepository registeredClientRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">    void testSaveClient() &#123;</span><br><span class="line">        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">                .clientSecret(&quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(&quot;secret&quot;))</span><br><span class="line">                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">                .redirectUri(&quot;http://127.0.0.1:1069/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">                .redirectUri(&quot;http://127.0.0.1:1069/authorized&quot;)</span><br><span class="line">                .scope(OidcScopes.OPENID).scope(&quot;message.read&quot;)</span><br><span class="line">                .scope(&quot;message.write&quot;)</span><br><span class="line">                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">                .build();</span><br><span class="line">        registeredClientRepository.save(registeredClient);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以registeredClientRepository创建客户端</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开：<a href="http://127.0.0.1:1067/oauth2/authorize?response_type=code&client_id=messaging-client&scope=message.read&redirect_uri=http://127.0.0.1:1067/authorized">http://127.0.0.1:1067/oauth2/authorize?response_type&#x3D;code&amp;client_id&#x3D;messaging-client&amp;scope&#x3D;message.read&amp;redirect_uri&#x3D;http://127.0.0.1:1067/authorized</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678243822906-ab077efe-c963-4e24-a89d-e5fc2beb53e8.png"></p>
<p>输入前面的添加的账号密码</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678243858497-5b68bed5-2d79-48fb-9209-c2e3639c258b.png"></p>
<p>报错了，不过没关系。因为在oath2中第一步是拿到code 拿到code之后才能换取token</p>
<p>我们只要拿到地址栏后面的code信息就好。复制出code信息，打开postman进行post请求</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244026029-0c3c4817-9483-481e-9899-69e8fb636d3b.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244264220-25530875-31db-4c3d-bd62-a4b910934a98.png"></p>
<p>点击访问</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244286055-479c09a7-92be-4354-9e80-831a3295a893.png"></p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义密码模式</title>
    <url>/2024/03/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679106524585-028d887a-7d9d-4e18-af56-f2bcdc192049.png"></p>
<p>在官方的说明中我们可以看到OAuth 2.1 废弃了 OAuth 2.0 中的密码模式，只提供了三种授权类型：授权码、刷新令牌、客户端凭证。</p>
<span id="more"></span>
<p>oauth2.1中授权码模式的流程为：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/jpeg/25873401/1679108178925-bf9d2710-85d2-45f0-a277-cfe3fe0595a5.jpeg" alt="画板"></p>
<p>由上图可知我们想要沿用密码模式会有两种方案</p>
<p>1.自定义密码模式   </p>
<p>2.修改授权码模式，自定义授权页面，使用授权页面自动提交获取token。</p>
<h2 id="自定义密码模式："><a href="#自定义密码模式：" class="headerlink" title="自定义密码模式："></a>自定义密码模式：</h2><p>在官网中对自定义配置的描述<img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109031954-9f6a10bf-a4a8-4c0b-9bee-229c07ae5844.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109044969-a5836447-2dc8-4a6c-b58b-dcad2c8d05f7.png"></p>
<p>这里可以看到在授权断点是可以实现自定义的，于是就有了接下来的思路：</p>
<p>直接略过前面的密码验证、用户确认， 直接自定义授权端点。在自定义的端点中处理授权信息，打开</p>
<p>7 <font style="color:rgb(25, 30, 30);">authorizationEndpoint</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109474910-3209f835-9aba-42bd-b42e-4a60b946d3b3.png"></p>
<p>这里可以看到自定义一个oauth2的授权请求需要定义一个处理器 一个主处理器，但是官方并没有给具体的例子所以需要看下其他授权端点的做法来完成自定义，以code授权的源码为例分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class OAuth2AuthorizationCodeAuthenticationConverter implements AuthenticationConverter &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	@Override</span><br><span class="line">	public Authentication convert(HttpServletRequest request) &#123;</span><br><span class="line">		// grant_type (REQUIRED)</span><br><span class="line">		String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE);</span><br><span class="line">		if (!AuthorizationGrantType.AUTHORIZATION_CODE.getValue().equals(grantType)) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">		MultiValueMap&lt;String, String&gt; parameters = OAuth2EndpointUtils.getParameters(request);</span><br><span class="line"></span><br><span class="line">		// code (REQUIRED)</span><br><span class="line">		String code = parameters.getFirst(OAuth2ParameterNames.CODE);</span><br><span class="line">		if (!StringUtils.hasText(code) ||</span><br><span class="line">				parameters.get(OAuth2ParameterNames.CODE).size() != 1) &#123;</span><br><span class="line">			OAuth2EndpointUtils.throwError(</span><br><span class="line">					OAuth2ErrorCodes.INVALID_REQUEST,</span><br><span class="line">					OAuth2ParameterNames.CODE,</span><br><span class="line">					OAuth2EndpointUtils.ACCESS_TOKEN_REQUEST_ERROR_URI);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// redirect_uri (REQUIRED)</span><br><span class="line">		// Required only if the &quot;redirect_uri&quot; parameter was included in the authorization request</span><br><span class="line">		String redirectUri = parameters.getFirst(OAuth2ParameterNames.REDIRECT_URI);</span><br><span class="line">		if (StringUtils.hasText(redirectUri) &amp;&amp;</span><br><span class="line">				parameters.get(OAuth2ParameterNames.REDIRECT_URI).size() != 1) &#123;</span><br><span class="line">			OAuth2EndpointUtils.throwError(</span><br><span class="line">					OAuth2ErrorCodes.INVALID_REQUEST,</span><br><span class="line">					OAuth2ParameterNames.REDIRECT_URI,</span><br><span class="line">					OAuth2EndpointUtils.ACCESS_TOKEN_REQUEST_ERROR_URI);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">		parameters.forEach((key, value) -&gt; &#123;</span><br><span class="line">			if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.CLIENT_ID) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.CODE) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.REDIRECT_URI)) &#123;</span><br><span class="line">				additionalParameters.put(key, value.get(0));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		return new OAuth2AuthorizationCodeAuthenticationToken(</span><br><span class="line">				code, clientPrincipal, redirectUri, additionalParameters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里可以看出Converter的主要作用是对参数整理然后生成一个新得OAuth2AuthorizationCodeAuthenticationToken 对象，接着看下OAuth2AuthorizationCodeAuthenticationToken的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2AuthorizationCodeAuthenticationToken extends OAuth2AuthorizationGrantAuthenticationToken &#123;</span><br><span class="line">	private final String code;</span><br><span class="line">	private final String redirectUri;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Constructs an &#123;@code OAuth2AuthorizationCodeAuthenticationToken&#125; using the provided parameters.</span><br><span class="line">	 *</span><br><span class="line">	 * @param code the authorization code</span><br><span class="line">	 * @param clientPrincipal the authenticated client principal</span><br><span class="line">	 * @param redirectUri the redirect uri</span><br><span class="line">	 * @param additionalParameters the additional parameters</span><br><span class="line">	 */</span><br><span class="line">	public OAuth2AuthorizationCodeAuthenticationToken(String code, Authentication clientPrincipal,</span><br><span class="line">			@Nullable String redirectUri, @Nullable Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">		super(AuthorizationGrantType.AUTHORIZATION_CODE, clientPrincipal, additionalParameters);</span><br><span class="line">		Assert.hasText(code, &quot;code cannot be empty&quot;);</span><br><span class="line">		this.code = code;</span><br><span class="line">		this.redirectUri = redirectUri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Returns the authorization code.</span><br><span class="line">	 *</span><br><span class="line">	 * @return the authorization code</span><br><span class="line">	 */</span><br><span class="line">	public String getCode() &#123;</span><br><span class="line">		return this.code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Returns the redirect uri.</span><br><span class="line">	 *</span><br><span class="line">	 * @return the redirect uri</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	public String getRedirectUri() &#123;</span><br><span class="line">		return this.redirectUri;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是保存参数对象的。</p>
<p>接着再看下主处理的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class OAuth2AuthorizationCodeAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">	private static final String ERROR_URI = &quot;https://datatracker.ietf.org/doc/html/rfc6749#section-5.2&quot;;</span><br><span class="line">	private static final OAuth2TokenType AUTHORIZATION_CODE_TOKEN_TYPE =</span><br><span class="line">			new OAuth2TokenType(OAuth2ParameterNames.CODE);</span><br><span class="line">	private static final OAuth2TokenType ID_TOKEN_TOKEN_TYPE =</span><br><span class="line">			new OAuth2TokenType(OidcParameterNames.ID_TOKEN);</span><br><span class="line">	private final OAuth2AuthorizationService authorizationService;</span><br><span class="line">	private final OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Constructs an &#123;@code OAuth2AuthorizationCodeAuthenticationProvider&#125; using the provided parameters.</span><br><span class="line">	 *</span><br><span class="line">	 * @param authorizationService the authorization service</span><br><span class="line">	 * @param tokenGenerator the token generator</span><br><span class="line">	 * @since 0.2.3</span><br><span class="line">	 */</span><br><span class="line">	public OAuth2AuthorizationCodeAuthenticationProvider(OAuth2AuthorizationService authorizationService,</span><br><span class="line">			OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator) &#123;</span><br><span class="line">		Assert.notNull(authorizationService, &quot;authorizationService cannot be null&quot;);</span><br><span class="line">		Assert.notNull(tokenGenerator, &quot;tokenGenerator cannot be null&quot;);</span><br><span class="line">		this.authorizationService = authorizationService;</span><br><span class="line">		this.tokenGenerator = tokenGenerator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">		OAuth2AuthorizationCodeAuthenticationToken authorizationCodeAuthentication =</span><br><span class="line">				(OAuth2AuthorizationCodeAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">		OAuth2ClientAuthenticationToken clientPrincipal =</span><br><span class="line">				getAuthenticatedClientElseThrowInvalidClient(authorizationCodeAuthentication);</span><br><span class="line">		RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();</span><br><span class="line"></span><br><span class="line">		OAuth2Authorization authorization = this.authorizationService.findByToken(</span><br><span class="line">				authorizationCodeAuthentication.getCode(), AUTHORIZATION_CODE_TOKEN_TYPE);</span><br><span class="line">		if (authorization == null) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line">		OAuth2Authorization.Token&lt;OAuth2AuthorizationCode&gt; authorizationCode =</span><br><span class="line">				authorization.getToken(OAuth2AuthorizationCode.class);</span><br><span class="line"></span><br><span class="line">		OAuth2AuthorizationRequest authorizationRequest = authorization.getAttribute(</span><br><span class="line">				OAuth2AuthorizationRequest.class.getName());</span><br><span class="line"></span><br><span class="line">		if (!registeredClient.getClientId().equals(authorizationRequest.getClientId())) &#123;</span><br><span class="line">			if (!authorizationCode.isInvalidated()) &#123;</span><br><span class="line">				// Invalidate the authorization code given that a different client is attempting to use it</span><br><span class="line">				authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());</span><br><span class="line">				this.authorizationService.save(authorization);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (StringUtils.hasText(authorizationRequest.getRedirectUri()) &amp;&amp;</span><br><span class="line">				!authorizationRequest.getRedirectUri().equals(authorizationCodeAuthentication.getRedirectUri())) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!authorizationCode.isActive()) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// @formatter:off</span><br><span class="line">		DefaultOAuth2TokenContext.Builder tokenContextBuilder = DefaultOAuth2TokenContext.builder()</span><br><span class="line">				.registeredClient(registeredClient)</span><br><span class="line">				.principal(authorization.getAttribute(Principal.class.getName()))</span><br><span class="line">				.providerContext(ProviderContextHolder.getProviderContext())</span><br><span class="line">				.authorization(authorization)</span><br><span class="line">				.authorizedScopes(authorization.getAttribute(OAuth2Authorization.AUTHORIZED_SCOPE_ATTRIBUTE_NAME))</span><br><span class="line">				.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">				.authorizationGrant(authorizationCodeAuthentication);</span><br><span class="line">		// @formatter:on</span><br><span class="line"></span><br><span class="line">		OAuth2Authorization.Builder authorizationBuilder = OAuth2Authorization.from(authorization);</span><br><span class="line"></span><br><span class="line">		// ----- Access token -----</span><br><span class="line">		OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();</span><br><span class="line">		OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">		if (generatedAccessToken == null) &#123;</span><br><span class="line">			OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">					&quot;The token generator failed to generate the access token.&quot;, ERROR_URI);</span><br><span class="line">			throw new OAuth2AuthenticationException(error);</span><br><span class="line">		&#125;</span><br><span class="line">		OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,</span><br><span class="line">				generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),</span><br><span class="line">				generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());</span><br><span class="line">		if (generatedAccessToken instanceof ClaimAccessor) &#123;</span><br><span class="line">			authorizationBuilder.token(accessToken, (metadata) -&gt;</span><br><span class="line">					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, ((ClaimAccessor) generatedAccessToken).getClaims()));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			authorizationBuilder.accessToken(accessToken);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// ----- Refresh token -----</span><br><span class="line">		OAuth2RefreshToken refreshToken = null;</span><br><span class="line">		if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &amp;&amp;</span><br><span class="line">				// Do not issue refresh token to public client</span><br><span class="line">				!clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) &#123;</span><br><span class="line"></span><br><span class="line">			tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();</span><br><span class="line">			OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">			if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) &#123;</span><br><span class="line">				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">						&quot;The token generator failed to generate the refresh token.&quot;, ERROR_URI);</span><br><span class="line">				throw new OAuth2AuthenticationException(error);</span><br><span class="line">			&#125;</span><br><span class="line">			refreshToken = (OAuth2RefreshToken) generatedRefreshToken;</span><br><span class="line">			authorizationBuilder.refreshToken(refreshToken);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// ----- ID token -----</span><br><span class="line">		OidcIdToken idToken;</span><br><span class="line">		if (authorizationRequest.getScopes().contains(OidcScopes.OPENID)) &#123;</span><br><span class="line">			tokenContext = tokenContextBuilder.tokenType(ID_TOKEN_TOKEN_TYPE).build();</span><br><span class="line">			OAuth2Token generatedIdToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">			if (!(generatedIdToken instanceof Jwt)) &#123;</span><br><span class="line">				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">						&quot;The token generator failed to generate the ID token.&quot;, ERROR_URI);</span><br><span class="line">				throw new OAuth2AuthenticationException(error);</span><br><span class="line">			&#125;</span><br><span class="line">			idToken = new OidcIdToken(generatedIdToken.getTokenValue(), generatedIdToken.getIssuedAt(),</span><br><span class="line">					generatedIdToken.getExpiresAt(), ((Jwt) generatedIdToken).getClaims());</span><br><span class="line">			authorizationBuilder.token(idToken, (metadata) -&gt;</span><br><span class="line">					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, idToken.getClaims()));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			idToken = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		authorization = authorizationBuilder.build();</span><br><span class="line"></span><br><span class="line">		// Invalidate the authorization code as it can only be used once</span><br><span class="line">		authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());</span><br><span class="line"></span><br><span class="line">		this.authorizationService.save(authorization);</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; additionalParameters = Collections.emptyMap();</span><br><span class="line">		if (idToken != null) &#123;</span><br><span class="line">			additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">			additionalParameters.put(OidcParameterNames.ID_TOKEN, idToken.getTokenValue());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return new OAuth2AccessTokenAuthenticationToken(</span><br><span class="line">				registeredClient, clientPrincipal, accessToken, refreshToken, additionalParameters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">		return OAuth2AuthorizationCodeAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到token的生成详细信息。</p>
<h3 id="自定义授权扩展"><a href="#自定义授权扩展" class="headerlink" title="自定义授权扩展"></a>自定义授权扩展</h3><p>以此为参展自定义一个模式总共需要三个类</p>
<p>OAuth2PasswordAuthenticationConverter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationConverter  implements AuthenticationConverter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication convert(HttpServletRequest request) &#123;</span><br><span class="line">        // grant_type (REQUIRED)</span><br><span class="line">        String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE);</span><br><span class="line">        if (!AuthorizationGrantType.PASSWORD.getValue().equals(grantType)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, String&gt; parameters = getParameters(request);</span><br><span class="line"></span><br><span class="line">        // username (REQUIRED)</span><br><span class="line">        String username = parameters.getFirst(OAuth2ParameterNames.USERNAME);</span><br><span class="line">        if (StrUtil.isEmpty(username) ||</span><br><span class="line">                parameters.get(OAuth2ParameterNames.USERNAME).size() != 1) &#123;</span><br><span class="line">            throw new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_NOT_EXIST, &quot;username cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // password (REQUIRED)</span><br><span class="line">        String password = parameters.getFirst(OAuth2ParameterNames.PASSWORD);</span><br><span class="line">        if (StrUtil.isEmpty(password) ||</span><br><span class="line">                parameters.get(OAuth2ParameterNames.PASSWORD).size() != 1) &#123;</span><br><span class="line">            throw new LuckOAuth2AuthencticationException(ResponseStatusEnum.PASSWORD_INCORRECT, &quot;password cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">        parameters.forEach((key, value) -&gt; &#123;</span><br><span class="line">            if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) &amp;&amp;</span><br><span class="line">                    !key.equals(OAuth2ParameterNames.USERNAME) &amp;&amp;</span><br><span class="line">                    !key.equals(OAuth2ParameterNames.PASSWORD)) &#123;</span><br><span class="line">                additionalParameters.put(key, value.get(0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return new OAuth2PasswordAuthenticationToken(username, password, clientPrincipal, additionalParameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MultiValueMap&lt;String, String&gt; getParameters(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; parameters = new LinkedMultiValueMap&lt;&gt;(parameterMap.size());</span><br><span class="line">        parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line">            if (values.length &gt; 0) &#123;</span><br><span class="line">                for (String value : values) &#123;</span><br><span class="line">                    parameters.add(key, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OAuth2PasswordAuthenticationToken</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationToken extends OAuth2AuthorizationGrantAuthenticationToken &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private final String username;</span><br><span class="line">    @Getter</span><br><span class="line">    private final String password;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &#123;@code OAuth2PasswordAuthenticationToken&#125; using the provided parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param username             the username</span><br><span class="line">     * @param password             the password</span><br><span class="line">     * @param clientPrincipal      the authenticated client principal</span><br><span class="line">     * @param additionalParameters the additional parameters</span><br><span class="line">     */</span><br><span class="line">    public OAuth2PasswordAuthenticationToken(String username, String password, Authentication clientPrincipal,</span><br><span class="line">                                                Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">        super(AuthorizationGrantType.PASSWORD, clientPrincipal, additionalParameters);</span><br><span class="line">        Assert.hasText(username, &quot;username cannot be empty&quot;);</span><br><span class="line">        Assert.hasText(password, &quot;password cannot be empty&quot;);</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OAuth2PasswordAuthenticationProvider</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">    private static final String ERROR_URI = &quot;https://datatracker.ietf.org/doc/html/rfc6749#section-5.2&quot;;</span><br><span class="line">    private final AuthenticationManager authenticationManager;</span><br><span class="line">    private final OAuth2AuthorizationService authorizationService;</span><br><span class="line">    private final OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &#123;@code OAuth2PasswordAuthenticationProvider&#125; using the provided parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param authorizationService the authorization service</span><br><span class="line">     * @param tokenGenerator       the token generator</span><br><span class="line">     */</span><br><span class="line">    public OAuth2PasswordAuthenticationProvider(AuthenticationManager authenticationManager,</span><br><span class="line">                                                OAuth2AuthorizationService authorizationService,</span><br><span class="line">                                                OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator) &#123;</span><br><span class="line">        Assert.notNull(authenticationManager, &quot;authenticationManager cannot be null&quot;);</span><br><span class="line">        Assert.notNull(authorizationService, &quot;authorizationService cannot be null&quot;);</span><br><span class="line">        Assert.notNull(tokenGenerator, &quot;tokenGenerator cannot be null&quot;);</span><br><span class="line">        this.authenticationManager = authenticationManager;</span><br><span class="line">        this.authorizationService = authorizationService;</span><br><span class="line">        this.tokenGenerator = tokenGenerator;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">        OAuth2PasswordAuthenticationToken passwordAuthentication = (OAuth2PasswordAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">        OAuth2ClientAuthenticationToken clientPrincipal = getAuthenticatedClientElseThrowInvalidClient(passwordAuthentication);</span><br><span class="line">        RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();</span><br><span class="line">        Assert.notNull(registeredClient, &quot;registeredClient cannot be null&quot;);</span><br><span class="line"></span><br><span class="line">        if (!registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.PASSWORD)) &#123;</span><br><span class="line">            throw new OAuth2AuthenticationException(OAuth2ErrorCodes.UNAUTHORIZED_CLIENT);</span><br><span class="line">        &#125;</span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;Retrieved registered client&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Attempts to authenticate the passwordAuthentication</span><br><span class="line">        Authentication authenticate = authenticate(passwordAuthentication);</span><br><span class="line"></span><br><span class="line">        DefaultOAuth2TokenContext.Builder tokenContextBuilder = getTokenContextBuilder(passwordAuthentication,</span><br><span class="line">                registeredClient, authenticate);</span><br><span class="line"></span><br><span class="line">        OAuth2Authorization.Builder authorizationBuilder = getAuthorizationBuilder(passwordAuthentication,</span><br><span class="line">                registeredClient);</span><br><span class="line"></span><br><span class="line">        OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();</span><br><span class="line"></span><br><span class="line">        // ----- Access token -----</span><br><span class="line">        OAuth2AccessToken accessToken = getAccessToken(authorizationBuilder, tokenContext);</span><br><span class="line"></span><br><span class="line">        // ----- Refresh token -----</span><br><span class="line">        OAuth2RefreshToken refreshToken = getRefreshToken(clientPrincipal, registeredClient, tokenContextBuilder, authorizationBuilder);</span><br><span class="line"></span><br><span class="line">        return new OAuth2AccessTokenAuthenticationToken(</span><br><span class="line">                registeredClient, clientPrincipal, accessToken, refreshToken, passwordAuthentication.getAdditionalParameters());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Authentication authenticate(OAuth2PasswordAuthenticationToken passwordAuthentication) &#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken token =</span><br><span class="line">                new UsernamePasswordAuthenticationToken(passwordAuthentication.getUsername(),</span><br><span class="line">                        passwordAuthentication.getPassword());</span><br><span class="line">        Authentication authenticate;</span><br><span class="line">        try &#123;</span><br><span class="line">            authenticate = authenticationManager.authenticate(token);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw oAuth2AuthenticationException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return authenticate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static DefaultOAuth2TokenContext.Builder getTokenContextBuilder(</span><br><span class="line">            OAuth2PasswordAuthenticationToken passwordAuthentication,</span><br><span class="line">            RegisteredClient registeredClient,</span><br><span class="line">            Authentication authenticate) &#123;</span><br><span class="line">        return DefaultOAuth2TokenContext.builder()</span><br><span class="line">                .registeredClient(registeredClient)</span><br><span class="line">                .principal(authenticate)</span><br><span class="line">                .providerContext(ProviderContextHolder.getProviderContext())</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.PASSWORD)</span><br><span class="line">                .authorizationGrant(passwordAuthentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static OAuth2Authorization.Builder getAuthorizationBuilder(</span><br><span class="line">            OAuth2PasswordAuthenticationToken passwordAuthentication,</span><br><span class="line">            RegisteredClient registeredClient) &#123;</span><br><span class="line">        return OAuth2Authorization.withRegisteredClient(registeredClient)</span><br><span class="line">                .principalName(passwordAuthentication.getName())</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OAuth2AccessToken getAccessToken(OAuth2Authorization.Builder authorizationBuilder,</span><br><span class="line">                                             OAuth2TokenContext tokenContext) &#123;</span><br><span class="line">        OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">        if (generatedAccessToken == null) &#123;</span><br><span class="line">            OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">                    &quot;The token generator failed to generate the access token.&quot;, ERROR_URI);</span><br><span class="line">            throw new OAuth2AuthenticationException(error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;Generated access token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,</span><br><span class="line">                generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),</span><br><span class="line">                generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());</span><br><span class="line">        if (generatedAccessToken instanceof ClaimAccessor) &#123;</span><br><span class="line">            authorizationBuilder.token(accessToken, (metadata) -&gt;</span><br><span class="line">                    metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME,</span><br><span class="line">                            ((ClaimAccessor) generatedAccessToken).getClaims()));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            authorizationBuilder.accessToken(accessToken);</span><br><span class="line">        &#125;</span><br><span class="line">        return accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OAuth2RefreshToken getRefreshToken(OAuth2ClientAuthenticationToken clientPrincipal,</span><br><span class="line">                                               RegisteredClient registeredClient,</span><br><span class="line">                                               DefaultOAuth2TokenContext.Builder tokenContextBuilder,</span><br><span class="line">                                               OAuth2Authorization.Builder authorizationBuilder) &#123;</span><br><span class="line">        OAuth2TokenContext tokenContext;</span><br><span class="line">        OAuth2RefreshToken refreshToken = null;</span><br><span class="line">        if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &amp;&amp;</span><br><span class="line">                // Do not issue refresh token to public client</span><br><span class="line">                !clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) &#123;</span><br><span class="line"></span><br><span class="line">            tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();</span><br><span class="line">            OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">            if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) &#123;</span><br><span class="line">                OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">                        &quot;The token generator failed to generate the refresh token.&quot;,ERROR_URI);</span><br><span class="line">                throw new OAuth2AuthenticationException(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Generated refresh token&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            refreshToken = (OAuth2RefreshToken) generatedRefreshToken;</span><br><span class="line">            authorizationBuilder.refreshToken(refreshToken);</span><br><span class="line"></span><br><span class="line">            this.authorizationService.save(authorizationBuilder.build());</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Saved authorization&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">        return OAuth2PasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * OAuth2 认证失败处理器只能处理 OAuth2AuthenticationException，故转换</span><br><span class="line">     *</span><br><span class="line">     * @param authenticationException 身份验证异常</span><br><span class="line">     * @return &#123;@link OAuth2AuthenticationException&#125;</span><br><span class="line">     */</span><br><span class="line">    private OAuth2AuthenticationException oAuth2AuthenticationException(Exception authenticationException) &#123;</span><br><span class="line">        if (authenticationException instanceof UsernameNotFoundException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof BadCredentialsException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.USERNAME_OR_PASSWORD_INCORRECT);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof LockedException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_FROZEN);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof AccountExpiredException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_EXPIRED);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof CredentialsExpiredException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.PASSWORD_EXPIRED);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof InternalAuthenticationServiceException) &#123;</span><br><span class="line">            if (authenticationException.getCause() instanceof DisabledException) &#123;</span><br><span class="line">                return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_DISABLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new LuckOAuth2AuthencticationException(ResponseStatusEnum.IDENTITY_VERIFICATION_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">    public OAuth2ClientAuthenticationToken getAuthenticatedClientElseThrowInvalidClient(Authentication authentication) &#123;</span><br><span class="line">        OAuth2ClientAuthenticationToken clientPrincipal = null;</span><br><span class="line">        if (OAuth2ClientAuthenticationToken.class.isAssignableFrom(authentication.getPrincipal().getClass())) &#123;</span><br><span class="line">            clientPrincipal = (OAuth2ClientAuthenticationToken) authentication.getPrincipal();</span><br><span class="line">        &#125;</span><br><span class="line">        if (clientPrincipal != null &amp;&amp; clientPrincipal.isAuthenticated()) &#123;</span><br><span class="line">            return clientPrincipal;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_CLIENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果需要自定义claims可以添加一个自定义OAuth2TokenCustomizer</p>
<p>这里以OAuth2TokenCustomizerImpl为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class OAuth2TokenCustomizerImpl implements OAuth2TokenCustomizer&lt;JwtEncodingContext&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void customize(JwtEncodingContext context) &#123;</span><br><span class="line">        JwtClaimsSet.Builder builder = context.getClaims();</span><br><span class="line"></span><br><span class="line">        // 客户端模式不返回具体用户信息</span><br><span class="line">        if (SecurityConstants.CLIENT_CREDENTIALS.equals(context.getAuthorizationGrantType().getValue())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User user = (User) context.getPrincipal().getPrincipal();</span><br><span class="line">        builder.claims((claims) -&gt; &#123;</span><br><span class="line">            claims.put(&quot;username&quot;, user.getUsername());</span><br><span class="line">            claims.put(&quot;authorities&quot;, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toArray());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>自定义鉴权成功或者鉴权失败代码可以参照</p>
<p>DefaultAuthenticationFailureHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAuthenticationFailureHandler implements AuthenticationFailureHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String AUTHENTICATION_METHOD = &quot;authentication_method&quot;;</span><br><span class="line">    private static final String CREDENTIALS = &quot;credentials&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123;</span><br><span class="line">        AjaxResult&lt;?&gt; error = createError(exception);</span><br><span class="line"></span><br><span class="line">            ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(error, servletServerHttpResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 创建 error</span><br><span class="line">         *</span><br><span class="line">         * @param exception /</span><br><span class="line">         * @return /</span><br><span class="line">         */</span><br><span class="line">        private AjaxResult&lt;?&gt; createError(AuthenticationException exception) &#123;</span><br><span class="line">            AjaxResult&lt;?&gt; error = null;</span><br><span class="line"></span><br><span class="line">            if (exception instanceof LuckOAuth2AuthencticationException) &#123;</span><br><span class="line">                error = AjaxResult.error(((LuckOAuth2AuthencticationException) exception).getCode(),</span><br><span class="line">                        exception.getMessage());</span><br><span class="line">            &#125; else if (exception instanceof OAuth2AuthenticationException) &#123;</span><br><span class="line">                OAuth2AuthenticationException oAuth2AuthenticationException= (OAuth2AuthenticationException) exception;</span><br><span class="line">                String errorCode = oAuth2AuthenticationException.getError().getErrorCode();</span><br><span class="line">                String description = oAuth2AuthenticationException.getError().getDescription();</span><br><span class="line">                if (OAuth2ErrorCodes.INVALID_CLIENT.equals(errorCode))&#123;</span><br><span class="line">                    if (StrUtil.isEmpty(description)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, &quot;无效的客户端&quot;);</span><br><span class="line">                    &#125; else if (description.contains(OAuth2ParameterNames.CLIENT_ID)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_NOT_EXIST);</span><br><span class="line">                    &#125; else if (description.contains(AUTHENTICATION_METHOD)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.AUTHORIZATION_DENIED);</span><br><span class="line">                    &#125; else if (description.contains(CREDENTIALS)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_PASSWORD_EMPTY);</span><br><span class="line">                    &#125; else if (description.contains(OAuth2ParameterNames.CLIENT_SECRET)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_PASSWORD_INCORRECT);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                switch (errorCode) &#123;</span><br><span class="line">                    case OAuth2ErrorCodes.UNSUPPORTED_GRANT_TYPE :</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.UNSUPPORTED_GRANT_TYPE);</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_REQUEST : &#123;</span><br><span class="line">                        if (StrUtil.isEmpty(description)) &#123;</span><br><span class="line">                            return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, &quot;无效的客户端&quot;);</span><br><span class="line">                        &#125; else if (description.contains(OAuth2ParameterNames.GRANT_TYPE)) &#123;</span><br><span class="line">                            return AjaxResult.error(ResponseStatusEnum.GRANT_TYPE_EMPTY);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_GRANT : return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT);</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_SCOPE : return AjaxResult.error(ResponseStatusEnum.INVALID_SCOPE);</span><br><span class="line">                    case OAuth2ErrorCodes.UNAUTHORIZED_CLIENT :</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED_CLIENT);</span><br><span class="line">                    default : error = AjaxResult.error(ResponseStatusEnum.USER_LOGIN_ABNORMAL.getCode(),</span><br><span class="line">                            oAuth2AuthenticationException.getError().getErrorCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error = AjaxResult.error(ResponseStatusEnum.USER_LOGIN_ABNORMAL, exception.getLocalizedMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DefaultAuthenticationSuccessHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定响应数据不使用 ResponseData 封装的参数名称</span><br><span class="line">     * Swagger 登录时可用</span><br><span class="line">     */</span><br><span class="line">    private static final String NO_RESPONSE_DATA_PARAM_NAME = &quot;no_response_data&quot;;</span><br><span class="line"></span><br><span class="line">    private final Converter&lt;OAuth2AccessTokenResponse, Map&lt;String, Object&gt;&gt; accessTokenResponseParametersConverter =</span><br><span class="line">            new DefaultOAuth2AccessTokenResponseMapConverter();</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">        OAuth2AccessTokenAuthenticationToken accessTokenAuthentication = (OAuth2AccessTokenAuthenticationToken) authentication;</span><br><span class="line">        OAuth2AccessToken accessToken = accessTokenAuthentication.getAccessToken();</span><br><span class="line">        OAuth2RefreshToken refreshToken = accessTokenAuthentication.getRefreshToken();</span><br><span class="line">        Map&lt;String, Object&gt; additionalParameters = accessTokenAuthentication.getAdditionalParameters();</span><br><span class="line">        OAuth2AccessTokenResponse.Builder builder = OAuth2AccessTokenResponse.withToken(accessToken.getTokenValue())</span><br><span class="line">                .tokenType(accessToken.getTokenType()).scopes(accessToken.getScopes());</span><br><span class="line">        if (accessToken.getIssuedAt() != null &amp;&amp; accessToken.getExpiresAt() != null) &#123;</span><br><span class="line">            builder.expiresIn(ChronoUnit.SECONDS.between(accessToken.getIssuedAt(), accessToken.getExpiresAt()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (refreshToken != null) &#123;</span><br><span class="line">            builder.refreshToken(refreshToken.getTokenValue());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!CollectionUtils.isEmpty(additionalParameters)) &#123;</span><br><span class="line">            builder.additionalParameters(additionalParameters);</span><br><span class="line">        &#125;</span><br><span class="line">        OAuth2AccessTokenResponse accessTokenResponse = builder.build();</span><br><span class="line">        Map&lt;String, Object&gt; tokenResponseParameters = this.accessTokenResponseParametersConverter.convert(accessTokenResponse);</span><br><span class="line">        ServletServerHttpResponse httpResponse = new ServletServerHttpResponse(response);</span><br><span class="line"></span><br><span class="line">        boolean noResponseData = Boolean.parseBoolean(request.getParameter(NO_RESPONSE_DATA_PARAM_NAME));</span><br><span class="line">        if (noResponseData) &#123;</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(tokenResponseParameters, httpResponse);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AjaxResult&lt;Map&lt;String, Object&gt;&gt; responseData = AjaxResult.ok(tokenResponseParameters);</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(responseData, httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然如果你需要自定义获取用户信息重写UserDetailsService，和其他版本的一致就好</p>
<h3 id="自定义配置信息"><a href="#自定义配置信息" class="headerlink" title="自定义配置信息"></a>自定义配置信息</h3><p>当代码逻辑写完之后需要增加配置让代码生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个Spring security 的过滤器链，默认会配置</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Introspection endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Revocation endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization Server Metadata endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * JWK Set endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 Provider Configuration endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 UserInfo endpoint</span><br><span class="line">     * 这些协议端点，只有配置了他才能够访问的到接口地址（类似mvc的controller）。</span><br><span class="line">     *</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(1)</span><br><span class="line">    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        OAuth2AuthorizationServerConfigurer&lt;HttpSecurity&gt; authorizationServerConfigurer =</span><br><span class="line">                new OAuth2AuthorizationServerConfigurer&lt;&gt;();</span><br><span class="line">        http.apply(authorizationServerConfigurer);</span><br><span class="line">        authorizationServerConfigurer</span><br><span class="line">                .authorizationService(authorizationService())</span><br><span class="line">                .tokenEndpoint(tokenEndpoint-&gt;tokenEndpoint</span><br><span class="line">                                .accessTokenRequestConverter(new OAuth2PasswordAuthenticationConverter())</span><br><span class="line">                                .accessTokenResponseHandler(responseDataAuthenticationSuccessHandler())</span><br><span class="line">                                .errorResponseHandler(authenticationFailureHandler()));</span><br><span class="line">        DefaultSecurityFilterChain chain = http</span><br><span class="line">                .requestMatcher(authorizationServerConfigurer.getEndpointsMatcher())</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt;</span><br><span class="line">                        authorize.anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                .csrf(CsrfConfigurer::disable)</span><br><span class="line">                .build();</span><br><span class="line">        addingAdditionalAuthenticationProvider(http);</span><br><span class="line">        return chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个也是个Spring Security的过滤器链，用于Spring Security的身份认证。</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(2)</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                // Form login handles the redirect to the login page from the</span><br><span class="line">                // authorization server filter chain</span><br><span class="line">                .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationSuccessHandler responseDataAuthenticationSuccessHandler() &#123;</span><br><span class="line">        return new DefaultAuthenticationSuccessHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationFailureHandler authenticationFailureHandler() &#123;</span><br><span class="line">        return new DefaultAuthenticationFailureHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置用户信息，或者配置用户数据来源，主要用于用户的检索。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">//        UserDetails userDetails = User.withDefaultPasswordEncoder()</span><br><span class="line">//                .username(&quot;user&quot;)</span><br><span class="line">//                .password(&quot;password&quot;)</span><br><span class="line">//                .roles(&quot;USER&quot;)</span><br><span class="line">//                .build();</span><br><span class="line">//       return new InMemoryUserDetailsManager();</span><br><span class="line"></span><br><span class="line">        return new OAuth2UserDetailsManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * oauth2 用于第三方认证，RegisteredClientRepository 主要用于管理第三方（每个第三方就是一个客户端）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RegisteredClientRepository registeredClientRepository() &#123;</span><br><span class="line">//        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">//                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">//                .clientSecret(&quot;&#123;noop&#125;secret&quot;)</span><br><span class="line">//                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/authorized&quot;)</span><br><span class="line">//                .scope(OidcScopes.OPENID)</span><br><span class="line">//                .scope(&quot;message.read&quot;)</span><br><span class="line">//                .scope(&quot;message.write&quot;)</span><br><span class="line">//                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">//                .build();</span><br><span class="line">//</span><br><span class="line">//        return new InMemoryRegisteredClientRepository(registeredClient);</span><br><span class="line">        return new JdbcRegisteredClientRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationService authorizationService()&#123;</span><br><span class="line">        return new OAuth2RedisAuthorizationService(redisService);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 用于给access_token签名使用。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JWKSource&lt;SecurityContext&gt; jwkSource() &#123;</span><br><span class="line">        KeyPair keyPair = generateRsaKey();</span><br><span class="line">        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        RSAKey rsaKey = new RSAKey.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        JWKSet jwkSet = new JWKSet(rsaKey);</span><br><span class="line">        return new ImmutableJWKSet&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成秘钥对，为jwkSource提供服务。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static KeyPair generateRsaKey() &#123;</span><br><span class="line">        KeyPair keyPair;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            keyPairGenerator.initialize(2048);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置Authorization Server实例</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ProviderSettings providerSettings() &#123;</span><br><span class="line">        return ProviderSettings.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void addingAdditionalAuthenticationProvider(HttpSecurity http) &#123;</span><br><span class="line">        AuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class);</span><br><span class="line">        OAuth2AuthorizationService authorizationService = http.getSharedObject(OAuth2AuthorizationService.class);</span><br><span class="line">        OAuth2TokenGenerator&lt;?&gt; tokenGenerator = http.getSharedObject(OAuth2TokenGenerator.class);</span><br><span class="line"></span><br><span class="line">        OAuth2PasswordAuthenticationProvider passwordAuthenticationProvider =</span><br><span class="line">                new OAuth2PasswordAuthenticationProvider(authenticationManager, authorizationService, tokenGenerator);</span><br><span class="line">        http.authenticationProvider(passwordAuthenticationProvider);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>备注：</p>
<p>registeredClientRepository 客户端信息</p>
<p>authorizationService token新增和处理</p>
<p>providerSettings  访问端点配置 默认为：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679126686151-d9dce2ff-ee10-4965-9c54-2744170deb62.png"></p>
<p>addingAdditionalAuthenticationProvider</p>
<p><code>OAuth2TokenEndpointConfigurer</code> 并没有提供批量设置 <code>AuthenticationProvider</code> 的方法，即，如果你要同时配置 authorization_code、refresh_token、client_credentials、password 的 <code>AuthenticationProvider</code> 的话，你需要调用多次 <code>accessTokenResponseHandler() </code>但是<code>HttpSecurity</code>提供了一个 <code>authenticationProvider()</code> 可以动态添加 <code>AuthenticationProvider</code></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>新版本的spring-authorization-server不同于原来的oauth2的版本，去除了密码模式，让很多简单的自定义登陆变的很麻烦，但是其中可自定义的地方有很多</p>
<p>Converter ：从访问令牌中获取参数，并格式化</p>
<p>Provider ：主处理器用于生成token以及保存token</p>
<p>AuthorizationService ：保存token信息，获取token信息</p>
<p>ResponseHandler ：返回信息处理</p>
<p>Token：格式化访问信息为Provider提供数据</p>
<p>Customizer ：自定义claims信息数据可以从context.getPrincipal().getPrincipal()中获取</p>
<p>Manager ：自定义获取用户信息逻辑</p>
<p>当然如果你不希望这么麻烦想要更简单的实现登陆，可以自定义<font style="color:rgb(25, 30, 30);">consentPage页面然后在自定义的consentPage中增加脚本自动提交表单获取令牌</font></p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudGateway详解</title>
    <url>/2024/03/25/SpringCloudGateway%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Spring-Cloud-Gateway-的核心功能："><a href="#Spring-Cloud-Gateway-的核心功能：" class="headerlink" title="Spring Cloud Gateway 的核心功能："></a><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway 的核心功能：</font></h2><p><font style="color:rgb(25, 27, 31);">断言（Predicate）：参照 Java8 的新特性Predicate，允许开发人员匹配 HTTP 请求中的任何内容，比如请求头或请求参数，最后根据匹配结果返回一个布尔值。 路由（route）：由ID、目标URI、断言集合和过滤器集合组成。如果聚合断言结果为真，则转发到该路由。 过滤器（filter）：可以在返回请求之前或之后修改请求和响应的内容。</font></p>
<span id="more"></span>
<h2 id="1、路由-Route"><a href="#1、路由-Route" class="headerlink" title="1、路由 Route"></a><font style="color:rgb(25, 27, 31);">1、路由 Route</font></h2><p><font style="color:rgb(25, 27, 31);">Route 主要由 路由id、目标uri、断言集合和过滤器集合组成，那我们简单看看这些属性到底有什么作用。 （1）id：路由标识，要求唯一，名称任意（默认值 uuid，一般不用，需要自定义） （2）uri：请求最终被转发到的目标地址 （3）order： 路由优先级，数字越小，优先级越高 （4）predicates：断言数组，即判断条件，如果返回值是boolean，则转发请求到 uri 属性指定的服务中 （5）filters：过滤器数组，在请求传递过程中，对请求做一些修改</font></p>
<h2 id="2、断言-Predicate"><a href="#2、断言-Predicate" class="headerlink" title="2、断言 Predicate"></a><font style="color:rgb(25, 27, 31);">2、断言 Predicate</font></h2><p><font style="color:rgb(25, 27, 31);">Predicate 来自于 Java8 的借口。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。 Predicate 可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。Spring Cloud Gateway 内置了许多 Predict，这些 Predict 的源码在 org.springframework.cloud.gateway.handler.predicate 包中，有兴趣可以阅读一下</font></p>
<h2 id="3、过滤器-filter"><a href="#3、过滤器-filter" class="headerlink" title="3、过滤器 filter"></a><font style="color:rgb(25, 27, 31);">3、过滤器 filter</font></h2><p><font style="color:rgb(25, 27, 31);">Gateway 过滤器的生命周期： PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。 POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。 Gateway 过滤器从作用范围可分为两种: GatewayFilter：应用到单个路由或者一个分组的路由上（需要在配置文件中配置） GlobalFilter：应用到所有的路由上（无需配置，全局生效） （1）局部过滤器 GatewayFilter： Spring Cloud Gateway 中内置了许多的局部过滤器；局部过滤器需要在指定路由配置才能生效，默认是不生效的</font></p>
<p><font style="color:rgb(25, 27, 31);">（2）自定义局部过滤器： 虽说内置的过滤器能够解决很多场景，但是难免还是有些特殊需求需要定制一个过滤器，下面就来介绍一下如何自定义局部过滤器。</font></p>
<p><font style="color:rgb(25, 27, 31);">(3) GlobalFilter 全局过滤器： 全局过滤器应用全部路由上，无需开发者配置，Spring Cloud Gateway 也内置了一些全局过滤器。GlobalFilter 的功能其实和 GatewayFilter 是相同的，只是 GlobalFilter 的作用域是所有的路由配置，而不是绑定在指定的路由配置上。多个 GlobalFilter 可以通过 @Order 或者 getOrder() 方法指定执行顺序，order值越小，执行的优先级越高。 注意，由于过滤器有 pre 和 post 两种类型，pre 类型过滤器如果 order 值越小，那么它就应该在pre过滤器链的顶层，post 类型过滤器如果 order 值越小，那么它就应该在 post 过滤器链的底层</font></p>
<p><font style="color:rgb(25, 27, 31);">(4) 过滤器规则（Filter）</font></p>
<p><font style="color:rgb(25, 27, 31);">过滤规则 实例 说明 PrefixPath - PrefixPath&#x3D;&#x2F;app 在请求路径前加上app RewritePath - RewritePath&#x3D;&#x2F;test, &#x2F;app&#x2F;test 访问localhost:9022&#x2F;test,请求会转发到localhost:8001&#x2F;app&#x2F;test SetPath SetPath&#x3D;&#x2F;app&#x2F;{path} 通过模板设置路径，转发的规则时会在路径前增加app，{path}表示原请求路径 RedirectTo 重定向 RemoveRequestHeader 去掉某个请求头信息 注：当配置多个filter时，优先定义的会被调用，剩余的filter将不会生效</font></p>
<h2 id="4、Predicate-断言条件-转发规则-介绍"><a href="#4、Predicate-断言条件-转发规则-介绍" class="headerlink" title="4、Predicate 断言条件(转发规则)介绍"></a><font style="color:rgb(25, 27, 31);">4、Predicate 断言条件(转发规则)介绍</font></h2><p><font style="color:rgb(25, 27, 31);">每一个Predicate的使用，你可以理解为：当满足这种条件后才会被转发，如果是多个，那就是都满足的情况下被转发。</font></p>
<h2 id="Path-方式匹配转发"><a href="#Path-方式匹配转发" class="headerlink" title="Path 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Path 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">通过Path转发示例，我们讲解下上面的两种配置，分别是application.yml以及RouteLocator。</font></p>
<p><font style="color:rgb(25, 27, 31);">配置文件匹配地址转发</font></p>
<p><font style="color:rgb(25, 27, 31);">我们在application.yml配置文件内添加对应的路由配置，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"></span><br><span class="line">application:</span><br><span class="line"></span><br><span class="line">name: spring-cloud-gateway-sample</span><br><span class="line"></span><br><span class="line">cloud:</span><br><span class="line"></span><br><span class="line">gateway:</span><br><span class="line"></span><br><span class="line">routes:</span><br><span class="line"></span><br><span class="line">- id: blog</span><br><span class="line"></span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line"></span><br><span class="line">predicates:</span><br><span class="line"></span><br><span class="line"># 匹配路径转发</span><br><span class="line"></span><br><span class="line">- Path=/api-boot-datasource-switch.html</span><br><span class="line"></span><br><span class="line"># 端口号</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line"></span><br><span class="line">port: 9090</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><strong><font style="color:rgb(25, 27, 31);">先来解释下route的组成部分：</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">id：路由的ID uri：匹配路由的转发地址 predicates：配置该路由的断言，通过PredicateDefinition类进行接收配置。 在上面的配置中，当访问<a href="http://localhost:9090/api-boot-datasource-switch.html%E6%97%B6%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8F%91%E5%88%B0">http://localhost:9090/api-boot-datasource-switch.html时就会被自动转发到</a></font><a href="https://link.zhihu.com/?target=http://blog.xx.com/api-boot-datasource-switch.html"><font style="color:rgb(25, 27, 31);">http://blog.xx.com/api-boot-datasource-switch.html</font></a><font style="color:rgb(25, 27, 31);">，这里要注意完全匹配Path的值时才会进行路由转发。</font></p>
<p><font style="color:rgb(25, 27, 31);">访问效果如下所示：</font></p>
<p><font style="color:rgb(25, 27, 31);">spring-cloud-gateway-path-predicate.png</font></p>
<p><font style="color:rgb(25, 27, 31);">RouteLocator 匹配路径转发</font></p>
<p><font style="color:rgb(25, 27, 31);">在上面的配置中，如果使用RouteLocator方式该怎么进行配置呢？</font></p>
<p><font style="color:rgb(25, 27, 31);">如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RouteLocator routeLocator(RouteLocatorBuilder builder) &#123;</span><br><span class="line">return builder.routes()</span><br><span class="line">.route(&quot;blog&quot;, r -&gt;</span><br><span class="line">r.path(&quot;/api-boot-datasource-switch.html&quot;).uri(&quot;http://blog.xx.com&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="Before-方式匹配转发"><a href="#Before-方式匹配转发" class="headerlink" title="Before 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Before 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">当部署有访问时间限制的接口时，我们可以通过Before Predicate来完成某一个时间点之前允许访问，过时后则不允许转发请求到具体的服务，配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Before=2019-05-01T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，我们允许2019-05-01日凌晨之前通过路由转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">，通过查看org.springframework.cloud.gateway.handler.predicate.BeforeRoutePredicateFactory源码我们发现，Spring Cloud Gateway的Before断言采用的ZonedDateTime进行匹配时间，这里要注意存在时区的问题，需要配置[Asia&#x2F;Shanghai]作为中国时区。</font></p>
<h2 id="After-方式匹配转发"><a href="#After-方式匹配转发" class="headerlink" title="After 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">After 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">After Predicate与Before配置使用一致，匹配某一个时间点之后允许路由转发，如下所示配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- After=2019-04-29T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中允许2019-04-29凌晨之后进行转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">。</font></p>
<h2 id="Between-方式匹配转发"><a href="#Between-方式匹配转发" class="headerlink" title="Between 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Between 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">那如果是一个时间段内允许请求转发，通过Before、After组合配置也可以完成，不过Spring Cloud Gateway还是提供了Between方式，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Between=2019-04-29T00:00:00+08:00[Asia/Shanghai], 2019-05-01T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，允许在2019-04-29日凌晨后 &amp; 2019-05-01凌晨之前请求转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">。</font></p>
<h2 id="Cookie-方式匹配转发"><a href="#Cookie-方式匹配转发" class="headerlink" title="Cookie 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Cookie 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway 还提供了根据Cookie值的方式匹配转发请求，如果请求中所携带的Cookie值与配置的Predicate匹配，那么就可以被允许转发到指定地址，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Cookie=hengboy, leo</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，如果客户端发送请求时携带了”hengboy&#x3D;leo”的Cookie信息，则允许请求转发。</font></p>
<p><strong><font style="color:rgb(25, 27, 31);">测试Cookie方式转发：</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">curl <a href="http://localhost:9090/">http://localhost:9090</a> –cookie “hengboy&#x3D;leo” 通过上面方式我们是可以成功转发请求的，如果我们修改Cookie的值，就会导致无法转发，出现404。</font></p>
<h2 id="Header-方式匹配转发"><a href="#Header-方式匹配转发" class="headerlink" title="Header 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Header 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以根据发送请求的Header信息进行匹配转发，加入我们可以根据X-Request-Id的值进行匹配，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，如果X-Request-Id的值为数字，那么就可以转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">，我们通过如下方式进行测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">curl <a href="http://localhost:9090/">http://localhost:9090</a> -H “X-Request-Id:123456” 如果头信息为X-Request-Id:abc时，就会转发失败，出现404。</font></p>
<h2 id="Host-方式匹配转发"><a href="#Host-方式匹配转发" class="headerlink" title="Host 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Host 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以根据Host主机名进行匹配转发，如果我们的接口只允许\.</font><a href="https://link.zhihu.com/?target=http://xx.com"><font style="color:rgb(25, 27, 31);">http://xx.com</font></a><font style="color:rgb(25, 27, 31);">域名进行访问，那么配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Host=\*\*.xx.com</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">测试如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. curl http://localhost:9090 -H &quot;Host: xx.com&quot; // 匹配</span><br><span class="line">2. curl http://localhost:9090 -H &quot;Host: api.xx.com&quot; // 匹配</span><br><span class="line">3. curl http://localhost:9090 -H &quot;Host: admin.xx.com&quot; // 匹配</span><br><span class="line">4. curl http://localhost:9090 -H &quot;Host: hengboy.com&quot; // 不匹配</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="请求方式-方式匹配转发"><a href="#请求方式-方式匹配转发" class="headerlink" title="请求方式 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">请求方式 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Rest请求风格的接口内往往会存在多种请求方式的接口，如果我们的接口只允许POST请求访问，那么配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Method=POST</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">发送GET请求测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">~ curl <a href="http://localhost:9090/">http://localhost:9090</a></font></p>
<p><font style="color:rgb(25, 27, 31);">{“timestamp”:”2019-04-29T06:27:41.121+0000”,”path”:”&#x2F;“,”status”:404,”error”:”Not Found”,”message”:null} 我们的请求并未被Spring Cloud Gateway进行转发，那么我们再来通过POST请求进行测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">curl -X POST <a href="http://localhost:9090/">http://localhost:9090</a> 是可以被转发到目标地址uri的，不过我的这个博客是OSS部署的，阿里云限制了POST访问，尽管如此我们也证明了可以转发。</font></p>
<p><font style="color:rgb(25, 27, 31);">请求参数 方式匹配转发 Spring Cloud GateWay还支持根据指定的参数进行匹配，Query方式的Predicate也有两种方式匹配情况，如下所示：</font></p>
<p><font style="color:rgb(25, 27, 31);">请求中存在xxx参数 cloud: gateway: routes: - id: blog uri: </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">predicates: - Query&#x3D;xxx 我们通过curl <a href="http://localhost:9090/?xxx%5C=123%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%88%90%E5%8A%9F%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%8C%E5%8F%AA%E8%A6%81%E5%8F%82%E6%95%B0%E5%AD%98%E5%9C%A8xxx%E5%B0%B1%E4%BC%9A%E8%A2%AB%E6%88%90%E5%8A%9F%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%90%A6%E5%88%99%E5%87%BA%E7%8E%B0404%E8%BD%AC%E5%8F%91%E5%A4%B1%E8%B4%A5%E3%80%82">http://localhost:9090\?xxx\=123是可以被成功转发的，只要参数存在xxx就会被成功转发，否则出现404转发失败。</a></font></p>
<p><font style="color:rgb(25, 27, 31);">请求中存在xxx参数且值为zzz cloud: gateway: routes: - id: blog uri: </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">predicates: - Query&#x3D;xxx, zzz 根据上面配置，我们限定了参数xxx必须为zzz时才会被成功转发，否则同样会出现404抓发失败。</font></p>
<p><font style="color:rgb(25, 27, 31);">请求路径 方式匹配转发 Spring Cloud Gateway提供了请求路径变量方式匹配转发，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Path=/article/&#123;articleId&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">在上面配置中{articleId}是一个路径变量，可以是任意值，匹配&#x2F;article&#x2F;1、&#x2F;article&#x2F;abc等，测试如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ curl http://localhost:9090/article/1 // 匹配</span><br><span class="line">~ curl http://localhost:9090/article/abc // 匹配</span><br><span class="line">~ curl http://localhost:9090/article/1/1 // 不匹配</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="请求IP-方式匹配转发"><a href="#请求IP-方式匹配转发" class="headerlink" title="请求IP 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">请求IP 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以限制允许访问接口的客户端IP地址，配置后只对指定IP地址的客户端进行请求转发，配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- RemoteAddr=192.168.1.56/24</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面我们配置了192.168.1.56&#x2F;24，其中192.168.1.56是客户端的IP地址，而24则是子网掩码。</font></p>
<h2 id="组合示例"><a href="#组合示例" class="headerlink" title="组合示例"></a><font style="color:rgb(25, 27, 31);">组合示例</font></h2><p><font style="color:rgb(25, 27, 31);">相同的Predicate也可以配置多个，请求的转发是必须满足所有的Predicate后才可以进行路由转发，组合使用示例如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Query=author, hengboy</span><br><span class="line">- Query=leo</span><br><span class="line">- Method=GET</span><br><span class="line">- Cookie=hengboy, leo</span><br><span class="line">- Header=X-Request-Id, \d+</span><br><span class="line">- RemoteAddr=192.168.1.56/24</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font style="color:rgb(25, 27, 31);">总结</font></h2><p><font style="color:rgb(25, 27, 31);">本章节讲解了Spring Cloud Gateway的相关谓词、断言基本使用方式，GateWay内部提供了很多种灵活的路由转发规则，在同一个路由内存在多个Predicate时，同时满足规则后请求才会被路由转发。</font></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot项目中引用SpringCloudGateway</title>
    <url>/2024/03/26/springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E7%94%A8SpringCloudGateway/</url>
    <content><![CDATA[<h1 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h1><p>首先我们打开官网可以看到如下的描述：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1672730319068-d939400c-0dc9-466e-ae30-1cff4d5c6783.png"></p>
<p>SpringCloudGateway旨在提供一种简单而有效的方式来路由到API，并为它们提供跨领域的关注点，例如：安全性、监控&#x2F;度量和弹性。</p>
<span id="more"></span>
<h1 id="为什么要使用网关"><a href="#为什么要使用网关" class="headerlink" title="为什么要使用网关"></a>为什么要使用网关</h1><p>当我们有多个服务的时候，前端需要访问服务的时候需要在前端维护好这几个服务的路径信息，<font style="color:rgb(0, 0, 0);">这样的架构会有如下几个典型的问题：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">每个微服务都需要配置单独的访问域名，开通外网访问权限，每新增一个服务都需要先让运维人员配置好域名映射</font></li>
<li><font style="color:rgb(1, 1, 1);">客户端需要维护所有微服务的访问地址，试想一下如果微服务有几十几百个呢？</font></li>
<li><font style="color:rgb(1, 1, 1);">当服务需要对接口进行权限控制，必须要认证用户才能调用，那么所有的权限逻辑在服务端都要重新编写一套。</font></li>
</ul>
<p><font style="color:rgb(0, 0, 0);">所以我们需要在微服务之前加一个网关服务，让所有的客户端只要访问网关，网关负责对请求进行转发；将权限校验逻辑放到网关的过滤器中，后端服务不需要再关注权限校验的代码；只需要对外提供一个可供外网访问的域名地址，新增服务后也不需要再让运维人员进行网络配置了，这样上面的架构就变成了通过网关转达到对应的服务</font></p>
<h1 id="如何在springboot项目中引用网关"><a href="#如何在springboot项目中引用网关" class="headerlink" title="如何在springboot项目中引用网关"></a>如何在springboot项目中引用网关</h1><h3 id="增加pom"><a href="#增加pom" class="headerlink" title="增加pom"></a>增加pom</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1672731071359-61f824de-4903-44e6-aba3-515a3f594da3.png"></p>
<p>我们从官网可以看到gateway需要的pom项，因为我们的服务都使用nacos所以需要加上nacos的pom项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--nacos--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(85, 86, 102);">由于springcloud2020弃用了</font><a href="https://so.csdn.net/so/search?q=Ribbon&spm=1001.2101.3001.7020">Ribbon</a><font style="color:rgb(85, 86, 102);">，因此Alibaba在2021版本nacos中删除了Ribbon的jar包，因此无法通过lb路由到指定微服务，出现了503情况。</font></p>
<p><font style="color:rgb(85, 86, 102);">所以只需要引入springcloud loadbalancer包即可</font></p>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LuckGatewayApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(LuckGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bootstap-yml"><a href="#bootstap-yml" class="headerlink" title="bootstap.yml"></a>bootstap.yml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1060</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: luck-gateway</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在nacos中建立网关的路由配置"><a href="#在nacos中建立网关的路由配置" class="headerlink" title="在nacos中建立网关的路由配置"></a><font style="color:rgb(1, 1, 1);">在nacos中建立网关的路由配置</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          lowerCaseServiceId: true</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: luck-uid</span><br><span class="line">        uri: lb://luck-uid</span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/uid/**</span><br><span class="line">        filters:</span><br><span class="line">          - StripPrefix=1</span><br></pre></td></tr></table></figure>



<h3 id="配置详解："><a href="#配置详解：" class="headerlink" title="配置详解："></a><font style="color:rgb(0, 0, 0);">配置详解：</font></h3><p><font style="color:rgb(119, 119, 119);">id: 在所有路由定义中需要唯一，不能重复</font><br><font style="color:rgb(119, 119, 119);">uri: lb:&#x2F;&#x2F;**  lb:&#x2F;&#x2F;为固定写法，表示开启负载均衡； ** 即服务在Nacos中注册的名字</font><br><font style="color:rgb(119, 119, 119);">predicates:- Path&#x3D;&#x2F;</font>uid<font style="color:rgb(119, 119, 119);">&#x2F;** 使用”Path Route Predicate Factory”，规则为&#x2F;</font>uid<font style="color:rgb(119, 119, 119);">&#x2F;** 的请求都还转发至微服务</font>luck-uid<font style="color:rgb(119, 119, 119);">中。</font></p>
<p>filters : - StripPrefix &#x3D;1 <strong><font style="color:rgb(77, 77, 77);">若有StripPrefix过滤器时，gateway会根据StripPrefix&#x3D;1所配的值（这里是1）去掉URL路径中的部分前缀</font></strong><font style="color:rgb(77, 77, 77);">（这里去掉一个前缀，即去掉lbs）</font></p>
<p><font style="color:rgb(0, 0, 0);"></font></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud项目使用nacos</title>
    <url>/2024/03/28/%E4%BD%8E%E4%BE%B5%E5%85%A5%E7%9A%84%E7%81%B0%E5%BA%A6%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="设计简介："><a href="#设计简介：" class="headerlink" title="设计简介："></a>设计简介：</h3><p>灰度平台配置的主键是以域名来做主键配置，以域名来关联规则，依托这些规则来判断哪些哪些请求需要走灰度</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/jpeg/25873401/1701237832373-b55015c3-0ea5-468c-bb8f-f849cbc5daba.jpeg" alt="画板"></p>
<h3 id="为什么要做这个平台"><a href="#为什么要做这个平台" class="headerlink" title="为什么要做这个平台"></a>为什么要做这个平台</h3><p>系统的稳定性，多有2方面造成</p>
<p>1.生产环境运行期间，异常造成的服务宕机，造成的系统不可用。</p>
<p>2.在更新服务时因为准备不足或者遗漏造成的更新时服务不可用。</p>
<p>在第一点上我们可以做好监控和告警，使用容器编排工具自动重启，服务集群来避免。</p>
<p>但是第二点人员干涉较多，很容易出现纰漏，所以构建一个灰度的平台，在系统上线后逐步的将系统开放出去，尽早的发现纰漏减少因为更新系统造成的宕机损失</p>
<h3 id="平台功能与使用场景"><a href="#平台功能与使用场景" class="headerlink" title="平台功能与使用场景"></a>平台功能<font style="color:rgb(47, 48, 52);">与使用场景</font></h3><p>平台包含规则域名管理、规则管理、比例管理。平台与openresty通过redis联动，规则的筛选通过lua脚本来执行。</p>
<p>域名管理：域名的增加、修改、删除、以及全量灰度修改、全量下线</p>
<p>规则灰度：主要配置请求类型，然后根据不同的请求类型获取对应的参数，通过规则类型（大于等于小于包含不等于等符号）来判断请求是否属于灰度</p>
<p>比例灰度：设置请求有多少数据进入灰度，这里需要注意：比例只能从小到大，最低到1%，最高到100%（第一次设置10%那后续只能从10%往上加）</p>
<p>使用场景：</p>
<p>服务A，B更新，创建服务A，B的灰度服务并在nacos的元空间中增加灰度版本，然后增加域名——规则灰度——ip灰度——白名单——公司IP地址；公司网络访问服务测试灰度内容，无异常后，再根据自己的需要配置参数规则匹配或者比例灰度来进行小部分的发布，当然如果对服务很有信息也可以直接更新到线上</p>
<h3 id="为了实现灰度都做了什么"><a href="#为了实现灰度都做了什么" class="headerlink" title="为了实现灰度都做了什么"></a>为了实现灰度都做了什么</h3><p><font style="color:rgb(47, 48, 52);"></font></p>
]]></content>
      <categories>
        <category>灰度平台</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>灰度</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud项目使用nacos</title>
    <url>/2024/03/27/springcloud%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8nacos/</url>
    <content><![CDATA[<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><h2 id="Nacos-融合-Spring-Cloud："><a href="#Nacos-融合-Spring-Cloud：" class="headerlink" title="Nacos 融合 Spring Cloud："></a><font style="color:rgb(36, 41, 46);">Nacos 融合 Spring Cloud：</font></h2><p><a href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html">https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html</a></p>
<h2 id="Java-SDK："><a href="#Java-SDK：" class="headerlink" title="Java SDK："></a><font style="color:rgb(36, 41, 46);">Java SDK：</font></h2><p><a href="https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html">https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html</a></p>
<h1 id="POM文件引用："><a href="#POM文件引用：" class="headerlink" title="POM文件引用："></a>POM文件引用：</h1><h2 id="父pom"><a href="#父pom" class="headerlink" title="父pom"></a>父pom</h2><p>springcloud，springboot，springcloudalibaba，nacos版本引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">      &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">      &lt;spring-boot.version&gt;2.6.13&lt;/spring-boot.version&gt;</span><br><span class="line">      &lt;spring-cloud.version&gt;2021.0.5&lt;/spring-cloud.version&gt;</span><br><span class="line">      &lt;spring-cloud-alibaba.version&gt;2021.0.4.0&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">      &lt;alibaba.nacos.version&gt;2.1.1&lt;/alibaba.nacos.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;!--统一版本--&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.luck.sugar&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;luck-bom&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- SpringBoot 依赖配置 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- SpringCloud 微服务 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- Alibaba Nacos 配置 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;alibaba.nacos.version&#125;&lt;/version&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- Mybatis 依赖配置 --&gt;</span><br><span class="line"></span><br><span class="line">           &lt;!-- SpringCloud Alibaba 微服务 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">       &lt;/dependencies&gt;</span><br><span class="line">   &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>因为我们使用了注册中心所以配置不能再使用application.yaml，需要优先级更高的bootstrap文件来找到nacos的配置文件，在springboot2.2以后bootstrap默认是关闭的需要打开才能默认使用bootstrap文件为配置文件，需要在pom文件中添加模块引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- bootstrap 启动器 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="子pom"><a href="#子pom" class="headerlink" title="子pom"></a>子pom</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;!--  spring web --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- spring test --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--nacos--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h1 id="配置文件修改："><a href="#配置文件修改：" class="headerlink" title="配置文件修改："></a>配置文件修改：</h1><p>上节解释了配置文件变化，以下是bootstrap.yml的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1066</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: luck-uid</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 49.235.122.65:8848</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 49.235.122.65:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="启动类注解添加："><a href="#启动类注解添加：" class="headerlink" title="启动类注解添加："></a>启动类注解添加：</h1><p><font style="color:#bbb529;">@EnableDiscoveryClient</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LuckUidApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(LuckUidApplication.class, args);</span><br><span class="line">        System.out.println(&quot;(♥◠‿◠)ﾉﾞ  ID服务启动成功   ლ(´ڡ`ლ)ﾞ  \n&quot; +</span><br><span class="line">                &quot; .-------.       .-------.          \n&quot; +</span><br><span class="line">                &quot; | i--------------------i |         \n&quot; +</span><br><span class="line">                &quot; | |                    | |         \n&quot; +</span><br><span class="line">                &quot; \\|   O       O        |/          \n&quot; +</span><br><span class="line">                &quot;   |      /\\           |           \n&quot; +</span><br><span class="line">                &quot;   |     /  \\          |           \n&quot; +</span><br><span class="line">                &quot;   |    \\__/           |           \n&quot; +</span><br><span class="line">                &quot;   |      __-- .        |           \n&quot; +</span><br><span class="line">                &quot;           `-..-&#x27;              &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1670814234495-463d58c8-b5df-4c44-9129-728a4b419988.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1670814281972-0e0c6a3b-0840-43c4-aafc-63de05ef2b20.png"></p>
<h1 id="异常备注："><a href="#异常备注：" class="headerlink" title="异常备注："></a>异常备注：</h1><h3 id="bootstrap-yml未生效：链接地址为-127-0-0-1"><a href="#bootstrap-yml未生效：链接地址为-127-0-0-1" class="headerlink" title="bootstrap.yml未生效：链接地址为 127.0.0.1"></a>bootstrap.yml未生效：链接地址为 127.0.0.1</h3><p>pom未添加spring-cloud-starter-bootstrap，</p>
<p>配置文件格式异常</p>
<h3 id="项目启动完成后没有注册到nacos中："><a href="#项目启动完成后没有注册到nacos中：" class="headerlink" title="项目启动完成后没有注册到nacos中："></a>项目启动完成后没有注册到nacos中：</h3><p>子pom中未引用：spring-cloud-starter-alibaba-nacos-discovery</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>Spring</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID总结</title>
    <url>/2024/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    <content><![CDATA[<p>:::success<br>分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式 ID，那么我们如何设计它呢？本文将详细讲述分布式 ID 及其生成方案。</p>
<p>:::</p>
<hr>
<h1 id="为什么需要分布式-ID"><a href="#为什么需要分布式-ID" class="headerlink" title="为什么需要分布式 ID"></a>为什么需要分布式 ID</h1><p>目前大部分的系统都已是分布式系统，所以在这种场景的业务开发中，经常会需要唯一 ID 对数据进行标识，比如用户身份标识、消息标识等等。</p>
<p>并且在数据量达到一定规模后，大部分的系统也需要进行分库分表，这种场景下单库的自增 ID 已达不到我们的预期。所以我们需要分布式 ID 来对各种场景的数据进行唯一标识。</p>
<h1 id="分布式-ID-的特性"><a href="#分布式-ID-的特性" class="headerlink" title="分布式 ID 的特性"></a>分布式 ID 的特性</h1><p><strong>主要特性：</strong></p>
<ul>
<li>全局唯一：分布式 ID 最基本要求，必须全局唯一。</li>
<li>高可用：高并发下要保证 ID 的生成效率，避免影响系统。</li>
<li>易用性：使用简单，可快速接入。</li>
</ul>
<p><strong>除此之外根据不同场景还有：</strong></p>
<ul>
<li>有序性：数据库场景下的主键 ID，有序性可便于数据写入和排序。</li>
<li>安全性：无规则 ID，一般用于避免业务信息泄露场景，如订单量。</li>
</ul>
<h1 id="分布式-ID-常见生成方案"><a href="#分布式-ID-常见生成方案" class="headerlink" title="分布式 ID 常见生成方案"></a>分布式 ID 常见生成方案</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718614981558-bee358fe-b5f6-4890-b69e-9eb60310084d.jpeg" alt="画板"></p>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p><strong>UUID</strong>（Universally Unique Identifier），即通用唯一识别码。UUID 的目的是让分布式系统中的所有元素都能有唯一的识别信息。</p>
<p>UUID 是由128位二进制数组成，通常表示为32个十六进制字符，形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>



<p>这个字符串由五个部分组成，以连字符<code>-</code>分隔开，具体如下：</p>
<table>
<thead>
<tr>
<th align="center">部分</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">时间戳</td>
<td align="center">32 bits</td>
<td>UUID的前32位表示当前的时间戳。</td>
</tr>
<tr>
<td align="center">时钟序列和随机数</td>
<td align="center">16 bits</td>
<td>用于保证在同一时刻生成的UUID的唯一性。</td>
</tr>
<tr>
<td align="center">变体标识</td>
<td align="center">4 bits</td>
<td>标识 UUID 的变体，通常为固定值，表示是由 RFC 4122 定义。</td>
</tr>
<tr>
<td align="center">版本号</td>
<td align="center">4 bits</td>
<td>标识UUID的版本，常见版本有1、3、4和5</td>
</tr>
<tr>
<td align="center">节点</td>
<td align="center">48 bits</td>
<td>在版本 1 中，这部分包含生成 UUID 的计算机的唯一标识。</td>
</tr>
</tbody></table>
<p><strong>主要的 UUID 版本及其生成规则：</strong></p>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">场景</th>
<th>生成规则</th>
</tr>
</thead>
<tbody><tr>
<td align="center">版本 1</td>
<td align="center">基于时间和节点</td>
<td>由当前的时间戳和节点信息生成。包括时间戳、时钟序列、节点标识。</td>
</tr>
<tr>
<td align="center">版本 2</td>
<td align="center">基于DCE安全标识符</td>
<td>类似版本 1，但在时间戳部分包含 POSIX UID&#x2F;GID 信息。</td>
</tr>
<tr>
<td align="center">版本 3</td>
<td align="center">基于名字和散列值（MD5 版）</td>
<td>由命名空间和名字的MD5散列生成。</td>
</tr>
<tr>
<td align="center">版本 4</td>
<td align="center">完全随机生成</td>
<td>通过随机或伪随机生成128位数字。</td>
</tr>
<tr>
<td align="center">版本 5</td>
<td align="center">基于名字和散列值（SHA-1 版）</td>
<td>通过随机或伪随机生成128位数字。</td>
</tr>
</tbody></table>
<p><strong>Java中 UUID 对版本 4 进行了实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认版本 4</span></span><br><span class="line">    System.out.println(UUID.randomUUID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本 3，由命名空间和名字的MD5散列生成，相同命名空间结果相同</span></span><br><span class="line">    <span class="comment">// 如下，&quot;fuxing&quot;返回的UUID一直为8b9b6bc3-90c8-37ef-bbef-0ed0c552718f</span></span><br><span class="line">    System.out.println(UUID.nameUUIDFromBytes(<span class="string">&quot;fuxing&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong>本地生成，没有网络消耗，性能非常高。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>占用空间大，32 个字符串，128 位。</li>
<li>不安全：版本 1 可能会造成 mac 地址泄露。</li>
<li>无序，非自增。</li>
<li>机器时间不对，可能造成 UUID 重复。</li>
</ul>
<h2 id="数据库自增-ID"><a href="#数据库自增-ID" class="headerlink" title="数据库自增 ID"></a>数据库自增 ID</h2><p>实现简单，解释通过数据库表中的主键 ID 自增来生成唯一标识。如下，维护一个 MySQL 表来生成 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `unique_id` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `value` char(10) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当需要生成分布式 ID 时，向表中插入数据并返回主键 ID，这里 value 无含义，只是为了占位，方便插入数据。</p>
<p><strong>优点：</strong>实现简单，基本满足业务需求，且天然有序。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>那么有没有办法解决数据库自增 ID 的缺点呢？</p>
<p>通过水平拆分的方案，将表设置到不同的数据库中，设置不同的起始值和步长，这样可以有效的生成集群中的唯一 ID，也大大降低 ID 生成数据库操作的负载，示例如下。</p>
<p><code>&lt;font style=&quot;color:rgb(62, 62, 62);&quot;&gt;unique_id_1&lt;/font&gt;</code><font style="color:rgb(62, 62, 62);">配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>

<p><code>&lt;font style=&quot;color:rgb(62, 62, 62);&quot;&gt;unique_id_2&lt;/font&gt;</code><font style="color:rgb(62, 62, 62);">配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>



<p>这个还是需要根据自己的业务需求来，水平扩展的集群数量要符合自己的数据量，因为当设置的集群数量不足以满足高并发时，再次进行扩容集群会很麻烦。多台机器的起始值和步长都需要重新配置。</p>
<h2 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h2><p>号段模式是当下分布式 ID 生成器的主流实现方式之一，比如美团 Leaf-segment、滴滴 Tinyid、微信序列号等都使用的该方案，下面的大厂中间件中会展开说明。</p>
<p>号段模式也是基于数据库的自增 ID，数据库自增 ID 是一次性获取一个分布式 ID，**<font style="color:#5C8D07;">号段模式可以理解成从数据库批量获取 ID，然后将 ID 缓存在本地</font>**，以此来提高业务获取 ID 的效率。</p>
<p>例如，每次从数据库获取 ID 时，获取一个号段，如(1,1000]，这个范围表示 1000 个 ID，业务应用在请求获取 ID 时，只需要在本地从 1 开始自增并返回，而不用每次去请求数据库，一直到本地自增到 1000 时，才去数据库重新获取新的号段，后续流程循环往复。</p>
<p>表结构可进行如下设计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `id_generator` (</span><br><span class="line">  `id` int(10) NOT NULL,</span><br><span class="line">  `max_id` bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  `step` int(10) NOT NULL COMMENT &#x27;号段的步长&#x27;,</span><br><span class="line">  `version` int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  `biz_type` int(20) NOT NULL COMMENT &#x27;业务场景&#x27;,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>



<p>其中<code>max_id</code>和<code>step</code>用于获取批量的 ID，<code>version</code>是一个乐观锁，保证并发时数据的正确性。</p>
<p>比如，我们新增一条表数据如下。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">max_id</th>
<th align="center">step</th>
<th align="center">version</th>
<th align="center">biz_type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">100</td>
<td align="center">1000</td>
<td align="center">0</td>
<td align="center">001</td>
</tr>
</tbody></table>
<p>然后我们可以使用该号段批量生成的 ID，当<code>max_id = 1000</code>，则执行 update 操作生成新的号段。新的号段的 SQL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE </span><br><span class="line">id_generator </span><br><span class="line">SET </span><br><span class="line">max_id = #&#123;max_id+ step&#125;, </span><br><span class="line">version = version + 1 </span><br><span class="line">WHERE </span><br><span class="line">version = #&#123;version&#125; AND biz_type = 001;</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong>ID 有序递增、存储消耗空间小。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>缺点同样可以通过集群的方式进行优化，也可以如Tinyid 采用双缓存进行优化，下面的大厂中间件中会展开说明。</p>
<h2 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h2><p>当使用数据库来生成 ID 性能不够的时候，可以尝试使用 Redis 来生成 ID。原理则是利用 Redis 的原子操作 INCR 和 INCRBY 来实现。</p>
<p><strong>命令示例：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>INCR</strong></td>
<td>让一个整形的key自增1</td>
<td>:::tips redis&gt; <font style="color:#E8323C;">SET</font> mykey “10”<br/>“OK”<br/>redis&gt; <font style="color:#E8323C;">INCR</font> mykey<br/>(integer) 11<br/>:::</td>
</tr>
<tr>
<td align="center"><strong>INCRBY</strong></td>
<td>让一个整形的key自增并指定步长</td>
<td>:::tips redis&gt; <font style="color:#E8323C;">SET</font> mykey “10”<br/>“OK”<br/>redis&gt; <font style="color:#E8323C;">INCRBY</font> mykey 5<br/>(integer) 15<br/>:::</td>
</tr>
</tbody></table>
<p><strong>优点：</strong>不依赖于数据库，使用灵活，支持高并发。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>系统须引入 Redis 数据库。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li><font style="color:rgb(25, 27, 31);">Redis 出现单点故障问题，可能会丢数据导致 ID 重复</font>。</li>
</ul>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法（Snowflake）是 twitter 公司内部分布式项目采用的 ID 生成算法。结果是一个 long 型的 ID。Snowflake 算法将 64bit 划分为多段，分开来标识机器、时间等信息，具体组成结构如下图所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718695293290-53f569fe-4b3d-4e3b-8161-804a80c69b7a.jpeg" alt="画板"></p>
<p><strong>结构说明：</strong></p>
<table>
<thead>
<tr>
<th align="center">结构</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">符号位</td>
<td align="center">1 bit</td>
<td>0 表示正数，1 表示负数。</td>
</tr>
<tr>
<td align="center">时间戳</td>
<td align="center">41 bits</td>
<td>存储的是<code>当前时间戳 - 开始时间戳</code>，最长 69 年。</td>
</tr>
<tr>
<td align="center">机器位</td>
<td align="center">10 bits</td>
<td>前 5位 datacenterId，后 5 位 workerId ，最多表示 1024 台。</td>
</tr>
<tr>
<td align="center">序列号</td>
<td align="center">12 bits</td>
<td>毫秒内的流水号，意味着每个节点在每毫秒可以产生 4096 个 ID。</td>
</tr>
</tbody></table>
<p><strong>优点：</strong></p>
<p>稳定性高，不依赖于数据库等第三方系统。</p>
<p>使用灵活方便，可以根据业务需求的特性来调整算法中的 bit 位。</p>
<p>单机上 ID 单调自增，毫秒数在高位，自增序列在低位，整体上按照时间自增排序。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，可能导致发号重复或者服务处于不可用状态。</li>
<li>ID 可能不是全局递增，虽然 ID 在单机上是递增的。</li>
<li><font style="color:rgb(25, 27, 31);">Redis 出现单点故障问题，可能会丢数据导致 ID 重复</font>。</li>
</ul>
<p>当我们选择了雪花算法可以参考<font style="color:rgb(47, 48, 52);">shardingsphere的雪花算法，以此为例来写一个starter</font></p>
<p><font style="color:rgb(47, 48, 52);">定义接口</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultIdGenerator implements IdGenerator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long nextId() &#123;</span><br><span class="line">        Comparable&lt;?&gt; key=  IDUtils.generateKey();</span><br><span class="line">        return (Long) key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义雪花算法实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.fbb.pomelo.id.utils;</span><br><span class="line"></span><br><span class="line">import com.google.common.base.Preconditions;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import lombok.experimental.UtilityClass;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.net.NetworkInterface;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@UtilityClass</span><br><span class="line">public final class IDUtils &#123;</span><br><span class="line">    public static final long EPOCH;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_BITS = 12L;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_BITS = 10L;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_MASK = (1 &lt;&lt; SEQUENCE_BITS) - 1;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_LEFT_SHIFT_BITS = SEQUENCE_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long TIMESTAMP_LEFT_SHIFT_BITS = WORKER_ID_LEFT_SHIFT_BITS + WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_MAX_VALUE = 1L &lt;&lt; WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID = 0;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_VIBRATION_VALUE = 1;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS = 10;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    private static TimeService timeService = new TimeService();</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    private Properties properties = new Properties();</span><br><span class="line"></span><br><span class="line">    private int sequenceOffset = -1;</span><br><span class="line"></span><br><span class="line">    private long sequence;</span><br><span class="line"></span><br><span class="line">    private long lastMilliseconds;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(2016, Calendar.NOVEMBER, 1);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, 0);</span><br><span class="line">        calendar.set(Calendar.MINUTE, 0);</span><br><span class="line">        calendar.set(Calendar.SECOND, 0);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, 0);</span><br><span class="line">        EPOCH = calendar.getTimeInMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized Comparable&lt;?&gt; generateKey() &#123;</span><br><span class="line">        long currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">        if (waitTolerateTimeDifferenceIfNeed(currentMilliseconds)) &#123;</span><br><span class="line">            currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        if (lastMilliseconds == currentMilliseconds) &#123;</span><br><span class="line">            if (0L == (sequence = (sequence + 1) &amp; SEQUENCE_MASK)) &#123;</span><br><span class="line">                currentMilliseconds = waitUntilNextTime(currentMilliseconds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            vibrateSequenceOffset();</span><br><span class="line">            sequence = sequenceOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        lastMilliseconds = currentMilliseconds;</span><br><span class="line">        return ((currentMilliseconds - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (getWorkerId() &lt;&lt; WORKER_ID_LEFT_SHIFT_BITS) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    private boolean waitTolerateTimeDifferenceIfNeed(final long currentMilliseconds) &#123;</span><br><span class="line">        if (lastMilliseconds &lt;= currentMilliseconds) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeDifferenceMilliseconds = lastMilliseconds - currentMilliseconds;</span><br><span class="line">        Preconditions.checkState(timeDifferenceMilliseconds &lt; getMaxTolerateTimeDifferenceMilliseconds(),</span><br><span class="line">                &quot;Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds&quot;, lastMilliseconds, currentMilliseconds);</span><br><span class="line">        Thread.sleep(timeDifferenceMilliseconds);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getWorkerId() &#123;</span><br><span class="line">        long result = Long.valueOf(properties.getProperty(&quot;worker.id&quot;, String.valueOf(WORKER_ID)));</span><br><span class="line">        if (result &lt;= 0L)&#123;</span><br><span class="line">            result = generateWorkerId();</span><br><span class="line">        &#125;</span><br><span class="line">        Preconditions.checkArgument(result &gt;= 0L &amp;&amp; result &lt; WORKER_ID_MAX_VALUE);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxVibrationOffset() &#123;</span><br><span class="line">        int result = Integer.parseInt(properties.getProperty(&quot;max.vibration.offset&quot;, String.valueOf(DEFAULT_VIBRATION_VALUE)));</span><br><span class="line">        Preconditions.checkArgument(result &gt;= 0 &amp;&amp; result &lt;= SEQUENCE_MASK, &quot;Illegal max vibration offset&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxTolerateTimeDifferenceMilliseconds() &#123;</span><br><span class="line">        return Integer.valueOf(properties.getProperty(&quot;max.tolerate.time.difference.milliseconds&quot;, String.valueOf(MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long waitUntilNextTime(final long lastTime) &#123;</span><br><span class="line">        long result = timeService.getCurrentMillis();</span><br><span class="line">        while (result &lt;= lastTime) &#123;</span><br><span class="line">            result = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void vibrateSequenceOffset() &#123;</span><br><span class="line">        sequenceOffset = sequenceOffset &gt;= getMaxVibrationOffset() ? 0 : sequenceOffset + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long generateWorkerId() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return generateWorkerIdBaseOnMac();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return generateRandomWorkerId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * randomly generate one as workerId</span><br><span class="line">     * @return workerId</span><br><span class="line">     */</span><br><span class="line">    private long generateRandomWorkerId() &#123;</span><br><span class="line">        return new Random().nextInt((int)WORKER_ID_MAX_VALUE + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * use lowest 10 bit of available MAC as workerId</span><br><span class="line">     * @return workerId</span><br><span class="line">     * @throws Exception when there is no available mac found</span><br><span class="line">     */</span><br><span class="line">    private long generateWorkerIdBaseOnMac() throws Exception &#123;</span><br><span class="line">        Enumeration&lt;NetworkInterface&gt; all = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        while (all.hasMoreElements()) &#123;</span><br><span class="line">            NetworkInterface networkInterface = all.nextElement();</span><br><span class="line">            boolean loopBack = networkInterface.isLoopback();</span><br><span class="line">            boolean isVirtual = networkInterface.isVirtual();</span><br><span class="line">            if (loopBack || isVirtual) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] mac = networkInterface.getHardwareAddress();</span><br><span class="line">            return ((mac[4] &amp; 0B11) &lt;&lt; 8) | (mac[5] &amp; 0xFF);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(&quot;no available mac found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取随机ID</span><br><span class="line">     * @return 随机ID用以替代传统的UUID</span><br><span class="line">     */</span><br><span class="line">    public String get32UUID() &#123;</span><br><span class="line">        ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">        return (new UUID(random.nextLong(), random.nextLong())).toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TimeService &#123;</span><br><span class="line">    public long getCurrentMillis() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class IdAutoConfiguration &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 注入ID生成器实现</span><br><span class="line">     * @return see &#123;@link DefaultIdGenerator&#125;</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public IdGenerator idGenerator() &#123;</span><br><span class="line">        return new DefaultIdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>META-INF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">     com.fbb.pomelo.id.configuration.IdAutoConfiguration</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="大厂中间件"><a href="#大厂中间件" class="headerlink" title="大厂中间件"></a>大厂中间件</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718614818789-89d8afe6-37ff-4335-a746-1aea25018e23.jpeg" alt="画板"></p>
<h2 id="美团-Leaf"><a href="#美团-Leaf" class="headerlink" title="美团 Leaf"></a><font style="color:rgb(88, 90, 90);">美团 Leaf</font></h2><p><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html">Leaf 的官方文档</a>，简介和特性可访问了解，这里我将对 Leaf 的两种方案，Leaf segment 和 Leaf-snowflake 进行。</p>
<h3 id="Leaf-segment"><a href="#Leaf-segment" class="headerlink" title="Leaf segment"></a>Leaf segment</h3><p>基于数据库号段模式的 ID 生成方案，上面我们介绍到普通的号段模式有一些缺点：</p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>那么 Leaf 是如何做的呢？Leaf 采用了预分发的方式生成ID，也就是在 DB 之上挂 n 个 Leaf Server，每个Server启动时，都会去 DB 拿固定长度的 ID List。</p>
<p>这样就做到了完全基于分布式的架构，同时因为ID是由内存分发，所以也可以做到很高效，处理流程图如下：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718698426441-afdf835d-f486-4d25-b783-42521191ff2b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Leaf"></p>
<p><strong>其中：</strong></p>
<ul>
<li>Leaf Server 1：从 DB 加载号段[1，1000]。</li>
<li>Leaf Server 2：从 DB 加载号段[1001，2000]。</li>
<li>Leaf Server 3：从 DB 加载号段[2001，3000]。</li>
</ul>
<p>用户**<font style="color:#5C8D07;">通过轮询的方式</font>**调用 Leaf Server 的各个服务，所以某一个 Client 获取到的ID序列可能是：1，1001，2001，2，1002，2002。当某个 Leaf Server 号段用完之后，下一次请求就会从 DB 中加载新的号段，这样保证了每次加载的号段是递增的。</p>
<p>为了解决在更新DB号段的时出现的耗时和阻塞服务的问题，Leaf 采用了**<font style="color:#5C8D07;">异步更新</font>**的策略，同时通过双缓存的方式，保证无论何时DB出现问题，都能有一个 Buffer 的号段可以正常对外提供服务，只要 DB 在一个 Buffer 的下发的周期内恢复，就不会影响整个 Leaf 的可用性。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718698969771-dbe0fd2a-5501-44d0-8db1-2c250de2b7d9.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Leaf"></p>
<p>除此之外，Leaf 还**<font style="color:#5C8D07;">通过动态调整步长</font>**，解决由于步长固定导致的缓存中的 ID 被过快消耗问题，以及步长设置过大导致的号段 ID 跨度过大问题，具体公式可去官方文档中了解。</p>
<p>对于数据一致性问题，Leaf 目前是通过中间件 Zebra 加 MHA 做的主从切换。</p>
<h3 id="Leaf-Snowflake"><a href="#Leaf-Snowflake" class="headerlink" title="Leaf Snowflake"></a>Leaf Snowflake</h3><p>Leaf-snowflake 方案沿用 Snowflake 方案的 bit 位设计。</p>
<p>对于 workerID 的分配：当服务集群较小时，通过配置即可；服务集群较大时，基于 zookeeper 持久顺序节点的特性引入 zookeeper 组件配置 workerID。架构如下图所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/3003575/1718699670231-b390838f-2dd5-4e13-a52d-f446cb8fd6dc.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10"></p>
<h2 id="百度-UidGenerator"><a href="#百度-UidGenerator" class="headerlink" title="百度 UidGenerator"></a>百度 UidGenerator</h2><p><a href="https://github.com/baidu/uid-generator">开源地址</a></p>
<p>UidGenerator 方案是基于 Snowflake 算法的 ID 生成器，其对雪花算法的 bit 位的分配做了微调。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718700335302-7c7d4146-8057-464e-af50-6e39a5c6d527.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_25,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10"></p>
<hr>
<p><strong>结构说明（参数可在 Spring Bean 配置中进行配置）：</strong></p>
<table>
<thead>
<tr>
<th>结构</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>符号位</td>
<td align="center">1 bit</td>
<td><font style="color:rgb(37, 43, 58);">最高位始终是 0。</font></td>
</tr>
<tr>
<td>增量秒</td>
<td align="center"><font style="color:rgb(37, 43, 58);">28</font> bits</td>
<td>表示自客户纪元（2016-05-20）以来的增量秒。最大时间为 8.7 年。</td>
</tr>
<tr>
<td>工作节点</td>
<td align="center">22 bits</td>
<td>表示工作节点 ID，最大值为 4.2 百万个。</td>
</tr>
<tr>
<td>序列号</td>
<td align="center">13 bits</td>
<td>表示一秒钟内的序列，默认情况下每秒最多 8192 个。</td>
</tr>
</tbody></table>
<p>UidGenerator 方案包含两种实现方式，DefaultUidGenerator 和 CachedUidGenerator ，性能要求高的情况下推荐 CachedUidGenerator。</p>
<h2 id="滴滴-Tinyid"><a href="#滴滴-Tinyid" class="headerlink" title="滴滴 Tinyid"></a>滴滴 Tinyid</h2><p><a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">Tinyid 官方文档</a></p>
<p>Tinyid 方案是在 Leaf-segment 的算法基础上升级而来，不仅支持了数据库多主节点模式，还提供了 tinyid-client 客户端的接入方式，使用起来更加方便。</p>
<p>Tinyid 也是采用了异步加双缓存策略，首先可用号段加载到内存中，并在内存中生成 ID，可用号段在首次获取 ID 时加载，号段用到一定程度的时候，就去异步加载下一个号段，保证内存中始终有可用号段，则可避免性能波动。</p>
<p><strong>实现原理如下所示：</strong></p>
<p><img src="https://github.com/didi/tinyid/raw/master/doc/tinyid_final.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_29,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Tinyid"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文对分布式 ID 以及其场景的生成方案做了介绍，还针对一下大厂的中间件进行简单分析，中间件的接入代码本文并没有做详细介绍，但是官方文档的链接都帖子了每个子标题下，其中都有详细介绍。</p>
<p>文中还针对每个生成方案的优缺点作出了说明，具体的使用可针对优缺点加上业务需求来进行选型。</p>
<hr>
<blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/534893180">[1] 腾讯技术工程. 分布式唯一 ID 生成方案浅谈.</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2377401">[2] 孟斯特. UUID 介绍.</a></p>
<p><a href="https://blog.csdn.net/jiaomubai/article/details/124385324">[3] 文丑颜不良啊. 雪花算法（SnowFlake）.</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>ID</tag>
      </tags>
  </entry>
</search>
