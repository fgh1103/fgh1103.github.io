<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Canal</title>
    <url>/2022/06/11/Canal/</url>
    <content><![CDATA[<h2 id="什么是Canal"><a href="#什么是Canal" class="headerlink" title="什么是Canal"></a>什么是Canal</h2><p>canal译意为水道&#x2F;管道&#x2F;沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。<br>从这句话理解到了什么？<br>基于MySQL，并且通过MySQL日志进行的增量解析，这也就意味着对原有的业务代码完全是无侵入性的。</p>
<span id="more"></span>
<p><strong>工作原理</strong>：解析MySQL的binlog日志，提供增量数据。</p>
<h2 id="Canal能做什么"><a href="#Canal能做什么" class="headerlink" title="Canal能做什么"></a>Canal能做什么</h2><p>基于日志增量订阅和消费的业务包括</p>
<ul>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护(拆分异构索引、倒排索引等)</li>
<li>业务 cache 刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ul>
<p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。<br>官方文档：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<h2 id="Canal数据如何传输？"><a href="#Canal数据如何传输？" class="headerlink" title="Canal数据如何传输？"></a>Canal数据如何传输？</h2><p>先来一张官方图：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650355686553-164622a0-3c7c-4356-82f8-3778ee9975a6.png#averageHue=%23f3f2f2&clientId=ub5d898f2-92c2-4&from=paste&id=ub5e1132e&originHeight=569&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua4319a32-b052-48db-a60d-bc7965ab4c2&title="><br>Canal分为服务端和客户端，这也是阿里常用的套路：</p>
<ul>
<li>服务端：负责解析MySQL的binlog日志，传递增量数据给客户端或者消息中间件</li>
<li>客户端：负责解析服务端传过来的数据，然后定制自己的业务处理。</li>
</ul>
<p>目前为止支持的消息中间件很全面了，比如Kafka、RocketMQ，RabbitMQ。</p>
<h2 id="数据同步还有其他中间件吗？"><a href="#数据同步还有其他中间件吗？" class="headerlink" title="数据同步还有其他中间件吗？"></a>数据同步还有其他中间件吗？</h2><p>有，当然有，还有一些开源的中间件也是相当不错的，比如Bifrost。<br>常见的几款中间件的区别如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/jpeg/25873401/1650355699488-47931f43-dbf5-4368-94c1-4c0df391ca21.jpeg#averageHue=%23e78379&clientId=ub5d898f2-92c2-4&from=paste&id=u0c2ffed1&originHeight=265&originWidth=640&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4e2a647e-3eb9-4b25-ac5c-8ed1645131d&title="><br>当然要我选择的话，首选阿里的中间件Canal。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Canal的实战，集成到SpringBoot"><a href="#Canal的实战，集成到SpringBoot" class="headerlink" title="Canal的实战，集成到SpringBoot"></a>Canal的实战，集成到SpringBoot</h2><h3 id="Canal服务端安装"><a href="#Canal服务端安装" class="headerlink" title="Canal服务端安装"></a>Canal服务端安装</h3><p>服务端需要下载压缩包，下载地址：<a href="https://github.com/alibaba/canal/releases">https://github.com/alibaba/canal/releases</a><br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356266972-8003453b-8323-4e12-85a7-4af4f9de6e64.png#averageHue=%23fefdfd&clientId=ub5d898f2-92c2-4&from=paste&height=858&id=uc284655e&name=image.png&originHeight=858&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87200&status=done&style=none&taskId=u56ed93ae-9eb9-4a89-a9d3-10c32925cfe&title=&width=867" alt="image.png"><br>下载稳定版本v1.1.5<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356447084-372caebe-0c97-466d-820b-e231d9421234.png#averageHue=%23fefaf9&clientId=ub5d898f2-92c2-4&from=paste&height=326&id=u7de74c62&name=image.png&originHeight=326&originWidth=863&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26771&status=done&style=none&taskId=ub0e23bb0-04b7-4b3c-bc70-ae83c9bc074&title=&width=863" alt="image.png"><br>下载完成解压，目录如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356460373-1b23ca59-a31d-4651-8c65-6457e88c3399.png#averageHue=%23fefdfd&clientId=ub5d898f2-92c2-4&from=paste&id=ubfec025c&originHeight=223&originWidth=985&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8473ca90-4285-446d-8011-ee8cb593e37&title="><br>本文使用<strong>Canal+RabbitMQ</strong>进行数据的同步，因此下面步骤完全按照这个base进行。</p>
<h3 id="打开MySQL的binlog日志"><a href="#打开MySQL的binlog日志" class="headerlink" title="打开MySQL的binlog日志"></a>打开MySQL的binlog日志</h3><p>请参考<a href="https://www.yuque.com/u25495771/yqh657/cv1548">https://www.yuque.com/u25495771/yqh657/cv1548</a></p>
<h3 id="设置MySQL的配置"><a href="#设置MySQL的配置" class="headerlink" title="设置MySQL的配置"></a>设置MySQL的配置</h3><p>需要设置服务端配置文件中的MySQL配置，这样Canal才能知道需要监听哪个库、哪个表的日志文件。<br>一个 Server 可以配置多个实例监听 ，Canal 功能默认自带的有个 example 实例，本篇就用 example 实例 。如果增加实例，复制 example 文件夹内容到同级目录下，然后在 canal.properties 指定添加实例的名称。<br>修改canal.deployer-1.1.5\conf\example\instance.properties配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># url</span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line"># username/password</span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=root</span><br><span class="line"># 监听的数据库</span><br><span class="line">canal.instance.defaultDatabaseName=test</span><br><span class="line"></span><br><span class="line"># 监听的表，可以指定，多个用逗号分割，这里正则是监听所有</span><br><span class="line">canal.instance.filter.regex=.*\\..*</span><br></pre></td></tr></table></figure>
<h3 id="设置RabbitMQ的配置"><a href="#设置RabbitMQ的配置" class="headerlink" title="设置RabbitMQ的配置"></a>设置RabbitMQ的配置</h3><p>服务端默认的传输方式是tcp，需要在配置文件中设置MQ的相关信息。<br>这里需要修改两处配置文件，如下；</p>
<ol>
<li>canal.deployer-1.1.5\conf\canal.properties</li>
</ol>
<p>这个配置文件主要是设置MQ相关的配置，比如URL，用户名、密码…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 传输方式：tcp, kafka, rocketMQ, rabbitMQ</span><br><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line">##################################################</span><br><span class="line">######### 		RabbitMQ	 #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host = 127.0.0.1</span><br><span class="line">rabbitmq.virtual.host =/</span><br><span class="line"># exchange</span><br><span class="line">rabbitmq.exchange =canal.exchange</span><br><span class="line"># 用户名、密码</span><br><span class="line">rabbitmq.username =guest</span><br><span class="line">rabbitmq.password =guest</span><br><span class="line">## 是否持久化</span><br><span class="line">rabbitmq.deliveryMode = 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>canal.deployer-1.1.5\conf\example\instance.properties</li>
</ol>
<p>这个文件设置MQ的路由KEY，这样才能路由到指定的队列中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canal.mq.topic=canal.routing.key</span><br></pre></td></tr></table></figure>
<h3 id="RabbitMQ新建exchange和Queue"><a href="#RabbitMQ新建exchange和Queue" class="headerlink" title="RabbitMQ新建exchange和Queue"></a>RabbitMQ新建exchange和Queue</h3><p>在RabbitMQ中需要新建一个canal.exchange（必须和配置中的相同）的exchange和一个名称为 canal.queue（名称随意）的队列。<br>其中绑定的路由KEY为：canal.routing.key（必须和配置中的相同），如下图：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356683237-bd7aa4dd-0249-4367-a4f1-d18fd642b151.png#averageHue=%23f8f7f7&clientId=ue7f6981a-5aa6-4&from=paste&id=u84bc14bb&originHeight=242&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub5a2273f-91e8-454f-82f8-f436dcbfb34&title="></p>
<h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>点击bin目录下的脚本，windows直接双击startup.bat，启动成功如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356701506-8b6915b7-a13c-4bf4-b2b8-be891699bd1a.png#averageHue=%232e2c2a&clientId=ue7f6981a-5aa6-4&from=paste&id=uc58fbd70&originHeight=315&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u899d291e-03ac-4e87-9905-4a09ece2ef3&title="></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在本地数据库test中的oauth_client_details插入一条数据，如下：<br>INSERT INTO <code>oauth_client_details</code> VALUES (‘myjszl’, ‘res1’, ‘$2a$10$F1tQdeb0SEMdtjlO8X&#x2F;0wO6Gqybu6vPC&#x2F;Xg8OmP9&#x2F;TL1i4beXdK9W’, ‘all’, ‘password,refresh_token,authorization_code,client_credentials,implicit’, ‘<a href="http://www.baidu.com/">http://www.baidu.com</a>‘, NULL, 1000, 1000, NULL, ‘false’);</p>
<p>此时查看MQ中的canal.queue已经有了数据，如下：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650356727749-58f14d0b-4d67-4390-b426-8c4f12bda6a6.png#averageHue=%23fcfcfc&clientId=ue7f6981a-5aa6-4&from=paste&id=u20a8b6dd&originHeight=164&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucc2b654f-0461-4176-96b2-09bb8aae423&title=">其实就是一串JSON数据，这个JSON如下：<br>{<br> “data”: [{<br>  “client_id”: “myjszl”,<br>  “resource_ids”: “res1”,<br>  “client_secret”: “$2a$10$F1tQdeb0SEMdtjlO8X&#x2F;0wO6Gqybu6vPC&#x2F;Xg8OmP9&#x2F;TL1i4beXdK9W”,<br>  “scope”: “all”,<br>  “authorized_grant_types”: “password,refresh_token,authorization_code,client_credentials,implicit”,<br>  “web_server_redirect_uri”: “<a href="http://www.baidu.com/">http://www.baidu.com</a>“,<br>  “authorities”: null,<br>  “access_token_validity”: “1000”,<br>  “refresh_token_validity”: “1000”,<br>  “additional_information”: null,<br>  “autoapprove”: “false”<br> }],<br> “database”: “test”,<br> “es”: 1640337532000,<br> “id”: 7,<br> “isDdl”: false,<br> “mysqlType”: {<br>  “client_id”: “varchar(48)”,<br>  “resource_ids”: “varchar(256)”,<br>  “client_secret”: “varchar(256)”,<br>  “scope”: “varchar(256)”,<br>  “authorized_grant_types”: “varchar(256)”,<br>  “web_server_redirect_uri”: “varchar(256)”,<br>  “authorities”: “varchar(256)”,<br>  “access_token_validity”: “int(11)”,<br>  “refresh_token_validity”: “int(11)”,<br>  “additional_information”: “varchar(4096)”,<br>  “autoapprove”: “varchar(256)”<br> },<br> “old”: null,<br> “pkNames”: [“client_id”],<br> “sql”: “”,<br> “sqlType”: {<br>  “client_id”: 12,<br>  “resource_ids”: 12,<br>  “client_secret”: 12,<br>  “scope”: 12,<br>  “authorized_grant_types”: 12,<br>  “web_server_redirect_uri”: 12,<br>  “authorities”: 12,<br>  “access_token_validity”: 4,<br>  “refresh_token_validity”: 4,<br>  “additional_information”: 12,<br>  “autoapprove”: 12<br> },<br> “table”: “oauth_client_details”,<br> “ts”: 1640337532520,<br> “type”: “INSERT”<br>}</p>
<p>每个字段的意思已经很清楚了，有表名称、方法、参数、参数类型、参数值…..<br>客户端要做的就是监听MQ获取JSON数据，然后将其解析出来，处理自己的业务逻辑。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>打开IDEA创建项目canal-toos<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1650357369053-2135bca0-7417-422d-a9ae-23ced9f4a203.png#averageHue=%233d4143&clientId=ue7f6981a-5aa6-4&from=paste&height=779&id=u1ae9689a&name=image.png&originHeight=779&originWidth=818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63356&status=done&style=none&taskId=uea85711c-4dbe-4e2d-9f1a-6889877ef0a&title=&width=818" alt="image.png"><br>引用POM文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!-- Mybatis plus代码生产插件 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- Mybatisplus代码生成模板 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- Mybatis基础依赖 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--mybatisplus 依赖插件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--mysql依赖插件--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;5.1.38&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">   &lt;!-- rabbitmq 服务调用依赖 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!-- jackosn基础依赖 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.9.9&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="创建消息实体类"><a href="#创建消息实体类" class="headerlink" title="创建消息实体类"></a>创建消息实体类</h3><p>MQ传递过来的是JSON数据，当然要创建个实体类接收数据，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Canal消息接收实体类</span><br><span class="line"> */</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class CanalMessage&lt;T&gt; &#123;</span><br><span class="line">    @JsonProperty(&quot;type&quot;)</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;table&quot;)</span><br><span class="line">    private String table;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;data&quot;)</span><br><span class="line">    private List&lt;T&gt; data;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;database&quot;)</span><br><span class="line">    private String database;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;es&quot;)</span><br><span class="line">    private Long es;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;id&quot;)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;isDdl&quot;)</span><br><span class="line">    private Boolean isDdl;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;old&quot;)</span><br><span class="line">    private List&lt;T&gt; old;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;pkNames&quot;)</span><br><span class="line">    private List&lt;String&gt; pkNames;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;sql&quot;)</span><br><span class="line">    private String sql;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;ts&quot;)</span><br><span class="line">    private Long ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加RabbitMQ消费端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cn.hutool.json.JSONUtil;</span><br><span class="line">import cn.myjszl.middle.ware.canal.mq.rabbit.model.CanalMessage;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 监听MQ获取Canal增量的数据消息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class CanalRabbitMQListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings = &#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value = @Queue(value = &quot;canal.queue&quot;, durable = &quot;true&quot;),</span><br><span class="line">                    exchange = @Exchange(value = &quot;canal.exchange&quot;),</span><br><span class="line">                    key = &quot;canal.routing.key&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void handleDataChange(String message) &#123;</span><br><span class="line">        //将message转换为CanalMessage</span><br><span class="line">        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class);</span><br><span class="line">        String tableName = canalMessage.getTable();</span><br><span class="line">        log.info(&quot;Canal 监听 &#123;&#125; 发生变化；明细：&#123;&#125;&quot;, tableName, message);</span><br><span class="line">        String tableName =canalMessage.getTable();</span><br><span class="line">        if (canalMessage.getData()!=null)&#123;</span><br><span class="line">                for (int i=0;i&lt;canalMessage.getData().size();i++ ) &#123;</span><br><span class="line">                Map&lt;String,Object&gt; map= mapper.readValue(canalMessage.getData().get(i).toString(),Map.class);</span><br><span class="line"></span><br><span class="line">                if (canalMessage.getType().contains(&quot;INSERT&quot;))&#123;</span><br><span class="line">                    sava(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (canalMessage.getType().contains(&quot;UPDATE&quot;))&#123;</span><br><span class="line">                    update(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (canalMessage.getType().contains(&quot;DELETE&quot;))&#123;</span><br><span class="line">                    delect(map,tableName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public  String underlineToHump(String str) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(str))&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //正则匹配下划线及后一个字符，删除下划线并将匹配的字符转成大写</span><br><span class="line">        Matcher matcher = UNDERLINE_PATTERN.matcher(str);</span><br><span class="line">        StringBuffer sb = new StringBuffer(str);</span><br><span class="line">        if (matcher.find()) &#123;</span><br><span class="line">            sb = new StringBuffer();</span><br><span class="line">            //将当前匹配的子串替换成指定字符串，并且将替换后的子串及之前到上次匹配的子串之后的字符串添加到StringBuffer对象中</span><br><span class="line">            //正则之前的字符和被替换的字符</span><br><span class="line">            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());</span><br><span class="line">            //把之后的字符串也添加到StringBuffer对象中</span><br><span class="line">            matcher.appendTail(sb);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //去除除字母之外的前面带的下划线</span><br><span class="line">            return sb.toString().replaceAll(&quot;_&quot;, &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return underlineToHump(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    public void sava(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line">        Object tableObjet = tableClass.newInstance();</span><br><span class="line">        for (String key :oldTable.keySet())&#123;</span><br><span class="line">            Method[] methods =  tableObjet.getClass().getMethods();</span><br><span class="line">            Object mapValue=oldTable.get(key);</span><br><span class="line"></span><br><span class="line">            String methodName = underlineToHump(&quot;set&quot;+upperFirstCase(key.toLowerCase()));</span><br><span class="line">            for (Method method:methods)&#123;</span><br><span class="line">                if (method.getName().equals(methodName))&#123;</span><br><span class="line">                    if (method.getParameterTypes()[0].equals(String.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            mapValue =&quot; &quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, mapValue.toString());</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Date.class)|| method.getParameterTypes()[0].equals(LocalDateTime.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                        method.invoke(tableObjet, LocalDateTime.parse(mapValue.toString(),formatter));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Integer.class)||method.getParameterTypes()[0].equals(int.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Integer.parseInt(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Long.class)||method.getParameterTypes()[0].equals(long.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Long.parseLong(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Double.class)||method.getParameterTypes()[0].equals(double.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Double.parseDouble(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Boolean.class)||method.getParameterTypes()[0].equals(boolean.class)) &#123;</span><br><span class="line">                        if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(tableObjet, Boolean.parseBoolean(mapValue.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Object pojo = mapper.readValue(mapper.writeValueAsString(oldTable), tableClass.getClass());</span><br><span class="line"></span><br><span class="line">        String newTable= lowerFirstCase(tableName+&quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line"></span><br><span class="line">        service.save(tableObjet);</span><br><span class="line">    &#125;</span><br><span class="line">        public void update(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, IOException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException &#123;</span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line">        Object tableObjet = tableClass.newInstance();</span><br><span class="line">        for (String key :oldTable.keySet()) &#123;</span><br><span class="line">            Method[] methods = tableObjet.getClass().getMethods();</span><br><span class="line">            Object mapValue = oldTable.get(key);</span><br><span class="line">            if (ObjectUtils.isEmpty(mapValue))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String methodName = underlineToHump(&quot;set&quot; + upperFirstCase(key.toLowerCase()));</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                if (method.getName().equals(methodName)) &#123;</span><br><span class="line">                    if (method.getParameterTypes()[0].equals(String.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, mapValue.toString());</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Date.class) || method.getParameterTypes()[0].equals(LocalDateTime.class)) &#123;</span><br><span class="line">                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">                        method.invoke(tableObjet, LocalDateTime.parse(mapValue.toString(), formatter));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Integer.class) || method.getParameterTypes()[0].equals(int.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Integer.parseInt(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Long.class) || method.getParameterTypes()[0].equals(long.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Long.parseLong(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Double.class) || method.getParameterTypes()[0].equals(double.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Double.parseDouble(mapValue.toString()));</span><br><span class="line">                    &#125; else if (method.getParameterTypes()[0].equals(Boolean.class) || method.getParameterTypes()[0].equals(boolean.class)) &#123;</span><br><span class="line">                        method.invoke(tableObjet, Boolean.parseBoolean(mapValue.toString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    //method.invoke(tableObjet,oldTable.get(key));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newTable = lowerFirstCase(tableName + &quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line">        service.updateById(tableObjet);</span><br><span class="line">    &#125;</span><br><span class="line">    public void delect(Map&lt;String,Object&gt; oldTable,String tableName) throws ClassNotFoundException, IOException &#123;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        Class tableClass = Class.forName(&quot;com.koalas.canal.tools.base.entity.&quot;+tableName);</span><br><span class="line"></span><br><span class="line">        QueryWrapper wrapper = new QueryWrapper();</span><br><span class="line">        wrapper.eq(&quot;ID&quot;,oldTable.get(&quot;ID&quot;));</span><br><span class="line">        String newTable= lowerFirstCase(tableName+&quot;ServiceImpl&quot;);</span><br><span class="line"></span><br><span class="line">        ServiceImpl service = (ServiceImpl) SpringBeanUtils.getBeanByString(newTable);</span><br><span class="line">        service.remove(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>springboot</tag>
        <tag>canal</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>安装RabbitMQ</title>
    <url>/2022/01/11/%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<h2 id="参照官网："><a href="#参照官网：" class="headerlink" title="参照官网："></a>参照官网：</h2><p><a href="https://www.rabbitmq.com/install-rpm.html#package-cloud">https://www.rabbitmq.com/install-rpm.html#package-cloud</a></p>
<span id="more"></span>
<h2 id="添加yum存储库信息"><a href="#添加yum存储库信息" class="headerlink" title="添加yum存储库信息"></a>添加yum存储库信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">touch rabbitmq.repo</span><br><span class="line">vi rabbitmq.repo</span><br></pre></td></tr></table></figure>
<p>rabbitmq.repo中添加文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#In /etc/yum.repos.d/rabbitmq.repo</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## Zero dependency Erlang</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq_erlang</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[rabbitmq_server]</span><br><span class="line">name=rabbitmq_server</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h2><p>使用命令：yum install rabbitmq-server</p>
<p>最后修改一直选y<br>将会自动下载安装对应的<a href="https://so.csdn.net/so/search?q=erlang&spm=1001.2101.3001.7020">erlang</a>版本、rabbitmq版本、keys等。<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644656259455-3fe11f75-b3a3-40b7-92ae-521df1e6b76c.png#clientId=u99af809c-8097-4&from=paste&height=529&id=ubb7d3f11&name=image.png&originHeight=529&originWidth=1887&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73715&status=done&style=none&taskId=u5df5f38f-98fd-4151-826f-39030d372c6&title=&width=1887" alt="image.png"></p>
<h2 id="修改登录拦截"><a href="#修改登录拦截" class="headerlink" title="修改登录拦截"></a>修改登录拦截</h2><p>rabbitmq 3.3.0开始禁用除localhost外的地址采取guest登录，所以此处需要将拦截去除。<br>找到安装目录<br>vi rabbit.app<br>将其中loopback_users, [&lt;&lt;”guest”&gt;&gt;]字段中的数据修改成下列方式：<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659808980-04bf71e4-c7ae-4346-8be6-47d62ebd8a85.png#clientId=u99af809c-8097-4&from=paste&id=ub3d16f82&name=image.png&originHeight=563&originWidth=501&originalType=url&ratio=1&rotation=0&showTitle=false&size=46996&status=done&style=none&taskId=u28d72f30-d720-4c4c-a149-eb0933f0eaa&title=" alt="image.png"></p>
<h2 id="启动rabbitmq"><a href="#启动rabbitmq" class="headerlink" title="启动rabbitmq"></a>启动rabbitmq</h2><p>service rabbitmq-server start</p>
<h2 id="开启图形化"><a href="#开启图形化" class="headerlink" title="开启图形化"></a>开启图形化</h2><p>rabbitmq-plugins enable rabbitmq_management<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659826635-8d068b00-e708-46c4-bd51-2e4b9f9e86dd.png#clientId=u99af809c-8097-4&from=paste&id=u225e2c08&name=image.png&originHeight=186&originWidth=670&originalType=url&ratio=1&rotation=0&showTitle=false&size=19642&status=done&style=none&taskId=u9402a1a4-793f-49ae-8461-428aa7895c5&title=" alt="image.png"></p>
<h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><p>rabbitmqctl status</p>
<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><p>使用命令rabbitmqctl add_user username password进行添加新用户。<br>rabbitmqctl add_user xiangjiao bunana<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659924599-bc6befcb-314f-48c0-aaf1-12ede71381d9.png#clientId=u99af809c-8097-4&from=paste&id=ub67c24ee&name=image.png&originHeight=45&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&size=8623&status=done&style=none&taskId=uc663062d-0c58-4570-ad64-e364a76c652&title=" alt="image.png"></p>
<h2 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h2><p>使用命令rabbitmqctl set_user_tags username administrator设置用户tag。<br>rabbitmqctl set_user_tags xiangjiao administrator<br><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659930697-fc18293d-a7cb-42b9-86a0-9f001f700899.png#clientId=u99af809c-8097-4&from=paste&id=u9bac882c&name=image.png&originHeight=27&originWidth=669&originalType=url&ratio=1&rotation=0&showTitle=false&size=4718&status=done&style=none&taskId=u396a0295-cbf2-4cc0-92a4-f1308d063cb&title=" alt="image.png"></p>
<h1 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659937730-5b420d6a-2d54-4b74-a5d8-1714df1188f0.png#clientId=u99af809c-8097-4&from=paste&id=u26e58c6c&name=image.png&originHeight=253&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&size=16836&status=done&style=none&taskId=u93fc0373-469d-436c-a3ea-67a98f50a61&title=" alt="image.png"></p>
<p> <img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1644659947739-f1582562-2b4e-48ce-8ee5-e63aa60ddba1.png#clientId=u99af809c-8097-4&from=paste&id=u90593ccb&name=image.png&originHeight=740&originWidth=1457&originalType=url&ratio=1&rotation=0&showTitle=false&size=67428&status=done&style=none&taskId=uc63ffb4a-3243-4c60-9c35-1f499430c7f&title=" alt="image.png"></p>
<h1 id="命令拓展"><a href="#命令拓展" class="headerlink" title="命令拓展"></a>命令拓展</h1><h2 id="卸载rabbitmq"><a href="#卸载rabbitmq" class="headerlink" title="卸载rabbitmq"></a>卸载rabbitmq</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–卸载</span><br><span class="line">–停止服务</span><br><span class="line">rabbitmqctl app_stop</span><br><span class="line">yum list | grep rabbitmq</span><br><span class="line">yum -y remove rabbitmq-server.noarch</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="卸载erlang支持"><a href="#卸载erlang支持" class="headerlink" title="卸载erlang支持"></a>卸载erlang支持</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list | grep erlang</span><br><span class="line">yum -y remove erlang-*</span><br><span class="line">yum remove erlang.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig rabbitmq-server on # 添加开机启动RabbitMQ服务</span><br><span class="line">/sbin/service rabbitmq-server start # 启动服务</span><br><span class="line">/sbin/service rabbitmq-server status # 查看服务状态</span><br><span class="line">/sbin/service rabbitmq-server stop # 停止服务</span><br><span class="line">rabbitmqctl list_users #查看用户列表信息和权限信息</span><br><span class="line">rabbitmqctl list_user_permissions xxxxx #查看指定用户的权限信息</span><br><span class="line">rabbitmqctl delete_user guest #删除guest用户</span><br><span class="line">rabbitmqctl add_user username password #添加新用户</span><br><span class="line">rabbitmqctl set_user_tags username administrator #设置用户tag</span><br><span class="line">rabbitmqctl set_permissions -p / username “.&quot; &quot;.” “.*” #赋予用户默认vhost的全部操作权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义用户信息</title>
    <url>/2024/03/11/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在集成Oauth2.1认证中心，采用默认的数据结构实现了认证，但是大部分时候默认的用户结构并不能满足生产的需要，所以接下来以RBAC权限设计来实现用户</p>
<span id="more"></span>
<h2 id="基于RBAC的权限设计"><a href="#基于RBAC的权限设计" class="headerlink" title="基于RBAC的权限设计"></a>基于RBAC的权限设计</h2><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE system_user(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT COMMENT &#x27;编号&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36)    COMMENT &#x27;租户号&#x27; ,</span><br><span class="line">    USER_ID VARCHAR(36) NOT NULL   COMMENT &#x27;用户编号&#x27; ,</span><br><span class="line">    DEPT_ID VARCHAR(36)    COMMENT &#x27;部门编号&#x27; ,</span><br><span class="line">    USER_NAME VARCHAR(100) NOT NULL   COMMENT &#x27;用户账号&#x27; ,</span><br><span class="line">    NICK_NAME VARCHAR(100)    COMMENT &#x27;用户昵称&#x27; ,</span><br><span class="line">    EMAIL VARCHAR(100)    COMMENT &#x27;用户邮箱&#x27; ,</span><br><span class="line">    PHONE_NUMBER VARCHAR(100)    COMMENT &#x27;用户手机号&#x27; ,</span><br><span class="line">    SEX INT    COMMENT &#x27;性别&#x27; ,</span><br><span class="line">    AVATAR VARCHAR(100)    COMMENT &#x27;头像地址&#x27; ,</span><br><span class="line">    PASSWORD VARCHAR(100) NOT NULL   COMMENT &#x27;密码&#x27; ,</span><br><span class="line">    STATUS INT NOT NULL   COMMENT &#x27;用户状态&#x27; ,</span><br><span class="line">    DEL_FLAG INT NOT NULL   COMMENT &#x27;删除标志（0代表存在 2代表删除）&#x27; ,</span><br><span class="line">    REVISION INT NOT NULL  COMMENT &#x27;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(100)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(100)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户表&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE system_role(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36)    COMMENT &#x27;角色编号;角色编号&#x27; ,</span><br><span class="line">    ROLE_NAME VARCHAR(100)    COMMENT &#x27;角色名称;角色名称&#x27; ,</span><br><span class="line">    ROLE_KEY VARCHAR(100)    COMMENT &#x27;角色权限字符串;角色权限字符串&#x27; ,</span><br><span class="line">    ROLE_SORT INT    COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    DATA_SCOPE VARCHAR(100)    COMMENT &#x27;数据范围;数据范围（1：全部数据权限 2：自定数据权限 3：本部门数据权限 4：本部门及以下数据权限）&#x27; ,</span><br><span class="line">    MENU_CHECK_STRICTLY VARCHAR(1)    COMMENT &#x27;菜单树选择项是否关联显示;菜单树选择项是否关联显示&#x27; ,</span><br><span class="line">    DEPT_CHECK_STRICTLY VARCHAR(1)    COMMENT &#x27;部门树选择项是否关联显示;部门树选择项是否关联显示&#x27; ,</span><br><span class="line">    STATUS VARCHAR(1)    COMMENT &#x27;角色状态（0正常 1停用）;角色状态（0正常 1停用）&#x27; ,</span><br><span class="line">    DEL_FLAG VARCHAR(1)    COMMENT &#x27;删除标志（0代表存在 2代表删除）;删除标志（0代表存在 2代表删除）&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36)    COMMENT &#x27;租户号;租户号&#x27; ,</span><br><span class="line">    REVISION INT  NOT NULL    COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(36)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(36)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_menu(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID&#x27; ,</span><br><span class="line">    MENU_ID VARCHAR(36) NOT NULL   COMMENT &#x27;菜单编号;菜单编号&#x27; ,</span><br><span class="line">    TENANT_ID VARCHAR(36) NOT NULL   COMMENT &#x27;租户号;租户号&#x27; ,</span><br><span class="line">    MENU_NAME VARCHAR(100) NOT NULL   COMMENT &#x27;菜单名称;菜单名称&#x27; ,</span><br><span class="line">    PARENT_ID VARCHAR(36)    COMMENT &#x27;父菜单ID;父菜单ID&#x27; ,</span><br><span class="line">    ORDER_NUM INT    COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    PATH VARCHAR(100)    COMMENT &#x27;路由地址;路由地址&#x27; ,</span><br><span class="line">    COMPONENT VARCHAR(100)    COMMENT &#x27;组件路径;组件路径&#x27; ,</span><br><span class="line">    QUERY VARCHAR(100)    COMMENT &#x27;路由参数;路由参数&#x27; ,</span><br><span class="line">    IS_FRAME VARCHAR(1)    COMMENT &#x27;是否为外链（0是 1否）;是否为外链（0是 1否）&#x27; ,</span><br><span class="line">    IS_CACHE VARCHAR(1)    COMMENT &#x27;是否缓存（0缓存 1不缓存）;是否缓存（0缓存 1不缓存）&#x27; ,</span><br><span class="line">    MENU_TYPE VARCHAR(32)    COMMENT &#x27;菜单类型（M目录 C菜单 F按钮）;菜单类型（M目录 C菜单 F按钮）&#x27; ,</span><br><span class="line">    VISIBLE VARCHAR(100)    COMMENT &#x27;菜单状态（0显示 1隐藏）;菜单状态（0显示 1隐藏）&#x27; ,</span><br><span class="line">    STATUS VARCHAR(100)    COMMENT &#x27;菜单状态（0正常 1停用）;菜单状态（0正常 1停用）&#x27; ,</span><br><span class="line">    PERMS VARCHAR(100)    COMMENT &#x27;权限标识;权限标识&#x27; ,</span><br><span class="line">    ICON VARCHAR(100)    COMMENT &#x27;菜单图标;菜单图标&#x27; ,</span><br><span class="line">    REVISION INT NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    CREATED_BY VARCHAR(100)    COMMENT &#x27;创建人&#x27; ,</span><br><span class="line">    CREATED_TIME DATETIME    COMMENT &#x27;创建时间&#x27; ,</span><br><span class="line">    UPDATED_BY VARCHAR(100)    COMMENT &#x27;更新人&#x27; ,</span><br><span class="line">    UPDATED_TIME DATETIME    COMMENT &#x27;更新时间&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID,MENU_ID)</span><br><span class="line">)  COMMENT = &#x27;菜单权限表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_user_role(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    USER_ID VARCHAR(36) NOT NULL   COMMENT &#x27;用户ID;用户ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36) NOT NULL   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色关联表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE system_role_menu(</span><br><span class="line">    ID INT NOT NULL AUTO_INCREMENT  COMMENT &#x27;ID;ID&#x27; ,</span><br><span class="line">    ROLE_ID VARCHAR(36) NOT NULL   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    MENU_ID VARCHAR(36) NOT NULL   COMMENT &#x27;菜单ID;菜单ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;角色权限菜单表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自定义用户实现"><a href="#自定义用户实现" class="headerlink" title="自定义用户实现"></a><font style="color:rgb(0, 0, 0);">自定义用户实现</font></h3><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>改造网关实现授权</title>
    <url>/2024/03/14/%E6%94%B9%E9%80%A0%E7%BD%91%E5%85%B3%E5%AE%9E%E7%8E%B0%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>先看下认证授权的过程，认证客户端的认证是最先被认证的，只有先认证客户端可会进行token的认证，而我们不应该把客户端的信息暴漏在外面所以客户端的信息只能通过网关转发的时候注入到请求中</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/27343190/1667726854430-5c1f32f8-d71b-4c75-815c-c75de9cac331.png"></p>
<span id="more"></span>

<h2 id="直接请求认证服务器的流程"><a href="#直接请求认证服务器的流程" class="headerlink" title="直接请求认证服务器的流程"></a>直接请求认证服务器的流程</h2><p>请求<font style="color:rgb(33, 33, 33);">&#x2F;oauth2&#x2F;token 输入表单信息</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132164269-3335ac9d-d4a6-4464-81aa-b9753aae6360.png"></p>
<p><font style="color:rgb(107, 107, 107);"> </font>Authorization设置为Basic Auth</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132230680-00619d4b-b0be-436a-8431-cf863ddfb67c.png"></p>
<p>获得结果</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679132311409-b4aac947-0f53-4d41-a529-549fadb993b5.png"></p>
<p>使用网关转发请求和注入服务的时候，当客户端不能直接提供客户端信息的时候，需要在网关转发时注入</p>
<h2 id="改造网关"><a href="#改造网关" class="headerlink" title="改造网关"></a>改造网关</h2><h3 id="增加局部过滤器"><a href="#增加局部过滤器" class="headerlink" title="增加局部过滤器"></a>增加局部过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoginFilter extends AbstractGatewayFilterFactory&lt;LoginFilter.Config&gt; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private  ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientProperties clientProperties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LoginFilter() &#123;</span><br><span class="line">        super(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Token URL 标识</span><br><span class="line">     */</span><br><span class="line">    private static final String TOKEN_URL_IDENTIFY = &quot;oauth2/token&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public GatewayFilter apply(Config config) &#123;</span><br><span class="line">        return (exchange, chain) -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">                //判断是否是请求token</span><br><span class="line">                String path = request.getURI().getPath();</span><br><span class="line">                if (!StrUtil.containsIgnoreCase(path, TOKEN_URL_IDENTIFY)) &#123;</span><br><span class="line">                    return chain.filter(exchange);</span><br><span class="line">                &#125;</span><br><span class="line">                //TODO:后续可以增加验证码验证</span><br><span class="line">                //注入客户端信息</span><br><span class="line">                ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">                String clientStr =String.format(&quot;%s:%s&quot;,clientProperties.getClientId(),clientProperties.getClientSecret());</span><br><span class="line">                String base = Base64.encode(clientStr);</span><br><span class="line">                addHeader(mutate,&quot;Authorization&quot;,String.format(&quot;Basic %s&quot;,base));</span><br><span class="line">            &#125;catch (UnauthorizedException ex)&#123;</span><br><span class="line">                getErrResponse(exchange, AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED,ex.getMessage()));</span><br><span class="line">            &#125;catch (Exception e) &#123;</span><br><span class="line">                return getErrResponse(exchange, AjaxResult.error(ResponseStatusEnum.SYS_ERROR, e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class Config &#123;</span><br><span class="line">        // 在这里可以定义配置属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addHeader(ServerHttpRequest.Builder mutate, String name, Object value)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueStr = value.toString();</span><br><span class="line">        String valueEncode = valueStr;</span><br><span class="line">        mutate.header(name, valueEncode);</span><br><span class="line">    &#125;</span><br><span class="line">    private Mono&lt;Void&gt; getErrResponse(ServerWebExchange exchange, Object errInfo) &#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">        return response.writeWith(Mono.create(monoSink -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                byte[] bytes = objectMapper.writeValueAsBytes(errInfo);</span><br><span class="line">                DataBuffer dataBuffer = response.bufferFactory().wrap(bytes);</span><br><span class="line">                monoSink.success(dataBuffer);</span><br><span class="line">            &#125; catch (JsonProcessingException jsonProcessingException) &#123;</span><br><span class="line">                log.error(jsonProcessingException.getMessage());</span><br><span class="line">                monoSink.error(jsonProcessingException);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置客户端信息"><a href="#配置客户端信息" class="headerlink" title="配置客户端信息"></a>配置客户端信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RefreshScope</span><br><span class="line">@ConfigurationProperties(prefix = &quot;security.client&quot;)</span><br><span class="line">public class ClientProperties &#123;</span><br><span class="line">    private String clientId;</span><br><span class="line">    private String clientSecret;</span><br><span class="line"></span><br><span class="line">    public String getClientId() &#123;</span><br><span class="line">        return clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClientId(String clientId) &#123;</span><br><span class="line">        this.clientId = clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getClientSecret() &#123;</span><br><span class="line">        return clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setClientSecret(String clientSecret) &#123;</span><br><span class="line">        this.clientSecret = clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">  client:</span><br><span class="line">    clientId: messaging-client</span><br><span class="line">    clientSecret: secret</span><br></pre></td></tr></table></figure>

<h3 id="路由中添加过滤器"><a href="#路由中添加过滤器" class="headerlink" title="路由中添加过滤器"></a>路由中添加过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- id: luck-auth</span><br><span class="line">  uri: lb://luck-auth</span><br><span class="line">  predicates:</span><br><span class="line">    - Path=/auth/**</span><br><span class="line">  filters:</span><br><span class="line">    - StripPrefix=1</span><br><span class="line">    - CacheRequestFilter</span><br><span class="line">    - LoginFilter</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133263303-ffd2f328-09fa-4bd4-9a53-9c5ded039cf4.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133272368-1c2b04a7-f9b0-49ac-90e4-dce9298e5f8d.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679133290397-da9266f6-dd79-4b06-ac87-736203474128.png"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Authorization设置为Basic Auth 的实际操作为在Header中新增一个key为Authorization value为 Basic +base64({clientId}:{clientSecret}) 。这里Basic后面是有一个空格的需要注意。</p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>资源服务器鉴权处理</title>
    <url>/2024/03/15/%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>在oauth2中授权服务器颁发过令牌后，用户就可以对资源进行访问，这时会有一个问题就是需要验证令牌，而前边文章中令牌使用的jwt格式，所以需要一个统一的资源管理器来验证令牌解析令牌</p>
<span id="more"></span>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class BearerTokenAuthenticationFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">	private final AuthenticationManagerResolver&lt;HttpServletRequest&gt; authenticationManagerResolver;</span><br><span class="line"></span><br><span class="line">	private AuthenticationEntryPoint authenticationEntryPoint = new BearerTokenAuthenticationEntryPoint();</span><br><span class="line"></span><br><span class="line">	private AuthenticationFailureHandler authenticationFailureHandler = (request, response, exception) -&gt; &#123;</span><br><span class="line">		if (exception instanceof AuthenticationServiceException) &#123;</span><br><span class="line">			throw exception;</span><br><span class="line">		&#125;</span><br><span class="line">		this.authenticationEntryPoint.commence(request, response, exception);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	private BearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();</span><br><span class="line"></span><br><span class="line">	private AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = new WebAuthenticationDetailsSource();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Construct a &#123;@code BearerTokenAuthenticationFilter&#125; using the provided parameter(s)</span><br><span class="line">	 * @param authenticationManagerResolver</span><br><span class="line">	 */</span><br><span class="line">	public BearerTokenAuthenticationFilter(</span><br><span class="line">			AuthenticationManagerResolver&lt;HttpServletRequest&gt; authenticationManagerResolver) &#123;</span><br><span class="line">		Assert.notNull(authenticationManagerResolver, &quot;authenticationManagerResolver cannot be null&quot;);</span><br><span class="line">		this.authenticationManagerResolver = authenticationManagerResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Construct a &#123;@code BearerTokenAuthenticationFilter&#125; using the provided parameter(s)</span><br><span class="line">	 * @param authenticationManager</span><br><span class="line">	 */</span><br><span class="line">	public BearerTokenAuthenticationFilter(AuthenticationManager authenticationManager) &#123;</span><br><span class="line">		Assert.notNull(authenticationManager, &quot;authenticationManager cannot be null&quot;);</span><br><span class="line">		this.authenticationManagerResolver = (request) -&gt; authenticationManager;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Extract any</span><br><span class="line">	 * &lt;a href=&quot;https://tools.ietf.org/html/rfc6750#section-1.2&quot; target=&quot;_blank&quot;&gt;Bearer</span><br><span class="line">	 * Token&lt;/a&gt; from the request and attempt an authentication.</span><br><span class="line">	 * @param request</span><br><span class="line">	 * @param response</span><br><span class="line">	 * @param filterChain</span><br><span class="line">	 * @throws ServletException</span><br><span class="line">	 * @throws IOException</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		String token;</span><br><span class="line">		try &#123;</span><br><span class="line">			token = this.bearerTokenResolver.resolve(request);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (OAuth2AuthenticationException invalid) &#123;</span><br><span class="line">			this.logger.trace(&quot;Sending to authentication entry point since failed to resolve bearer token&quot;, invalid);</span><br><span class="line">			this.authenticationEntryPoint.commence(request, response, invalid);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (token == null) &#123;</span><br><span class="line">			this.logger.trace(&quot;Did not process request since did not find bearer token&quot;);</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BearerTokenAuthenticationToken authenticationRequest = new BearerTokenAuthenticationToken(token);</span><br><span class="line">		authenticationRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			AuthenticationManager authenticationManager = this.authenticationManagerResolver.resolve(request);</span><br><span class="line">			Authentication authenticationResult = authenticationManager.authenticate(authenticationRequest);</span><br><span class="line">			SecurityContext context = SecurityContextHolder.createEmptyContext();</span><br><span class="line">			context.setAuthentication(authenticationResult);</span><br><span class="line">			SecurityContextHolder.setContext(context);</span><br><span class="line">			if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">				this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authenticationResult));</span><br><span class="line">			&#125;</span><br><span class="line">			filterChain.doFilter(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (AuthenticationException failed) &#123;</span><br><span class="line">			SecurityContextHolder.clearContext();</span><br><span class="line">			this.logger.trace(&quot;Failed to process authentication request&quot;, failed);</span><br><span class="line">			this.authenticationFailureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link BearerTokenResolver&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link DefaultBearerTokenResolver&#125;.</span><br><span class="line">	 * @param bearerTokenResolver the &#123;@code BearerTokenResolver&#125; to use</span><br><span class="line">	 */</span><br><span class="line">	public void setBearerTokenResolver(BearerTokenResolver bearerTokenResolver) &#123;</span><br><span class="line">		Assert.notNull(bearerTokenResolver, &quot;bearerTokenResolver cannot be null&quot;);</span><br><span class="line">		this.bearerTokenResolver = bearerTokenResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationEntryPoint&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link BearerTokenAuthenticationEntryPoint&#125;.</span><br><span class="line">	 * @param authenticationEntryPoint the &#123;@code AuthenticationEntryPoint&#125; to use</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationEntryPoint(final AuthenticationEntryPoint authenticationEntryPoint) &#123;</span><br><span class="line">		Assert.notNull(authenticationEntryPoint, &quot;authenticationEntryPoint cannot be null&quot;);</span><br><span class="line">		this.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationFailureHandler&#125; to use. Default implementation invokes</span><br><span class="line">	 * &#123;@link AuthenticationEntryPoint&#125;.</span><br><span class="line">	 * @param authenticationFailureHandler the &#123;@code AuthenticationFailureHandler&#125; to use</span><br><span class="line">	 * @since 5.2</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationFailureHandler(final AuthenticationFailureHandler authenticationFailureHandler) &#123;</span><br><span class="line">		Assert.notNull(authenticationFailureHandler, &quot;authenticationFailureHandler cannot be null&quot;);</span><br><span class="line">		this.authenticationFailureHandler = authenticationFailureHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the &#123;@link AuthenticationDetailsSource&#125; to use. Defaults to</span><br><span class="line">	 * &#123;@link WebAuthenticationDetailsSource&#125;.</span><br><span class="line">	 * @param authenticationDetailsSource the &#123;@code AuthenticationConverter&#125; to use</span><br><span class="line">	 * @since 5.5</span><br><span class="line">	 */</span><br><span class="line">	public void setAuthenticationDetailsSource(</span><br><span class="line">			AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource) &#123;</span><br><span class="line">		Assert.notNull(authenticationDetailsSource, &quot;authenticationDetailsSource cannot be null&quot;);</span><br><span class="line">		this.authenticationDetailsSource = authenticationDetailsSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JwtAuthenticationProvider的  jwt的主流程处理中心</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class JwtAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line"></span><br><span class="line">	private final Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">	private final JwtDecoder jwtDecoder;</span><br><span class="line"></span><br><span class="line">	private Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt; jwtAuthenticationConverter = new JwtAuthenticationConverter();</span><br><span class="line"></span><br><span class="line">	public JwtAuthenticationProvider(JwtDecoder jwtDecoder) &#123;</span><br><span class="line">		Assert.notNull(jwtDecoder, &quot;jwtDecoder cannot be null&quot;);</span><br><span class="line">		this.jwtDecoder = jwtDecoder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Decode and validate the</span><br><span class="line">	 * &lt;a href=&quot;https://tools.ietf.org/html/rfc6750#section-1.2&quot; target=&quot;_blank&quot;&gt;Bearer</span><br><span class="line">	 * Token&lt;/a&gt;.</span><br><span class="line">	 * @param authentication the authentication request object.</span><br><span class="line">	 * @return A successful authentication</span><br><span class="line">	 * @throws AuthenticationException if authentication failed for some reason</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">		BearerTokenAuthenticationToken bearer = (BearerTokenAuthenticationToken) authentication;</span><br><span class="line">		Jwt jwt = getJwt(bearer);</span><br><span class="line">		AbstractAuthenticationToken token = this.jwtAuthenticationConverter.convert(jwt);</span><br><span class="line">		token.setDetails(bearer.getDetails());</span><br><span class="line">		this.logger.debug(&quot;Authenticated token&quot;);</span><br><span class="line">		return token;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Jwt getJwt(BearerTokenAuthenticationToken bearer) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return this.jwtDecoder.decode(bearer.getToken());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BadJwtException failed) &#123;</span><br><span class="line">			this.logger.debug(&quot;Failed to authenticate since the JWT was invalid&quot;);</span><br><span class="line">			throw new InvalidBearerTokenException(failed.getMessage(), failed);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (JwtException failed) &#123;</span><br><span class="line">			throw new AuthenticationServiceException(failed.getMessage(), failed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">		return BearerTokenAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setJwtAuthenticationConverter(</span><br><span class="line">			Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt; jwtAuthenticationConverter) &#123;</span><br><span class="line">		Assert.notNull(jwtAuthenticationConverter, &quot;jwtAuthenticationConverter cannot be null&quot;);</span><br><span class="line">		this.jwtAuthenticationConverter = jwtAuthenticationConverter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析doFilterInternal方法我们可知：</p>
<ul>
<li>请求会被 BearerTokenAuthenticationFilter 拦截器拦截，通过bearerTokenResolver解析出token字符串如果没有解析出来，则由下一个过滤器处理。如果失败将被AuthenticationEntryPoint统一拦截处理</li>
<li>解析出来则构建一个BearerTokenAuthenticationToken对象。</li>
<li>将HttpServletRequest传递给AuthenticationManagerResolver对象，由它选择出AuthenticationManager对象，然后将 BearerTokenAuthenticationToken传递给AuthenticationManager对象进行认证。AuthenticationManager对象的实现，取决于我们的token对象是JWT还是opaque token</li>
<li>在AuthenticationManager由多个Provider对Authentication进行处理最终返回结果，当对象为jwt时处理对象为JwtAuthenticationProvider，在JwtAuthenticationProvider会先通过jwtDecoder解析jwt字符串，最终对JwtAuthenticationConverter将jwt字符串处理的为AbstractAuthenticationToken</li>
<li>验证失败<ul>
<li>清空 SecurityContextHolder 对象。</li>
<li>交由AuthenticationFailureHandler对象处理。</li>
</ul>
</li>
<li>验证成功<ul>
<li>将 Authentication对象设置到SecurityContextHolder中。</li>
<li>交由余下的过滤器继续处理。</li>
</ul>
</li>
</ul>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>pom文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>ResourceServerConfiguration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableMethodSecurity</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class ResourceServerConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line"></span><br><span class="line">    private final HttpSecurity http;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityFilterChain filterChain() throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .antMatchers(&quot;/actuator/**&quot;, &quot;/v3/api-docs/**&quot;, &quot;/swagger-ui/**&quot;,</span><br><span class="line">                                &quot;/swagger-ui.html&quot;).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                .oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">                        .authenticationEntryPoint(luckAuthenticationEntryPoint())</span><br><span class="line">                        .bearerTokenResolver(new LuckBearerTokenResolver(redisService))</span><br><span class="line">                        .jwt());</span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationConverter jwtAuthenticationConverter() &#123;</span><br><span class="line">        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();</span><br><span class="line">        grantedAuthoritiesConverter.setAuthorityPrefix(&quot;&quot;);</span><br><span class="line">        grantedAuthoritiesConverter.setAuthoritiesClaimName(&quot;authorities&quot;);</span><br><span class="line"></span><br><span class="line">        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();</span><br><span class="line">        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);</span><br><span class="line">        return jwtAuthenticationConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LuckAuthenticationEntryPoint luckAuthenticationEntryPoint() &#123;</span><br><span class="line">        return new LuckAuthenticationEntryPoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return PasswordEncoderFactories.createDelegatingPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;pms&quot;)</span><br><span class="line">    public PermissionHandler permissionHandler() &#123;</span><br><span class="line">        return new PermissionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>异常定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public class LuckAuth2AuthencticationException extends OAuth2AuthenticationException &#123;</span><br><span class="line">    private final String code;</span><br><span class="line"></span><br><span class="line">    public LuckAuth2AuthencticationException(ResponseStatusEnum status) &#123;</span><br><span class="line">        super(new OAuth2Error(status.getMsg()), status.getMsg());</span><br><span class="line">        this.code = status.getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查异常处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LuckAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line">        ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);</span><br><span class="line">        AjaxResult&lt;?&gt; error;</span><br><span class="line">        if(authException instanceof InvalidBearerTokenException)&#123;</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.FAILED_DEPENDENCY);</span><br><span class="line">            error = AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, authException.getMessage());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            error = AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED, authException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpEndpointUtils.writeWithMessageConverters(error, servletServerHttpResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令牌适配器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class LuckBearerTokenResolver implements BearerTokenResolver &#123;</span><br><span class="line"></span><br><span class="line">    private final RedisService redisService;</span><br><span class="line"></span><br><span class="line">    private static final Pattern AUTHORIZATION_PATTERN = Pattern.compile(&quot;^Bearer (?&lt;token&gt;[a-zA-Z0-9-._~+/]+=*)$&quot;,</span><br><span class="line">            Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line">    private boolean allowFormEncodedBodyParameter = false;</span><br><span class="line"></span><br><span class="line">    private boolean allowUriQueryParameter = false;</span><br><span class="line"></span><br><span class="line">    private String bearerTokenHeaderName = HttpHeaders.AUTHORIZATION;</span><br><span class="line"></span><br><span class="line">//    public  LuckBearerTokenResolver(RedisService redisService)&#123;</span><br><span class="line">//        this.redisService = redisService;</span><br><span class="line">//    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String resolve(HttpServletRequest request) &#123;</span><br><span class="line">            final String authorizationHeaderToken = resolveFromAuthorizationHeader(request);</span><br><span class="line">            final String parameterToken = isParameterTokenSupportedForRequest(request)</span><br><span class="line">                    ? resolveFromRequestParameters(request) : null;</span><br><span class="line">            if (authorizationHeaderToken != null) &#123;</span><br><span class="line">                if (parameterToken != null) &#123;</span><br><span class="line">                    final BearerTokenError error = BearerTokenErrors</span><br><span class="line">                            .invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);</span><br><span class="line">                    throw new OAuth2AuthenticationException(error);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return authorizationHeaderToken;</span><br><span class="line">            &#125;</span><br><span class="line">            if (parameterToken != null &amp;&amp; isParameterTokenEnabledForRequest(request)) &#123;</span><br><span class="line">                return parameterToken;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Set if transport of access token using form-encoded body parameter is supported.</span><br><span class="line">     * Defaults to &#123;@code false&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param allowFormEncodedBodyParameter if the form-encoded body parameter is</span><br><span class="line">     *                                      supported</span><br><span class="line">     */</span><br><span class="line">    public void setAllowFormEncodedBodyParameter(boolean allowFormEncodedBodyParameter) &#123;</span><br><span class="line">        this.allowFormEncodedBodyParameter = allowFormEncodedBodyParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set if transport of access token using URI query parameter is supported. Defaults</span><br><span class="line">     * to &#123;@code false&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The spec recommends against using this mechanism for sending bearer tokens, and</span><br><span class="line">     * even goes as far as stating that it was only included for completeness.</span><br><span class="line">     *</span><br><span class="line">     * @param allowUriQueryParameter if the URI query parameter is supported</span><br><span class="line">     */</span><br><span class="line">    public void setAllowUriQueryParameter(boolean allowUriQueryParameter) &#123;</span><br><span class="line">        this.allowUriQueryParameter = allowUriQueryParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set this value to configure what header is checked when resolving a Bearer Token.</span><br><span class="line">     * This value is defaulted to &#123;@link HttpHeaders#AUTHORIZATION&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This allows other headers to be used as the Bearer Token source such as</span><br><span class="line">     * &#123;@link HttpHeaders#PROXY_AUTHORIZATION&#125;</span><br><span class="line">     *</span><br><span class="line">     * @param bearerTokenHeaderName the header to check when retrieving the Bearer Token.</span><br><span class="line">     * @since 5.4</span><br><span class="line">     */</span><br><span class="line">    public void setBearerTokenHeaderName(String bearerTokenHeaderName) &#123;</span><br><span class="line">        this.bearerTokenHeaderName = bearerTokenHeaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String resolveFromAuthorizationHeader(HttpServletRequest request) &#123;</span><br><span class="line">        String authorization = request.getHeader(this.bearerTokenHeaderName);</span><br><span class="line">        if (!StringUtils.startsWithIgnoreCase(authorization, &quot;bearer&quot;)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization);</span><br><span class="line">        if (!matcher.matches()) &#123;</span><br><span class="line">            BearerTokenError error = BearerTokenErrors.invalidToken(&quot;Bearer token is malformed&quot;);</span><br><span class="line">            throw new OAuth2AuthenticationException(error);</span><br><span class="line">        &#125;</span><br><span class="line">        return matcher.group(&quot;token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String resolveFromRequestParameters(HttpServletRequest request) &#123;</span><br><span class="line">        String[] values = request.getParameterValues(&quot;access_token&quot;);</span><br><span class="line">        if (values == null || values.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (values.length == 1) &#123;</span><br><span class="line">            return values[0];</span><br><span class="line">        &#125;</span><br><span class="line">        BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);</span><br><span class="line">        throw new OAuth2AuthenticationException(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isParameterTokenSupportedForRequest(final HttpServletRequest request) &#123;</span><br><span class="line">        return ((&quot;POST&quot;.equals(request.getMethod())</span><br><span class="line">                &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED_VALUE.equals(request.getContentType()))</span><br><span class="line">                || &quot;GET&quot;.equals(request.getMethod()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isParameterTokenEnabledForRequest(final HttpServletRequest request) &#123;</span><br><span class="line">        return ((this.allowFormEncodedBodyParameter &amp;&amp; &quot;POST&quot;.equals(request.getMethod())</span><br><span class="line">                &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED_VALUE.equals(request.getContentType()))</span><br><span class="line">                || (this.allowUriQueryParameter &amp;&amp; &quot;GET&quot;.equals(request.getMethod())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建 token key</span><br><span class="line">     * @param token token</span><br><span class="line">     * @return token key</span><br><span class="line">     */</span><br><span class="line">    private String buildKey(String token) &#123;</span><br><span class="line">        return String.format(&quot;%s:%s:%s&quot;, CacheConstants.TOKEN, OAuth2ParameterNames.ACCESS_TOKEN, token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    oauth2:</span><br><span class="line">      resourceserver:</span><br><span class="line">        jwt:</span><br><span class="line">          issuer-uri: http://192.168.1.186:1067</span><br></pre></td></tr></table></figure>



<h2 id="服务引用统一的资源服务器配置："><a href="#服务引用统一的资源服务器配置：" class="headerlink" title="服务引用统一的资源服务器配置："></a>服务引用统一的资源服务器配置：</h2><p>pom:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.luck.sugar&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;luck-common-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HomeController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;test&quot;)</span><br><span class="line">    @PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;)&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p>先到授权服务器获取token</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304403339-c483e02f-5dc0-44ee-ab67-dd137794d4f8.png"></p>
<p>然后在资源服务器中添加key为<font style="color:rgb(33, 33, 33);">Authorization的headers</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304459217-12582e36-cc83-4a25-80db-d973ec10e1c7.png">接着在token后面加数字1</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679304562201-a7dc64ca-0218-438a-9a16-003074b4e014.png"></p>
<p>抛出异常An error occurred while attempting to decode the Jwt: Signed JWT rejected: Invalid signature</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在资源服务器的流程中有多个扩展点必须的扩展点为</p>
<p>jwtAuthenticationConverter  他定义了权限信息从jwt的那个Claims下取出，之前的授权服务器中将权限信息放入了authorities 所以上面的的例子定义了权限信息从authorities中获取</p>
<p>BearerTokenResolver：提取令牌</p>
<p>AuthenticationManagerResolver ：获取认证中心，一般使用默认的AuthenticationManager</p>
<p>JwtDecoder：他定义了jwt解析，可以结合jwtAuthenticationConverter 完成从缓存中获取权限信息</p>
<p>AuthenticationProvider：身份验证实现，如果身份验证有特殊处理可以增加</p>
<p>AuthenticationEntryPoint:BearerTokenResolver 获取失败的错误提示处理</p>
<p>AuthenticationFailureHandler: 授权失败错误处理</p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>集成Oauth2.1认证中心</title>
    <url>/2024/03/11/%E9%9B%86%E6%88%90Oauth2.1%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>新版本中的springcloud已经将springcloudoauth2包取消掉，oauth2新增了一个spring-authorization-server的项目，在spring-authorization-server下现在已经有3个可用版本，其中0.3.0对应的是jdk11版本， 0.4.0对应的是jdk8版本，1.0版本对应的是jdk17。以下的实例是以jdk11为例</p>
<span id="more"></span>
<h2 id="建立授权服务"><a href="#建立授权服务" class="headerlink" title="建立授权服务"></a>建立授权服务</h2><p>创建服务的过程这里不做赘述，项目需要的pom文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--jdbc--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;!--auth --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-security-oauth2-authorization-server&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">Spring authorization Server</font><font style="color:rgb(18, 18, 18);">的建表文件在：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org/springframework/security/oauth2/server/authorization/oauth2-authorization-consent-schema.sql</span><br><span class="line"></span><br><span class="line">org/springframework/security/oauth2/server/authorization/oauth2-authorization-schema.sql</span><br><span class="line"></span><br><span class="line">org/springframework/security/oauth2/server/authorization/client/oauth2-registered-client-schema.sql</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">Spring Security</font><font style="color:rgb(18, 18, 18);">的建表语句在</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org/springframework/security/core/userdetails/jdbc/users.ddl</span><br></pre></td></tr></table></figure>

<p>总共5张表，这里放出0.3.0版本的sql其他版本需要自己找一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE oauth2_authorization_consent (</span><br><span class="line">    registered_client_id varchar(100) NOT NULL,</span><br><span class="line">    principal_name varchar(200) NOT NULL,</span><br><span class="line">    authorities varchar(1000) NOT NULL,</span><br><span class="line">    PRIMARY KEY (registered_client_id, principal_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">IMPORTANT:</span><br><span class="line">    If using PostgreSQL, update ALL columns defined with &#x27;blob&#x27; to &#x27;text&#x27;,</span><br><span class="line">    as PostgreSQL does not support the &#x27;blob&#x27; data type.</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE oauth2_authorization (</span><br><span class="line">    id varchar(100) NOT NULL,</span><br><span class="line">    registered_client_id varchar(100) NOT NULL,</span><br><span class="line">    principal_name varchar(200) NOT NULL,</span><br><span class="line">    authorization_grant_type varchar(100) NOT NULL,</span><br><span class="line">    attributes blob DEFAULT NULL,</span><br><span class="line">    state varchar(500) DEFAULT NULL,</span><br><span class="line">    authorization_code_value blob DEFAULT NULL,</span><br><span class="line">    authorization_code_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    authorization_code_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    authorization_code_metadata blob DEFAULT NULL,</span><br><span class="line">    access_token_value blob DEFAULT NULL,</span><br><span class="line">    access_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    access_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    access_token_metadata blob DEFAULT NULL,</span><br><span class="line">    access_token_type varchar(100) DEFAULT NULL,</span><br><span class="line">    access_token_scopes varchar(1000) DEFAULT NULL,</span><br><span class="line">    oidc_id_token_value blob DEFAULT NULL,</span><br><span class="line">    oidc_id_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    oidc_id_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    oidc_id_token_metadata blob DEFAULT NULL,</span><br><span class="line">    refresh_token_value blob DEFAULT NULL,</span><br><span class="line">    refresh_token_issued_at timestamp DEFAULT NULL,</span><br><span class="line">    refresh_token_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    refresh_token_metadata blob DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE oauth2_registered_client (</span><br><span class="line">    id varchar(100) NOT NULL,</span><br><span class="line">    client_id varchar(100) NOT NULL,</span><br><span class="line">    client_id_issued_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,</span><br><span class="line">    client_secret varchar(200) DEFAULT NULL,</span><br><span class="line">    client_secret_expires_at timestamp DEFAULT NULL,</span><br><span class="line">    client_name varchar(200) NOT NULL,</span><br><span class="line">    client_authentication_methods varchar(1000) NOT NULL,</span><br><span class="line">    authorization_grant_types varchar(1000) NOT NULL,</span><br><span class="line">    redirect_uris varchar(1000) DEFAULT NULL,</span><br><span class="line">    scopes varchar(1000) NOT NULL,</span><br><span class="line">    client_settings varchar(2000) NOT NULL,</span><br><span class="line">    token_settings varchar(2000) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    username varchar(50)  not null</span><br><span class="line">        primary key,</span><br><span class="line">    password varchar(500) not null,</span><br><span class="line">    enabled  tinyint(1)   not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table authorities</span><br><span class="line">(</span><br><span class="line">    username  varchar(50) not null,</span><br><span class="line">    authority varchar(50) not null,</span><br><span class="line">    constraint ix_auth_username</span><br><span class="line">        unique (username, authority),</span><br><span class="line">    constraint fk_authorities_users</span><br><span class="line">        foreign key (username) references users (username)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1067</span><br><span class="line">spring:</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/oauth2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure>

<h2 id="自定义授权服务器"><a href="#自定义授权服务器" class="headerlink" title="自定义授权服务器"></a>自定义授权服务器</h2><p>在springsecurity5.6以后配置文件为新建Configuration，然后覆盖Bean的形式进行配置，所以这里我们创建配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class AuthorizationServerConfig &#123;</span><br><span class="line">    @Autowired()</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Autowired()</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个Spring security 的过滤器链，默认会配置</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Introspection endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Revocation endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization Server Metadata endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * JWK Set endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 Provider Configuration endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 UserInfo endpoint</span><br><span class="line">     * 这些协议端点，只有配置了他才能够访问的到接口地址（类似mvc的controller）。</span><br><span class="line">     *</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(1)</span><br><span class="line">    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);</span><br><span class="line">        http</span><br><span class="line">                // Redirect to the login page when not authenticated from the</span><br><span class="line">                // authorization endpoint</span><br><span class="line">                .exceptionHandling((exceptions) -&gt; exceptions</span><br><span class="line">                        .authenticationEntryPoint(</span><br><span class="line">                                new LoginUrlAuthenticationEntryPoint(&quot;/login&quot;))</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个也是个Spring Security的过滤器链，用于Spring Security的身份认证。</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(2)</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                // Form login handles the redirect to the login page from the</span><br><span class="line">                // authorization server filter chain</span><br><span class="line">                .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置用户信息，或者配置用户数据来源，主要用于用户的检索。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">//        UserDetails userDetails = User.withDefaultPasswordEncoder()</span><br><span class="line">//                .username(&quot;user&quot;)</span><br><span class="line">//                .password(&quot;password&quot;)</span><br><span class="line">//                .roles(&quot;USER&quot;)</span><br><span class="line">//                .build();</span><br><span class="line">//       return new InMemoryUserDetailsManager();</span><br><span class="line"></span><br><span class="line">        return new JdbcUserDetailsManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * oauth2 用于第三方认证，RegisteredClientRepository 主要用于管理第三方（每个第三方就是一个客户端）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RegisteredClientRepository registeredClientRepository() &#123;</span><br><span class="line">//        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">//                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">//                .clientSecret(&quot;&#123;noop&#125;secret&quot;)</span><br><span class="line">//                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/authorized&quot;)</span><br><span class="line">//                .scope(OidcScopes.OPENID)</span><br><span class="line">//                .scope(&quot;message.read&quot;)</span><br><span class="line">//                .scope(&quot;message.write&quot;)</span><br><span class="line">//                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">//                .build();</span><br><span class="line">//</span><br><span class="line">//        return new InMemoryRegisteredClientRepository(registeredClient);</span><br><span class="line">        return new JdbcRegisteredClientRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于给access_token签名使用。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JWKSource&lt;SecurityContext&gt; jwkSource() &#123;</span><br><span class="line">        KeyPair keyPair = generateRsaKey();</span><br><span class="line">        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        RSAKey rsaKey = new RSAKey.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        JWKSet jwkSet = new JWKSet(rsaKey);</span><br><span class="line">        return new ImmutableJWKSet&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成秘钥对，为jwkSource提供服务。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static KeyPair generateRsaKey() &#123;</span><br><span class="line">        KeyPair keyPair;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            keyPairGenerator.initialize(2048);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationService authorizationService() &#123;</span><br><span class="line">        return new JdbcOAuth2AuthorizationService(jdbcTemplate, registeredClientRepository());</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationConsentService authorizationConsentService() &#123;</span><br><span class="line">        return new JdbcOAuth2AuthorizationConsentService(jdbcTemplate, registeredClientRepository());</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 配置Authorization Server实例</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ProviderSettings providerSettings() &#123;</span><br><span class="line">        return ProviderSettings.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在spring-authorization-server中实现了jdbc模式的可以直接链接数据库进行操作</p>
<h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsManager userDetailsManager;</span><br><span class="line">  @Test</span><br><span class="line">void testSaveUser() &#123;</span><br><span class="line">        UserDetails userDetails = User.builder().passwordEncoder(s -&gt; &quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(s))</span><br><span class="line">                .username(&quot;user&quot;)</span><br><span class="line">                .password(&quot;password&quot;)</span><br><span class="line">                .roles(&quot;ADMIN&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        userDetailsManager.createUser(userDetails);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 UserDetailsManager 创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private RegisteredClientRepository registeredClientRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">    void testSaveClient() &#123;</span><br><span class="line">        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">                .clientSecret(&quot;&#123;bcrypt&#125;&quot; + new BCryptPasswordEncoder().encode(&quot;secret&quot;))</span><br><span class="line">                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">                .redirectUri(&quot;http://127.0.0.1:1069/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">                .redirectUri(&quot;http://127.0.0.1:1069/authorized&quot;)</span><br><span class="line">                .scope(OidcScopes.OPENID).scope(&quot;message.read&quot;)</span><br><span class="line">                .scope(&quot;message.write&quot;)</span><br><span class="line">                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">                .build();</span><br><span class="line">        registeredClientRepository.save(registeredClient);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以registeredClientRepository创建客户端</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开：<a href="http://127.0.0.1:1067/oauth2/authorize?response_type=code&client_id=messaging-client&scope=message.read&redirect_uri=http://127.0.0.1:1067/authorized">http://127.0.0.1:1067/oauth2/authorize?response_type&#x3D;code&amp;client_id&#x3D;messaging-client&amp;scope&#x3D;message.read&amp;redirect_uri&#x3D;http://127.0.0.1:1067/authorized</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678243822906-ab077efe-c963-4e24-a89d-e5fc2beb53e8.png"></p>
<p>输入前面的添加的账号密码</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678243858497-5b68bed5-2d79-48fb-9209-c2e3639c258b.png"></p>
<p>报错了，不过没关系。因为在oath2中第一步是拿到code 拿到code之后才能换取token</p>
<p>我们只要拿到地址栏后面的code信息就好。复制出code信息，打开postman进行post请求</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244026029-0c3c4817-9483-481e-9899-69e8fb636d3b.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244264220-25530875-31db-4c3d-bd62-a4b910934a98.png"></p>
<p>点击访问</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1678244286055-479c09a7-92be-4354-9e80-831a3295a893.png"></p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义密码模式</title>
    <url>/2024/03/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679106524585-028d887a-7d9d-4e18-af56-f2bcdc192049.png"></p>
<p>在官方的说明中我们可以看到OAuth 2.1 废弃了 OAuth 2.0 中的密码模式，只提供了三种授权类型：授权码、刷新令牌、客户端凭证。</p>
<span id="more"></span>
<p>oauth2.1中授权码模式的流程为：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/jpeg/25873401/1679108178925-bf9d2710-85d2-45f0-a277-cfe3fe0595a5.jpeg" alt="画板"></p>
<p>由上图可知我们想要沿用密码模式会有两种方案</p>
<p>1.自定义密码模式   </p>
<p>2.修改授权码模式，自定义授权页面，使用授权页面自动提交获取token。</p>
<h2 id="自定义密码模式："><a href="#自定义密码模式：" class="headerlink" title="自定义密码模式："></a>自定义密码模式：</h2><p>在官网中对自定义配置的描述<img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109031954-9f6a10bf-a4a8-4c0b-9bee-229c07ae5844.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109044969-a5836447-2dc8-4a6c-b58b-dcad2c8d05f7.png"></p>
<p>这里可以看到在授权断点是可以实现自定义的，于是就有了接下来的思路：</p>
<p>直接略过前面的密码验证、用户确认， 直接自定义授权端点。在自定义的端点中处理授权信息，打开</p>
<p>7 <font style="color:rgb(25, 30, 30);">authorizationEndpoint</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679109474910-3209f835-9aba-42bd-b42e-4a60b946d3b3.png"></p>
<p>这里可以看到自定义一个oauth2的授权请求需要定义一个处理器 一个主处理器，但是官方并没有给具体的例子所以需要看下其他授权端点的做法来完成自定义，以code授权的源码为例分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class OAuth2AuthorizationCodeAuthenticationConverter implements AuthenticationConverter &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	@Override</span><br><span class="line">	public Authentication convert(HttpServletRequest request) &#123;</span><br><span class="line">		// grant_type (REQUIRED)</span><br><span class="line">		String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE);</span><br><span class="line">		if (!AuthorizationGrantType.AUTHORIZATION_CODE.getValue().equals(grantType)) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">		MultiValueMap&lt;String, String&gt; parameters = OAuth2EndpointUtils.getParameters(request);</span><br><span class="line"></span><br><span class="line">		// code (REQUIRED)</span><br><span class="line">		String code = parameters.getFirst(OAuth2ParameterNames.CODE);</span><br><span class="line">		if (!StringUtils.hasText(code) ||</span><br><span class="line">				parameters.get(OAuth2ParameterNames.CODE).size() != 1) &#123;</span><br><span class="line">			OAuth2EndpointUtils.throwError(</span><br><span class="line">					OAuth2ErrorCodes.INVALID_REQUEST,</span><br><span class="line">					OAuth2ParameterNames.CODE,</span><br><span class="line">					OAuth2EndpointUtils.ACCESS_TOKEN_REQUEST_ERROR_URI);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// redirect_uri (REQUIRED)</span><br><span class="line">		// Required only if the &quot;redirect_uri&quot; parameter was included in the authorization request</span><br><span class="line">		String redirectUri = parameters.getFirst(OAuth2ParameterNames.REDIRECT_URI);</span><br><span class="line">		if (StringUtils.hasText(redirectUri) &amp;&amp;</span><br><span class="line">				parameters.get(OAuth2ParameterNames.REDIRECT_URI).size() != 1) &#123;</span><br><span class="line">			OAuth2EndpointUtils.throwError(</span><br><span class="line">					OAuth2ErrorCodes.INVALID_REQUEST,</span><br><span class="line">					OAuth2ParameterNames.REDIRECT_URI,</span><br><span class="line">					OAuth2EndpointUtils.ACCESS_TOKEN_REQUEST_ERROR_URI);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">		parameters.forEach((key, value) -&gt; &#123;</span><br><span class="line">			if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.CLIENT_ID) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.CODE) &amp;&amp;</span><br><span class="line">					!key.equals(OAuth2ParameterNames.REDIRECT_URI)) &#123;</span><br><span class="line">				additionalParameters.put(key, value.get(0));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		return new OAuth2AuthorizationCodeAuthenticationToken(</span><br><span class="line">				code, clientPrincipal, redirectUri, additionalParameters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里可以看出Converter的主要作用是对参数整理然后生成一个新得OAuth2AuthorizationCodeAuthenticationToken 对象，接着看下OAuth2AuthorizationCodeAuthenticationToken的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2AuthorizationCodeAuthenticationToken extends OAuth2AuthorizationGrantAuthenticationToken &#123;</span><br><span class="line">	private final String code;</span><br><span class="line">	private final String redirectUri;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Constructs an &#123;@code OAuth2AuthorizationCodeAuthenticationToken&#125; using the provided parameters.</span><br><span class="line">	 *</span><br><span class="line">	 * @param code the authorization code</span><br><span class="line">	 * @param clientPrincipal the authenticated client principal</span><br><span class="line">	 * @param redirectUri the redirect uri</span><br><span class="line">	 * @param additionalParameters the additional parameters</span><br><span class="line">	 */</span><br><span class="line">	public OAuth2AuthorizationCodeAuthenticationToken(String code, Authentication clientPrincipal,</span><br><span class="line">			@Nullable String redirectUri, @Nullable Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">		super(AuthorizationGrantType.AUTHORIZATION_CODE, clientPrincipal, additionalParameters);</span><br><span class="line">		Assert.hasText(code, &quot;code cannot be empty&quot;);</span><br><span class="line">		this.code = code;</span><br><span class="line">		this.redirectUri = redirectUri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Returns the authorization code.</span><br><span class="line">	 *</span><br><span class="line">	 * @return the authorization code</span><br><span class="line">	 */</span><br><span class="line">	public String getCode() &#123;</span><br><span class="line">		return this.code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Returns the redirect uri.</span><br><span class="line">	 *</span><br><span class="line">	 * @return the redirect uri</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	public String getRedirectUri() &#123;</span><br><span class="line">		return this.redirectUri;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是保存参数对象的。</p>
<p>接着再看下主处理的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class OAuth2AuthorizationCodeAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">	private static final String ERROR_URI = &quot;https://datatracker.ietf.org/doc/html/rfc6749#section-5.2&quot;;</span><br><span class="line">	private static final OAuth2TokenType AUTHORIZATION_CODE_TOKEN_TYPE =</span><br><span class="line">			new OAuth2TokenType(OAuth2ParameterNames.CODE);</span><br><span class="line">	private static final OAuth2TokenType ID_TOKEN_TOKEN_TYPE =</span><br><span class="line">			new OAuth2TokenType(OidcParameterNames.ID_TOKEN);</span><br><span class="line">	private final OAuth2AuthorizationService authorizationService;</span><br><span class="line">	private final OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Constructs an &#123;@code OAuth2AuthorizationCodeAuthenticationProvider&#125; using the provided parameters.</span><br><span class="line">	 *</span><br><span class="line">	 * @param authorizationService the authorization service</span><br><span class="line">	 * @param tokenGenerator the token generator</span><br><span class="line">	 * @since 0.2.3</span><br><span class="line">	 */</span><br><span class="line">	public OAuth2AuthorizationCodeAuthenticationProvider(OAuth2AuthorizationService authorizationService,</span><br><span class="line">			OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator) &#123;</span><br><span class="line">		Assert.notNull(authorizationService, &quot;authorizationService cannot be null&quot;);</span><br><span class="line">		Assert.notNull(tokenGenerator, &quot;tokenGenerator cannot be null&quot;);</span><br><span class="line">		this.authorizationService = authorizationService;</span><br><span class="line">		this.tokenGenerator = tokenGenerator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">		OAuth2AuthorizationCodeAuthenticationToken authorizationCodeAuthentication =</span><br><span class="line">				(OAuth2AuthorizationCodeAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">		OAuth2ClientAuthenticationToken clientPrincipal =</span><br><span class="line">				getAuthenticatedClientElseThrowInvalidClient(authorizationCodeAuthentication);</span><br><span class="line">		RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();</span><br><span class="line"></span><br><span class="line">		OAuth2Authorization authorization = this.authorizationService.findByToken(</span><br><span class="line">				authorizationCodeAuthentication.getCode(), AUTHORIZATION_CODE_TOKEN_TYPE);</span><br><span class="line">		if (authorization == null) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line">		OAuth2Authorization.Token&lt;OAuth2AuthorizationCode&gt; authorizationCode =</span><br><span class="line">				authorization.getToken(OAuth2AuthorizationCode.class);</span><br><span class="line"></span><br><span class="line">		OAuth2AuthorizationRequest authorizationRequest = authorization.getAttribute(</span><br><span class="line">				OAuth2AuthorizationRequest.class.getName());</span><br><span class="line"></span><br><span class="line">		if (!registeredClient.getClientId().equals(authorizationRequest.getClientId())) &#123;</span><br><span class="line">			if (!authorizationCode.isInvalidated()) &#123;</span><br><span class="line">				// Invalidate the authorization code given that a different client is attempting to use it</span><br><span class="line">				authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());</span><br><span class="line">				this.authorizationService.save(authorization);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (StringUtils.hasText(authorizationRequest.getRedirectUri()) &amp;&amp;</span><br><span class="line">				!authorizationRequest.getRedirectUri().equals(authorizationCodeAuthentication.getRedirectUri())) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!authorizationCode.isActive()) &#123;</span><br><span class="line">			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// @formatter:off</span><br><span class="line">		DefaultOAuth2TokenContext.Builder tokenContextBuilder = DefaultOAuth2TokenContext.builder()</span><br><span class="line">				.registeredClient(registeredClient)</span><br><span class="line">				.principal(authorization.getAttribute(Principal.class.getName()))</span><br><span class="line">				.providerContext(ProviderContextHolder.getProviderContext())</span><br><span class="line">				.authorization(authorization)</span><br><span class="line">				.authorizedScopes(authorization.getAttribute(OAuth2Authorization.AUTHORIZED_SCOPE_ATTRIBUTE_NAME))</span><br><span class="line">				.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">				.authorizationGrant(authorizationCodeAuthentication);</span><br><span class="line">		// @formatter:on</span><br><span class="line"></span><br><span class="line">		OAuth2Authorization.Builder authorizationBuilder = OAuth2Authorization.from(authorization);</span><br><span class="line"></span><br><span class="line">		// ----- Access token -----</span><br><span class="line">		OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();</span><br><span class="line">		OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">		if (generatedAccessToken == null) &#123;</span><br><span class="line">			OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">					&quot;The token generator failed to generate the access token.&quot;, ERROR_URI);</span><br><span class="line">			throw new OAuth2AuthenticationException(error);</span><br><span class="line">		&#125;</span><br><span class="line">		OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,</span><br><span class="line">				generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),</span><br><span class="line">				generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());</span><br><span class="line">		if (generatedAccessToken instanceof ClaimAccessor) &#123;</span><br><span class="line">			authorizationBuilder.token(accessToken, (metadata) -&gt;</span><br><span class="line">					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, ((ClaimAccessor) generatedAccessToken).getClaims()));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			authorizationBuilder.accessToken(accessToken);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// ----- Refresh token -----</span><br><span class="line">		OAuth2RefreshToken refreshToken = null;</span><br><span class="line">		if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &amp;&amp;</span><br><span class="line">				// Do not issue refresh token to public client</span><br><span class="line">				!clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) &#123;</span><br><span class="line"></span><br><span class="line">			tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();</span><br><span class="line">			OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">			if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) &#123;</span><br><span class="line">				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">						&quot;The token generator failed to generate the refresh token.&quot;, ERROR_URI);</span><br><span class="line">				throw new OAuth2AuthenticationException(error);</span><br><span class="line">			&#125;</span><br><span class="line">			refreshToken = (OAuth2RefreshToken) generatedRefreshToken;</span><br><span class="line">			authorizationBuilder.refreshToken(refreshToken);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// ----- ID token -----</span><br><span class="line">		OidcIdToken idToken;</span><br><span class="line">		if (authorizationRequest.getScopes().contains(OidcScopes.OPENID)) &#123;</span><br><span class="line">			tokenContext = tokenContextBuilder.tokenType(ID_TOKEN_TOKEN_TYPE).build();</span><br><span class="line">			OAuth2Token generatedIdToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">			if (!(generatedIdToken instanceof Jwt)) &#123;</span><br><span class="line">				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">						&quot;The token generator failed to generate the ID token.&quot;, ERROR_URI);</span><br><span class="line">				throw new OAuth2AuthenticationException(error);</span><br><span class="line">			&#125;</span><br><span class="line">			idToken = new OidcIdToken(generatedIdToken.getTokenValue(), generatedIdToken.getIssuedAt(),</span><br><span class="line">					generatedIdToken.getExpiresAt(), ((Jwt) generatedIdToken).getClaims());</span><br><span class="line">			authorizationBuilder.token(idToken, (metadata) -&gt;</span><br><span class="line">					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, idToken.getClaims()));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			idToken = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		authorization = authorizationBuilder.build();</span><br><span class="line"></span><br><span class="line">		// Invalidate the authorization code as it can only be used once</span><br><span class="line">		authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());</span><br><span class="line"></span><br><span class="line">		this.authorizationService.save(authorization);</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; additionalParameters = Collections.emptyMap();</span><br><span class="line">		if (idToken != null) &#123;</span><br><span class="line">			additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">			additionalParameters.put(OidcParameterNames.ID_TOKEN, idToken.getTokenValue());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return new OAuth2AccessTokenAuthenticationToken(</span><br><span class="line">				registeredClient, clientPrincipal, accessToken, refreshToken, additionalParameters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">		return OAuth2AuthorizationCodeAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到token的生成详细信息。</p>
<h3 id="自定义授权扩展"><a href="#自定义授权扩展" class="headerlink" title="自定义授权扩展"></a>自定义授权扩展</h3><p>以此为参展自定义一个模式总共需要三个类</p>
<p>OAuth2PasswordAuthenticationConverter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationConverter  implements AuthenticationConverter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication convert(HttpServletRequest request) &#123;</span><br><span class="line">        // grant_type (REQUIRED)</span><br><span class="line">        String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE);</span><br><span class="line">        if (!AuthorizationGrantType.PASSWORD.getValue().equals(grantType)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, String&gt; parameters = getParameters(request);</span><br><span class="line"></span><br><span class="line">        // username (REQUIRED)</span><br><span class="line">        String username = parameters.getFirst(OAuth2ParameterNames.USERNAME);</span><br><span class="line">        if (StrUtil.isEmpty(username) ||</span><br><span class="line">                parameters.get(OAuth2ParameterNames.USERNAME).size() != 1) &#123;</span><br><span class="line">            throw new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_NOT_EXIST, &quot;username cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // password (REQUIRED)</span><br><span class="line">        String password = parameters.getFirst(OAuth2ParameterNames.PASSWORD);</span><br><span class="line">        if (StrUtil.isEmpty(password) ||</span><br><span class="line">                parameters.get(OAuth2ParameterNames.PASSWORD).size() != 1) &#123;</span><br><span class="line">            throw new LuckOAuth2AuthencticationException(ResponseStatusEnum.PASSWORD_INCORRECT, &quot;password cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; additionalParameters = new HashMap&lt;&gt;();</span><br><span class="line">        parameters.forEach((key, value) -&gt; &#123;</span><br><span class="line">            if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) &amp;&amp;</span><br><span class="line">                    !key.equals(OAuth2ParameterNames.USERNAME) &amp;&amp;</span><br><span class="line">                    !key.equals(OAuth2ParameterNames.PASSWORD)) &#123;</span><br><span class="line">                additionalParameters.put(key, value.get(0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return new OAuth2PasswordAuthenticationToken(username, password, clientPrincipal, additionalParameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MultiValueMap&lt;String, String&gt; getParameters(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; parameters = new LinkedMultiValueMap&lt;&gt;(parameterMap.size());</span><br><span class="line">        parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line">            if (values.length &gt; 0) &#123;</span><br><span class="line">                for (String value : values) &#123;</span><br><span class="line">                    parameters.add(key, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return parameters;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OAuth2PasswordAuthenticationToken</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationToken extends OAuth2AuthorizationGrantAuthenticationToken &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private final String username;</span><br><span class="line">    @Getter</span><br><span class="line">    private final String password;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &#123;@code OAuth2PasswordAuthenticationToken&#125; using the provided parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param username             the username</span><br><span class="line">     * @param password             the password</span><br><span class="line">     * @param clientPrincipal      the authenticated client principal</span><br><span class="line">     * @param additionalParameters the additional parameters</span><br><span class="line">     */</span><br><span class="line">    public OAuth2PasswordAuthenticationToken(String username, String password, Authentication clientPrincipal,</span><br><span class="line">                                                Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">        super(AuthorizationGrantType.PASSWORD, clientPrincipal, additionalParameters);</span><br><span class="line">        Assert.hasText(username, &quot;username cannot be empty&quot;);</span><br><span class="line">        Assert.hasText(password, &quot;password cannot be empty&quot;);</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>OAuth2PasswordAuthenticationProvider</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OAuth2PasswordAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line">    private static final String ERROR_URI = &quot;https://datatracker.ietf.org/doc/html/rfc6749#section-5.2&quot;;</span><br><span class="line">    private final AuthenticationManager authenticationManager;</span><br><span class="line">    private final OAuth2AuthorizationService authorizationService;</span><br><span class="line">    private final OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs an &#123;@code OAuth2PasswordAuthenticationProvider&#125; using the provided parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param authorizationService the authorization service</span><br><span class="line">     * @param tokenGenerator       the token generator</span><br><span class="line">     */</span><br><span class="line">    public OAuth2PasswordAuthenticationProvider(AuthenticationManager authenticationManager,</span><br><span class="line">                                                OAuth2AuthorizationService authorizationService,</span><br><span class="line">                                                OAuth2TokenGenerator&lt;? extends OAuth2Token&gt; tokenGenerator) &#123;</span><br><span class="line">        Assert.notNull(authenticationManager, &quot;authenticationManager cannot be null&quot;);</span><br><span class="line">        Assert.notNull(authorizationService, &quot;authorizationService cannot be null&quot;);</span><br><span class="line">        Assert.notNull(tokenGenerator, &quot;tokenGenerator cannot be null&quot;);</span><br><span class="line">        this.authenticationManager = authenticationManager;</span><br><span class="line">        this.authorizationService = authorizationService;</span><br><span class="line">        this.tokenGenerator = tokenGenerator;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">        OAuth2PasswordAuthenticationToken passwordAuthentication = (OAuth2PasswordAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">        OAuth2ClientAuthenticationToken clientPrincipal = getAuthenticatedClientElseThrowInvalidClient(passwordAuthentication);</span><br><span class="line">        RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();</span><br><span class="line">        Assert.notNull(registeredClient, &quot;registeredClient cannot be null&quot;);</span><br><span class="line"></span><br><span class="line">        if (!registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.PASSWORD)) &#123;</span><br><span class="line">            throw new OAuth2AuthenticationException(OAuth2ErrorCodes.UNAUTHORIZED_CLIENT);</span><br><span class="line">        &#125;</span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;Retrieved registered client&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Attempts to authenticate the passwordAuthentication</span><br><span class="line">        Authentication authenticate = authenticate(passwordAuthentication);</span><br><span class="line"></span><br><span class="line">        DefaultOAuth2TokenContext.Builder tokenContextBuilder = getTokenContextBuilder(passwordAuthentication,</span><br><span class="line">                registeredClient, authenticate);</span><br><span class="line"></span><br><span class="line">        OAuth2Authorization.Builder authorizationBuilder = getAuthorizationBuilder(passwordAuthentication,</span><br><span class="line">                registeredClient);</span><br><span class="line"></span><br><span class="line">        OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();</span><br><span class="line"></span><br><span class="line">        // ----- Access token -----</span><br><span class="line">        OAuth2AccessToken accessToken = getAccessToken(authorizationBuilder, tokenContext);</span><br><span class="line"></span><br><span class="line">        // ----- Refresh token -----</span><br><span class="line">        OAuth2RefreshToken refreshToken = getRefreshToken(clientPrincipal, registeredClient, tokenContextBuilder, authorizationBuilder);</span><br><span class="line"></span><br><span class="line">        return new OAuth2AccessTokenAuthenticationToken(</span><br><span class="line">                registeredClient, clientPrincipal, accessToken, refreshToken, passwordAuthentication.getAdditionalParameters());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Authentication authenticate(OAuth2PasswordAuthenticationToken passwordAuthentication) &#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken token =</span><br><span class="line">                new UsernamePasswordAuthenticationToken(passwordAuthentication.getUsername(),</span><br><span class="line">                        passwordAuthentication.getPassword());</span><br><span class="line">        Authentication authenticate;</span><br><span class="line">        try &#123;</span><br><span class="line">            authenticate = authenticationManager.authenticate(token);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw oAuth2AuthenticationException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return authenticate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static DefaultOAuth2TokenContext.Builder getTokenContextBuilder(</span><br><span class="line">            OAuth2PasswordAuthenticationToken passwordAuthentication,</span><br><span class="line">            RegisteredClient registeredClient,</span><br><span class="line">            Authentication authenticate) &#123;</span><br><span class="line">        return DefaultOAuth2TokenContext.builder()</span><br><span class="line">                .registeredClient(registeredClient)</span><br><span class="line">                .principal(authenticate)</span><br><span class="line">                .providerContext(ProviderContextHolder.getProviderContext())</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.PASSWORD)</span><br><span class="line">                .authorizationGrant(passwordAuthentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static OAuth2Authorization.Builder getAuthorizationBuilder(</span><br><span class="line">            OAuth2PasswordAuthenticationToken passwordAuthentication,</span><br><span class="line">            RegisteredClient registeredClient) &#123;</span><br><span class="line">        return OAuth2Authorization.withRegisteredClient(registeredClient)</span><br><span class="line">                .principalName(passwordAuthentication.getName())</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OAuth2AccessToken getAccessToken(OAuth2Authorization.Builder authorizationBuilder,</span><br><span class="line">                                             OAuth2TokenContext tokenContext) &#123;</span><br><span class="line">        OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">        if (generatedAccessToken == null) &#123;</span><br><span class="line">            OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">                    &quot;The token generator failed to generate the access token.&quot;, ERROR_URI);</span><br><span class="line">            throw new OAuth2AuthenticationException(error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;Generated access token&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,</span><br><span class="line">                generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),</span><br><span class="line">                generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());</span><br><span class="line">        if (generatedAccessToken instanceof ClaimAccessor) &#123;</span><br><span class="line">            authorizationBuilder.token(accessToken, (metadata) -&gt;</span><br><span class="line">                    metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME,</span><br><span class="line">                            ((ClaimAccessor) generatedAccessToken).getClaims()));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            authorizationBuilder.accessToken(accessToken);</span><br><span class="line">        &#125;</span><br><span class="line">        return accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private OAuth2RefreshToken getRefreshToken(OAuth2ClientAuthenticationToken clientPrincipal,</span><br><span class="line">                                               RegisteredClient registeredClient,</span><br><span class="line">                                               DefaultOAuth2TokenContext.Builder tokenContextBuilder,</span><br><span class="line">                                               OAuth2Authorization.Builder authorizationBuilder) &#123;</span><br><span class="line">        OAuth2TokenContext tokenContext;</span><br><span class="line">        OAuth2RefreshToken refreshToken = null;</span><br><span class="line">        if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &amp;&amp;</span><br><span class="line">                // Do not issue refresh token to public client</span><br><span class="line">                !clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) &#123;</span><br><span class="line"></span><br><span class="line">            tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();</span><br><span class="line">            OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);</span><br><span class="line">            if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) &#123;</span><br><span class="line">                OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,</span><br><span class="line">                        &quot;The token generator failed to generate the refresh token.&quot;,ERROR_URI);</span><br><span class="line">                throw new OAuth2AuthenticationException(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Generated refresh token&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            refreshToken = (OAuth2RefreshToken) generatedRefreshToken;</span><br><span class="line">            authorizationBuilder.refreshToken(refreshToken);</span><br><span class="line"></span><br><span class="line">            this.authorizationService.save(authorizationBuilder.build());</span><br><span class="line"></span><br><span class="line">            if (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(&quot;Saved authorization&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">        return OAuth2PasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * OAuth2 认证失败处理器只能处理 OAuth2AuthenticationException，故转换</span><br><span class="line">     *</span><br><span class="line">     * @param authenticationException 身份验证异常</span><br><span class="line">     * @return &#123;@link OAuth2AuthenticationException&#125;</span><br><span class="line">     */</span><br><span class="line">    private OAuth2AuthenticationException oAuth2AuthenticationException(Exception authenticationException) &#123;</span><br><span class="line">        if (authenticationException instanceof UsernameNotFoundException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof BadCredentialsException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.USERNAME_OR_PASSWORD_INCORRECT);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof LockedException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_FROZEN);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof AccountExpiredException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_EXPIRED);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof CredentialsExpiredException) &#123;</span><br><span class="line">            return new LuckOAuth2AuthencticationException(ResponseStatusEnum.PASSWORD_EXPIRED);</span><br><span class="line">        &#125;</span><br><span class="line">        if (authenticationException instanceof InternalAuthenticationServiceException) &#123;</span><br><span class="line">            if (authenticationException.getCause() instanceof DisabledException) &#123;</span><br><span class="line">                return new LuckOAuth2AuthencticationException(ResponseStatusEnum.ACCOUNT_DISABLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new LuckOAuth2AuthencticationException(ResponseStatusEnum.IDENTITY_VERIFICATION_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">    public OAuth2ClientAuthenticationToken getAuthenticatedClientElseThrowInvalidClient(Authentication authentication) &#123;</span><br><span class="line">        OAuth2ClientAuthenticationToken clientPrincipal = null;</span><br><span class="line">        if (OAuth2ClientAuthenticationToken.class.isAssignableFrom(authentication.getPrincipal().getClass())) &#123;</span><br><span class="line">            clientPrincipal = (OAuth2ClientAuthenticationToken) authentication.getPrincipal();</span><br><span class="line">        &#125;</span><br><span class="line">        if (clientPrincipal != null &amp;&amp; clientPrincipal.isAuthenticated()) &#123;</span><br><span class="line">            return clientPrincipal;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_CLIENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果需要自定义claims可以添加一个自定义OAuth2TokenCustomizer</p>
<p>这里以OAuth2TokenCustomizerImpl为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class OAuth2TokenCustomizerImpl implements OAuth2TokenCustomizer&lt;JwtEncodingContext&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void customize(JwtEncodingContext context) &#123;</span><br><span class="line">        JwtClaimsSet.Builder builder = context.getClaims();</span><br><span class="line"></span><br><span class="line">        // 客户端模式不返回具体用户信息</span><br><span class="line">        if (SecurityConstants.CLIENT_CREDENTIALS.equals(context.getAuthorizationGrantType().getValue())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User user = (User) context.getPrincipal().getPrincipal();</span><br><span class="line">        builder.claims((claims) -&gt; &#123;</span><br><span class="line">            claims.put(&quot;username&quot;, user.getUsername());</span><br><span class="line">            claims.put(&quot;authorities&quot;, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toArray());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>自定义鉴权成功或者鉴权失败代码可以参照</p>
<p>DefaultAuthenticationFailureHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAuthenticationFailureHandler implements AuthenticationFailureHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String AUTHENTICATION_METHOD = &quot;authentication_method&quot;;</span><br><span class="line">    private static final String CREDENTIALS = &quot;credentials&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123;</span><br><span class="line">        AjaxResult&lt;?&gt; error = createError(exception);</span><br><span class="line"></span><br><span class="line">            ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);</span><br><span class="line">            servletServerHttpResponse.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(error, servletServerHttpResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 创建 error</span><br><span class="line">         *</span><br><span class="line">         * @param exception /</span><br><span class="line">         * @return /</span><br><span class="line">         */</span><br><span class="line">        private AjaxResult&lt;?&gt; createError(AuthenticationException exception) &#123;</span><br><span class="line">            AjaxResult&lt;?&gt; error = null;</span><br><span class="line"></span><br><span class="line">            if (exception instanceof LuckOAuth2AuthencticationException) &#123;</span><br><span class="line">                error = AjaxResult.error(((LuckOAuth2AuthencticationException) exception).getCode(),</span><br><span class="line">                        exception.getMessage());</span><br><span class="line">            &#125; else if (exception instanceof OAuth2AuthenticationException) &#123;</span><br><span class="line">                OAuth2AuthenticationException oAuth2AuthenticationException= (OAuth2AuthenticationException) exception;</span><br><span class="line">                String errorCode = oAuth2AuthenticationException.getError().getErrorCode();</span><br><span class="line">                String description = oAuth2AuthenticationException.getError().getDescription();</span><br><span class="line">                if (OAuth2ErrorCodes.INVALID_CLIENT.equals(errorCode))&#123;</span><br><span class="line">                    if (StrUtil.isEmpty(description)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, &quot;无效的客户端&quot;);</span><br><span class="line">                    &#125; else if (description.contains(OAuth2ParameterNames.CLIENT_ID)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_NOT_EXIST);</span><br><span class="line">                    &#125; else if (description.contains(AUTHENTICATION_METHOD)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.AUTHORIZATION_DENIED);</span><br><span class="line">                    &#125; else if (description.contains(CREDENTIALS)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_PASSWORD_EMPTY);</span><br><span class="line">                    &#125; else if (description.contains(OAuth2ParameterNames.CLIENT_SECRET)) &#123;</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.CLIENT_PASSWORD_INCORRECT);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                switch (errorCode) &#123;</span><br><span class="line">                    case OAuth2ErrorCodes.UNSUPPORTED_GRANT_TYPE :</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.UNSUPPORTED_GRANT_TYPE);</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_REQUEST : &#123;</span><br><span class="line">                        if (StrUtil.isEmpty(description)) &#123;</span><br><span class="line">                            return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT, &quot;无效的客户端&quot;);</span><br><span class="line">                        &#125; else if (description.contains(OAuth2ParameterNames.GRANT_TYPE)) &#123;</span><br><span class="line">                            return AjaxResult.error(ResponseStatusEnum.GRANT_TYPE_EMPTY);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_GRANT : return AjaxResult.error(ResponseStatusEnum.INVALID_GRANT);</span><br><span class="line">                    case OAuth2ErrorCodes.INVALID_SCOPE : return AjaxResult.error(ResponseStatusEnum.INVALID_SCOPE);</span><br><span class="line">                    case OAuth2ErrorCodes.UNAUTHORIZED_CLIENT :</span><br><span class="line">                        return AjaxResult.error(ResponseStatusEnum.UNAUTHORIZED_CLIENT);</span><br><span class="line">                    default : error = AjaxResult.error(ResponseStatusEnum.USER_LOGIN_ABNORMAL.getCode(),</span><br><span class="line">                            oAuth2AuthenticationException.getError().getErrorCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error = AjaxResult.error(ResponseStatusEnum.USER_LOGIN_ABNORMAL, exception.getLocalizedMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DefaultAuthenticationSuccessHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定响应数据不使用 ResponseData 封装的参数名称</span><br><span class="line">     * Swagger 登录时可用</span><br><span class="line">     */</span><br><span class="line">    private static final String NO_RESPONSE_DATA_PARAM_NAME = &quot;no_response_data&quot;;</span><br><span class="line"></span><br><span class="line">    private final Converter&lt;OAuth2AccessTokenResponse, Map&lt;String, Object&gt;&gt; accessTokenResponseParametersConverter =</span><br><span class="line">            new DefaultOAuth2AccessTokenResponseMapConverter();</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">        OAuth2AccessTokenAuthenticationToken accessTokenAuthentication = (OAuth2AccessTokenAuthenticationToken) authentication;</span><br><span class="line">        OAuth2AccessToken accessToken = accessTokenAuthentication.getAccessToken();</span><br><span class="line">        OAuth2RefreshToken refreshToken = accessTokenAuthentication.getRefreshToken();</span><br><span class="line">        Map&lt;String, Object&gt; additionalParameters = accessTokenAuthentication.getAdditionalParameters();</span><br><span class="line">        OAuth2AccessTokenResponse.Builder builder = OAuth2AccessTokenResponse.withToken(accessToken.getTokenValue())</span><br><span class="line">                .tokenType(accessToken.getTokenType()).scopes(accessToken.getScopes());</span><br><span class="line">        if (accessToken.getIssuedAt() != null &amp;&amp; accessToken.getExpiresAt() != null) &#123;</span><br><span class="line">            builder.expiresIn(ChronoUnit.SECONDS.between(accessToken.getIssuedAt(), accessToken.getExpiresAt()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (refreshToken != null) &#123;</span><br><span class="line">            builder.refreshToken(refreshToken.getTokenValue());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!CollectionUtils.isEmpty(additionalParameters)) &#123;</span><br><span class="line">            builder.additionalParameters(additionalParameters);</span><br><span class="line">        &#125;</span><br><span class="line">        OAuth2AccessTokenResponse accessTokenResponse = builder.build();</span><br><span class="line">        Map&lt;String, Object&gt; tokenResponseParameters = this.accessTokenResponseParametersConverter.convert(accessTokenResponse);</span><br><span class="line">        ServletServerHttpResponse httpResponse = new ServletServerHttpResponse(response);</span><br><span class="line"></span><br><span class="line">        boolean noResponseData = Boolean.parseBoolean(request.getParameter(NO_RESPONSE_DATA_PARAM_NAME));</span><br><span class="line">        if (noResponseData) &#123;</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(tokenResponseParameters, httpResponse);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AjaxResult&lt;Map&lt;String, Object&gt;&gt; responseData = AjaxResult.ok(tokenResponseParameters);</span><br><span class="line">            HttpEndpointUtils.writeWithMessageConverters(responseData, httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然如果你需要自定义获取用户信息重写UserDetailsService，和其他版本的一致就好</p>
<h3 id="自定义配置信息"><a href="#自定义配置信息" class="headerlink" title="自定义配置信息"></a>自定义配置信息</h3><p>当代码逻辑写完之后需要增加配置让代码生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是个Spring security 的过滤器链，默认会配置</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Introspection endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Token Revocation endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OAuth2 Authorization Server Metadata endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * JWK Set endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 Provider Configuration endpoint</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * OpenID Connect 1.0 UserInfo endpoint</span><br><span class="line">     * 这些协议端点，只有配置了他才能够访问的到接口地址（类似mvc的controller）。</span><br><span class="line">     *</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(1)</span><br><span class="line">    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        OAuth2AuthorizationServerConfigurer&lt;HttpSecurity&gt; authorizationServerConfigurer =</span><br><span class="line">                new OAuth2AuthorizationServerConfigurer&lt;&gt;();</span><br><span class="line">        http.apply(authorizationServerConfigurer);</span><br><span class="line">        authorizationServerConfigurer</span><br><span class="line">                .authorizationService(authorizationService())</span><br><span class="line">                .tokenEndpoint(tokenEndpoint-&gt;tokenEndpoint</span><br><span class="line">                                .accessTokenRequestConverter(new OAuth2PasswordAuthenticationConverter())</span><br><span class="line">                                .accessTokenResponseHandler(responseDataAuthenticationSuccessHandler())</span><br><span class="line">                                .errorResponseHandler(authenticationFailureHandler()));</span><br><span class="line">        DefaultSecurityFilterChain chain = http</span><br><span class="line">                .requestMatcher(authorizationServerConfigurer.getEndpointsMatcher())</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt;</span><br><span class="line">                        authorize.anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                .csrf(CsrfConfigurer::disable)</span><br><span class="line">                .build();</span><br><span class="line">        addingAdditionalAuthenticationProvider(http);</span><br><span class="line">        return chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个也是个Spring Security的过滤器链，用于Spring Security的身份认证。</span><br><span class="line">     * @param http</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(2)</span><br><span class="line">    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                // Form login handles the redirect to the login page from the</span><br><span class="line">                // authorization server filter chain</span><br><span class="line">                .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationSuccessHandler responseDataAuthenticationSuccessHandler() &#123;</span><br><span class="line">        return new DefaultAuthenticationSuccessHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AuthenticationFailureHandler authenticationFailureHandler() &#123;</span><br><span class="line">        return new DefaultAuthenticationFailureHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置用户信息，或者配置用户数据来源，主要用于用户的检索。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">//        UserDetails userDetails = User.withDefaultPasswordEncoder()</span><br><span class="line">//                .username(&quot;user&quot;)</span><br><span class="line">//                .password(&quot;password&quot;)</span><br><span class="line">//                .roles(&quot;USER&quot;)</span><br><span class="line">//                .build();</span><br><span class="line">//       return new InMemoryUserDetailsManager();</span><br><span class="line"></span><br><span class="line">        return new OAuth2UserDetailsManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * oauth2 用于第三方认证，RegisteredClientRepository 主要用于管理第三方（每个第三方就是一个客户端）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RegisteredClientRepository registeredClientRepository() &#123;</span><br><span class="line">//        RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">//                .clientId(&quot;messaging-client&quot;)</span><br><span class="line">//                .clientSecret(&quot;&#123;noop&#125;secret&quot;)</span><br><span class="line">//                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">//                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/login/oauth2/code/messaging-client-oidc&quot;)</span><br><span class="line">//                .redirectUri(&quot;http://127.0.0.1:1067/authorized&quot;)</span><br><span class="line">//                .scope(OidcScopes.OPENID)</span><br><span class="line">//                .scope(&quot;message.read&quot;)</span><br><span class="line">//                .scope(&quot;message.write&quot;)</span><br><span class="line">//                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())</span><br><span class="line">//                .build();</span><br><span class="line">//</span><br><span class="line">//        return new InMemoryRegisteredClientRepository(registeredClient);</span><br><span class="line">        return new JdbcRegisteredClientRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public OAuth2AuthorizationService authorizationService()&#123;</span><br><span class="line">        return new OAuth2RedisAuthorizationService(redisService);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 用于给access_token签名使用。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JWKSource&lt;SecurityContext&gt; jwkSource() &#123;</span><br><span class="line">        KeyPair keyPair = generateRsaKey();</span><br><span class="line">        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        RSAKey rsaKey = new RSAKey.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        JWKSet jwkSet = new JWKSet(rsaKey);</span><br><span class="line">        return new ImmutableJWKSet&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成秘钥对，为jwkSource提供服务。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static KeyPair generateRsaKey() &#123;</span><br><span class="line">        KeyPair keyPair;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">            keyPairGenerator.initialize(2048);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置Authorization Server实例</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ProviderSettings providerSettings() &#123;</span><br><span class="line">        return ProviderSettings.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void addingAdditionalAuthenticationProvider(HttpSecurity http) &#123;</span><br><span class="line">        AuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class);</span><br><span class="line">        OAuth2AuthorizationService authorizationService = http.getSharedObject(OAuth2AuthorizationService.class);</span><br><span class="line">        OAuth2TokenGenerator&lt;?&gt; tokenGenerator = http.getSharedObject(OAuth2TokenGenerator.class);</span><br><span class="line"></span><br><span class="line">        OAuth2PasswordAuthenticationProvider passwordAuthenticationProvider =</span><br><span class="line">                new OAuth2PasswordAuthenticationProvider(authenticationManager, authorizationService, tokenGenerator);</span><br><span class="line">        http.authenticationProvider(passwordAuthenticationProvider);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>备注：</p>
<p>registeredClientRepository 客户端信息</p>
<p>authorizationService token新增和处理</p>
<p>providerSettings  访问端点配置 默认为：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1679126686151-d9dce2ff-ee10-4965-9c54-2744170deb62.png"></p>
<p>addingAdditionalAuthenticationProvider</p>
<p><code>OAuth2TokenEndpointConfigurer</code> 并没有提供批量设置 <code>AuthenticationProvider</code> 的方法，即，如果你要同时配置 authorization_code、refresh_token、client_credentials、password 的 <code>AuthenticationProvider</code> 的话，你需要调用多次 <code>accessTokenResponseHandler() </code>但是<code>HttpSecurity</code>提供了一个 <code>authenticationProvider()</code> 可以动态添加 <code>AuthenticationProvider</code></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>新版本的spring-authorization-server不同于原来的oauth2的版本，去除了密码模式，让很多简单的自定义登陆变的很麻烦，但是其中可自定义的地方有很多</p>
<p>Converter ：从访问令牌中获取参数，并格式化</p>
<p>Provider ：主处理器用于生成token以及保存token</p>
<p>AuthorizationService ：保存token信息，获取token信息</p>
<p>ResponseHandler ：返回信息处理</p>
<p>Token：格式化访问信息为Provider提供数据</p>
<p>Customizer ：自定义claims信息数据可以从context.getPrincipal().getPrincipal()中获取</p>
<p>Manager ：自定义获取用户信息逻辑</p>
<p>当然如果你不希望这么麻烦想要更简单的实现登陆，可以自定义<font style="color:rgb(25, 30, 30);">consentPage页面然后在自定义的consentPage中增加脚本自动提交表单获取令牌</font></p>
]]></content>
      <categories>
        <category>授权</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>SpringCloud</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudGateway详解</title>
    <url>/2024/03/25/SpringCloudGateway%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Spring-Cloud-Gateway-的核心功能："><a href="#Spring-Cloud-Gateway-的核心功能：" class="headerlink" title="Spring Cloud Gateway 的核心功能："></a><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway 的核心功能：</font></h2><p><font style="color:rgb(25, 27, 31);">断言（Predicate）：参照 Java8 的新特性Predicate，允许开发人员匹配 HTTP 请求中的任何内容，比如请求头或请求参数，最后根据匹配结果返回一个布尔值。 路由（route）：由ID、目标URI、断言集合和过滤器集合组成。如果聚合断言结果为真，则转发到该路由。 过滤器（filter）：可以在返回请求之前或之后修改请求和响应的内容。</font></p>
<span id="more"></span>
<h2 id="1、路由-Route"><a href="#1、路由-Route" class="headerlink" title="1、路由 Route"></a><font style="color:rgb(25, 27, 31);">1、路由 Route</font></h2><p><font style="color:rgb(25, 27, 31);">Route 主要由 路由id、目标uri、断言集合和过滤器集合组成，那我们简单看看这些属性到底有什么作用。 （1）id：路由标识，要求唯一，名称任意（默认值 uuid，一般不用，需要自定义） （2）uri：请求最终被转发到的目标地址 （3）order： 路由优先级，数字越小，优先级越高 （4）predicates：断言数组，即判断条件，如果返回值是boolean，则转发请求到 uri 属性指定的服务中 （5）filters：过滤器数组，在请求传递过程中，对请求做一些修改</font></p>
<h2 id="2、断言-Predicate"><a href="#2、断言-Predicate" class="headerlink" title="2、断言 Predicate"></a><font style="color:rgb(25, 27, 31);">2、断言 Predicate</font></h2><p><font style="color:rgb(25, 27, 31);">Predicate 来自于 Java8 的借口。Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。 Predicate 可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。Spring Cloud Gateway 内置了许多 Predict，这些 Predict 的源码在 org.springframework.cloud.gateway.handler.predicate 包中，有兴趣可以阅读一下</font></p>
<h2 id="3、过滤器-filter"><a href="#3、过滤器-filter" class="headerlink" title="3、过滤器 filter"></a><font style="color:rgb(25, 27, 31);">3、过滤器 filter</font></h2><p><font style="color:rgb(25, 27, 31);">Gateway 过滤器的生命周期： PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。 POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。 Gateway 过滤器从作用范围可分为两种: GatewayFilter：应用到单个路由或者一个分组的路由上（需要在配置文件中配置） GlobalFilter：应用到所有的路由上（无需配置，全局生效） （1）局部过滤器 GatewayFilter： Spring Cloud Gateway 中内置了许多的局部过滤器；局部过滤器需要在指定路由配置才能生效，默认是不生效的</font></p>
<p><font style="color:rgb(25, 27, 31);">（2）自定义局部过滤器： 虽说内置的过滤器能够解决很多场景，但是难免还是有些特殊需求需要定制一个过滤器，下面就来介绍一下如何自定义局部过滤器。</font></p>
<p><font style="color:rgb(25, 27, 31);">(3) GlobalFilter 全局过滤器： 全局过滤器应用全部路由上，无需开发者配置，Spring Cloud Gateway 也内置了一些全局过滤器。GlobalFilter 的功能其实和 GatewayFilter 是相同的，只是 GlobalFilter 的作用域是所有的路由配置，而不是绑定在指定的路由配置上。多个 GlobalFilter 可以通过 @Order 或者 getOrder() 方法指定执行顺序，order值越小，执行的优先级越高。 注意，由于过滤器有 pre 和 post 两种类型，pre 类型过滤器如果 order 值越小，那么它就应该在pre过滤器链的顶层，post 类型过滤器如果 order 值越小，那么它就应该在 post 过滤器链的底层</font></p>
<p><font style="color:rgb(25, 27, 31);">(4) 过滤器规则（Filter）</font></p>
<p><font style="color:rgb(25, 27, 31);">过滤规则 实例 说明 PrefixPath - PrefixPath&#x3D;&#x2F;app 在请求路径前加上app RewritePath - RewritePath&#x3D;&#x2F;test, &#x2F;app&#x2F;test 访问localhost:9022&#x2F;test,请求会转发到localhost:8001&#x2F;app&#x2F;test SetPath SetPath&#x3D;&#x2F;app&#x2F;{path} 通过模板设置路径，转发的规则时会在路径前增加app，{path}表示原请求路径 RedirectTo 重定向 RemoveRequestHeader 去掉某个请求头信息 注：当配置多个filter时，优先定义的会被调用，剩余的filter将不会生效</font></p>
<h2 id="4、Predicate-断言条件-转发规则-介绍"><a href="#4、Predicate-断言条件-转发规则-介绍" class="headerlink" title="4、Predicate 断言条件(转发规则)介绍"></a><font style="color:rgb(25, 27, 31);">4、Predicate 断言条件(转发规则)介绍</font></h2><p><font style="color:rgb(25, 27, 31);">每一个Predicate的使用，你可以理解为：当满足这种条件后才会被转发，如果是多个，那就是都满足的情况下被转发。</font></p>
<h2 id="Path-方式匹配转发"><a href="#Path-方式匹配转发" class="headerlink" title="Path 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Path 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">通过Path转发示例，我们讲解下上面的两种配置，分别是application.yml以及RouteLocator。</font></p>
<p><font style="color:rgb(25, 27, 31);">配置文件匹配地址转发</font></p>
<p><font style="color:rgb(25, 27, 31);">我们在application.yml配置文件内添加对应的路由配置，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"></span><br><span class="line">application:</span><br><span class="line"></span><br><span class="line">name: spring-cloud-gateway-sample</span><br><span class="line"></span><br><span class="line">cloud:</span><br><span class="line"></span><br><span class="line">gateway:</span><br><span class="line"></span><br><span class="line">routes:</span><br><span class="line"></span><br><span class="line">- id: blog</span><br><span class="line"></span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line"></span><br><span class="line">predicates:</span><br><span class="line"></span><br><span class="line"># 匹配路径转发</span><br><span class="line"></span><br><span class="line">- Path=/api-boot-datasource-switch.html</span><br><span class="line"></span><br><span class="line"># 端口号</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line"></span><br><span class="line">port: 9090</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><strong><font style="color:rgb(25, 27, 31);">先来解释下route的组成部分：</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">id：路由的ID uri：匹配路由的转发地址 predicates：配置该路由的断言，通过PredicateDefinition类进行接收配置。 在上面的配置中，当访问<a href="http://localhost:9090/api-boot-datasource-switch.html%E6%97%B6%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8F%91%E5%88%B0">http://localhost:9090/api-boot-datasource-switch.html时就会被自动转发到</a></font><a href="https://link.zhihu.com/?target=http://blog.xx.com/api-boot-datasource-switch.html"><font style="color:rgb(25, 27, 31);">http://blog.xx.com/api-boot-datasource-switch.html</font></a><font style="color:rgb(25, 27, 31);">，这里要注意完全匹配Path的值时才会进行路由转发。</font></p>
<p><font style="color:rgb(25, 27, 31);">访问效果如下所示：</font></p>
<p><font style="color:rgb(25, 27, 31);">spring-cloud-gateway-path-predicate.png</font></p>
<p><font style="color:rgb(25, 27, 31);">RouteLocator 匹配路径转发</font></p>
<p><font style="color:rgb(25, 27, 31);">在上面的配置中，如果使用RouteLocator方式该怎么进行配置呢？</font></p>
<p><font style="color:rgb(25, 27, 31);">如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RouteLocator routeLocator(RouteLocatorBuilder builder) &#123;</span><br><span class="line">return builder.routes()</span><br><span class="line">.route(&quot;blog&quot;, r -&gt;</span><br><span class="line">r.path(&quot;/api-boot-datasource-switch.html&quot;).uri(&quot;http://blog.xx.com&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="Before-方式匹配转发"><a href="#Before-方式匹配转发" class="headerlink" title="Before 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Before 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">当部署有访问时间限制的接口时，我们可以通过Before Predicate来完成某一个时间点之前允许访问，过时后则不允许转发请求到具体的服务，配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Before=2019-05-01T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，我们允许2019-05-01日凌晨之前通过路由转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">，通过查看org.springframework.cloud.gateway.handler.predicate.BeforeRoutePredicateFactory源码我们发现，Spring Cloud Gateway的Before断言采用的ZonedDateTime进行匹配时间，这里要注意存在时区的问题，需要配置[Asia&#x2F;Shanghai]作为中国时区。</font></p>
<h2 id="After-方式匹配转发"><a href="#After-方式匹配转发" class="headerlink" title="After 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">After 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">After Predicate与Before配置使用一致，匹配某一个时间点之后允许路由转发，如下所示配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- After=2019-04-29T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中允许2019-04-29凌晨之后进行转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">。</font></p>
<h2 id="Between-方式匹配转发"><a href="#Between-方式匹配转发" class="headerlink" title="Between 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Between 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">那如果是一个时间段内允许请求转发，通过Before、After组合配置也可以完成，不过Spring Cloud Gateway还是提供了Between方式，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Between=2019-04-29T00:00:00+08:00[Asia/Shanghai], 2019-05-01T00:00:00+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，允许在2019-04-29日凌晨后 &amp; 2019-05-01凌晨之前请求转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">。</font></p>
<h2 id="Cookie-方式匹配转发"><a href="#Cookie-方式匹配转发" class="headerlink" title="Cookie 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Cookie 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway 还提供了根据Cookie值的方式匹配转发请求，如果请求中所携带的Cookie值与配置的Predicate匹配，那么就可以被允许转发到指定地址，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Cookie=hengboy, leo</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，如果客户端发送请求时携带了”hengboy&#x3D;leo”的Cookie信息，则允许请求转发。</font></p>
<p><strong><font style="color:rgb(25, 27, 31);">测试Cookie方式转发：</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">curl <a href="http://localhost:9090/">http://localhost:9090</a> –cookie “hengboy&#x3D;leo” 通过上面方式我们是可以成功转发请求的，如果我们修改Cookie的值，就会导致无法转发，出现404。</font></p>
<h2 id="Header-方式匹配转发"><a href="#Header-方式匹配转发" class="headerlink" title="Header 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Header 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以根据发送请求的Header信息进行匹配转发，加入我们可以根据X-Request-Id的值进行匹配，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面配置中，如果X-Request-Id的值为数字，那么就可以转发到 </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">，我们通过如下方式进行测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">curl <a href="http://localhost:9090/">http://localhost:9090</a> -H “X-Request-Id:123456” 如果头信息为X-Request-Id:abc时，就会转发失败，出现404。</font></p>
<h2 id="Host-方式匹配转发"><a href="#Host-方式匹配转发" class="headerlink" title="Host 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">Host 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以根据Host主机名进行匹配转发，如果我们的接口只允许\.</font><a href="https://link.zhihu.com/?target=http://xx.com"><font style="color:rgb(25, 27, 31);">http://xx.com</font></a><font style="color:rgb(25, 27, 31);">域名进行访问，那么配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Host=\*\*.xx.com</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">测试如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. curl http://localhost:9090 -H &quot;Host: xx.com&quot; // 匹配</span><br><span class="line">2. curl http://localhost:9090 -H &quot;Host: api.xx.com&quot; // 匹配</span><br><span class="line">3. curl http://localhost:9090 -H &quot;Host: admin.xx.com&quot; // 匹配</span><br><span class="line">4. curl http://localhost:9090 -H &quot;Host: hengboy.com&quot; // 不匹配</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="请求方式-方式匹配转发"><a href="#请求方式-方式匹配转发" class="headerlink" title="请求方式 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">请求方式 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Rest请求风格的接口内往往会存在多种请求方式的接口，如果我们的接口只允许POST请求访问，那么配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Method=POST</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">发送GET请求测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">~ curl <a href="http://localhost:9090/">http://localhost:9090</a></font></p>
<p><font style="color:rgb(25, 27, 31);">{“timestamp”:”2019-04-29T06:27:41.121+0000”,”path”:”&#x2F;“,”status”:404,”error”:”Not Found”,”message”:null} 我们的请求并未被Spring Cloud Gateway进行转发，那么我们再来通过POST请求进行测试：</font></p>
<p><font style="color:rgb(25, 27, 31);">curl -X POST <a href="http://localhost:9090/">http://localhost:9090</a> 是可以被转发到目标地址uri的，不过我的这个博客是OSS部署的，阿里云限制了POST访问，尽管如此我们也证明了可以转发。</font></p>
<p><font style="color:rgb(25, 27, 31);">请求参数 方式匹配转发 Spring Cloud GateWay还支持根据指定的参数进行匹配，Query方式的Predicate也有两种方式匹配情况，如下所示：</font></p>
<p><font style="color:rgb(25, 27, 31);">请求中存在xxx参数 cloud: gateway: routes: - id: blog uri: </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">predicates: - Query&#x3D;xxx 我们通过curl <a href="http://localhost:9090/?xxx%5C=123%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%88%90%E5%8A%9F%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%8C%E5%8F%AA%E8%A6%81%E5%8F%82%E6%95%B0%E5%AD%98%E5%9C%A8xxx%E5%B0%B1%E4%BC%9A%E8%A2%AB%E6%88%90%E5%8A%9F%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%90%A6%E5%88%99%E5%87%BA%E7%8E%B0404%E8%BD%AC%E5%8F%91%E5%A4%B1%E8%B4%A5%E3%80%82">http://localhost:9090\?xxx\=123是可以被成功转发的，只要参数存在xxx就会被成功转发，否则出现404转发失败。</a></font></p>
<p><font style="color:rgb(25, 27, 31);">请求中存在xxx参数且值为zzz cloud: gateway: routes: - id: blog uri: </font><a href="https://link.zhihu.com/?target=http://blog.xx.com"><font style="color:rgb(25, 27, 31);">http://blog.xx.com</font></a><font style="color:rgb(25, 27, 31);">predicates: - Query&#x3D;xxx, zzz 根据上面配置，我们限定了参数xxx必须为zzz时才会被成功转发，否则同样会出现404抓发失败。</font></p>
<p><font style="color:rgb(25, 27, 31);">请求路径 方式匹配转发 Spring Cloud Gateway提供了请求路径变量方式匹配转发，如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Path=/article/&#123;articleId&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">在上面配置中{articleId}是一个路径变量，可以是任意值，匹配&#x2F;article&#x2F;1、&#x2F;article&#x2F;abc等，测试如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ curl http://localhost:9090/article/1 // 匹配</span><br><span class="line">~ curl http://localhost:9090/article/abc // 匹配</span><br><span class="line">~ curl http://localhost:9090/article/1/1 // 不匹配</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="请求IP-方式匹配转发"><a href="#请求IP-方式匹配转发" class="headerlink" title="请求IP 方式匹配转发"></a><font style="color:rgb(25, 27, 31);">请求IP 方式匹配转发</font></h2><p><font style="color:rgb(25, 27, 31);">Spring Cloud Gateway可以限制允许访问接口的客户端IP地址，配置后只对指定IP地址的客户端进行请求转发，配置如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- RemoteAddr=192.168.1.56/24</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<p><font style="color:rgb(25, 27, 31);">在上面我们配置了192.168.1.56&#x2F;24，其中192.168.1.56是客户端的IP地址，而24则是子网掩码。</font></p>
<h2 id="组合示例"><a href="#组合示例" class="headerlink" title="组合示例"></a><font style="color:rgb(25, 27, 31);">组合示例</font></h2><p><font style="color:rgb(25, 27, 31);">相同的Predicate也可以配置多个，请求的转发是必须满足所有的Predicate后才可以进行路由转发，组合使用示例如下所示：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">gateway:</span><br><span class="line">routes:</span><br><span class="line">- id: blog</span><br><span class="line">uri: http://blog.xx.com</span><br><span class="line">predicates:</span><br><span class="line">- Query=author, hengboy</span><br><span class="line">- Query=leo</span><br><span class="line">- Method=GET</span><br><span class="line">- Cookie=hengboy, leo</span><br><span class="line">- Header=X-Request-Id, \d+</span><br><span class="line">- RemoteAddr=192.168.1.56/24</span><br></pre></td></tr></table></figure>

<font style="color:rgb(25, 27, 31);">  
</font>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font style="color:rgb(25, 27, 31);">总结</font></h2><p><font style="color:rgb(25, 27, 31);">本章节讲解了Spring Cloud Gateway的相关谓词、断言基本使用方式，GateWay内部提供了很多种灵活的路由转发规则，在同一个路由内存在多个Predicate时，同时满足规则后请求才会被路由转发。</font></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot项目中引用SpringCloudGateway</title>
    <url>/2024/03/26/springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E7%94%A8SpringCloudGateway/</url>
    <content><![CDATA[<h1 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h1><p>首先我们打开官网可以看到如下的描述：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1672730319068-d939400c-0dc9-466e-ae30-1cff4d5c6783.png"></p>
<span id="more"></span>
<p>SpringCloudGateway旨在提供一种简单而有效的方式来路由到API，并为它们提供跨领域的关注点，例如：安全性、监控&#x2F;度量和弹性。</p>
<!-- more -->
<h1 id="为什么要使用网关"><a href="#为什么要使用网关" class="headerlink" title="为什么要使用网关"></a>为什么要使用网关</h1><p>当我们有多个服务的时候，前端需要访问服务的时候需要在前端维护好这几个服务的路径信息，<font style="color:rgb(0, 0, 0);">这样的架构会有如下几个典型的问题：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">每个微服务都需要配置单独的访问域名，开通外网访问权限，每新增一个服务都需要先让运维人员配置好域名映射</font></li>
<li><font style="color:rgb(1, 1, 1);">客户端需要维护所有微服务的访问地址，试想一下如果微服务有几十几百个呢？</font></li>
<li><font style="color:rgb(1, 1, 1);">当服务需要对接口进行权限控制，必须要认证用户才能调用，那么所有的权限逻辑在服务端都要重新编写一套。</font></li>
</ul>
<p><font style="color:rgb(0, 0, 0);">所以我们需要在微服务之前加一个网关服务，让所有的客户端只要访问网关，网关负责对请求进行转发；将权限校验逻辑放到网关的过滤器中，后端服务不需要再关注权限校验的代码；只需要对外提供一个可供外网访问的域名地址，新增服务后也不需要再让运维人员进行网络配置了，这样上面的架构就变成了通过网关转达到对应的服务</font></p>
<h1 id="如何在springboot项目中引用网关"><a href="#如何在springboot项目中引用网关" class="headerlink" title="如何在springboot项目中引用网关"></a>如何在springboot项目中引用网关</h1><h3 id="增加pom"><a href="#增加pom" class="headerlink" title="增加pom"></a>增加pom</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/25873401/1672731071359-61f824de-4903-44e6-aba3-515a3f594da3.png"></p>
<p>我们从官网可以看到gateway需要的pom项，因为我们的服务都使用nacos所以需要加上nacos的pom项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--nacos--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(85, 86, 102);">由于springcloud2020弃用了</font><a href="https://so.csdn.net/so/search?q=Ribbon&spm=1001.2101.3001.7020">Ribbon</a><font style="color:rgb(85, 86, 102);">，因此Alibaba在2021版本nacos中删除了Ribbon的jar包，因此无法通过lb路由到指定微服务，出现了503情况。</font></p>
<p><font style="color:rgb(85, 86, 102);">所以只需要引入springcloud loadbalancer包即可</font></p>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LuckGatewayApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(LuckGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bootstap-yml"><a href="#bootstap-yml" class="headerlink" title="bootstap.yml"></a>bootstap.yml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1060</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: luck-gateway</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在nacos中建立网关的路由配置"><a href="#在nacos中建立网关的路由配置" class="headerlink" title="在nacos中建立网关的路由配置"></a><font style="color:rgb(1, 1, 1);">在nacos中建立网关的路由配置</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          lowerCaseServiceId: true</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: luck-uid</span><br><span class="line">        uri: lb://luck-uid</span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/uid/**</span><br><span class="line">        filters:</span><br><span class="line">          - StripPrefix=1</span><br></pre></td></tr></table></figure>



<h3 id="配置详解："><a href="#配置详解：" class="headerlink" title="配置详解："></a><font style="color:rgb(0, 0, 0);">配置详解：</font></h3><p><font style="color:rgb(119, 119, 119);">id: 在所有路由定义中需要唯一，不能重复</font><br><font style="color:rgb(119, 119, 119);">uri: lb:&#x2F;&#x2F;**  lb:&#x2F;&#x2F;为固定写法，表示开启负载均衡； ** 即服务在Nacos中注册的名字</font><br><font style="color:rgb(119, 119, 119);">predicates:- Path&#x3D;&#x2F;</font>uid<font style="color:rgb(119, 119, 119);">&#x2F;** 使用”Path Route Predicate Factory”，规则为&#x2F;</font>uid<font style="color:rgb(119, 119, 119);">&#x2F;** 的请求都还转发至微服务</font>luck-uid<font style="color:rgb(119, 119, 119);">中。</font></p>
<p>filters : - StripPrefix &#x3D;1 <strong><font style="color:rgb(77, 77, 77);">若有StripPrefix过滤器时，gateway会根据StripPrefix&#x3D;1所配的值（这里是1）去掉URL路径中的部分前缀</font></strong><font style="color:rgb(77, 77, 77);">（这里去掉一个前缀，即去掉lbs）</font></p>
<p><font style="color:rgb(0, 0, 0);"></font></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud项目使用nacos</title>
    <url>/2024/03/28/%E4%BD%8E%E4%BE%B5%E5%85%A5%E7%9A%84%E7%81%B0%E5%BA%A6%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="设计简介："><a href="#设计简介：" class="headerlink" title="设计简介："></a>设计简介：</h3><p>灰度平台配置的主键是以域名来做主键配置，以域名来关联规则，依托这些规则来判断哪些哪些请求需要走灰度</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/jpeg/25873401/1701237832373-b55015c3-0ea5-468c-bb8f-f849cbc5daba.jpeg" alt="画板"></p>
<span id="more"></span>
<h3 id="为什么要做这个平台"><a href="#为什么要做这个平台" class="headerlink" title="为什么要做这个平台"></a>为什么要做这个平台</h3><p>系统的稳定性，多有2方面造成</p>
<p>1.生产环境运行期间，异常造成的服务宕机，造成的系统不可用。</p>
<p>2.在更新服务时因为准备不足或者遗漏造成的更新时服务不可用。</p>
<p>在第一点上我们可以做好监控和告警，使用容器编排工具自动重启，服务集群来避免。</p>
<p>但是第二点人员干涉较多，很容易出现纰漏，所以构建一个灰度的平台，在系统上线后逐步的将系统开放出去，尽早的发现纰漏减少因为更新系统造成的宕机损失</p>
<h3 id="平台功能与使用场景"><a href="#平台功能与使用场景" class="headerlink" title="平台功能与使用场景"></a>平台功能<font style="color:rgb(47, 48, 52);">与使用场景</font></h3><p>平台包含规则域名管理、规则管理、比例管理。平台与openresty通过redis联动，规则的筛选通过lua脚本来执行。</p>
<p>域名管理：域名的增加、修改、删除、以及全量灰度修改、全量下线</p>
<p>规则灰度：主要配置请求类型，然后根据不同的请求类型获取对应的参数，通过规则类型（大于等于小于包含不等于等符号）来判断请求是否属于灰度</p>
<p>比例灰度：设置请求有多少数据进入灰度，这里需要注意：比例只能从小到大，最低到1%，最高到100%（第一次设置10%那后续只能从10%往上加）</p>
<p>使用场景：</p>
<p>服务A，B更新，创建服务A，B的灰度服务并在nacos的元空间中增加灰度版本，然后增加域名——规则灰度——ip灰度——白名单——公司IP地址；公司网络访问服务测试灰度内容，无异常后，再根据自己的需要配置参数规则匹配或者比例灰度来进行小部分的发布，当然如果对服务很有信息也可以直接更新到线上</p>
<h3 id="为了实现灰度都做了什么"><a href="#为了实现灰度都做了什么" class="headerlink" title="为了实现灰度都做了什么"></a>为了实现灰度都做了什么</h3><p><font style="color:rgb(47, 48, 52);"></font></p>
]]></content>
      <categories>
        <category>灰度平台</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>灰度</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud项目使用nacos</title>
    <url>/2024/03/27/springcloud%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8nacos/</url>
    <content><![CDATA[<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><h2 id="Nacos-融合-Spring-Cloud："><a href="#Nacos-融合-Spring-Cloud：" class="headerlink" title="Nacos 融合 Spring Cloud："></a><font style="color:rgb(36, 41, 46);">Nacos 融合 Spring Cloud：</font></h2><p><a href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html">https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html</a></p>
<span id="more"></span>
<h2 id="Java-SDK："><a href="#Java-SDK：" class="headerlink" title="Java SDK："></a><font style="color:rgb(36, 41, 46);">Java SDK：</font></h2><p><a href="https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html">https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html</a></p>
<h1 id="POM文件引用："><a href="#POM文件引用：" class="headerlink" title="POM文件引用："></a>POM文件引用：</h1><h2 id="父pom"><a href="#父pom" class="headerlink" title="父pom"></a>父pom</h2><p>springcloud，springboot，springcloudalibaba，nacos版本引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">      &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">      &lt;spring-boot.version&gt;2.6.13&lt;/spring-boot.version&gt;</span><br><span class="line">      &lt;spring-cloud.version&gt;2021.0.5&lt;/spring-cloud.version&gt;</span><br><span class="line">      &lt;spring-cloud-alibaba.version&gt;2021.0.4.0&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">      &lt;alibaba.nacos.version&gt;2.1.1&lt;/alibaba.nacos.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;!--统一版本--&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.luck.sugar&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;luck-bom&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- SpringBoot 依赖配置 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- SpringCloud 微服务 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- Alibaba Nacos 配置 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;alibaba.nacos.version&#125;&lt;/version&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">           &lt;!-- Mybatis 依赖配置 --&gt;</span><br><span class="line"></span><br><span class="line">           &lt;!-- SpringCloud Alibaba 微服务 --&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">       &lt;/dependencies&gt;</span><br><span class="line">   &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>因为我们使用了注册中心所以配置不能再使用application.yaml，需要优先级更高的bootstrap文件来找到nacos的配置文件，在springboot2.2以后bootstrap默认是关闭的需要打开才能默认使用bootstrap文件为配置文件，需要在pom文件中添加模块引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- bootstrap 启动器 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="子pom"><a href="#子pom" class="headerlink" title="子pom"></a>子pom</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;!--  spring web --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- spring test --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--nacos--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h1 id="配置文件修改："><a href="#配置文件修改：" class="headerlink" title="配置文件修改："></a>配置文件修改：</h1><p>上节解释了配置文件变化，以下是bootstrap.yml的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 1066</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: luck-uid</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 49.235.122.65:8848</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 49.235.122.65:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: 5e81acf8-7ce3-42fe-b666-878b41d27fca</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="启动类注解添加："><a href="#启动类注解添加：" class="headerlink" title="启动类注解添加："></a>启动类注解添加：</h1><p><font style="color:#bbb529;">@EnableDiscoveryClient</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class LuckUidApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(LuckUidApplication.class, args);</span><br><span class="line">        System.out.println(&quot;(♥◠‿◠)ﾉﾞ  ID服务启动成功   ლ(´ڡ`ლ)ﾞ  \n&quot; +</span><br><span class="line">                &quot; .-------.       .-------.          \n&quot; +</span><br><span class="line">                &quot; | i--------------------i |         \n&quot; +</span><br><span class="line">                &quot; | |                    | |         \n&quot; +</span><br><span class="line">                &quot; \\|   O       O        |/          \n&quot; +</span><br><span class="line">                &quot;   |      /\\           |           \n&quot; +</span><br><span class="line">                &quot;   |     /  \\          |           \n&quot; +</span><br><span class="line">                &quot;   |    \\__/           |           \n&quot; +</span><br><span class="line">                &quot;   |      __-- .        |           \n&quot; +</span><br><span class="line">                &quot;           `-..-&#x27;              &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1670814234495-463d58c8-b5df-4c44-9129-728a4b419988.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1670814281972-0e0c6a3b-0840-43c4-aafc-63de05ef2b20.png"></p>
<h1 id="异常备注："><a href="#异常备注：" class="headerlink" title="异常备注："></a>异常备注：</h1><h3 id="bootstrap-yml未生效：链接地址为-127-0-0-1"><a href="#bootstrap-yml未生效：链接地址为-127-0-0-1" class="headerlink" title="bootstrap.yml未生效：链接地址为 127.0.0.1"></a>bootstrap.yml未生效：链接地址为 127.0.0.1</h3><p>pom未添加spring-cloud-starter-bootstrap，</p>
<p>配置文件格式异常</p>
<h3 id="项目启动完成后没有注册到nacos中："><a href="#项目启动完成后没有注册到nacos中：" class="headerlink" title="项目启动完成后没有注册到nacos中："></a>项目启动完成后没有注册到nacos中：</h3><p>子pom中未引用：spring-cloud-starter-alibaba-nacos-discovery</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>Spring</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID总结</title>
    <url>/2024/04/11/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    <content><![CDATA[<h2 id="分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式-ID，那么我们如何设计它呢？本文将详细讲述分布式-ID-及其生成方案。"><a href="#分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式-ID，那么我们如何设计它呢？本文将详细讲述分布式-ID-及其生成方案。" class="headerlink" title="分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式 ID，那么我们如何设计它呢？本文将详细讲述分布式 ID 及其生成方案。"></a>分布式系统中，我们经常需要对数据、消息等进行唯一标识，这个唯一标识就是分布式 ID，那么我们如何设计它呢？本文将详细讲述分布式 ID 及其生成方案。</h2><h1 id="为什么需要分布式-ID"><a href="#为什么需要分布式-ID" class="headerlink" title="为什么需要分布式 ID"></a>为什么需要分布式 ID</h1><p>目前大部分的系统都已是分布式系统，所以在这种场景的业务开发中，经常会需要唯一 ID 对数据进行标识，比如用户身份标识、消息标识等等。</p>
<span id="more"></span>


<p>并且在数据量达到一定规模后，大部分的系统也需要进行分库分表，这种场景下单库的自增 ID 已达不到我们的预期。所以我们需要分布式 ID 来对各种场景的数据进行唯一标识。</p>
<h1 id="分布式-ID-的特性"><a href="#分布式-ID-的特性" class="headerlink" title="分布式 ID 的特性"></a>分布式 ID 的特性</h1><p><strong>主要特性：</strong></p>
<ul>
<li>全局唯一：分布式 ID 最基本要求，必须全局唯一。</li>
<li>高可用：高并发下要保证 ID 的生成效率，避免影响系统。</li>
<li>易用性：使用简单，可快速接入。</li>
</ul>
<p><strong>除此之外根据不同场景还有：</strong></p>
<ul>
<li>有序性：数据库场景下的主键 ID，有序性可便于数据写入和排序。</li>
<li>安全性：无规则 ID，一般用于避免业务信息泄露场景，如订单量。</li>
</ul>
<h1 id="分布式-ID-常见生成方案"><a href="#分布式-ID-常见生成方案" class="headerlink" title="分布式 ID 常见生成方案"></a>分布式 ID 常见生成方案</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718614981558-bee358fe-b5f6-4890-b69e-9eb60310084d.jpeg" alt="画板"></p>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p><strong>UUID</strong>（Universally Unique Identifier），即通用唯一识别码。UUID 的目的是让分布式系统中的所有元素都能有唯一的识别信息。</p>
<p>UUID 是由128位二进制数组成，通常表示为32个十六进制字符，形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>



<p>这个字符串由五个部分组成，以连字符<code>-</code>分隔开，具体如下：</p>
<table>
<thead>
<tr>
<th align="center">部分</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">时间戳</td>
<td align="center">32 bits</td>
<td>UUID的前32位表示当前的时间戳。</td>
</tr>
<tr>
<td align="center">时钟序列和随机数</td>
<td align="center">16 bits</td>
<td>用于保证在同一时刻生成的UUID的唯一性。</td>
</tr>
<tr>
<td align="center">变体标识</td>
<td align="center">4 bits</td>
<td>标识 UUID 的变体，通常为固定值，表示是由 RFC 4122 定义。</td>
</tr>
<tr>
<td align="center">版本号</td>
<td align="center">4 bits</td>
<td>标识UUID的版本，常见版本有1、3、4和5</td>
</tr>
<tr>
<td align="center">节点</td>
<td align="center">48 bits</td>
<td>在版本 1 中，这部分包含生成 UUID 的计算机的唯一标识。</td>
</tr>
</tbody></table>
<p><strong>主要的 UUID 版本及其生成规则：</strong></p>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">场景</th>
<th>生成规则</th>
</tr>
</thead>
<tbody><tr>
<td align="center">版本 1</td>
<td align="center">基于时间和节点</td>
<td>由当前的时间戳和节点信息生成。包括时间戳、时钟序列、节点标识。</td>
</tr>
<tr>
<td align="center">版本 2</td>
<td align="center">基于DCE安全标识符</td>
<td>类似版本 1，但在时间戳部分包含 POSIX UID&#x2F;GID 信息。</td>
</tr>
<tr>
<td align="center">版本 3</td>
<td align="center">基于名字和散列值（MD5 版）</td>
<td>由命名空间和名字的MD5散列生成。</td>
</tr>
<tr>
<td align="center">版本 4</td>
<td align="center">完全随机生成</td>
<td>通过随机或伪随机生成128位数字。</td>
</tr>
<tr>
<td align="center">版本 5</td>
<td align="center">基于名字和散列值（SHA-1 版）</td>
<td>通过随机或伪随机生成128位数字。</td>
</tr>
</tbody></table>
<p><strong>Java中 UUID 对版本 4 进行了实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认版本 4</span></span><br><span class="line">    System.out.println(UUID.randomUUID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本 3，由命名空间和名字的MD5散列生成，相同命名空间结果相同</span></span><br><span class="line">    <span class="comment">// 如下，&quot;fuxing&quot;返回的UUID一直为8b9b6bc3-90c8-37ef-bbef-0ed0c552718f</span></span><br><span class="line">    System.out.println(UUID.nameUUIDFromBytes(<span class="string">&quot;fuxing&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong>本地生成，没有网络消耗，性能非常高。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>占用空间大，32 个字符串，128 位。</li>
<li>不安全：版本 1 可能会造成 mac 地址泄露。</li>
<li>无序，非自增。</li>
<li>机器时间不对，可能造成 UUID 重复。</li>
</ul>
<h2 id="数据库自增-ID"><a href="#数据库自增-ID" class="headerlink" title="数据库自增 ID"></a>数据库自增 ID</h2><p>实现简单，解释通过数据库表中的主键 ID 自增来生成唯一标识。如下，维护一个 MySQL 表来生成 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `unique_id` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `value` char(10) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当需要生成分布式 ID 时，向表中插入数据并返回主键 ID，这里 value 无含义，只是为了占位，方便插入数据。</p>
<p><strong>优点：</strong>实现简单，基本满足业务需求，且天然有序。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>那么有没有办法解决数据库自增 ID 的缺点呢？</p>
<p>通过水平拆分的方案，将表设置到不同的数据库中，设置不同的起始值和步长，这样可以有效的生成集群中的唯一 ID，也大大降低 ID 生成数据库操作的负载，示例如下。</p>
<p><code>&lt;font style=&quot;color:rgb(62, 62, 62);&quot;&gt;unique_id_1&lt;/font&gt;</code><font style="color:rgb(62, 62, 62);">配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>

<p><code>&lt;font style=&quot;color:rgb(62, 62, 62);&quot;&gt;unique_id_2&lt;/font&gt;</code><font style="color:rgb(62, 62, 62);">配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>



<p>这个还是需要根据自己的业务需求来，水平扩展的集群数量要符合自己的数据量，因为当设置的集群数量不足以满足高并发时，再次进行扩容集群会很麻烦。多台机器的起始值和步长都需要重新配置。</p>
<h2 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h2><p>号段模式是当下分布式 ID 生成器的主流实现方式之一，比如美团 Leaf-segment、滴滴 Tinyid、微信序列号等都使用的该方案，下面的大厂中间件中会展开说明。</p>
<p>号段模式也是基于数据库的自增 ID，数据库自增 ID 是一次性获取一个分布式 ID，**<font style="color:#5C8D07;">号段模式可以理解成从数据库批量获取 ID，然后将 ID 缓存在本地</font>**，以此来提高业务获取 ID 的效率。</p>
<p>例如，每次从数据库获取 ID 时，获取一个号段，如(1,1000]，这个范围表示 1000 个 ID，业务应用在请求获取 ID 时，只需要在本地从 1 开始自增并返回，而不用每次去请求数据库，一直到本地自增到 1000 时，才去数据库重新获取新的号段，后续流程循环往复。</p>
<p>表结构可进行如下设计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `id_generator` (</span><br><span class="line">  `id` int(10) NOT NULL,</span><br><span class="line">  `max_id` bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  `step` int(10) NOT NULL COMMENT &#x27;号段的步长&#x27;,</span><br><span class="line">  `version` int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  `biz_type` int(20) NOT NULL COMMENT &#x27;业务场景&#x27;,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>



<p>其中<code>max_id</code>和<code>step</code>用于获取批量的 ID，<code>version</code>是一个乐观锁，保证并发时数据的正确性。</p>
<p>比如，我们新增一条表数据如下。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">max_id</th>
<th align="center">step</th>
<th align="center">version</th>
<th align="center">biz_type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">100</td>
<td align="center">1000</td>
<td align="center">0</td>
<td align="center">001</td>
</tr>
</tbody></table>
<p>然后我们可以使用该号段批量生成的 ID，当<code>max_id = 1000</code>，则执行 update 操作生成新的号段。新的号段的 SQL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE </span><br><span class="line">id_generator </span><br><span class="line">SET </span><br><span class="line">max_id = #&#123;max_id+ step&#125;, </span><br><span class="line">version = version + 1 </span><br><span class="line">WHERE </span><br><span class="line">version = #&#123;version&#125; AND biz_type = 001;</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong>ID 有序递增、存储消耗空间小。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>缺点同样可以通过集群的方式进行优化，也可以如Tinyid 采用双缓存进行优化，下面的大厂中间件中会展开说明。</p>
<h2 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h2><p>当使用数据库来生成 ID 性能不够的时候，可以尝试使用 Redis 来生成 ID。原理则是利用 Redis 的原子操作 INCR 和 INCRBY 来实现。</p>
<p><strong>命令示例：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>命令</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>INCR</strong></td>
<td>让一个整形的key自增1</td>
<td>:::tips redis&gt; <font style="color:#E8323C;">SET</font> mykey “10”<br/>“OK”<br/>redis&gt; <font style="color:#E8323C;">INCR</font> mykey<br/>(integer) 11<br/>:::</td>
</tr>
<tr>
<td align="center"><strong>INCRBY</strong></td>
<td>让一个整形的key自增并指定步长</td>
<td>:::tips redis&gt; <font style="color:#E8323C;">SET</font> mykey “10”<br/>“OK”<br/>redis&gt; <font style="color:#E8323C;">INCRBY</font> mykey 5<br/>(integer) 15<br/>:::</td>
</tr>
</tbody></table>
<p><strong>优点：</strong>不依赖于数据库，使用灵活，支持高并发。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>系统须引入 Redis 数据库。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li><font style="color:rgb(25, 27, 31);">Redis 出现单点故障问题，可能会丢数据导致 ID 重复</font>。</li>
</ul>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法（Snowflake）是 twitter 公司内部分布式项目采用的 ID 生成算法。结果是一个 long 型的 ID。Snowflake 算法将 64bit 划分为多段，分开来标识机器、时间等信息，具体组成结构如下图所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718695293290-53f569fe-4b3d-4e3b-8161-804a80c69b7a.jpeg" alt="画板"></p>
<p><strong>结构说明：</strong></p>
<table>
<thead>
<tr>
<th align="center">结构</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">符号位</td>
<td align="center">1 bit</td>
<td>0 表示正数，1 表示负数。</td>
</tr>
<tr>
<td align="center">时间戳</td>
<td align="center">41 bits</td>
<td>存储的是<code>当前时间戳 - 开始时间戳</code>，最长 69 年。</td>
</tr>
<tr>
<td align="center">机器位</td>
<td align="center">10 bits</td>
<td>前 5位 datacenterId，后 5 位 workerId ，最多表示 1024 台。</td>
</tr>
<tr>
<td align="center">序列号</td>
<td align="center">12 bits</td>
<td>毫秒内的流水号，意味着每个节点在每毫秒可以产生 4096 个 ID。</td>
</tr>
</tbody></table>
<p><strong>优点：</strong></p>
<p>稳定性高，不依赖于数据库等第三方系统。</p>
<p>使用灵活方便，可以根据业务需求的特性来调整算法中的 bit 位。</p>
<p>单机上 ID 单调自增，毫秒数在高位，自增序列在低位，整体上按照时间自增排序。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，可能导致发号重复或者服务处于不可用状态。</li>
<li>ID 可能不是全局递增，虽然 ID 在单机上是递增的。</li>
<li><font style="color:rgb(25, 27, 31);">Redis 出现单点故障问题，可能会丢数据导致 ID 重复</font>。</li>
</ul>
<p>当我们选择了雪花算法可以参考<font style="color:rgb(47, 48, 52);">shardingsphere的雪花算法，以此为例来写一个starter</font></p>
<p><font style="color:rgb(47, 48, 52);">定义接口</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultIdGenerator implements IdGenerator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long nextId() &#123;</span><br><span class="line">        Comparable&lt;?&gt; key=  IDUtils.generateKey();</span><br><span class="line">        return (Long) key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义雪花算法实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.fbb.pomelo.id.utils;</span><br><span class="line"></span><br><span class="line">import com.google.common.base.Preconditions;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import lombok.experimental.UtilityClass;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.net.NetworkInterface;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@UtilityClass</span><br><span class="line">public final class IDUtils &#123;</span><br><span class="line">    public static final long EPOCH;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_BITS = 12L;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_BITS = 10L;</span><br><span class="line"></span><br><span class="line">    private static final long SEQUENCE_MASK = (1 &lt;&lt; SEQUENCE_BITS) - 1;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_LEFT_SHIFT_BITS = SEQUENCE_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long TIMESTAMP_LEFT_SHIFT_BITS = WORKER_ID_LEFT_SHIFT_BITS + WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID_MAX_VALUE = 1L &lt;&lt; WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line">    private static final long WORKER_ID = 0;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_VIBRATION_VALUE = 1;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS = 10;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    private static TimeService timeService = new TimeService();</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    private Properties properties = new Properties();</span><br><span class="line"></span><br><span class="line">    private int sequenceOffset = -1;</span><br><span class="line"></span><br><span class="line">    private long sequence;</span><br><span class="line"></span><br><span class="line">    private long lastMilliseconds;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(2016, Calendar.NOVEMBER, 1);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, 0);</span><br><span class="line">        calendar.set(Calendar.MINUTE, 0);</span><br><span class="line">        calendar.set(Calendar.SECOND, 0);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, 0);</span><br><span class="line">        EPOCH = calendar.getTimeInMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized Comparable&lt;?&gt; generateKey() &#123;</span><br><span class="line">        long currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">        if (waitTolerateTimeDifferenceIfNeed(currentMilliseconds)) &#123;</span><br><span class="line">            currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        if (lastMilliseconds == currentMilliseconds) &#123;</span><br><span class="line">            if (0L == (sequence = (sequence + 1) &amp; SEQUENCE_MASK)) &#123;</span><br><span class="line">                currentMilliseconds = waitUntilNextTime(currentMilliseconds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            vibrateSequenceOffset();</span><br><span class="line">            sequence = sequenceOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        lastMilliseconds = currentMilliseconds;</span><br><span class="line">        return ((currentMilliseconds - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (getWorkerId() &lt;&lt; WORKER_ID_LEFT_SHIFT_BITS) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    private boolean waitTolerateTimeDifferenceIfNeed(final long currentMilliseconds) &#123;</span><br><span class="line">        if (lastMilliseconds &lt;= currentMilliseconds) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeDifferenceMilliseconds = lastMilliseconds - currentMilliseconds;</span><br><span class="line">        Preconditions.checkState(timeDifferenceMilliseconds &lt; getMaxTolerateTimeDifferenceMilliseconds(),</span><br><span class="line">                &quot;Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds&quot;, lastMilliseconds, currentMilliseconds);</span><br><span class="line">        Thread.sleep(timeDifferenceMilliseconds);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getWorkerId() &#123;</span><br><span class="line">        long result = Long.valueOf(properties.getProperty(&quot;worker.id&quot;, String.valueOf(WORKER_ID)));</span><br><span class="line">        if (result &lt;= 0L)&#123;</span><br><span class="line">            result = generateWorkerId();</span><br><span class="line">        &#125;</span><br><span class="line">        Preconditions.checkArgument(result &gt;= 0L &amp;&amp; result &lt; WORKER_ID_MAX_VALUE);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxVibrationOffset() &#123;</span><br><span class="line">        int result = Integer.parseInt(properties.getProperty(&quot;max.vibration.offset&quot;, String.valueOf(DEFAULT_VIBRATION_VALUE)));</span><br><span class="line">        Preconditions.checkArgument(result &gt;= 0 &amp;&amp; result &lt;= SEQUENCE_MASK, &quot;Illegal max vibration offset&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxTolerateTimeDifferenceMilliseconds() &#123;</span><br><span class="line">        return Integer.valueOf(properties.getProperty(&quot;max.tolerate.time.difference.milliseconds&quot;, String.valueOf(MAX_TOLERATE_TIME_DIFFERENCE_MILLISECONDS)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long waitUntilNextTime(final long lastTime) &#123;</span><br><span class="line">        long result = timeService.getCurrentMillis();</span><br><span class="line">        while (result &lt;= lastTime) &#123;</span><br><span class="line">            result = timeService.getCurrentMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void vibrateSequenceOffset() &#123;</span><br><span class="line">        sequenceOffset = sequenceOffset &gt;= getMaxVibrationOffset() ? 0 : sequenceOffset + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long generateWorkerId() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return generateWorkerIdBaseOnMac();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return generateRandomWorkerId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * randomly generate one as workerId</span><br><span class="line">     * @return workerId</span><br><span class="line">     */</span><br><span class="line">    private long generateRandomWorkerId() &#123;</span><br><span class="line">        return new Random().nextInt((int)WORKER_ID_MAX_VALUE + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * use lowest 10 bit of available MAC as workerId</span><br><span class="line">     * @return workerId</span><br><span class="line">     * @throws Exception when there is no available mac found</span><br><span class="line">     */</span><br><span class="line">    private long generateWorkerIdBaseOnMac() throws Exception &#123;</span><br><span class="line">        Enumeration&lt;NetworkInterface&gt; all = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        while (all.hasMoreElements()) &#123;</span><br><span class="line">            NetworkInterface networkInterface = all.nextElement();</span><br><span class="line">            boolean loopBack = networkInterface.isLoopback();</span><br><span class="line">            boolean isVirtual = networkInterface.isVirtual();</span><br><span class="line">            if (loopBack || isVirtual) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] mac = networkInterface.getHardwareAddress();</span><br><span class="line">            return ((mac[4] &amp; 0B11) &lt;&lt; 8) | (mac[5] &amp; 0xFF);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(&quot;no available mac found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取随机ID</span><br><span class="line">     * @return 随机ID用以替代传统的UUID</span><br><span class="line">     */</span><br><span class="line">    public String get32UUID() &#123;</span><br><span class="line">        ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">        return (new UUID(random.nextLong(), random.nextLong())).toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TimeService &#123;</span><br><span class="line">    public long getCurrentMillis() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class IdAutoConfiguration &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 注入ID生成器实现</span><br><span class="line">     * @return see &#123;@link DefaultIdGenerator&#125;</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public IdGenerator idGenerator() &#123;</span><br><span class="line">        return new DefaultIdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>META-INF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">     com.fbb.pomelo.id.configuration.IdAutoConfiguration</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="大厂中间件"><a href="#大厂中间件" class="headerlink" title="大厂中间件"></a>大厂中间件</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/jpeg/3003575/1718614818789-89d8afe6-37ff-4335-a746-1aea25018e23.jpeg" alt="画板"></p>
<h2 id="美团-Leaf"><a href="#美团-Leaf" class="headerlink" title="美团 Leaf"></a><font style="color:rgb(88, 90, 90);">美团 Leaf</font></h2><p><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html">Leaf 的官方文档</a>，简介和特性可访问了解，这里我将对 Leaf 的两种方案，Leaf segment 和 Leaf-snowflake 进行。</p>
<h3 id="Leaf-segment"><a href="#Leaf-segment" class="headerlink" title="Leaf segment"></a>Leaf segment</h3><p>基于数据库号段模式的 ID 生成方案，上面我们介绍到普通的号段模式有一些缺点：</p>
<ul>
<li>数据库自身的单点故障和数据一致性问题。</li>
<li>不安全，比如可根据自增来判断订单量。</li>
<li>高并发场景可能会受限于数据库瓶颈。</li>
</ul>
<p>那么 Leaf 是如何做的呢？Leaf 采用了预分发的方式生成ID，也就是在 DB 之上挂 n 个 Leaf Server，每个Server启动时，都会去 DB 拿固定长度的 ID List。</p>
<p>这样就做到了完全基于分布式的架构，同时因为ID是由内存分发，所以也可以做到很高效，处理流程图如下：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718698426441-afdf835d-f486-4d25-b783-42521191ff2b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Leaf"></p>
<p><strong>其中：</strong></p>
<ul>
<li>Leaf Server 1：从 DB 加载号段[1，1000]。</li>
<li>Leaf Server 2：从 DB 加载号段[1001，2000]。</li>
<li>Leaf Server 3：从 DB 加载号段[2001，3000]。</li>
</ul>
<p>用户**<font style="color:#5C8D07;">通过轮询的方式</font>**调用 Leaf Server 的各个服务，所以某一个 Client 获取到的ID序列可能是：1，1001，2001，2，1002，2002。当某个 Leaf Server 号段用完之后，下一次请求就会从 DB 中加载新的号段，这样保证了每次加载的号段是递增的。</p>
<p>为了解决在更新DB号段的时出现的耗时和阻塞服务的问题，Leaf 采用了**<font style="color:#5C8D07;">异步更新</font>**的策略，同时通过双缓存的方式，保证无论何时DB出现问题，都能有一个 Buffer 的号段可以正常对外提供服务，只要 DB 在一个 Buffer 的下发的周期内恢复，就不会影响整个 Leaf 的可用性。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718698969771-dbe0fd2a-5501-44d0-8db1-2c250de2b7d9.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Leaf"></p>
<p>除此之外，Leaf 还**<font style="color:#5C8D07;">通过动态调整步长</font>**，解决由于步长固定导致的缓存中的 ID 被过快消耗问题，以及步长设置过大导致的号段 ID 跨度过大问题，具体公式可去官方文档中了解。</p>
<p>对于数据一致性问题，Leaf 目前是通过中间件 Zebra 加 MHA 做的主从切换。</p>
<h3 id="Leaf-Snowflake"><a href="#Leaf-Snowflake" class="headerlink" title="Leaf Snowflake"></a>Leaf Snowflake</h3><p>Leaf-snowflake 方案沿用 Snowflake 方案的 bit 位设计。</p>
<p>对于 workerID 的分配：当服务集群较小时，通过配置即可；服务集群较大时，基于 zookeeper 持久顺序节点的特性引入 zookeeper 组件配置 workerID。架构如下图所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/3003575/1718699670231-b390838f-2dd5-4e13-a52d-f446cb8fd6dc.webp?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10"></p>
<h2 id="百度-UidGenerator"><a href="#百度-UidGenerator" class="headerlink" title="百度 UidGenerator"></a>百度 UidGenerator</h2><p><a href="https://github.com/baidu/uid-generator">开源地址</a></p>
<p>UidGenerator 方案是基于 Snowflake 算法的 ID 生成器，其对雪花算法的 bit 位的分配做了微调。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/3003575/1718700335302-7c7d4146-8057-464e-af50-6e39a5c6d527.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_25,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10"></p>
<hr>
<p><strong>结构说明（参数可在 Spring Bean 配置中进行配置）：</strong></p>
<table>
<thead>
<tr>
<th>结构</th>
<th align="center">大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>符号位</td>
<td align="center">1 bit</td>
<td><font style="color:rgb(37, 43, 58);">最高位始终是 0。</font></td>
</tr>
<tr>
<td>增量秒</td>
<td align="center"><font style="color:rgb(37, 43, 58);">28</font> bits</td>
<td>表示自客户纪元（2016-05-20）以来的增量秒。最大时间为 8.7 年。</td>
</tr>
<tr>
<td>工作节点</td>
<td align="center">22 bits</td>
<td>表示工作节点 ID，最大值为 4.2 百万个。</td>
</tr>
<tr>
<td>序列号</td>
<td align="center">13 bits</td>
<td>表示一秒钟内的序列，默认情况下每秒最多 8192 个。</td>
</tr>
</tbody></table>
<p>UidGenerator 方案包含两种实现方式，DefaultUidGenerator 和 CachedUidGenerator ，性能要求高的情况下推荐 CachedUidGenerator。</p>
<h2 id="滴滴-Tinyid"><a href="#滴滴-Tinyid" class="headerlink" title="滴滴 Tinyid"></a>滴滴 Tinyid</h2><p><a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">Tinyid 官方文档</a></p>
<p>Tinyid 方案是在 Leaf-segment 的算法基础上升级而来，不仅支持了数据库多主节点模式，还提供了 tinyid-client 客户端的接入方式，使用起来更加方便。</p>
<p>Tinyid 也是采用了异步加双缓存策略，首先可用号段加载到内存中，并在内存中生成 ID，可用号段在首次获取 ID 时加载，号段用到一定程度的时候，就去异步加载下一个号段，保证内存中始终有可用号段，则可避免性能波动。</p>
<p><strong>实现原理如下所示：</strong></p>
<p><img src="https://github.com/didi/tinyid/raw/master/doc/tinyid_final.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_29,text_ZnV4aW5n,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="图片源自 Tinyid"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文对分布式 ID 以及其场景的生成方案做了介绍，还针对一下大厂的中间件进行简单分析，中间件的接入代码本文并没有做详细介绍，但是官方文档的链接都帖子了每个子标题下，其中都有详细介绍。</p>
<p>文中还针对每个生成方案的优缺点作出了说明，具体的使用可针对优缺点加上业务需求来进行选型。</p>
<hr>
<blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/534893180">[1] 腾讯技术工程. 分布式唯一 ID 生成方案浅谈.</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2377401">[2] 孟斯特. UUID 介绍.</a></p>
<p><a href="https://blog.csdn.net/jiaomubai/article/details/124385324">[3] 文丑颜不良啊. 雪花算法（SnowFlake）.</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>ID</tag>
      </tags>
  </entry>
  <entry>
    <title>实现用户配置数据源引用切换</title>
    <url>/2024/10/03/%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90%E5%BC%95%E7%94%A8%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="需求来源"><a href="#需求来源" class="headerlink" title="需求来源"></a>需求来源</h2><p>实现代码生成器的时候因为做了分库，所以在实现代码生成时就需要根据不同的配置去拉取不同的表结构，所以需要实现不同的库使用不同的数据源</p>
<span id="more"></span>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在mybatis中是以DataSource的形式来管理数据源的，在mybaitis-plus中预留了AbstractRoutingDataSource接口来实现数据源的切换与查找</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1726735329465-48b3cd5d-4d56-4e45-8b43-afdec1a7c275.png"></p>
<p>targetDataSources就是数据源的结合，如果我们需要增加数据源就需要在targetDataSources中增加新定义的数据源，并通知引用规则，实现如下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先我们要定义一个节点用于确定使用targetDataSources中的哪个数据源，定义DataSourceContextHolder，用于实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DataSourceContextHolder &#123;</span><br><span class="line">    </span><br><span class="line">    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public static void setDataSourceKey(String dataSourceKey) &#123;</span><br><span class="line">        contextHolder.set(dataSourceKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String getDataSourceKey() &#123;</span><br><span class="line">        return contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void clearDataSourceKey() &#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义DynamicDataSource继承与AbstractRoutingDataSource</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DynamicDataSource(DataSource defaultDataSource, Map&lt;Object, Object&gt; targetDataSources) &#123;</span><br><span class="line">    // 设置数据源集合</span><br><span class="line">    super.setTargetDataSources(targetDataSources);</span><br><span class="line">    super.setDefaultTargetDataSource(defaultDataSource);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">    return DataSourceContextHolder.getDataSourceKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里只做了两件事定义数据源，以及确认当前数据源的key</p>
<p>定义一个Configuration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(DataSourceProperties.class)</span><br><span class="line">public class PomeloDataSourceConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">    @Resource</span><br><span class="line">    private DataSourceProperties dataSourceProperties;</span><br><span class="line">    private DataSource defaultDataSource() &#123;</span><br><span class="line">        DataSource dataSource = DataSourceBuilder.create()</span><br><span class="line">                .url(dataSourceProperties.getUrl())</span><br><span class="line">                .username(dataSourceProperties.getUsername())</span><br><span class="line">                .password(dataSourceProperties.getPassword())</span><br><span class="line">                .driverClassName(dataSourceProperties.getDriverClassName())</span><br><span class="line">                .build();;</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public DynamicDataSource dynamicDataSource() &#123;</span><br><span class="line">        DynamicDataSource dynamicDataSource = new DynamicDataSource(defaultDataSource(), new HashMap&lt;&gt;());</span><br><span class="line">        return dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>如果我们需要使用多个数据源那需要我们获取到多个数据源，我们这里以数据库获取为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatasourceConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Resource</span><br><span class="line">    private GenDatabaseService genDatabaseService;</span><br><span class="line">    @Resource</span><br><span class="line">    private DynamicDataSource dynamicDataSource;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public DynamicDataSource dataSourceInit() &#123;</span><br><span class="line">        // 创建数据源</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;GenDatabase&gt; genDatabaseList = genDatabaseService.selectList();</span><br><span class="line">        for (GenDatabase genDatabase : genDatabaseList) &#123;</span><br><span class="line">            targetDataSources.put(genDatabase.getDatabaseId().toString(), DataSourceBuilder.create()</span><br><span class="line">                    .driverClassName(genDatabase.getDatabaseDriver())</span><br><span class="line">                    .url(genDatabase.getDatabaseUrl())</span><br><span class="line">                    .password(genDatabase.getDatabasePwd())</span><br><span class="line">                    .username(genDatabase.getDatabaseName()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        dynamicDataSource.setTargetDataSources(targetDataSources);</span><br><span class="line">        dynamicDataSource.afterPropertiesSet();</span><br><span class="line">        return dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时如果需要再不同的地方调用数据源可以根据 DataSourceContextHolder.setDataSourceKey来确认使用哪个数据源，如果有需要也可以以aop形式完成，这里不多赘述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DataSourceContextHolder.setDataSourceKey(tableQuery.getDatabaseId());</span><br><span class="line">DataSourceContextHolder.clearDataSourceKey();</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>权限模型RBAC模型</title>
    <url>/2024/10/03/%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8BRBAC%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="什么是RBAC模型"><a href="#什么是RBAC模型" class="headerlink" title="什么是RBAC模型"></a>什么是RBAC模型</h3><p>权限是需要给对应的用户的，当用户太多的时候如果一个一个用户的设定权限就会显得很复杂，这时候我们可以引入角色，<font style="color:rgb(74, 74, 74);">每个角色可以拥有多个权限，每个用户可以分配多个角色，这样用户就拥有了多个角色的多个权限</font></p>
<span id="more"></span>
<h3 id="为什么要用RBAC模型"><a href="#为什么要用RBAC模型" class="headerlink" title="为什么要用RBAC模型"></a>为什么要用RBAC模型</h3><p><font style="color:rgb(74, 74, 74);">因为有角色作为媒介，大大降低了错综复杂的交互关系，比如一家有上万人的公司，角色可能只需要几百个就搞定了，因为很多用户需要的权限是一样的，分配一样的角色就可以了。这种模型的对应关系图如下所示：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1723708654558-0d0105e6-79d2-40f7-b9c8-3e07cb75e2c5.png"></p>
<p><font style="color:rgb(74, 74, 74);">用户和角色，角色和权限都是多对多的关系，这种模型是最通用的权限管理模型，节省了很大的权限维护成本，当然这种只是通用的模式，在实际的业务是千变万化的，比如大部分公司是分层级的，层级越高权限越大这时候可以用角色继承的RBAC模型。还有很多角色是互斥的这时候可以使用带约束的RBAC。比如同一个角色有多个用户，我们可以采用在角色的前提下增加一个用户组来简化角色分配。在pomelo中我们使用了通用的RBAC模型，这里只展示通用的模型</font></p>
<h3 id="RBAC模型数据结构"><a href="#RBAC模型数据结构" class="headerlink" title="RBAC模型数据结构"></a>RBAC模型数据结构</h3><p>菜单表（权限表）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P TABLE IF EXISTS customer_menu;</span><br><span class="line">CREATE TABLE customer_menu(</span><br><span class="line">    `menu_id` varchar(32) NOT NULL  COMMENT &#x27;菜单编号;菜单编号&#x27; ,</span><br><span class="line">    `parent_id` varchar(32) NOT NULL  COMMENT &#x27;父菜单编号;父菜单编号&#x27; ,</span><br><span class="line">    `name` varchar(255) NOT NULL  COMMENT &#x27;菜单名称;菜单名称&#x27; ,</span><br><span class="line">    `another_name` varchar(255) NOT NULL  COMMENT &#x27;别称;别称&#x27; ,</span><br><span class="line">    `path` varchar(255) NOT NULL  COMMENT &#x27;菜单URL;菜单地址（目录 菜单信息为/xxx/xxx   按钮为:delete，create等）&#x27; ,</span><br><span class="line">    `order_num` int   COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    `component` varchar(255)   COMMENT &#x27;组件路径;组件路径&#x27; ,</span><br><span class="line">    `perms` varchar(255) NOT NULL  COMMENT &#x27;授权;授权(多个用逗号分隔，如：user:list,user:create);&#x27; ,</span><br><span class="line">    `type` tinyint(4) NOT NULL  COMMENT &#x27;类型;类型   0：目录   1：菜单   2：按钮;&#x27; ,</span><br><span class="line">    `icon` varchar(255) NOT NULL  COMMENT &#x27;菜单图标;菜单图标&#x27; ,</span><br><span class="line">    `is_full` tinyint(4)   COMMENT &#x27;是否跳转;是否跳转&#x27; ,</span><br><span class="line">    `is_link` varchar(255)   COMMENT &#x27;是否外链;是否外链&#x27; ,</span><br><span class="line">    `is_hide` tinyint(4)   COMMENT &#x27;是否隐藏;是否隐藏&#x27; ,</span><br><span class="line">    `is_affix` tinyint(4)   COMMENT &#x27;是否固定;是否固定&#x27; ,</span><br><span class="line">    `is_keep_alive` tinyint(4)   COMMENT &#x27;是否长连接;是否长连接&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; ,</span><br><span class="line">    PRIMARY KEY (menu_id)</span><br><span class="line">)  COMMENT = &#x27;菜单表&#x27;;</span><br></pre></td></tr></table></figure>

<p>角色表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_role;</span><br><span class="line">CREATE TABLE customer_role(</span><br><span class="line">    `role_id` varchar(32) NOT NULL  COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    `role_name` varchar(100) NOT NULL  COMMENT &#x27;角色名称;角色名称&#x27; ,</span><br><span class="line">    `role_key` varchar(32) NOT NULL  COMMENT &#x27;角色权限字符串;角色权限字符串&#x27; ,</span><br><span class="line">    `role_sort` int   COMMENT &#x27;显示顺序;显示顺序&#x27; ,</span><br><span class="line">    `data_scope` tinyint(4)   COMMENT &#x27;数据范围（1：全部数据权限 2：自定数据权限 ）;数据范围（1：全部数据权限 2：自定数据权限 ）&#x27; ,</span><br><span class="line">    `status` tinyint(4) NOT NULL  COMMENT &#x27;角色状态（0正常 1停用）;角色状态（0正常 1停用）&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; </span><br><span class="line">)  COMMENT = &#x27;角色表&#x27;;</span><br></pre></td></tr></table></figure>

<p>用户表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_user;</span><br><span class="line">CREATE TABLE customer_user(</span><br><span class="line">    `user_id` varchar(32) NOT NULL  COMMENT &#x27;用户编号;用户编号&#x27; ,</span><br><span class="line">    `user_name` varchar(30) NOT NULL  COMMENT &#x27;用户账号;用户账号&#x27; ,</span><br><span class="line">    `nick_name` varchar(30) NOT NULL  COMMENT &#x27;用户昵称;用户昵称&#x27; ,</span><br><span class="line">    `phone_number` varchar(20)   COMMENT &#x27;用户手机号;用户手机号&#x27; ,</span><br><span class="line">    `open_id` varchar(32)   COMMENT &#x27;微信Id;微信唯一标识&#x27; ,</span><br><span class="line">    `dy_id` varchar(32)   COMMENT &#x27;抖音Id;抖音唯一标识&#x27; ,</span><br><span class="line">    `sex` tinyint(4)   COMMENT &#x27;性别;性别（0男 1女 2未知）&#x27; ,</span><br><span class="line">    `avatar` varchar(100)   COMMENT &#x27;头像地址;头像地址&#x27; ,</span><br><span class="line">    `invite_code` varchar(32)   COMMENT &#x27;邀请码;邀请码&#x27; ,</span><br><span class="line">    `password` varchar(16) NOT NULL  COMMENT &#x27;密码;密码&#x27; ,</span><br><span class="line">    `salt` varchar(32) NOT NULL  COMMENT &#x27;盐;盐&#x27; ,</span><br><span class="line">    `status` tinyint(4) NOT NULL  COMMENT &#x27;用户状态;账号状态（0未验证  1已验证 2已冻结 3已过期）&#x27; ,</span><br><span class="line">    `revision` int(4) NOT NULL  COMMENT &#x27;乐观锁;乐观锁&#x27; ,</span><br><span class="line">    `create_time` datetime NOT NULL  COMMENT &#x27;创建时间;创建时间&#x27; ,</span><br><span class="line">    `update_time` datetime NOT NULL  COMMENT &#x27;更新时间;更新时间&#x27; ,</span><br><span class="line">    `del_flag` tinyint(4) NOT NULL  COMMENT &#x27;删除标记;删除标记&#x27; ,</span><br><span class="line">    PRIMARY KEY (user_id)</span><br><span class="line">)  COMMENT = &#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure>

<p>用户角色表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_user_role;</span><br><span class="line">CREATE TABLE customer_user_role(</span><br><span class="line">    `ID` INT AUTO_INCREMENT COMMENT &#x27;&#x27; ,</span><br><span class="line">    `user_id` varchar(32)   COMMENT &#x27;用户ID;用户ID&#x27; ,</span><br><span class="line">    `role_id` varchar(32)   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;用户角色表&#x27;;</span><br></pre></td></tr></table></figure>

<p>角色权限表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS customer_role_menu;</span><br><span class="line">CREATE TABLE customer_role_menu(</span><br><span class="line">    `ID` INT AUTO_INCREMENT COMMENT &#x27;&#x27; ,</span><br><span class="line">    `role_id` varchar(32)   COMMENT &#x27;角色ID;角色ID&#x27; ,</span><br><span class="line">    `menu_id` varchar(32)   COMMENT &#x27;菜单ID;菜单ID&#x27; ,</span><br><span class="line">    PRIMARY KEY (ID)</span><br><span class="line">)  COMMENT = &#x27;角色菜单管理表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>构建一个通用的数据访问模块</title>
    <url>/2024/10/01/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>当构建一个通用的数据访问模块的时候，一般需要处理分页，乐观锁、以及插入或者修改时一些公共字段默认值填充，以及慢查询处理定制化（虽然mysql自带的有这方面功能但是通知的灵活性不如自定义更实用）</p>
<span id="more"></span>
<h2 id="处理分页、乐观锁"><a href="#处理分页、乐观锁" class="headerlink" title="处理分页、乐观锁"></a>处理分页、乐观锁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    //分页</span><br><span class="line">    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">    // 乐观锁</span><br><span class="line">    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</span><br><span class="line">    return interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入或者修改设置默认字段"><a href="#插入或者修改设置默认字段" class="headerlink" title="插入或者修改设置默认字段"></a>插入或者修改设置默认字段</h2><p>首先定义基类BaseEntity，这里定义了createTime，updateTime，delFlag三个默认配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@SuperBuilder</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class BaseEntity &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建时间</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改时间</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除标志</span><br><span class="line">     */</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Integer delFlag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MetaObjectHandler接口是mybatisPlus为我们提供的的一个扩展接口，我们可以利用这个接口在我们插入或者更新数据的时候，为一些字段指定默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DailyMartMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;delFlag&quot;, Integer.class, DelEnum.NORMAL.code());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 2023/10/28 调整</span><br><span class="line">     * Mybatis-plus的自动更新要求待更新的字段为null，否则不更新。这就导致select 后 更新时无法自动更新 updateTime</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public MetaObjectHandler strictFillStrategy(MetaObject metaObject, String fieldName, Supplier&lt;?&gt; fieldVal) &#123;</span><br><span class="line">        Object obj = fieldVal.get();</span><br><span class="line">        if (Objects.nonNull(obj)) &#123;</span><br><span class="line">            metaObject.setValue(fieldName, obj);</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>将MetaObjectHandler注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在 插入/更新 数据时自动填充默认值</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public PomeloMetaObjectHandler myMetaObjectHandler() &#123;</span><br><span class="line">    return new PomeloMetaObjectHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="慢查询处理"><a href="#慢查询处理" class="headerlink" title="慢查询处理"></a>慢查询处理</h2><p>mysql的慢查询可以通过很多地方拦截，比如数据库本身就可以通过配置来实现拦击并打印为日志，一部分开源的数据库连接池也可以实现，比如阿里的druid。这些虽然都可以实现慢查询拦截，但是这些属于第三方，不够灵活所以我们这里可以使用<font style="color:rgb(47, 48, 52);">Mybatis提供的拦截器接口Interceptor来自己实现拦截，自己是实现时可以结合消息队列来完成阀值式处理，这些为后话，我们先来进行一个简单的实现</font></p>
<p><font style="color:rgb(47, 48, 52);">定义一个配置文件实体</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;pomelo.sql.slow&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class SlowSQLProperties &#123;</span><br><span class="line"></span><br><span class="line">    private boolean enable = false;</span><br><span class="line"></span><br><span class="line">    private long cost = 1000L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(47, 48, 52);">实现Interceptor</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;),</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;),</span><br><span class="line">        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class SlowSqlInterceptor implements Interceptor &#123;</span><br><span class="line">    private final SlowSQLProperties slowSQLProperties;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        StatementHandler statementHandler = (StatementHandler) target;</span><br><span class="line">        try &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            long costTime = stopWatch.getTotalTimeMillis();</span><br><span class="line"></span><br><span class="line">            if (costTime &gt;= slowSQLProperties.getCost()) &#123;</span><br><span class="line">                BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line"></span><br><span class="line">                String sql = boundSql.getSql();</span><br><span class="line"></span><br><span class="line">                // 20230901 去掉sql中的换行符</span><br><span class="line">                sql = sql.replaceAll(&quot;\\n+&quot;, &quot; &quot;);</span><br><span class="line"></span><br><span class="line">                log.warn(&quot;WARN !!!,监测到慢查询SQL:[&#123;&#125;] 执行耗时 &#123;&#125; ms &quot;, sql, costTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注入mybatis插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注入mybatis插件，可以统计SQL执行耗时</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">@ConditionalOnProperty(name = &quot;pomelo.sql.slow.enable&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><br><span class="line">public ConfigurationCustomizer mybatisConfigurationCustomizer() &#123;</span><br><span class="line">    return configuration -&gt; configuration.addInterceptor(new SlowSqlInterceptor(slowSQLProperties));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换ID生成器"><a href="#替换ID生成器" class="headerlink" title="替换ID生成器"></a>替换ID生成器</h2><p>在<a href="https://www.yuque.com/u25495771/ghfr2q/zsg53g1qtc5fxxeo">分布式ID</a>一文中我们自定义了ID，这里修改一下mybatis的id的生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IdGenerator implements IdentifierGenerator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Number nextId(Object entity) &#123;</span><br><span class="line">        return (Long)IDUtils.generateKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String nextUUID(Object entity) &#123;</span><br><span class="line">        return IDUtils.get32UUID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 替换Mybatis-plus的算法生成器</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public IdGenerator identifierGenerator() &#123;</span><br><span class="line">    return new IdGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一扫描地址"><a href="#统一扫描地址" class="headerlink" title="统一扫描地址"></a><font style="color:rgb(51, 51, 51);">统一扫描地址</font></h2><p>当我们使用mybatis时需要在<font style="color:rgb(47, 48, 52);">每个服务启动类上都需要通过@MapperScan注解指定Mapper对象的包路径地址。如果各个模块的命名规则之间遵循统一的命名规范，那么我们可以在配置主类中直接设置Mapper对象的包路径地址，这样SpringBoot启动类就不再需要依赖此注解了</font></p>
<p><font style="color:rgb(47, 48, 52);"></font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>构建统一返回以及全局异常处理</title>
    <url>/2024/10/03/%E6%9E%84%E5%BB%BA%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E4%BB%A5%E5%8F%8A%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="统一返回格式"><a href="#统一返回格式" class="headerlink" title="统一返回格式"></a>统一返回格式</h2><h3 id="为什么需要统一返回格式"><a href="#为什么需要统一返回格式" class="headerlink" title="为什么需要统一返回格式"></a>为什么需要统一返回格式</h3><p><font style="color:rgb(47, 48, 52);">接口的返回值类型众多，有的直接返回数据传输对象（DTO），甚至直接返回数据对象（DO），还有的返回Result对象。这样对外交互时对方处理起来特别的复杂，所以需要统一的返回格式。</font></p>
<span id="more"></span>
<h3 id="构建统一返回格式"><a href="#构建统一返回格式" class="headerlink" title="构建统一返回格式"></a>构建统一返回格式</h3><h4 id="构建Result对象"><a href="#构建Result对象" class="headerlink" title="构建Result对象"></a><font style="color:rgb(51, 51, 51);">构建Result对象</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ResultHelper &#123;</span><br><span class="line">    </span><br><span class="line">    // 成功的响应结果</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(Result.SUCCESS_CODE)</span><br><span class="line">                .setData(data)</span><br><span class="line">                .setMessage(Result.SUCCESS_MESSAGE)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 失败的响应结果</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(String code, String message) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(code)</span><br><span class="line">                .setMessage(message)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 失败的响应结果，使用默认的错误码</span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(String message) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(ErrorCode.SERVICE_ERROR.getCode())</span><br><span class="line">                .setMessage(message)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static &lt;T&gt; Result&lt;T&gt; failure(ErrorCode errorCode) &#123;</span><br><span class="line">        return new Result&lt;T&gt;()</span><br><span class="line">                .setCode(errorCode.getCode())</span><br><span class="line">                .setMessage(errorCode.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问下接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public Result&lt;String&gt; test() &#123;</span><br><span class="line">        return ResultHelper.success(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723015024331-f73efb26-3859-4649-9d2d-60d30bb50bc0.png"></p>
<h2 id="统一的模板方法"><a href="#统一的模板方法" class="headerlink" title="统一的模板方法"></a>统一的模板方法</h2><h3 id="为什么需要统一的模板方法"><a href="#为什么需要统一的模板方法" class="headerlink" title="为什么需要统一的模板方法"></a>为什么需要统一的模板方法</h3><p>按照上面的示例一切都很美好，代码也很简洁，内容也如预期做了输出，但是我们考虑一个问题，如果有上百个接口的时候，需要对接口进行一些公共代码的调整，比如讲参数和输出打印出来，对参数进行验证，统计代码执行的时间。当遇到这种需求可以使用AOP做切面编程，但是切面编程的效率并不是很好，所以可以选择使用统一的模板方法来处理这些问题。既可以实现统一的管理公共代码，又可以更规范的书写代码</p>
<h3 id="构建统一的模板方法"><a href="#构建统一的模板方法" class="headerlink" title="构建统一的模板方法"></a>构建统一的模板方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public abstract class ServerTemplate&lt;T, R&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    public R Process(T request) &#123;</span><br><span class="line">        log.info(&quot;开始执行，参数：&#123;&#125;&quot;, request);</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            // 参数校验</span><br><span class="line">            validParam(request);</span><br><span class="line">            // 执行业务代码</span><br><span class="line">            R response = doProcess(request);</span><br><span class="line">            // 记录时间信息</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            log.info(&quot;执行结束，耗时:&#123;&#125;ms&quot;, stopWatch.getTotalTimeMillis());</span><br><span class="line">            return response;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;执行异常，异常信息:&#123;&#125;&quot;, Arrays.toString(e.getStackTrace()));</span><br><span class="line">            // 抛出异常 统一处理</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected abstract void validParam(T request);</span><br><span class="line">    </span><br><span class="line">    protected abstract R doProcess(T request);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="使用统一格式创建一个接口"><a href="#使用统一格式创建一个接口" class="headerlink" title="使用统一格式创建一个接口"></a>使用统一格式创建一个接口</h2><p>改造一下之前的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">  public Result&lt;String&gt; test(@RequestBody String request) &#123;</span><br><span class="line">      return ResultHelper.success((new ServerTemplate&lt;String, String&gt;()&#123;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          protected void validParam(String request) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          protected String doProcess(String request) &#123;</span><br><span class="line">              return request;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;).process(request));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>执行代码</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723017417888-cb2a2f15-b9ec-4264-be8b-6c9331e82b5f.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723017431106-aa9e0616-a24b-4b47-9848-680c7a980206.png"></p>
<h2 id="再次优化：自动包装类"><a href="#再次优化：自动包装类" class="headerlink" title="再次优化：自动包装类"></a>再次优化：自动包装类</h2><p>每次都ResultHelper.success(）还要在参数中增加Result来维护一致性总是觉着有点太浪费时间，而且如果忘记了就会出错。所以需要再进一步优化一下，springboot的<font style="color:rgb(47, 48, 52);">ResponseBodyAdvice可以实现自动包装类</font></p>
<p>:::info<br><font style="color:rgb(154, 154, 154);">提示: ResponseBodyAdvice 可以拦截控制器(Controller)方法的返回值，允许我们统一处理返回值或响应体。这对于统一返回格式、加密、签名等场景非常有用。</font></p>
<p>:::</p>
<p>集成<font style="color:rgb(47, 48, 52);">ResponseBodyAdvice接口</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalResponseBodyAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        // boolean supports = returnType.getContainingClass().getPackage().getName().startsWith(&quot;com.jianzh5.dailymart&quot;);</span><br><span class="line">        return true;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request,</span><br><span class="line">                                  ServerHttpResponse response) &#123;</span><br><span class="line">        if (body == null) &#123;</span><br><span class="line">            return JsonUtils.obj2String(ResultHelper.success(&quot;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        if (body instanceof String) &#123;</span><br><span class="line">            // 当响应体是String类型时，使用ObjectMapper转换，因为Spring默认使用StringHttpMessageConverter处理字符串，不会将字符串识别为JSON</span><br><span class="line">            // return objectMapper.writeValueAsString(ResultFactory.success(body));</span><br><span class="line">            return JsonUtils.obj2String(ResultHelper.success(body));</span><br><span class="line">        &#125;</span><br><span class="line">        if (body instanceof Result&lt;?&gt;) &#123;</span><br><span class="line">            // 已经包装过的结果无需再次包装</span><br><span class="line">            return body;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对响应体进行包装</span><br><span class="line">        return ResultHelper.success(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再修改一下之前的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    </span><br><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public String test(@RequestBody String request) &#123;</span><br><span class="line">        return (new ServerTemplate&lt;String, String&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected void validParam(String request) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected String doProcess(String request) &#123;</span><br><span class="line">                return request;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;).process(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723024004078-4916bbdd-5b70-49a2-b0c6-29ddd9be84cd.png"></p>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>在构建系统的可靠性时容错处理是重要的考虑方便之一，想要系统更加的健壮全局就需要添加全局异常处理，springboot其实已经做了前期的工作，@RestControllerAdvice注解+@ExceptionHandler可以解决这方面的顾虑</p>
<h3 id="自定义异常的创建和使用"><a href="#自定义异常的创建和使用" class="headerlink" title="自定义异常的创建和使用"></a>自定义异常的创建和使用</h3><p>定义自定义异常基类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public abstract class AbstractException extends RuntimeException &#123;</span><br><span class="line">    </span><br><span class="line">    @Serial</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    </span><br><span class="line">    private final String code;</span><br><span class="line">    private final String message;</span><br><span class="line">    </span><br><span class="line">    public AbstractException(ErrorCode errorCode, String message, Throwable throwable) &#123;</span><br><span class="line">        super(message, throwable);</span><br><span class="line">        this.code = errorCode.getCode();</span><br><span class="line">        this.message = Optional.ofNullable(message).orElse(errorCode.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public AbstractException(String code, String message, Throwable throwable) &#123;</span><br><span class="line">        super(message, throwable);</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义自定义异常类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BusinessException extends AbstractException &#123;</span><br><span class="line"></span><br><span class="line">    public BusinessException(ErrorCode errorCode, String message, Throwable throwable) &#123;</span><br><span class="line">        super(errorCode, message, throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(String code, String message, Throwable throwable) &#123;</span><br><span class="line">        super(code, message, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局异常的定义"><a href="#全局异常的定义" class="headerlink" title="全局异常的定义"></a>全局异常的定义</h3><p>在服务端在接收到参数，通常是不受信任的，这时我们需要对参数进行验证，因为参数验证并不是业务错误所以需要进行额外的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(value = &#123;MethodArgumentNotValidException.class, BindException.class, ValidationException.class&#125;)</span><br><span class="line">    public Result&lt;Void&gt; handleValidException(HttpServletRequest request, Exception e) &#123;</span><br><span class="line">        String exceptionStr = &quot;参数校验异常&quot;;</span><br><span class="line">        if (e instanceof MethodArgumentNotValidException ex) &#123;</span><br><span class="line">            BindingResult bindingResult = ex.getBindingResult();</span><br><span class="line">            FieldError firstFieldError = CollectionUtil.getFirst(bindingResult.getFieldErrors());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstFieldError)</span><br><span class="line">                    .map(FieldError::getDefaultMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">            </span><br><span class="line">        &#125; else if (e instanceof ConstraintViolationException) &#123;</span><br><span class="line">            ConstraintViolationException ex = (ConstraintViolationException) e;</span><br><span class="line">            </span><br><span class="line">            ConstraintViolation&lt;?&gt; firstConstraintViolation = CollectionUtil.getFirst(ex.getConstraintViolations());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstConstraintViolation)</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">            </span><br><span class="line">        &#125; else if (e instanceof BindException) &#123;</span><br><span class="line">            BindException ex = (BindException) e;</span><br><span class="line">            ObjectError firstObjectError = CollectionUtil.getFirst(ex.getAllErrors());</span><br><span class="line">            </span><br><span class="line">            exceptionStr = Optional.ofNullable(firstObjectError)</span><br><span class="line">                    .map(ObjectError::getDefaultMessage)</span><br><span class="line">                    .orElse(StrUtil.EMPTY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;, request.getMethod(), getUrl(request), exceptionStr);</span><br><span class="line">        return ResultHelper.failure(ErrorCode.PARAMETER_VALIDATION_FAILED.getCode(), exceptionStr);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理自定义异常</span><br><span class="line">    @ExceptionHandler(value = &#123;AbstractException.class&#125;)</span><br><span class="line">    public Result&lt;Void&gt; handleAbstractException(HttpServletRequest request, AbstractException ex) &#123;</span><br><span class="line">        String requestURL = getUrl(request);</span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; [ex] &#123;&#125;&quot;, request.getMethod(), requestURL, ex.toString());</span><br><span class="line">        return ResultHelper.failure(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 兜底处理</span><br><span class="line">    @ExceptionHandler(value = Throwable.class)</span><br><span class="line">    public Result&lt;Void&gt; handleThrowable(HttpServletRequest request, Throwable throwable) &#123;</span><br><span class="line">        log.error(&quot;[&#123;&#125;] &#123;&#125; &quot;, request.getMethod(), getUrl(request), throwable);</span><br><span class="line">        return ResultHelper.failure(ErrorCode.SERVICE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取浏览地址信息</span><br><span class="line">    private String getUrl(HttpServletRequest request) &#123;</span><br><span class="line">        if (StrUtil.isEmpty(request.getQueryString())) &#123;</span><br><span class="line">            return request.getRequestURL().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return request.getRequestURL().toString() + &quot;?&quot; + request.getQueryString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试全局异常的定义"><a href="#测试全局异常的定义" class="headerlink" title="测试全局异常的定义"></a>测试全局异常的定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public String test(@RequestBody String request) &#123;</span><br><span class="line">        return (new ServerTemplate&lt;String, String&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected void validParam(String request) &#123;</span><br><span class="line">                if (request == null)&#123;</span><br><span class="line">                    throw new BusinessException(ErrorCode.CLIENT_ERROR.getCode(), &quot;请求参数不能为空&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected String doProcess(String request) &#123;</span><br><span class="line">                return request;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;).process(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723025785241-71b9b63e-878a-48ae-bf8f-ebf6754ca7b1.png"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上文中实现了统一返回格式以及统一的模板方法，以及为了简化写法的自动包装类和全局异常的处理，在日常开发中每个人的写法各异，统一的写法规定可以避免错误的代码实现以及提升代码的可读性，可以提升整个系统的可靠性，我们可以借助springboot的注解来实现这些在</p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>构建通用的Redis辅助类</title>
    <url>/2024/10/03/%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8%E7%9A%84Redis%E8%BE%85%E5%8A%A9%E7%B1%BB/</url>
    <content><![CDATA[<p>Redis中常用的功能可以分为两款，第一是缓存用于提升读性能，可以根据不同的数据类型来实现月签到统计，排行榜，消息订阅等功能。第二是用于实现分布式锁，一个成熟的辅助类可以对这两项功能进行封装，并列出常用的方法</p>
<span id="more"></span>
<h2 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h2><p>这里讲的是构建通用的辅助类，主要针对的是在开发中遇到的问题的解决方案，在实际的开发中</p>
<p>1.在集群环境中所有的数据都集中在0数据页中，key如果没有清晰的标识，容易出现互相覆盖的问题</p>
<p>2.不同的系统序列化问题</p>
<p>3.散乱的引用，后续对某个功能进行修改或者扩展太过繁杂</p>
<p>架构就是为了解决问题，根绝以上的问题，在构建辅助类的时候我们可以来</p>
<p>首先需要定义配置项key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;pomelo.cache.redis&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class PomeloRedisProperties &#123;</span><br><span class="line">    /**Redis前缀**/</span><br><span class="line">    private String prefix = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**默认超时时间**/</span><br><span class="line">    private Long timeout = 30000L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 时间单位</span><br><span class="line">     */</span><br><span class="line">    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义统一的key序列化方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class PomeloRedisKeySerializer  implements RedisSerializer&lt;String&gt; &#123;</span><br><span class="line">    private final String keyPrefix;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(String key) throws SerializationException &#123;</span><br><span class="line">        String buildKey = keyPrefix + key;</span><br><span class="line">        return buildKey.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String deserialize(byte[] bytes) throws SerializationException &#123;</span><br><span class="line">        return new String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自动注入设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableConfigurationProperties(PomeloRedisProperties.class)</span><br><span class="line">public class PomeloRedisCacheAutoConfiguration &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 构建Redis的Key</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PomeloRedisKeySerializer redisKeySerializer() &#123;</span><br><span class="line">        String prefix = pomeloRedisProperties.getPrefix();</span><br><span class="line">        return new PomeloRedisKeySerializer(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * redisTemplate相关配置</span><br><span class="line">     * [@Role(BeanDefinition.ROLE_INFRASTRUCTURE)] 表明这个bean是完全后台模式，不需要被代理。</span><br><span class="line">     *</span><br><span class="line">     * @param factory Redis连接工厂类</span><br><span class="line">     * @return 返回配置项对象</span><br><span class="line">     */</span><br><span class="line">    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        // 配置连接工厂</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jacksonSerial = new Jackson2JsonRedisSerializer&lt;&gt;(objectMapper, Object.class);</span><br><span class="line"></span><br><span class="line">        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        // null值字段不显示</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        // 美化JSON输出</span><br><span class="line">        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span><br><span class="line">        objectMapper.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        // 值采用json序列化</span><br><span class="line">        template.setValueSerializer(jacksonSerial);</span><br><span class="line">        // 使用StringRedisSerializer来序列化和反序列化redis的key值</span><br><span class="line">        template.setKeySerializer(redisKeySerializer());</span><br><span class="line">        // 设置hash key 和value序列化模式</span><br><span class="line">        template.setHashKeySerializer(redisKeySerializer());</span><br><span class="line">        // template.setHashValueSerializer(jacksonSerial);</span><br><span class="line">        template.setHashValueSerializer(jacksonSerial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义公共的辅助类：</p>
<h4 id="key操作辅助类"><a href="#key操作辅助类" class="headerlink" title="key操作辅助类"></a>key操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    /**</span><br><span class="line">     * 删除key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     */</span><br><span class="line">    public void delete(String key) &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量删除key</span><br><span class="line">     *</span><br><span class="line">     * @param keys</span><br><span class="line">     */</span><br><span class="line">    public void delete(Collection&lt;String&gt; keys) &#123;</span><br><span class="line">        stringRedisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列化key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public byte[] dump(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.dump(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否存在key</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean exists(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean expire(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param date</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean expireAt(String key, Date date) &#123;</span><br><span class="line">        return stringRedisTemplate.expireAt(key, date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查找匹配的key</span><br><span class="line">     *</span><br><span class="line">     * @param pattern</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; keys(String pattern) &#123;</span><br><span class="line">        return stringRedisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将当前数据库的 key 移动到给定的数据库 db 当中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param dbIndex</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean move(String key, int dbIndex) &#123;</span><br><span class="line">        return stringRedisTemplate.move(key, dbIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除 key 的过期时间，key 将持久保持</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean persist(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.persist(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 的剩余的过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long getExpire(String key, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.getExpire(key, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 的剩余的过期时间</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long getExpire(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.getExpire(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从当前数据库中随机返回一个 key</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String randomKey() &#123;</span><br><span class="line">        return stringRedisTemplate.randomKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改 key 的名称</span><br><span class="line">     *</span><br><span class="line">     * @param oldKey</span><br><span class="line">     * @param newKey</span><br><span class="line">     */</span><br><span class="line">    public void rename(String oldKey, String newKey) &#123;</span><br><span class="line">        stringRedisTemplate.rename(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 仅当 newkey 不存在时，将 oldKey 改名为 newkey</span><br><span class="line">     *</span><br><span class="line">     * @param oldKey</span><br><span class="line">     * @param newKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean renameIfAbsent(String oldKey, String newKey) &#123;</span><br><span class="line">        return stringRedisTemplate.renameIfAbsent(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 所储存的值的类型</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public DataType type(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.type(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="String类型操作辅助类"><a href="#String类型操作辅助类" class="headerlink" title="String类型操作辅助类"></a>String类型操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisStringUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 返回 key 中字符串值的子字符</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().get(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将给定 key 的值设为 value ，并返回 key 的旧值(old value)</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getAndSet(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对 key 所储存的字符串值，获取指定偏移量上的位(bit)</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param offset</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean getBit(String key, long offset) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().getBit(key, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量获取</span><br><span class="line">     *</span><br><span class="line">     * @param keys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; multiGet(Collection&lt;String&gt; keys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().multiGet(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置ASCII码, 字符串&#x27;a&#x27;的ASCII码是97, 转为二进制是&#x27;01100001&#x27;, 此方法是将二进制第offset位值变为value</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @param value 值,true为1, false为0</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean setBit(String key, long offset, boolean value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().setBit(key, offset, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param timeout 过期时间</span><br><span class="line">     * @param unit    时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES</span><br><span class="line">     *                秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS</span><br><span class="line">     */</span><br><span class="line">    public void setEx(String key, String value, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只有在 key 不存在时设置 key 的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return 之前已经存在返回false, 不存在返回true</span><br><span class="line">     */</span><br><span class="line">    public boolean setIfAbsent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param offset 从指定位置开始覆写</span><br><span class="line">     */</span><br><span class="line">    public void setRange(String key, String value, long offset) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取字符串的长度</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long size(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量添加</span><br><span class="line">     *</span><br><span class="line">     * @param maps</span><br><span class="line">     */</span><br><span class="line">    public void multiSet(Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().multiSet(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</span><br><span class="line">     *</span><br><span class="line">     * @param maps</span><br><span class="line">     * @return 之前已经存在返回false, 不存在返回true</span><br><span class="line">     */</span><br><span class="line">    public boolean multiSetIfAbsent(Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().multiSetIfAbsent(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加(自增长), 负数则为自减</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long incrBy(String key, long increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double incrByFloat(String key, double increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 追加到末尾</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Integer append(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().append(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="List操作辅助类"><a href="#List操作辅助类" class="headerlink" title="List操作辅助类"></a>List操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisListUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过索引获取列表中的元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lIndex(String key, long index) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().index(key, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取列表指定范围内的元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start 开始位置, 0是开始位置</span><br><span class="line">     * @param end   结束位置, -1返回所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; lRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存储在list头部</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPush(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushAll(String key, String... value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushAll(String key, Collection&lt;String&gt; value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当list存在的时候才加入</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPushIfPresent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果pivot存在,再pivot前面添加</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param pivot</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLeftPush(String key, String pivot, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPush(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushAll(String key, String... value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushAll(String key, Collection&lt;String&gt; value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为已存在的列表添加值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPushIfPresent(String key, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在pivot元素的右边添加值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param pivot</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRightPush(String key, String pivot, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过索引设置列表元素的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index 位置</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    public void lSet(String key, long index, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForList().set(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的第一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return 删除的元素</span><br><span class="line">     */</span><br><span class="line">    public String lLeftPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout 等待时间</span><br><span class="line">     * @param unit    时间单位</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBLeftPop(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().leftPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除并获取列表最后一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return 删除的元素</span><br><span class="line">     */</span><br><span class="line">    public String lRightPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param timeout 等待时间</span><br><span class="line">     * @param unit    时间单位</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBRightPop(String key, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span><br><span class="line">     *</span><br><span class="line">     * @param sourceKey</span><br><span class="line">     * @param destinationKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lRightPopAndLeftPush(String sourceKey, String destinationKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPopAndLeftPush(sourceKey,</span><br><span class="line">                destinationKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span><br><span class="line">     *</span><br><span class="line">     * @param sourceKey</span><br><span class="line">     * @param destinationKey</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String lBRightPopAndLeftPush(String sourceKey, String destinationKey,</span><br><span class="line">                                        long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().rightPopAndLeftPush(sourceKey,</span><br><span class="line">                destinationKey, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除集合中值等于value得元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param index index=0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素;</span><br><span class="line">     *              index&lt;0, 从尾部开始删除第一个值等于value的元素;</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lRemove(String key, long index, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().remove(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 裁剪list</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     */</span><br><span class="line">    public void lTrim(String key, long start, long end) &#123;</span><br><span class="line">        stringRedisTemplate.opsForList().trim(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取列表长度</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long lLen(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForList().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Set操作类型辅助类"><a href="#Set操作类型辅助类" class="headerlink" title="Set操作类型辅助类"></a>Set操作类型辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisSetUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set添加元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sAdd(String key, String... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set移除元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sRemove(String key, Object... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除并返回集合的一个随机元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String sPop(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().pop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将元素value从一个集合移到另一个集合</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean sMove(String key, String value, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().move(key, value, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断集合是否包含value</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean sIsMember(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sIntersect(String key, String otherKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersect(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sIntersect(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersect(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的交集存储到destKey集合中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sIntersectAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersectAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的交集存储到destKey集合中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sIntersectAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().intersectAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的并集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sUnion(String key, String otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的并集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sUnion(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的并集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sUnionAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的并集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sUnionAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                               String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取两个集合的差集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDifference(String key, String otherKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().difference(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key集合与多个集合的差集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDifference(String key, Collection&lt;String&gt; otherKeys) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().difference(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与otherKey集合的差集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sDifference(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().differenceAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * key集合与多个集合的差集存储到destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long sDifference(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                            String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().differenceAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合所有元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; setMembers(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中的一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String sRandomMember(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().randomMember(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中count个元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param count</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; sRandomMembers(String key, long count) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().randomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机获取集合中count个元素并且去除重复的</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param count</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; sDistinctRandomMembers(String key, long count) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().distinctRandomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;String&gt; sScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Hash操作辅助类"><a href="#Hash操作辅助类" class="headerlink" title="Hash操作辅助类"></a>Hash操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisHashUtils &#123;</span><br><span class="line"></span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    private final PomeloRedisProperties pomeloRedisProperties;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取存储在哈希表中指定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Object hGet(String key, String field) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().get(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有给定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;Object, Object&gt; hGetAll(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有给定字段的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param fields</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; hMultiGet(String key, Collection&lt;Object&gt; fields) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().multiGet(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hPut(String key, String hashKey, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hPutAll(String key, Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(key, maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 仅当hashKey不存在时才设置</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param hashKey</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean hPutIfAbsent(String key, String hashKey, String value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().putIfAbsent(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个或多个哈希表字段</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param fields</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hDelete(String key, Object... fields) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().delete(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查看哈希表 key 中，指定的字段是否存在</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean hExists(String key, String field) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().hasKey(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为哈希表 key 中的指定字段的整数值加上增量 increment</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @param increment</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hIncrBy(String key, Object field, long increment) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().increment(key, field, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为哈希表 key 中的指定字段的整数值加上增量 increment</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param field</span><br><span class="line">     * @param delta</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double hIncrByFloat(String key, Object field, double delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().increment(key, field, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取所有哈希表中的字段</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;Object&gt; hKeys(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().keys(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取哈希表中字段的数量</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long hSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取哈希表中所有值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; hValues(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().values(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 迭代哈希表中的键值对</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; hScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForHash().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ZSet操作辅助类"><a href="#ZSet操作辅助类" class="headerlink" title="ZSet操作辅助类"></a>ZSet操作辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisZSetUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加元素,有序集合是按照元素的score值由小到大排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param score</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean zAdd(String key, String value, double score) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().add(key, value, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zAdd(String key, Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemove(String key, Object... values) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long zRemove(String key, Collection&lt;String&gt; values) &#123;</span><br><span class="line">        if (values != null &amp;&amp; !values.isEmpty()) &#123;</span><br><span class="line">            Object[] objs = values.toArray(new Object[values.size()]);</span><br><span class="line">            return stringRedisTemplate.opsForZSet().remove(key, objs);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加元素的score值，并返回增加后的值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param delta</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double zIncrementScore(String key, String value, double delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().incrementScore(key, value, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return 0表示第一位</span><br><span class="line">     */</span><br><span class="line">    public Long zRank(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回元素在集合的排名,按元素的score值由大到小排列</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zReverseRank(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从小到大排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start 开始位置</span><br><span class="line">     * @param end   结束位置, -1查询所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取zset集合的所有元素, 从小到大排序</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRangeAll(String key) &#123;</span><br><span class="line">        return zRange(key, 0, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合元素, 并且把score值也获取</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, long start,</span><br><span class="line">                                                                   long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeWithScores(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min 最小值</span><br><span class="line">     * @param max 最大值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zRangeByScore(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从小到大排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min 最小值</span><br><span class="line">     * @param max 最大值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,</span><br><span class="line">                                                                          double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,</span><br><span class="line">                                                                          double min, double max, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max,</span><br><span class="line">                start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRange(key, start, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, long min, long max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合的元素, 从大到小排序, 并返回score值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key,</span><br><span class="line">                                                                          long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeWithScores(key, start,</span><br><span class="line">                end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, double min,</span><br><span class="line">                                            double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Score值查询集合元素, 从大到小排序</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores(</span><br><span class="line">            String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key,</span><br><span class="line">                min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; zReverseRangeByScore(String key, double min,</span><br><span class="line">                                            double max, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().reverseRangeByScore(key, min, max,</span><br><span class="line">                start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据score值获取集合元素数量</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zCount(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().count(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zSize(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合大小</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zZCard(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().zCard(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取集合中value元素的score值</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double zScore(String key, Object value) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().score(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移除指定索引位置的成员</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param start</span><br><span class="line">     * @param end</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemoveRange(String key, long start, long end) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().removeRange(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据指定的score值的范围来移除成员</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param min</span><br><span class="line">     * @param max</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zRemoveRangeByScore(String key, double min, double max) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().removeRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取key和otherKey的并集并存储在destKey中</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zUnionAndStore(String key, String otherKey, String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zUnionAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                               String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet()</span><br><span class="line">                .unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKey</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zIntersectAndStore(String key, String otherKey,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().intersectAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交集</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param otherKeys</span><br><span class="line">     * @param destKey</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long zIntersectAndStore(String key, Collection&lt;String&gt; otherKeys,</span><br><span class="line">                                   String destKey) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().intersectAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param key</span><br><span class="line">     * @param options</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Cursor&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForZSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="管道辅助类"><a href="#管道辅助类" class="headerlink" title="管道辅助类"></a>管道辅助类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisPipelineUtils &#123;</span><br><span class="line">    private final StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    /**</span><br><span class="line">     * 扫描主键，建议使用</span><br><span class="line">     *</span><br><span class="line">     * @param patten</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; scan(String patten) &#123;</span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.execute((RedisCallback&lt;Set&lt;String&gt;&gt;) connection -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">            try (Cursor&lt;byte[]&gt; cursor = connection.scan( ScanOptions.scanOptions()</span><br><span class="line">                    .match(patten).count(10000).build())) &#123;</span><br><span class="line">                while (cursor.hasNext()) &#123;</span><br><span class="line">                    result.add(new String(cursor.next()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;);</span><br><span class="line">        return keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 管道技术，提高性能</span><br><span class="line">     *</span><br><span class="line">     * @param type</span><br><span class="line">     * @param values</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;Object&gt; lRightPushPipeline(String type, Collection&lt;String&gt; values) &#123;</span><br><span class="line">        List&lt;Object&gt; results = stringRedisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">                StringRedisConnection stringRedisConn = (StringRedisConnection) connection;</span><br><span class="line">                //集合转换数组</span><br><span class="line">                String[] strings = values.toArray(new String[values.size()]);</span><br><span class="line">                //直接批量发送</span><br><span class="line">                stringRedisConn.rPush(type, strings);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public List&lt;Object&gt; refreshWithPipeline(String futureKey, String topicKey, Collection&lt;String&gt; tasks) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; result = stringRedisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Nullable</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123;</span><br><span class="line">                StringRedisConnection stringRedisConnection = (StringRedisConnection) redisConnection;</span><br><span class="line">                String[] allTask = tasks.toArray(new String[tasks.size()]);</span><br><span class="line">                stringRedisConnection.lPush(topicKey, allTask);</span><br><span class="line">                stringRedisConnection.zRem(futureKey, allTask);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自定义RedissonClient"><a href="#自定义RedissonClient" class="headerlink" title="自定义RedissonClient"></a>自定义RedissonClient</h2><p>缓存我们使用的RedisTemplate，但是布隆处理器和分布式锁我们需要使用RedissonClient，增加RedissonClient配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><br><span class="line">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><br><span class="line">public class RedissonClientAutoConfiguration &#123;</span><br><span class="line">    private RedisProperties redisProperties;</span><br><span class="line"></span><br><span class="line">    private final static String SCHEMA = &quot;redis://&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">            name = &#123;&quot;redissonClient&quot;&#125;</span><br><span class="line">    )</span><br><span class="line">    public RedissonClient redissonClient()&#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line"></span><br><span class="line">        //集群模式</span><br><span class="line">        if(redisProperties.getCluster() != null)&#123;</span><br><span class="line">            RedisProperties.Cluster cluster = redisProperties.getCluster();</span><br><span class="line">            List&lt;String&gt; nodes = cluster.getNodes();</span><br><span class="line"></span><br><span class="line">            ClusterServersConfig clusterServersConfig = config.useClusterServers()</span><br><span class="line">                    .addNodeAddress(getSchemaAddress(nodes));</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                clusterServersConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line">            //哨兵模式</span><br><span class="line">        &#125;else if (redisProperties.getSentinel() != null)&#123;</span><br><span class="line">            RedisProperties.Sentinel sentinel = redisProperties.getSentinel();</span><br><span class="line">            List&lt;String&gt; nodes = sentinel.getNodes();</span><br><span class="line"></span><br><span class="line">            SentinelServersConfig sentinelServersConfig = config.useSentinelServers()</span><br><span class="line">                    .setMasterName(sentinel.getMaster())</span><br><span class="line">                    .setConnectTimeout(50000)</span><br><span class="line">                    .addSentinelAddress(getSchemaAddress(nodes))</span><br><span class="line">                    .setMasterConnectionPoolSize(64)</span><br><span class="line">                    .setMasterConnectionMinimumIdleSize(32)</span><br><span class="line">                    .setSlaveConnectionPoolSize(64)</span><br><span class="line">                    .setSlaveConnectionMinimumIdleSize(32);</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                sentinelServersConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            SingleServerConfig singleServerConfig = config.useSingleServer()</span><br><span class="line">                    .setAddress(SCHEMA + redisProperties.getHost() + &quot;:&quot; + redisProperties.getPort())</span><br><span class="line">                    .setDatabase(redisProperties.getDatabase());</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(redisProperties.getPassword()))&#123;</span><br><span class="line">                singleServerConfig.setPassword(redisProperties.getPassword());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        config.setCodec(new JsonJacksonCodec());</span><br><span class="line"></span><br><span class="line">        return Redisson.create(config);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建Schema的redis连接</span><br><span class="line">     * @param nodes 节点</span><br><span class="line">     * @return schema数组</span><br><span class="line">     */</span><br><span class="line">    private String[] getSchemaAddress(List&lt;String&gt; nodes) &#123;</span><br><span class="line">        String[] sentinelAddressesWithSchema = new String[nodes.size()];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            sentinelAddressesWithSchema[i] = SCHEMA + nodes.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sentinelAddressesWithSchema;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布隆处理器"><a href="#布隆处理器" class="headerlink" title="布隆处理器"></a>布隆处理器</h2><p>布隆过滤器（Bloom filter）是一种空间效率极高的概率型数据结构，用于判断一个元素是否在一个集合中。它的原理是当一个元素被加入集合时，通过几个不同的Hash函数将元素映射成一个位数组中的多个位置，再次查询时如果位数组中的每一位都此被设置过，则肯定在集合中。如果这些位有任何一位没有被设置过，则肯定不在集合中。主要的优点是空间效率和查询时间都远超一般的算法。</p>
<p>布隆过滤器可以用来解决缓存穿透问题。在接到一个查询请求时，先用布隆过滤器检查，如果布隆过滤器判断元素不在集合中，那么就可以不用去数据库中查询了，直接返回“元素不存在”。</p>
<p>一般在使用布隆过滤器的具体操作为：</p>
<ol>
<li>先将所有可能查询的数据hash到布隆过滤器中</li>
<li>当用户查询数据的时候，首先在布隆过滤器查询数据是否存在</li>
<li>如果布隆过滤器认为数据不存在，则直接返回给用户“数据不存在”</li>
<li>如果布隆过滤器认为数据存在，那么再去数据库中查询数据</li>
<li>再将数据库查询出来的数据存入缓存</li>
</ol>
<p>定义一个简单的布隆过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class PomeloBloomFilterAutoConfiguration &#123;</span><br><span class="line">    private static final String BLOOM_KEY = &quot;pomelo_bloom_filter&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 布隆过滤器</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RBloomFilter&lt;String&gt; cacheBloomFilter(RedissonClient redissonClient) &#123;</span><br><span class="line">        RBloomFilter&lt;String&gt; rBloomFilter = redissonClient.getBloomFilter(BLOOM_KEY);</span><br><span class="line">        rBloomFilter.tryInit(50000L, 0.03D);</span><br><span class="line">        return rBloomFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义一个简单的过滤器工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedisBloomFilterUtils &#123;</span><br><span class="line">    private  final RBloomFilter bloomFilter;;</span><br><span class="line">    public boolean add(String value) &#123;</span><br><span class="line">        return bloomFilter.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean contains(String value) &#123;</span><br><span class="line">        return bloomFilter.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><font style="color:rgb(77, 77, 77);">并发执行是比较场景的场景，单机情况下，我们可以利用</font><a href="https://so.csdn.net/so/search?q=%E9%94%81%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020">锁机制</a><font style="color:rgb(77, 77, 77);">来实现顺序执行。然而微服务时代，多节点运行，如何让某业务可以同一时刻只允许一个任务运行呢？</font><br><font style="color:rgb(77, 77, 77);">Redisson实现分布式锁的用法，可以很容易实现分布式锁的配置。</font></p>
<p><font style="color:rgb(77, 77, 77);">我们按照本地模式来在辅助类中实现本地锁</font></p>
<p><font style="color:rgb(77, 77, 77);">定义ILock</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ILock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 加锁，并返回锁对象</span><br><span class="line">     */</span><br><span class="line">    Lock tryLock(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放锁对象</span><br><span class="line">     */</span><br><span class="line">    void unlock(Lock lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义DistributeLock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface DistributeLock extends ILock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建锁实例</span><br><span class="line">     */</span><br><span class="line">    RLock getLock(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建公平锁实例</span><br><span class="line">     */</span><br><span class="line">    RLock getFairLock(String key);</span><br><span class="line"></span><br><span class="line">    boolean tryLock(RLock lock);</span><br><span class="line">    boolean tryLock(RLock lock, long timeout);</span><br><span class="line"></span><br><span class="line">    RLock tryLock(String key);</span><br><span class="line">    RLock tryLock(String key, long timeout) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    RLock tryLock(String key, long timeout, TimeUnit timeUnit) throws InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现DistributeLock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class RedissonDistributeLock implements DistributeLock&#123;</span><br><span class="line">    private final RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock getLock(String key) &#123;</span><br><span class="line">        return redissonClient.getLock(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock getFairLock(String key) &#123;</span><br><span class="line">        return redissonClient.getFairLock(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(RLock lock) &#123;</span><br><span class="line">        return lock.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(RLock lock, long timeout) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (lock.tryLock(timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key) &#123;</span><br><span class="line">        RLock lock = getLock(key);</span><br><span class="line">        if (lock.tryLock()) &#123;</span><br><span class="line">            return lock; // 直接返回锁对象</span><br><span class="line">        &#125;</span><br><span class="line">        return null; // 获取锁失败，返回null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key, long timeout) &#123;</span><br><span class="line">        return tryLock(key, timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    @Override</span><br><span class="line">    public RLock tryLock(String key, long timeout, TimeUnit timeUnit) &#123;</span><br><span class="line">        RLock lock = getLock(key);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (lock.tryLock(timeout, timeUnit)) &#123;</span><br><span class="line">                return lock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(Lock lock) &#123;</span><br><span class="line">        if (lock instanceof RLock) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自动配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">public class PomeloLockAutoConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnClass(RedissonClient.class)</span><br><span class="line">    public DistributeLock redissonDistributeLock(RedissonClient redissonClient) &#123;</span><br><span class="line">        return new RedissonDistributeLock(redissonClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>工具</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>统一返回时间格式</title>
    <url>/2024/10/06/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>在springboot中@RestController的返回会使用Jackson来将响应序列化为json格式，所以构建统一的响应中的日期格式可以定义统一的序列化参数来实现，springboot自带的时间格式定义怎么处理的</p>
<span id="more"></span>
<h3 id="1-使用-DateTimeFormat和-JsonFormat都是处理时间格式化问题的"><a href="#1-使用-DateTimeFormat和-JsonFormat都是处理时间格式化问题的" class="headerlink" title="1.使用@DateTimeFormat和@JsonFormat都是处理时间格式化问题的"></a>1.使用@DateTimeFormat和@JsonFormat都是处理时间格式化问题的</h3><table>
<thead>
<tr>
<th>区别</th>
<th>@DateTimeFormat</th>
<th>@JsonFormat</th>
</tr>
</thead>
<tbody><tr>
<td>使用方法</td>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”)</font></td>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">@JsonFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”, timezone &#x3D; “GMT+8”)</font></td>
</tr>
<tr>
<td>使用场景</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">URL传参时，格式化前端传向后端日期类型的时间格式</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">JSON传参，格式化前端传参和后端返回给前端的时间格式，传参可能不一定是json，但是一般接口向前端返回数据，基本上都是封装的统一返回格式，然后JSON返回。所以这个注解是一定要加的！</font></td>
</tr>
<tr>
<td>使用地方</td>
<td><font style="color:rgb(79, 79, 79);">实体类日期字段上、或者字段的set方法上、或者方法入参上</font></td>
<td><font style="color:rgb(79, 79, 79);">实体类日期字段上、或者字段的set方法上、、或者方法入参上</font></td>
</tr>
<tr>
<td>来源</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">org.springframework.format.annotation</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">com.fasterxml.jackson.annotation</font></td>
</tr>
</tbody></table>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>一旦使用yyyy-MM-dd 格式，如果传时分秒就会报错，或者是使用 yyyy-MM-dd HH:mm:ss，如果传yyyy-MM-dd 也会报错。</li>
<li>假如是springboot项目的话，使用这两个注解是不用导其他的依赖包的！</li>
<li>框架当中默认他会认为 前端传的是UTC时间，然后SpringMVC在接到参数的时候，会进行转换为本地区时间，向前端返回参数的时候会转换为UTC时间！</li>
<li>这两个注解可以选择在实体类的set方法当中使用，也可以在字段上使用，效果是一样的！</li>
</ul>
<h3 id="2-在全局配置文件中设置"><a href="#2-在全局配置文件中设置" class="headerlink" title="2.在全局配置文件中设置"></a>2.在全局配置文件中设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss </span><br><span class="line">    time-zone: GMT+8</span><br></pre></td></tr></table></figure>

<h3 id="3-通过JavaBean方式配置"><a href="#3-通过JavaBean方式配置" class="headerlink" title="3.通过JavaBean方式配置"></a>3.通过JavaBean方式配置</h3><p>定义DateForamtConfiguration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DateForamtConfiguration &#123;</span><br><span class="line"></span><br><span class="line">        public static final String timeFormat = &quot;HH:mm:ss&quot;;</span><br><span class="line">        public static final String dateFormat = &quot;yyyy-MM-dd&quot;;</span><br><span class="line">        public static final String dateTimeFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 全局时间格式化</span><br><span class="line">         */</span><br><span class="line">        @Bean</span><br><span class="line">        public Jackson2ObjectMapperBuilderCustomizer customizer() &#123;</span><br><span class="line">            return builder -&gt; &#123;</span><br><span class="line">                builder.simpleDateFormat(dateTimeFormat);</span><br><span class="line">                //日期序列化</span><br><span class="line">                builder.serializers(new LocalTimeSerializer(DateTimeFormatter.ofPattern(timeFormat)));</span><br><span class="line">                builder.serializers(new LocalDateSerializer(DateTimeFormatter.ofPattern(dateFormat)));</span><br><span class="line">                builder.serializers(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(dateTimeFormat)));</span><br><span class="line">                //日期反序列化</span><br><span class="line">                builder.deserializers(new LocalTimeDeserializer(DateTimeFormatter.ofPattern(timeFormat)));</span><br><span class="line">                builder.deserializers(new LocalDateDeserializer(DateTimeFormatter.ofPattern(dateFormat)));</span><br><span class="line">                builder.deserializers(new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(dateTimeFormat)));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>格式化</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>集成Nacos+SpringCloudGateway实现配置中心以及服务发现</title>
    <url>/2024/10/03/%E9%9B%86%E6%88%90Nacos+SpringCloudGateway%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>前面已经实现了统一返回以及异常处理，也完成了通用的数据模块，我们已经可以借此来实现服务，但是在微服务中肯定不会只有一个服务，当我们有多个服务的时候，会出现多个痛点：</p>
<ol>
<li>当服务多的时候分布在不同的服务器上部署的时候，前端寻址将是困难重重，所以需要一个统一的入口，来帮助前端来访问这些服务</li>
<li>多个服务分部在不同的主机上，当我们因为某种原因需要修改多个服务的配置文件时，工作量巨大。</li>
</ol>
<p>而Nacos+SpringCloudGateway可以帮我们解决这个问题</p>
<span id="more"></span>
<h2 id="集成Nacos"><a href="#集成Nacos" class="headerlink" title="集成Nacos"></a>集成Nacos</h2><h3 id="nacos是做什么的"><a href="#nacos是做什么的" class="headerlink" title="nacos是做什么的"></a>nacos是做什么的</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723102566330-cd999175-7353-4a7c-977c-9c09184126c6.png"></p>
<p>nacos的官网关于nacos的介绍一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台，那他有什么作用呢<img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723102912210-7e6f66de-bf32-4988-aeae-aa4e993406c0.png"></p>
<p>官网的描述是这样的，总结一下有两点：服务发现和服务注册以及配置管理，那nacos能做些什么呢</p>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册:"></a>服务注册:</h4><p>服务提供者在启动时向 Nacos 注册中心注册自己的服务信息，包括服务名称、IP 地址、端口号等。</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现:"></a>服务发现:</h4><p>服务消费者从 Nacos 注册中心获取服务提供者的信息，从而能够调用服务。</p>
<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查:"></a>健康检查:</h4><p>Nacos 支持服务实例的健康检查，可以自动剔除不健康的服务实例。</p>
<h4 id="服务元数据管理"><a href="#服务元数据管理" class="headerlink" title="服务元数据管理:"></a>服务元数据管理:</h4><p>除了基本的服务信息外，还可以附加服务的元数据，如版本、权重等。</p>
<h4 id="服务分组"><a href="#服务分组" class="headerlink" title="服务分组:"></a>服务分组:</h4><p>支持服务分组，可以根据不同的业务场景将服务划分到不同的组。</p>
<h4 id="服务版本控制"><a href="#服务版本控制" class="headerlink" title="服务版本控制:"></a>服务版本控制:</h4><p>支持服务版本管理，便于灰度发布和回滚。</p>
<h4 id="配置管理："><a href="#配置管理：" class="headerlink" title="配置管理："></a>配置管理：</h4><p>动态的配置管理用于集中管理配置文件</p>
<h3 id="在user模块中集成nacos"><a href="#在user模块中集成nacos" class="headerlink" title="在user模块中集成nacos"></a>在user模块中集成nacos</h3><p>首先定义pom文件（前文中已经定义了nacos的版本）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>启动类增加@EnableDiscoveryClient</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class PomeloCustomerModulesApplication &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(PomeloCustomerModulesApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加文件bootstrap.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  port: 5030</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: pomelo-customer</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # 服务注册地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        namespace: c3477374-9bfd-4c52-a511-8a99468d7759</span><br><span class="line">      config:</span><br><span class="line">        # 配置中心地址</span><br><span class="line">        server-addr: 你的nacos地址:8848</span><br><span class="line">        # 配置文件格式</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # 共享配置</span><br><span class="line">        shared-configs:</span><br><span class="line">          - application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">        namespace: c3477374-9bfd-4c52-a511-8a99468d7759</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>启动服务</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723189847074-be1be5fa-4d1c-4948-bd2a-95e1bbc355d7.png"></p>
<p>可以看到已经连接到nacos</p>
<h2 id="集成SpringCloudGateway"><a href="#集成SpringCloudGateway" class="headerlink" title="集成SpringCloudGateway"></a>集成SpringCloudGateway</h2><h3 id="SpringCloudGateway是做什么的"><a href="#SpringCloudGateway是做什么的" class="headerlink" title="SpringCloudGateway是做什么的"></a>SpringCloudGateway是做什么的</h3><pre><code>在微服务架构中，一个系统会被拆分为很多个微服务。那么作为客户端要如何去调用这么多的微服务呢？如果没有网关的存在，我们只能在客户端记录每个微服务的地址，然后分别去调用。这样的话会产生很多问题，例如：
</code></pre>
<ul>
<li>客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性</li>
<li>认证复杂，每个微服务都有独立认证</li>
<li>存在跨域请求，在一定场景下处理相对复杂</li>
</ul>
<p>为解决上面的问题所以引入了网关的概念：所谓的API网关，就是指系统的统一入口，提供内部服务的路由中转，为客户端提供统一服务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、路由转发等。</p>
<p><font style="color:rgb(0, 0, 0);">Spring Cloud Gateway就是api网关。官网上对Spring Cloud Gateway如下：</font></p>
<p>:::info<br><font style="color:rgb(0, 0, 0);">This project provides a libraries for building an API Gateway on top of Spring WebFlux or Spring WebMVC. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring&#x2F;metrics, and resiliency.</font></p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a><font style="color:rgb(0, 0, 0);">Features</font></h2><p><font style="color:rgb(0, 0, 0);">Spring Cloud Gateway features:</font></p>
<ul>
<li><font style="color:rgb(0, 0, 0);">Built on Spring Framework and Spring Boot</font></li>
<li><font style="color:rgb(0, 0, 0);">Able to match routes on any request attribute.</font></li>
<li><font style="color:rgb(0, 0, 0);">Predicates and filters are specific to routes.</font></li>
<li><font style="color:rgb(0, 0, 0);">Circuit Breaker integration.</font></li>
<li><font style="color:rgb(0, 0, 0);">Spring Cloud DiscoveryClient integration</font></li>
<li><font style="color:rgb(0, 0, 0);">Easy to write Predicates and Filters</font></li>
<li><font style="color:rgb(0, 0, 0);">Request Rate Limiting</font></li>
<li><font style="color:rgb(0, 0, 0);">Path Rewriting</font></li>
</ul>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring5.0+Spring Boot20和 Project Reactor等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的API路由管理方式。</font></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><font style="color:rgb(79, 79, 79);">作用</font></h4><ul>
<li><font style="color:rgb(77, 77, 77);">反向代理</font></li>
<li><font style="color:rgb(77, 77, 77);">鉴权</font></li>
<li><font style="color:rgb(77, 77, 77);">流量控制</font></li>
<li><font style="color:rgb(77, 77, 77);">熔断</font></li>
<li><font style="color:rgb(77, 77, 77);">日志监控</font></li>
</ul>
<h3 id="通过SpringCloudGateway找到user模块"><a href="#通过SpringCloudGateway找到user模块" class="headerlink" title="通过SpringCloudGateway找到user模块"></a>通过SpringCloudGateway找到user模块</h3><p>当了解过概念后我们来动手实践一下</p>
<h4 id="第一步引入pom"><a href="#第一步引入pom" class="headerlink" title="第一步引入pom"></a>第一步引入pom</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--nacos--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二步引入nacos"><a href="#第二步引入nacos" class="headerlink" title="第二步引入nacos"></a>第二步引入nacos</h4><p>按照上面nacos的步驟做一遍</p>
<h4 id="第三步配置路由"><a href="#第三步配置路由" class="headerlink" title="第三步配置路由"></a>第三步配置路由</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          lowerCaseServiceId: true</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: pomelo-user</span><br><span class="line">        uri: lb://pomelo-user</span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/user/**</span><br><span class="line">        filters:</span><br><span class="line">          - StripPrefix=1</span><br></pre></td></tr></table></figure>

<h4 id="第四步测试"><a href="#第四步测试" class="headerlink" title="第四步测试"></a>第四步测试</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1723191800165-3fce78f5-7a95-4d7e-8fd5-c36b50d2b6bd.png"></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>nacos</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2024/05/03/%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>类型</th>
<th>单体</th>
<th>微服务</th>
</tr>
</thead>
<tbody><tr>
<td>部署速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>扩展能力</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>复用能力</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>复杂度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>耦合度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>调试</td>
<td>容易</td>
<td>困难</td>
</tr>
<tr>
<td>问题排查</td>
<td>容易</td>
<td>困难</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>差</td>
</tr>
</tbody></table>
<span id="more"></span>


<p>单体应用：随着时间的积累代码量越来越大构建速度会越来越慢，部署也会越来越慢，随着代码的积累各种代码的耦合度会越来越高，技术债务逐步上升代码的扩展能力持续下降，复用困难，业务为了避免各种技术债务复杂度会越来越高。因为技术债务较高当开发人员离职后，继任者需要大量的时间去熟悉系统和代码，造成经济损失。但是在开发中单体服务代码集中日志集中所以调试简单，问题排查过程简单。而且单体中不需要额外的服务调用所以性能会更好一点</p>
<p>微服务应用：通过设计将业务进行拆分，降低各个服务间的耦合，每个服务独立部署并且实现服务轻量化，所以构建迅速。因为各个服务独立与其他服务耦合度低所以复用能力和扩展能力更强，每个服务更专注自己的业务领域所以业务的复杂度更低。复杂度更低即使开发人员离职，继任者只需要了解自己需要负责的服务就可以胜任。但是微服务因为做了拆分所以数据的交换需要进行进程通讯，而且同一个请求可能经过多个服务。进程间的通讯会对性能产生影响，请求经过多个服务会使数据的事务实施困难，以及单个请求的异常因为链路太长定位问题困难。</p>
<p>针对微服务的缺点我们的弥补措施：</p>
<p>微服务之间互相调用网络请求的瓶颈：尽量的明确接口数据长度，使用缓存，减少服务间的交互，更改交互方式为rpc</p>
<p>调试和问题排查：问题排查主要是分为两部分</p>
<p>1.问题的定位问题： 引入skywalking来对全链路进行追踪</p>
<p>2.问题的上下文信息获取：引入ELK日志管理解决方案，对日志进行集中，并通过skywalking提供的唯一ID对数据进行查询分析</p>
<p>事务：事务可以根据业务情况来使用诸如两段式提交的解决方案或者使用最终一致性解决方案来解决</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>单体</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign调用时如何传递传递Token并且多线程环境也能适用</title>
    <url>/2024/10/16/OpenFeign%E8%B0%83%E7%94%A8%E6%97%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E4%BC%A0%E9%80%92Token%E5%B9%B6%E4%B8%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B9%9F%E8%83%BD%E9%80%82%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>在上一片文章中我<font style="color:rgb(47, 48, 52);">们解决了网关层认证后向后端服务传递用户信息的问题。今天我们来解决另外一个问题：如何在 OpenFeign 中传递 Token，并且保证多线程情况下也能适用。</font></p>
<span id="more"></span>
<p><font style="color:rgb(47, 48, 52);">如果我们想要在OpenFeign中获取到用户信息，我们可以通过如下步骤实现</font></p>
<h3 id="实现RequestInterceptor接口"><a href="#实现RequestInterceptor接口" class="headerlink" title="实现RequestInterceptor接口"></a><font style="color:rgb(47, 48, 52);">实现RequestInterceptor接口</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloFeignRequestInterceptor implements RequestInterceptor &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void apply(RequestTemplate requestTemplate) &#123;</span><br><span class="line">        Map&lt;String, String&gt; headerMap = RequestHeaderContextHolder.getInstance().get();</span><br><span class="line">        if (ObjectUtil.isNotEmpty(headerMap)) &#123;</span><br><span class="line">            // heders头透传</span><br><span class="line">            for (Map.Entry&lt;String, String&gt; entry : headerMap.entrySet()) &#123;</span><br><span class="line">                requestTemplate.header(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用InheritableThreadLocal保存header信息"><a href="#使用InheritableThreadLocal保存header信息" class="headerlink" title="使用InheritableThreadLocal保存header信息"></a>使用<font style="color:rgb(47, 48, 52);">InheritableThreadLocal保存header信息</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RequestHeaderContextHolder &#123;</span><br><span class="line">    </span><br><span class="line">    // 使用InheritableThreadLocal，使得共享变量可被子线程继承</span><br><span class="line">    private final ThreadLocal&lt;Map&lt;String, String&gt;&gt; REQUEST_HEADER_HOLDER;</span><br><span class="line">    private RequestHeaderContextHolder() &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER = new InheritableThreadLocal&lt;&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            protected Map&lt;String, String&gt; initialValue() &#123;</span><br><span class="line">                return new HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * return RequestHeaderHolder instance</span><br><span class="line">     */</span><br><span class="line">    public static RequestHeaderContextHolder getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 根据键获取请求头的值</span><br><span class="line">     * @param key 请求头的键</span><br><span class="line">     * @return 对应键的值</span><br><span class="line">     */</span><br><span class="line">    public String getValue(String key) &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取当前线程的请求头信息</span><br><span class="line">     * @return 请求头Map</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, String&gt; get() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取当前线程的用户信息</span><br><span class="line">     * @return 当前用户信息</span><br><span class="line">     */</span><br><span class="line">    public String getCurrentUser() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCurrentUserName() &#123;</span><br><span class="line">        return this.REQUEST_HEADER_HOLDER.get().get(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 设置当前线程的用户信息</span><br><span class="line">     * @param userId 用户ID</span><br><span class="line">     */</span><br><span class="line">    public void setCurrentUser(String userId) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_ID_HEADER, userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentUser(String userId, String userName) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_ID_HEADER, userId);</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(SecurityConstants.USER_NAME_HEADER, userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 设置请求头信息</span><br><span class="line">     */</span><br><span class="line">    public void set(String key, String value) &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.get().put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        this.REQUEST_HEADER_HOLDER.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类的单例模式</span><br><span class="line">     */</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        </span><br><span class="line">        private static final RequestHeaderContextHolder instance = new RequestHeaderContextHolder();</span><br><span class="line">        private SingletonHolder() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改请求拦截器"><a href="#修改请求拦截器" class="headerlink" title="修改请求拦截器"></a><font style="color:rgb(47, 48, 52);">修改请求拦截器</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserTokenHandlerInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String userId = request.getHeader(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">        String userName = request.getHeader(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">        RequestHeaderContextHolder.getInstance().setCurrentUser(userId, userName);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        RequestHeaderContextHolder.getInstance().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>通过实现requestInterceotor接口我们在每次进行feign调用时都会将header头文件进行传递。但是在异步的环境中无法获取到header头文件信息，我们通过自定义<font style="color:rgb(47, 48, 52);">InheritableThreadLocal结构体对header进行保存然后贡献的形式进行处理。这样可以在不同的场景下依然可以完成数据的保存</font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Sa-Token的微服务权限验证</title>
    <url>/2024/10/06/%E5%9F%BA%E4%BA%8ESa-Token%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p><strong><font style="color:rgb(44, 62, 80);">Sa-Token</font></strong><font style="color:rgb(52, 73, 94);"> 是一个轻量级 Java 权限认证框架主，要解决：</font><strong><font style="color:rgb(44, 62, 80);">登录认证</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">权限认证</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">单点登录</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">OAuth2.0</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">分布式Session会话</font></strong><font style="color:rgb(52, 73, 94);">、</font><strong><font style="color:rgb(44, 62, 80);">微服务网关鉴权</font></strong><font style="color:rgb(52, 73, 94);"> 等一系列权限相关问题。Sa-Token 旨在以简单、优雅的方式完成系统的权限认证部分。</font></p>
<p><font style="color:rgb(52, 73, 94);">官网地址：</font><a href="https://sa-token.cc/">https://sa-token.cc/</a></p>
<span id="more"></span>
<h2 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>多种登陆模式，账号密码，手机号验证码等</li>
<li>网关验证登陆是否过期，黑白名单等处理</li>
<li>可以支持角色和权限字符串鉴权验证</li>
<li>实现登出功能</li>
<li>减少数据库访问，登陆后数据详情放入redis中</li>
</ul>
<p>在pomelo中权限的验证，采用了token格式的数据，对与用户信息进行缓存的形式进行操作，并没有使用jwt，主要考虑有两种：jwt的数据保存在token字符串中，增加了前端到后段的通讯负担，敏感数据的解析一样需要从服务端中获取，所以在pomelo中，我们直接使用token来进行交互，并把用户的数据保存在redis缓存中，虽然需要承担redis缓存宕机带来的用户验证异常，但是也拥有很高的灵活性</p>
<h3 id="网关统一认证处理"><a href="#网关统一认证处理" class="headerlink" title="网关统一认证处理"></a>网关统一认证处理</h3><p>网关可以统一的来实现权限的认证，但是不够灵活，所以在网关中只对消息中是否存在token来进行判断，token消息是否过期进行处理，当消息正常时新增Header对token进行透传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class AuthFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DistributedCache distributedCache;</span><br><span class="line">    // 排除过滤的 uri 地址，nacos自行添加</span><br><span class="line">    @Autowired</span><br><span class="line">    private IgnoreWhiteProperties ignoreWhite;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthProperties authProperties;</span><br><span class="line">    /**</span><br><span class="line">     * 连接 Token 前缀和 Token 值的字符</span><br><span class="line">     */</span><br><span class="line">    public static final String TOKEN_CONNECTOR_CHAT  = &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">        String path = exchange.getRequest().getURI().getPath();</span><br><span class="line">        // 跳过不需要验证的路径</span><br><span class="line">        if (StringUtils.matches(path, ignoreWhite.getWhites())) &#123;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        String token = getToken(request);</span><br><span class="line">        if (StrUtil.isEmpty(token)) &#123;</span><br><span class="line">            return unauthorizedResponse(exchange, ErrorCode.TOKEN_EMPTY_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        // 验证token是否过期</span><br><span class="line">        if (!distributedCache.hasKey(authProperties.getIdentifier() + &quot;:login:token:&quot; + token)) &#123;</span><br><span class="line">            return unauthorizedResponse(exchange, ErrorCode.TOKEN_EXPIRATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String prefixToken =String.format(&quot;%s%s%s&quot;, authProperties.getPrefix(),TOKEN_CONNECTOR_CHAT, token) ;</span><br><span class="line">        addHeader(mutate, authProperties.getIdentifier(), prefixToken,true);</span><br><span class="line">        String loginUserKey  = String.format(&quot;%S%S&quot;, SecurityConstants.USER_KEY, token);</span><br><span class="line">        if (distributedCache.hasKey(loginUserKey)) &#123;</span><br><span class="line">            LoginUser loginUser= distributedCache.get(loginUserKey, LoginUser.class);</span><br><span class="line">            if (loginUser != null)&#123;</span><br><span class="line">                addHeader(mutate, SecurityConstants.USER_ID_HEADER, loginUser.getUserId(),false);</span><br><span class="line">                addHeader(mutate, SecurityConstants.USER_NAME_HEADER, loginUser.getUserName(),false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addHeader(ServerHttpRequest.Builder mutate, String name, Object value,Boolean isEncode) &#123;</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueStr = value.toString();</span><br><span class="line">        if (isEncode)&#123;</span><br><span class="line">            mutate.header(name, valueStr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String valueEncode = ServletUtils.urlEncode(valueStr);</span><br><span class="line">        mutate.header(name, valueEncode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Mono&lt;Void&gt; unauthorizedResponse(ServerWebExchange exchange, ErrorCode errorCode) &#123;</span><br><span class="line">        log.error(&quot;[鉴权异常处理]请求路径:&#123;&#125;&quot;, exchange.getRequest().getPath());</span><br><span class="line">        return ServletUtils.webFluxResponseWriter(exchange.getResponse(), errorCode.getMessage(), errorCode.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求token</span><br><span class="line">     */</span><br><span class="line">    private String getToken(ServerHttpRequest request) &#123;</span><br><span class="line">        String token = request.getHeaders().getFirst(SecurityConstants.AUTHORIZATION_HEADER);</span><br><span class="line">        // 如果前端设置了令牌前缀，则裁剪掉前缀</span><br><span class="line">        if (StrUtil.isNotEmpty(token) &amp;&amp; token.startsWith(authProperties.getPrefix())) &#123;</span><br><span class="line">            token = token.replaceFirst(authProperties.getPrefix(), &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="登陆授权"><a href="#登陆授权" class="headerlink" title="登陆授权"></a>登陆授权</h3><p>登陆需要支持两种模式一种是短信登陆，以及账号密码登陆。短信登陆时如果账号未注册，直接注册新用户，账号密码需要提前注册后才能登陆。当用户身份验证通过后，需要将token放入redis用于处理token超时的问题，2将token与用户信息关联，为后续验证做好准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public LoginRspVo login(LoginDTO loginDTO) &#123;</span><br><span class="line">       // 预认证 验证参数</span><br><span class="line">       preAuthenticationCheck(loginDTO);</span><br><span class="line">       // 认证</span><br><span class="line">       LoginUser loginUser = authenticate(loginDTO);</span><br><span class="line">       CacheUtil.addLoginUser(loginUser);</span><br><span class="line">       // 角色获取</span><br><span class="line">       List&lt;String&gt; roles = getRoles(loginUser.getUserId());</span><br><span class="line">       if (CollectionUtil.isNotEmpty(roles))&#123;</span><br><span class="line">           CacheUtil.updateRoleCache(loginUser.getUserId(), roles);</span><br><span class="line"></span><br><span class="line">           // 权限获取</span><br><span class="line">           for (String role : roles) &#123;</span><br><span class="line">               List&lt;String&gt; permissions = getPermissions(role);</span><br><span class="line">               CacheUtil.updatePermissionCache(role, permissions);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       LoginRspVo loginRspVo = new LoginRspVo();</span><br><span class="line">       loginRspVo.setAccess_token(loginUser.getToken());</span><br><span class="line">       loginRspVo.setUserId(loginUser.getUserId());</span><br><span class="line">       loginRspVo.setUserName(loginUser.getUserName());</span><br><span class="line">       loginRspVo.setLoginTime(loginUser.getLoginTime());</span><br><span class="line">       return loginRspVo;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>实现思路：当系统用户登录完成后，将用户数据放入缓存，以及将用户的角色和权限信息放入到缓存。以供网关以及后续鉴权提供数据支持。</p>
<h3 id="服务鉴权"><a href="#服务鉴权" class="headerlink" title="服务鉴权"></a>服务鉴权</h3><p>在sa-token中提供了StpInterface借口，来对权限以及角色进行处理，处理思路：定义PomeloInterfaceImpl对用户的权限以及角色获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PomeloInterfaceImpl implements StpInterface &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public List&lt;String&gt; getPermissionList(Object loginId, String loginType) &#123;</span><br><span class="line">        // 1. 声明权限码集合</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        // 2. 遍历角色列表，查询拥有的权限码</span><br><span class="line">        for (String roleId : getRoleList(loginId, loginType)) &#123;</span><br><span class="line">            List&lt;String&gt; permissionList = (List&lt;String&gt;) SaManager.getSaTokenDao()</span><br><span class="line">                    .getObject(SaManager.getConfig().getTokenName()+&quot;:role-find-permission:&quot; + roleId);</span><br><span class="line">            if (permissionList == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            list.addAll(permissionList);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public List&lt;String&gt; getRoleList(Object loginId, String loginType) &#123;</span><br><span class="line">        List&lt;String&gt; roleList = (List&lt;String&gt;) SaManager.getSaTokenDao()</span><br><span class="line">                .getObject(SaManager.getConfig().getTokenName()+&quot;:loginId-find-role:&quot; + loginId);</span><br><span class="line">        return roleList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>权限</tag>
        <tag>sa-token</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务中的ACL与OpenFeign的绝佳配合</title>
    <url>/2024/10/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84ACL%E4%B8%8EOpenFeign%E7%9A%84%E7%BB%9D%E4%BD%B3%E9%85%8D%E5%90%88/</url>
    <content><![CDATA[<h2 id="ACL的概念"><a href="#ACL的概念" class="headerlink" title="ACL的概念"></a>ACL的概念</h2><p>在一些情况下我们需要引入第三方的接口来进行操作，但是当我们引用第三方接口的时候也会有一些隐患，第三方&#x3D;不可空，没准哪一天对方的接口参数突然就变掉了，如果我们直接在多个地方引用了第三方的接口，我们就需要在不同的地方处理接口方法，这时我们就需要引入防腐层的概念</p>
<h3 id="什么是防腐层"><a href="#什么是防腐层" class="headerlink" title="什么是防腐层"></a>什么是防腐层</h3><p>在许多情况下，我们的系统需要依赖其他系统，但被依赖的系统可能具有不合理的数据结构、API、协议或技术实现。如果我们强烈依赖外部系统，就会导致我们的系统受到<strong>“腐蚀”</strong>。在这种情况下，通过引入防腐层，可以有效地隔离外部依赖和内部逻辑，无论外部如何变化，内部代码尽可能保持不变。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737213600511-5dd8e777-8274-4482-92b6-db88a7a8179e.png"></p>
<span id="more"></span>
<p>防腐层不仅仅是一层简单的调用封装，在实际开发中，ACL可以提供更多强大的功能：</p>
<ol>
<li><strong>适配器：</strong> 很多时候外部依赖的数据、接口和协议并不符合内部规范，通过适配器模式，可以将数据转化逻辑封装到ACL内部，降低对业务代码的侵入。</li>
<li><strong>缓存：</strong> 对于频繁调用且数据变更不频繁的外部依赖，通过在ACL里嵌入缓存逻辑，能够有效的降低对于外部依赖的请求压力。同时，很多时候缓存逻辑是写在业务代码里的，通过将缓存逻辑嵌入ACL，能够降低业务代码的复杂度。</li>
<li><strong>兜底：</strong> 如果外部依赖的稳定性较差，提高系统稳定性的策略之一是通过ACL充当兜底，例如在外部依赖出问题时，返回最近一次成功的缓存或业务兜底数据。这种兜底逻辑通常复杂，如果散布在核心业务代码中，会难以维护。通过集中在ACL中，更容易进行测试和修改。</li>
<li><strong>易于测试：</strong> ACL的接口类能够很容易的实现Mock或Stub，以便于单元测试。</li>
<li><strong>功能开关：</strong> 有时候，我们希望在某些场景下启用或禁用某个接口的功能，或者让某个接口返回特定值。我们可以在ACL中配置功能开关，而不会影响真实的业务代码。</li>
</ol>
<h3 id="如何实现防腐层"><a href="#如何实现防腐层" class="headerlink" title="如何实现防腐层"></a>如何实现防腐层</h3><p><font style="color:rgb(47, 48, 52);">实现ACL防腐层的步骤如下：</font></p>
<ol>
<li><font style="color:rgb(47, 48, 52);">对于依赖的外部对象，我们提取所需的字段，并创建一个内部所需的DTO类。</font></li>
<li><font style="color:rgb(47, 48, 52);">构建一个新的Facade，在Facade中封装调用链路，将外部类转化为内部类。Facade可以参考Repository的实现模式，将接口定义在领域层，而将实现放在基础设施层。</font></li>
<li><font style="color:rgb(47, 48, 52);">在ApplicationService中依赖内部的Facade对象。</font></li>
</ol>
<p>具体的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class CustomerMenuDTO &#123;</span><br><span class="line">    // 菜单ID</span><br><span class="line">    private String menuId;</span><br><span class="line">    // 父菜单ID，一级菜单为0</span><br><span class="line">    private String parentId;</span><br><span class="line">    // 菜单名称</span><br><span class="line">    private String name;</span><br><span class="line">    // 别称</span><br><span class="line">    private String anotherName;</span><br><span class="line">    // 组件路径</span><br><span class="line">    private String component;</span><br><span class="line">    // 菜单URL</span><br><span class="line">    private String path;</span><br><span class="line">    // 排序</span><br><span class="line">    private Integer orderNum;</span><br><span class="line">    // 菜单标题</span><br><span class="line">    private String title;</span><br><span class="line">    // 授权(多个用逗号分隔)</span><br><span class="line">    private String perms;</span><br><span class="line">    // 类型 0：目录 1：菜单 2：按钮</span><br><span class="line">    private Integer type;</span><br><span class="line">    // 菜单图标</span><br><span class="line">    private String icon;</span><br><span class="line">    // 是否跳转</span><br><span class="line">    private Boolean IsFull;</span><br><span class="line">    // 是否外链</span><br><span class="line">    private String isLink;</span><br><span class="line">    // 是否隐藏</span><br><span class="line">    private Boolean isHide;</span><br><span class="line">    // 是否固定</span><br><span class="line">    private Boolean isAffix;</span><br><span class="line">    // 是否长连接</span><br><span class="line">    private Boolean isKeepAlive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">Facade</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(name = &quot;pomelo-customer&quot;)</span><br><span class="line">public interface CustomerRemoteFacade &#123;</span><br><span class="line">    //获取用户角色</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName);</span><br><span class="line">    //获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserId/&#123;UserId&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserId(@PathVariable(&quot;UserId&quot;) String UserId);</span><br><span class="line">    //根据手机号获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber);</span><br><span class="line">    //获取用户角色信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId);</span><br><span class="line">    //获取用户权限</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在服务中应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final CustomerRemoteFacade customerRemoteFacade;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  CustomerUserDTO customerUser = customerRemoteFacade.getUserInfoByPhoneNumber(phonePasswordLoginDTO.getPhone());</span><br><span class="line">       if (customerUser ==null)&#123;</span><br><span class="line">           throw new BusinessException(ErrorCode.USERNAME_PASSWORD_INCORRECT);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这样，经过acl防腐处理，我们的服务中就不需要直接调用第三方接口了，当第三方的接口有过修改，我们只需要在acl中将逻辑更改，这样并不会影响到主体业务</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><font style="color:rgb(47, 48, 52);">在没有防腐层ACL的情况下，系统需要直接依赖外部对象和外部调用接口，调用逻辑如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737214136984-079e1779-c4fe-4ae8-b17d-eab63490e35b.png"></p>
<font style="color:rgb(47, 48, 52);">  
</font>

<p><font style="color:rgb(47, 48, 52);">而有了防腐层ACL后，系统只需要依赖内部的值类和接口，调用逻辑如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2025/png/25873401/1737214136953-fab41375-7967-4827-a6d7-eb95351dd551.png"></p>
<h2 id="OpenFeign的应用"><a href="#OpenFeign的应用" class="headerlink" title="OpenFeign的应用"></a>OpenFeign的应用</h2><h3 id="微服务中的远程调用"><a href="#微服务中的远程调用" class="headerlink" title="微服务中的远程调用"></a>微服务中的远程调用</h3><p>在pomelo中服务间的远程调用，我们单独的定义一个包来完成。同样我们在引用方，也可以以acl的思想来使用openFeign应用。接下来我们看一下用户登录引用用户服务的实现过程</p>
<h4 id="定义服务接口"><a href="#定义服务接口" class="headerlink" title="定义服务接口"></a>定义服务接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span><br><span class="line">public class CustomerUserInternal &#123;</span><br><span class="line">    private final CustomerUserService customerUserService;</span><br><span class="line">    private final CustomerRoleService customerRoleService;</span><br><span class="line">    private final CustomerMenuService customerMenuService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据用户名获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param UserName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    public CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName) &#123;</span><br><span class="line">        return customerUserService.selectUserByUserName(UserName);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 根据手机号获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param PhoneNumber</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    public CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber) &#123;</span><br><span class="line">        return customerUserService.selectUserByPhoneNumber(PhoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 根据id获取用户信息</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoById/&#123;id&#125;&quot;)</span><br><span class="line">    public CustomerUserListDTO getUserInfoById(@PathVariable(&quot;id&quot;) String id) &#123;</span><br><span class="line">        return customerUserService.selectUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    public List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId) &#123;</span><br><span class="line">        return customerRoleService.selectRoleByUserId(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据角色获取权限信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    public List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId) &#123;</span><br><span class="line">        return customerMenuService.getMenuOptionsByRoleId(roleId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acl防腐层facade实现"><a href="#acl防腐层facade实现" class="headerlink" title="acl防腐层facade实现"></a>acl防腐层facade实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(name = &quot;pomelo-customer&quot;)</span><br><span class="line">public interface CustomerRemoteFacade &#123;</span><br><span class="line">    //获取用户角色</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserName/&#123;UserName&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserName(@PathVariable(&quot;UserName&quot;) String UserName);</span><br><span class="line">    //获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByUserId/&#123;UserId&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByUserId(@PathVariable(&quot;UserId&quot;) String UserId);</span><br><span class="line">    //根据手机号获取用户信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getUserInfoByPhoneNumber/&#123;PhoneNumber&#125;&quot;)</span><br><span class="line">    CustomerUserDTO getUserInfoByPhoneNumber(@PathVariable(&quot;PhoneNumber&quot;) String PhoneNumber);</span><br><span class="line">    //获取用户角色信息</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getRoleByUserId/&#123;userId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerRoleDto&gt; getRoleByUserId(@PathVariable(&quot;userId&quot;) String userId);</span><br><span class="line">    //获取用户权限</span><br><span class="line">    @GetMapping(&quot;/Internal/customer/getByRoleId/&#123;roleId&#125;&quot;)</span><br><span class="line">    List&lt;CustomerMenuDTO&gt; getByPermissions(@PathVariable(&quot;roleId&quot;) String roleId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="启动服务增加注解"><a href="#启动服务增加注解" class="headerlink" title="启动服务增加注解"></a>启动服务增加注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(&quot;com.fbb.pomelo.auth.acl&quot;)</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在引用方调用接口进行参数处理</p>
<h3 id="自定义微服务解码器"><a href="#自定义微服务解码器" class="headerlink" title="自定义微服务解码器"></a>自定义微服务解码器</h3><p>我们在构建统一返回以及全局异常处理中提出过对参数的返回体进行了包装，那我们引用feign的时间就需要对之前的包装进行解码</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloFeignResponseDecoder implements Decoder &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object decode(Response response, Type type) throws IOException, DecodeException, FeignException &#123;</span><br><span class="line">        // 因为在web中定义过返回自动转换为Result，所以在使用openfeign时为了方便我们需要自定义解码将Result接触</span><br><span class="line">        Result&lt;?&gt; result = JsonUtils.inputStream2Obj(response.body().asInputStream(),Result.class);</span><br><span class="line">        if (ErrorCode.OK.getCode().equals(result.getCode())) &#123;</span><br><span class="line">            Object data = result.getData();</span><br><span class="line">            if (ObjectUtil.isEmpty(data))&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            JavaType javaType = TypeFactory.defaultInstance().constructType(type);</span><br><span class="line">            return JsonUtils.convertValue(data, javaType);</span><br><span class="line">        &#125;</span><br><span class="line">        // 异常则抛出业务异常</span><br><span class="line">        throw new RemoteException(result.getCode(), result.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="上游异常的统一处理"><a href="#上游异常的统一处理" class="headerlink" title="上游异常的统一处理"></a>上游异常的统一处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class PomeloFeignErrorDecoder implements ErrorDecoder &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Exception decode(String s, Response response) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Reader reader = response.body().asReader(Charset.defaultCharset());</span><br><span class="line">            Result&lt;?&gt; result = JsonUtils.reader2Obj(reader, Result.class);</span><br><span class="line">            return new RemoteException(result.getCode(), result.getMessage());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;Response转换异常&quot;, e);</span><br><span class="line">            throw new RemoteException(ErrorCode.FEIGN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Feign全局异常处理"><a href="#Feign全局异常处理" class="headerlink" title="Feign全局异常处理"></a>Feign全局异常处理</h3><p>feign的全局异常依然是沿用了spring的RestControllerAdvice注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">@Slf4j</span><br><span class="line">@Order(Ordered.HIGHEST_PRECEDENCE) // 优先级</span><br><span class="line">@ResponseStatus(code = HttpStatus.BAD_REQUEST) // 统一 HTTP 状态码</span><br><span class="line">public class PomeloFeignExceptionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(FeignException.class)</span><br><span class="line">    public Result&lt;?&gt; handleFeignException(FeignException e) &#123;</span><br><span class="line">        // log.error(&quot;FeignException: &quot;, e);</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(ErrorCode.REMOTE_ERROR.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(DecodeException.class)</span><br><span class="line">    public Result&lt;?&gt; handleDecodeException(DecodeException e) &#123;</span><br><span class="line">        log.error(&quot;Feign Decode Error: &quot;, e);</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        if (cause instanceof AbstractException) &#123;</span><br><span class="line">            RemoteException remoteException = (RemoteException) cause;</span><br><span class="line">            // 上游符合全局响应包装约定的再次抛出即可</span><br><span class="line">            return new Result&lt;Void&gt;()</span><br><span class="line">                    .setCode(remoteException.getCode())</span><br><span class="line">                    .setMessage(remoteException.getMessage())</span><br><span class="line">                    .setTimestamp(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        // 全部转换成RemoteException</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(ErrorCode.REMOTE_ERROR.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    @ExceptionHandler(RemoteException.class)</span><br><span class="line">    public Result&lt;?&gt; handleRemoteException(RemoteException e) &#123;</span><br><span class="line">        log.error(&quot;Feign Remote Error: &quot;, e);</span><br><span class="line">        return new Result&lt;Void&gt;()</span><br><span class="line">                .setCode(e.getCode())</span><br><span class="line">                .setMessage(e.getMessage())</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><font style="color:rgb(47, 48, 52);">我们学习了如何使用ACL来隔离外部依赖，降低系统耦合度。在微服务架构中，我们探讨了如何通过OpenFeign来实现跨服务调用，并解决了全局包装和异常处理的问题，希望本文的内容对您在软件开发项目中有所帮助。</font></p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>脚手架</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2024/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><font style="color:rgb(77, 77, 77);">1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</font></p>
<p>:::info</p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.5);">Consistency（一致性）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">Availability（可用性）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">Partition tolerance （分区容错性）</font></li>
</ul>
<p>:::</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727676127141-2d6e2681-9b7a-40cc-a38f-71676129af12.png"></p>
<span id="more"></span>
<p><font style="color:rgb(77, 77, 77);">它们的第一个字母分别是 C、A、P。</font></p>
<p><font style="color:rgb(77, 77, 77);">Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</font></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><font style="color:rgb(77, 77, 77);">Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</font></p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p><font style="color:rgb(77, 77, 77);">Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</font></p>
<h3 id="分区容错"><a href="#分区容错" class="headerlink" title="分区容错"></a>分区容错</h3><p><strong><font style="color:rgb(77, 77, 77);">Partition（分区）</font></strong><font style="color:rgb(77, 77, 77);">：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">Tolerance（容错）</font></strong><font style="color:rgb(77, 77, 77);">：在集群出现分区时，整个系统也要持续对外提供服务</font></p>
<h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p><font style="color:rgb(77, 77, 77);">在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727676224018-30b6e228-e99e-4d1f-b7e9-e33ebe7f5390.png"></p>
<p>如果此时要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</p>
<p>如果此时要保证可用性，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。</p>
<p>也就是说，在P(分区情况下)一定会出现的情况下，A和C之间只能实现一个。</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li>
<li><strong>Soft State（软状态）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态。</li>
<li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li>
</ul>
<h2 id="解决分布式事务的思路"><a href="#解决分布式事务的思路" class="headerlink" title="解决分布式事务的思路"></a><font style="color:rgb(79, 79, 79);">解决分布式事务的思路</font></h2><p><font style="color:rgb(77, 77, 77);">分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：</font></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">AP模式：</font><strong><font style="color:rgb(77, 77, 77);">各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。  既最终一致性</font></strong></li>
<li><font style="color:rgb(77, 77, 77);">CP模式：</font><strong><font style="color:rgb(77, 77, 77);">各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态</font></strong><font style="color:rgb(77, 77, 77);">。既最终一致性</font></li>
</ul>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在实际应用中，</p>
<p>2PC与3PC都是使用的AP模式</p>
<p>本地事务表使用的CP模式</p>
<h3 id="2PC与3PC"><a href="#2PC与3PC" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h3><h4 id="二阶段提交（2PC）"><a href="#二阶段提交（2PC）" class="headerlink" title="二阶段提交（2PC）"></a>二阶段提交（2PC）</h4><h5 id="阶段一：准备阶段"><a href="#阶段一：准备阶段" class="headerlink" title="阶段一：准备阶段"></a>阶段一：准备阶段</h5><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727680107070-126ca8cb-a71a-4392-b599-9a044ac40c3d.png"></p>
<ol>
<li><font style="color:rgb(37, 41, 51);">协调者向所有参与者发送commit请求，询问是否可以提交事务，并等待答复。</font></li>
<li><font style="color:rgb(37, 41, 51);">各参与者开始准备执行事务，将uodo log和redo log记入事务日志中，并不提交事务。</font></li>
<li><font style="color:rgb(37, 41, 51);">如果参与者执行成功，则向协调者返回yes，否则返回no。</font></li>
</ol>
<h5 id="阶段二：提交阶段"><a href="#阶段二：提交阶段" class="headerlink" title="阶段二：提交阶段"></a>阶段二：提交阶段</h5><p><font style="color:rgb(37, 41, 51);">协调者收到各个参与者的准备信息后，根据反馈情况，通知各个参与者Commit或者Rollback。</font></p>
<h6 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a><font style="color:rgb(37, 41, 51);">事务提交</font></h6><p>当第一阶段所有参与者都反馈同意时，协调者发起正式提交事务请求，当所有的参与者都回复成功，则表明完成事务，具体流程如下：</p>
<ol>
<li><font style="color:rgb(37, 41, 51);">协调者向所有参与者发送正式提交事务请求（即：commit请求）。</font></li>
<li><font style="color:rgb(37, 41, 51);">参与者收到协调者的commit请求后，参与者正式执行事务提交操作，并释放整个事务期间占用的资源。</font></li>
<li><font style="color:rgb(37, 41, 51);">参与者完成事务提交后，向协调者发送ACK消息。</font></li>
<li><font style="color:rgb(37, 41, 51);">协调者收到所有参与者反馈的ACK消息后，完成事务。</font></li>
</ol>
<h6 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h6><p>如果任意一个参与者在第一阶段返回中止信息，或者由于超时协调者无法获取到所有参与者的信息，那么这个事务将会被回滚，具体流程如下：</p>
<ol>
<li>协调者向所有参与者发送回滚请求（即：rollback请求）。</li>
<li>参与者收到协调者发送的回滚请求后，参与者使用第一阶段中的undo log信息执行回滚操作，并释放在整个事务期间占用的资源。</li>
<li>参与者在执行完回滚操作之后，向协调者发送ACK信息。</li>
<li>协调者受到所有参与者反馈的信息后，取消事务。</li>
</ol>
<h5 id="2PC的优缺点"><a href="#2PC的优缺点" class="headerlink" title="2PC的优缺点"></a>2PC的优缺点</h5><p><strong>二阶段的确可以提供原子性操作，但是仍有如下缺点：</strong></p>
<ol>
<li>性能问题：所有参与者在提交阶段，都处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li>可靠性问题：如果协调者出现单点故障，或者出现不可用状态，参与者将一直处于锁定状态。</li>
<li>数据一致性问题：在阶段2中，如果出现协调者和参与者都挂了，有可能导致数据不一致。</li>
</ol>
<h4 id="三阶段提交（3PC）"><a href="#三阶段提交（3PC）" class="headerlink" title="三阶段提交（3PC）"></a><font style="color:rgb(37, 41, 51);">三阶段提交（3PC）</font></h4><p>与两阶段提交不同的是，三阶段提交有两个改动点：</p>
<ul>
<li>引入超时机制，在协调者与参与者中都引入了超时机制。</li>
<li>在第一阶段与第二阶段中，插入了一个<code>准备阶段</code>。保证了在最后提交阶段之前，各参与节点的状态是一致的。故3PC有CanCommit，PreCommit，DoCommit。</li>
</ul>
<p>所以3PC处理流程如下：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727680774753-2f1543a6-0c4c-4e5c-a214-d22cc31374c1.webp"></p>
<h5 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title=" CanCommit阶段"></a><font style="color:rgb(37, 41, 51);"> CanCommit阶段</font></h5><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回yes，否则返回no。</p>
<ol>
<li><strong>事务询问：</strong> 协调者向参与者发送CanCommit请求，询问是否可以执行事务提交操作，然后开始等待答复。</li>
<li><strong>响应反馈：</strong> 参与者接到CanCommit请求后，如果可以顺利执行事务，则反馈yes响应，并进入<code>预备状态</code>，否则反馈no。</li>
</ol>
<h5 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a><font style="color:rgb(37, 41, 51);">PreCommit阶段</font></h5><p><code>协调者</code>根据<code>参与者</code>的反馈情况决定是否可以继续执行事务的<code>PreCommit</code>阶段。</p>
<p>有两种反馈情况：</p>
<p>一、所有的参与者都反馈yes响应，那么就会执行事务的<code>PreCommit</code>阶段。</p>
<ol>
<li><strong>发送预提交请求：</strong> 协调者向参与者发送<code>PreCommit</code>请求，并进入Prepared阶段。</li>
<li><strong>预提交事务：</strong> 参与者收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中 <strong>（但不提交事务）</strong> 。</li>
<li><strong>响应反馈：</strong> 如果参与者都成功了执行事务操作，则返回ack响应，同时开始等待最终命令。</li>
</ol>
<p>二、加入有任何一个参与者反馈no响应，或者等待超时之后，协调者也没收到参与者的反馈，那么就执行事务中断。</p>
<ol>
<li><strong>发送中断请求：</strong> 协调者向所有参与者发送abort请求。</li>
<li><strong>中断事务：</strong> 参与者收到协调者发送的abort请求后（或者超时后，仍未收到协调者的请求），开始执行事务的中断。</li>
</ol>
<h5 id="DoCommit阶段"><a href="#DoCommit阶段" class="headerlink" title="DoCommit阶段"></a><font style="color:rgb(37, 41, 51);">DoCommit阶段</font></h5><p>该阶段进行真正的事务提交，可以分为如下两种情况：</p>
<p><strong>一、执行事务提交：协调者收到所有参与者的ack信息，开始执行提交事务。</strong></p>
<ol>
<li>发送DoCommit请求：协调者收到参与者发送的ack响应后，那么就会从<code>预提交状态</code>进入到<code>提交状态</code>，并向所有的参与者发送DoCommit请求。</li>
<li>事务提交：参与者接收到协调者发送的DoCommit请求，开始执行事务提交操作，并在完成事务操作后释放所有的事务资源。</li>
<li>响应反馈：事务提交完成后，参与者向协调者发送ack信息。</li>
<li>事务完成：协调者受到所有参与者的ack信息后，完成事务。</li>
</ol>
<p><strong>二、中断事务：协调者没能收到所有参与者的ack信息，开始执行中断事务。</strong></p>
<ol>
<li>发送中断请求：协调者性所有的参与者发送abort请求。</li>
<li>事务回滚：参与者收到abort请求后，开始利用阶段2中记录的undo log执行事务的回滚操作，并在完成回滚后，释放所有的事务资源。</li>
<li>响应反馈：参与者完成事务回滚后，向协调者发送ack信息。</li>
<li>中断事务：协调者受到所有参与者的ack信息后，执行事务中断。</li>
</ol>
<p>在进入DoCommit阶段是，如果协调者或者参与者出现问题，导致参与者无法接收到协调者发出的<code>提交事务/中断事务</code>请求，此时，参与者都会在等待超时之后，继续执行事务提交。这是基于概率来决定，当进入第三阶段时，说明第一阶段，所有的参与者都同意进行修改操作，同时在第二阶段，所有的参与者都统一同意PreCommit操作。所以，如果在第三阶段，如果出现网络问题，虽然参与者没有收到commit&#x2F;abort请求，但是它有理由相信：成功提交的几率很大。</p>
<p><font style="color:rgb(37, 41, 51);">3PC的优缺点</font></p>
<p><font style="color:rgb(37, 41, 51);">与2PC相比，3PC降低了阻塞范围，并且在等待超时后，协调者或者参与者中断事务，避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务，可能造成数据不一致。</font></p>
<p><strong><font style="color:rgb(37, 41, 51);">2PC和3PC都无法保证数据绝对的一致性，一般为预防这种问题，可以提交一个告警。</font></strong></p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a><font style="color:rgb(77, 77, 77);">TCC</font></h3><p><strong><font style="color:rgb(37, 41, 51);">TCC：</font></strong><font style="color:rgb(37, 41, 51);"> </font><font style="color:rgb(37, 41, 51);">TCC（Try Confirm Cancel）是应用层的两阶段提交，所以对业务有侵入。</font></p>
<p><strong><font style="color:rgb(37, 41, 51);">核心思想：</font></strong><font style="color:rgb(37, 41, 51);"> 针对每个操作，都要实现对应的</font><code>&lt;font style=&quot;color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);&quot;&gt;确认&lt;/font&gt;</code><font style="color:rgb(37, 41, 51);">和</font><code>&lt;font style=&quot;color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);&quot;&gt;补偿&lt;/font&gt;</code><font style="color:rgb(37, 41, 51);">操作，也就是业务逻辑的每个分支，都要实现Try、Confirm、Cancel三个操作。</font></p>
<h4 id="TCC的执行流程"><a href="#TCC的执行流程" class="headerlink" title="TCC的执行流程"></a><font style="color:rgb(37, 41, 51);">TCC的执行流程</font></h4><p>TCC的执行过程可以分成两个阶段：</p>
<ol>
<li><strong>第一阶段：</strong> Try。该阶段，通过try操作做检测并预留资源。（比如：下单，在try阶段，并不是真正的扣减库存，只是把下单的库存进行锁定。）</li>
<li><strong>第二阶段：</strong> Confirm&#x2F;Cancel。根据第一阶段的结果决定是执行confirm还是cancel。<ol>
<li>Confirm：对Try阶段锁定的资源实际扣除。</li>
<li>Cancel：对Try阶段锁定的资源进行释放。</li>
</ol>
</li>
</ol>
<h4 id="TCC是如何保证最终一致性"><a href="#TCC是如何保证最终一致性" class="headerlink" title="TCC是如何保证最终一致性"></a><font style="color:rgb(37, 41, 51);">TCC是如何保证最终一致性</font></h4><ul>
<li>TCC是以Try为中心的，Confirm操作和Cancel操作都是围绕着Try展开的。所以在Try阶段保障性是最好的，即使出现失败，也可以通过Cancel操作将其执行结果撤销。</li>
<li>在Try阶段执行成功，并进入到Confirm阶段时，默认Confirm阶段是不会出错的，也就是说只要Try成功，Confirm一定成功（TCC设计之初的定义）。</li>
<li>Confirm和Cancel如果失败，则由TCC框架进行重试补偿（定时）。</li>
<li>但仍存在极低情况下在<strong>CC</strong>阶段彻底失败，则需要人工介入。</li>
</ul>
<h4 id="TCC的注意事项"><a href="#TCC的注意事项" class="headerlink" title=" TCC的注意事项"></a><font style="color:rgb(37, 41, 51);"> TCC的注意事项</font></h4><h5 id="1-允许空回滚："><a href="#1-允许空回滚：" class="headerlink" title="(1) 允许空回滚："></a>(1) 允许空回滚：</h5><p>空回滚的原因是Try阶段超时或者丢包，导致TCC二阶段进行回滚，触发Cancel操作，此时事务参与者可能可能未收到Try操作，但是收到了Cancel操作。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727681701463-5db96149-aabe-4002-aa6b-496cb9967df8.webp"></p>
<p>所以，Cancel操作在实现的时候需要允许空回滚，即在Cancel执行时，如果没有查到对应业务的Try操作时，也是需要返回成功，让事务管理器认为已回滚。</p>
<h5 id="2-防悬挂控制："><a href="#2-防悬挂控制：" class="headerlink" title="(2) 防悬挂控制："></a>(2) 防悬挂控制：</h5><p><strong>悬挂</strong>是指二阶段的Cancel比一阶段的Try操作先执行，出现该问题的原因是Try阶段由于网络拥堵而超时，导致事务管理器生成回滚，触发Cancel操作，但之后拥堵网络的Try又被资源管理器收到了，但是Cancel操作比Try操作先到。如果按照前面允许空回滚的逻辑，回滚是会成功，事务管理器认为回滚成功，所以，此时应该<code>拒绝</code>空回滚之后的Try操作，否则会产生数据不一致。</p>
<p>因此，我们在Cancel空回滚返回成功之前，应记录该条事务xid或者业务主键，标识该记录已经回滚过，Try操作在执行前先检查这条事务xid或者业务主键是否标记为回滚成功，如果是，则不执行Try操作。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727681701424-9de15540-02c8-47b1-9359-05020686875c.webp"></p>
<h5 id="3-幂等控制"><a href="#3-幂等控制" class="headerlink" title="(3) 幂等控制"></a>(3) 幂等控制</h5><p>由于网络原因或者重试操作都有可能导致Try - Confirm - Cancel三个操作重复执行，所以使用TCC时需要注意这三个操作的幂等控制。通常针对具体业务选择对应的<code>业务幂等键</code>来做防重控制。</p>
<h4 id="TCC方案的优缺点"><a href="#TCC方案的优缺点" class="headerlink" title="TCC方案的优缺点"></a><font style="color:rgb(37, 41, 51);">TCC方案的优缺点</font></h4><h6 id="TCC事务机制相比上面的2PC3PC事务机制，有如下优点："><a href="#TCC事务机制相比上面的2PC3PC事务机制，有如下优点：" class="headerlink" title="TCC事务机制相比上面的2PC3PC事务机制，有如下优点："></a>TCC事务机制相比上面的2PC3PC事务机制，有如下优点：</h6><ol>
<li>性能提升：具体业务实现，控制资源锁的粒度变小，不会锁定整个资源。</li>
<li>数据最终一致性：基于Confirm和Cancel操作的幂等性，确保事务最终完成或者取消，保证了数据一致性。</li>
<li>可靠性：解决了XA协议的协调者单点故障问题。由主业务发起并控制整个业务活动，业务活动管理器可以变成多点，引入集群。</li>
</ol>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>TCC的Try - Confirm - Cancel操作功能需要按具体业务实现，业务耦合度高，提高了开发成功。</p>
<h3 id="本地事务表"><a href="#本地事务表" class="headerlink" title="本地事务表"></a>本地事务表</h3><h4 id="什么是本地消息表"><a href="#什么是本地消息表" class="headerlink" title="什么是本地消息表"></a><font style="color:rgb(37, 41, 51);">什么是本地消息表</font></h4><p><strong>本地事务表</strong>的核心思路是将**<code>分布式事务</code><strong>拆分</strong><code>**成本地事务**</code><strong>进行处理，该方案中主要有两个角色：</strong><code>事务主动方</code><strong>和</strong><code>事务被动方</code>**。<br>**<code>事务主动方</code><strong>需要额外新建事务消息表，并在本地事务中完成业务处理和记录事务消息，并轮训事务消息表的数据发哦那个事务消息，</strong><code>事务被动方</code>**基于消息中间件消费事务消息表中的事务。</p>
<p>这样可以避免一下两种情况导致的数据不一致性：</p>
<ul>
<li>业务处理成功，事务消息发送失败。</li>
<li>业务处理失败，事务消息发送成功。</li>
</ul>
<h4 id="本地事务表的执行流程"><a href="#本地事务表的执行流程" class="headerlink" title="本地事务表的执行流程"></a><font style="color:rgb(37, 41, 51);">本地事务表的执行流程</font></h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727682899971-9cb09696-10ea-493b-998e-11ccc9a0eecf.webp"></p>
<ul>
<li>事务主动方在同一个本地事务中处理业务和写消息表操作。</li>
<li>事务主动方通过消息中间件发送消息，通知事务被动发处理事务消息。</li>
<li>事务被动方接收到消息后，处理业务逻辑。</li>
<li>事务被动方通过消息中间件发送消息，通知事务主动方事务已处理。</li>
<li>事务主动方接收到消息后，更新消息表的状态为已处理。</li>
</ul>
<h5 id="一些必要的容错处理如下"><a href="#一些必要的容错处理如下" class="headerlink" title="一些必要的容错处理如下"></a><font style="color:rgb(37, 41, 51);">一些必要的容错处理如下</font></h5><ul>
<li>当①处理出错，由于事务还在事务主动方的本地事务中，直接回滚即可。</li>
<li>当②、④、⑤处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，通知事务被动方重新读取消息处理业务即可。</li>
<li>当③业务上处理失败，事务被动方可以发送消息给事务主动方回滚事务。</li>
</ul>
<h4 id="本地消息表优缺点"><a href="#本地消息表优缺点" class="headerlink" title="本地消息表优缺点"></a><font style="color:rgb(37, 41, 51);">本地消息表优缺点</font></h4><h5 id="1-优点："><a href="#1-优点：" class="headerlink" title="1) 优点："></a>1) 优点：</h5><ul>
<li>由于写消息表和业务数据在同一个本地事务中处理，确保了消息数据的可靠性，消息数据可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<h5 id="2-缺点："><a href="#2-缺点：" class="headerlink" title="2) 缺点："></a>2) 缺点：</h5><ul>
<li>与具体业务场景绑定，耦合性强，不可公用。</li>
<li>消息数据和业务数据同库，占用业务系统资源。</li>
<li>由于需要将消息持久化到数据库中，消息服务性能会受到一定的影响。</li>
</ul>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a><font style="color:rgb(37, 41, 51);">事务消息</font></h3><h4 id="MQ事务消息执行流程"><a href="#MQ事务消息执行流程" class="headerlink" title="MQ事务消息执行流程"></a><font style="color:rgb(37, 41, 51);">MQ事务消息执行流程</font></h4><p>通过消息的异步事务，可以保证<code>本地事务</code>和<code>消息发送</code>同时执行成功或失败，既能实现系统间的解耦，又能保证数据的最终一致性。</p>
<p><code>本地消息表</code>方案中，<code>事务主动方</code>通过在<code>同一个本地事务</code>中写<code>业务数据</code>和<code>消息数据</code>来保证数据的一致性。而事务消息相对于普通的MQ提供了<code>2PC</code>的提交接口，流程如下：</p>
<h5 id="1-正常执行情况"><a href="#1-正常执行情况" class="headerlink" title="1) 正常执行情况"></a><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727683362207-58fe821c-381b-4aca-9f6e-d05b6833fbbf.webp">1) 正常执行情况</h5><p>在事务主动方服务正常，没有发生故障的情况下，发消息流程如下：</p>
<ul>
<li>步骤①：发送Half消息</li>
<li>步骤②：Half消息发送成功</li>
<li>步骤③：开始执行本地事务</li>
<li>步骤④：根据本地事务执行结果向MQ Server发送Commit&#x2F;Rollback。</li>
<li>最终步骤：MQ Server基于Commit&#x2F;Rollback进行消息投递或者删除。</li>
</ul>
<h5 id="2-异常情况"><a href="#2-异常情况" class="headerlink" title="2) 异常情况"></a>2) 异常情况</h5><p>在断网或者应用重启情况下，图中的步骤④Commit或者Rollback未到达MQ Server，此时处理逻辑如下：</p>
<ul>
<li>步骤⑤：MQ Server未收到二次确认消息，发起消息回查。</li>
<li>步骤⑥：收到消息回查后，需要检查对应消息的本地事务执行状态。</li>
<li>步骤⑦：根据检查的本地事务执行状态，再次向MQ发送Commit&#x2F;Rollback。</li>
<li>最终步骤：MQ Server基于Commit&#x2F;Rollback进行消息投递或者删除</li>
</ul>
<h4 id="MQ事务消息的优缺点"><a href="#MQ事务消息的优缺点" class="headerlink" title="MQ事务消息的优缺点"></a>MQ事务消息的优缺点</h4><h5 id="1-优点（-相较于本地消息表-）"><a href="#1-优点（-相较于本地消息表-）" class="headerlink" title="1) 优点（ 相较于本地消息表 ）"></a>1) 优点（ 相较于本地消息表 ）</h5><ul>
<li>消息数据独立存储，降低业务系统与消息系统的耦合性。</li>
<li>吞吐量有所提升。</li>
</ul>
<h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2) 缺点"></a>2) 缺点</h5><ul>
<li>一次消息发送需要两次网络请求（Half消息+Commit&#x2F;Rollback）。</li>
<li>业务处理服务需要实现消息状态回查接口。</li>
</ul>
<h4 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h4><p>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对接口，如果事务被动方没有接收到主动方发送的消息，此时可以调用事务主动方提供的消息校对接口<code>主动获取</code>。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1727683362353-4ab255e2-2fa1-4673-a0cf-aac6358c75d5.webp"> 在可靠事务消息中，事务主动方需要将消息发送出去，并且让接收方成功接收消息，这种可靠性是由事务主动方保证的。</p>
<p>但是最大努力通知，事务主动方仅仅是做到尽最大努力（重试，轮询…）将信息发送给事务被动方，所以存在事务被动方接收不到信息的情况，所以需要事务被动发通过消息校对接口主动查询获取消息并消费，这种通知的可靠性是由事务被动方保证的。</p>
<p><strong>适用场景：</strong></p>
<p>适用于业务通知类型，如支付宝&#x2F;微信交易的结果，就是通过最大努力通知方式通知商户，既有回调通知，也有交易查询接口。</p>
<h3 id="分布式事务中间件Seata"><a href="#分布式事务中间件Seata" class="headerlink" title="分布式事务中间件Seata"></a>分布式事务中间件Seata</h3><h4 id="初识Seata"><a href="#初识Seata" class="headerlink" title="初识Seata"></a><font style="color:rgb(79, 79, 79);">初识Seata</font></h4><p><font style="color:rgb(77, 77, 77);">Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的</font><a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&spm=1001.2101.3001.7020"><font style="color:rgb(77, 77, 77);">分布式事务解决方案</font></a><font style="color:rgb(77, 77, 77);">。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</font></p>
<p><font style="color:rgb(77, 77, 77);">官网地址：</font><a href="http://seata.io/">http://seata.io/</a><font style="color:rgb(77, 77, 77);">，其中的文档、播客中提供了大量的使用说明、源码分析。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727683681068-3113ed0f-ef7b-438f-8112-1e6af770a110.png"></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<h4 id="Seata的架构"><a href="#Seata的架构" class="headerlink" title="Seata的架构"></a><font style="color:rgb(79, 79, 79);">Seata的架构</font></h4><p>Seata事务管理中有三个重要的角色：</p>
<ul>
<li>TC (Transaction Coordinator) - <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li>
<li>TM (Transaction Manager) - <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li>
<li>RM (Resource Manager) - <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p>整体的架构如图：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727683745367-07fb02a0-a23e-463f-940c-cf4d4ad22024.png"></p>
<p>Seata基于上述架构提供了四种不同的分布式事务解决方案：</p>
<ul>
<li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li>
<li>TCC模式：最终一致的分阶段事务模式，有业务侵入</li>
<li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li>
<li>SAGA模式：长事务模式，有业务侵入</li>
</ul>
<p>:::info<br>无论哪种方案，都离不开TC，也就是事务的协调者。</p>
<p>:::</p>
<p>这里XA模式可以理解为2PC或者3PC</p>
<p>TCC模式：上面已经讲过 </p>
<p>SAGA模式<font style="color:rgb(77, 77, 77);">和tcc很想,但是TCC操作的是冻结的预留数据,这个是直接操作数据</font></p>
<p>但是我们主要需要学习的是AT模式</p>
<h4 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h4><p><font style="color:rgb(77, 77, 77);">AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</font></p>
<h5 id="Seata的AT模型"><a href="#Seata的AT模型" class="headerlink" title="Seata的AT模型"></a><font style="color:rgb(79, 79, 79);">Seata的AT模型</font></h5><p><font style="color:rgb(77, 77, 77);">基本流程图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685192520-38d73085-a173-4ffb-ad7d-36010bf6b7a1.png"></p>
<h6 id="阶段一RM的工作："><a href="#阶段一RM的工作：" class="headerlink" title="阶段一RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段一RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">注册分支事务</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">记录undo-log（数据快照）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">执行业务sql并提交</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">报告事务状态</font></li>
</ul>
<h6 id="阶段二提交时RM的工作："><a href="#阶段二提交时RM的工作：" class="headerlink" title="阶段二提交时RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段二提交时RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">删除undo-log即可</font></li>
</ul>
<h6 id="阶段二回滚时RM的工作："><a href="#阶段二回滚时RM的工作：" class="headerlink" title="阶段二回滚时RM的工作："></a><font style="color:rgb(77, 77, 77);">阶段二回滚时RM的工作：</font></h6><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">根据undo-log恢复数据到更新前</font></li>
</ul>
<p>:::info<br><font style="color:rgb(85, 86, 102);">事务执行成功 删除快照 事务执行失败 同一回复到快照</font></p>
<p>:::</p>
<h5 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a><font style="color:rgb(79, 79, 79);">流程梳理</font></h5><p><font style="color:rgb(77, 77, 77);">我们用一个真实的业务来梳理下AT模式的原理。</font></p>
<p><font style="color:rgb(77, 77, 77);">比如，现在又一个数据库表，记录用户余额：</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);">id</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);">money</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">1</font></td>
<td><font style="color:rgb(79, 79, 79);">100</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">其中一个分支业务要执行的SQL为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tb_account set money = money - 10 where id = 1</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">AT模式下，当前分支事务执行流程如下：</font></p>
<p><font style="color:rgb(77, 77, 77);">一阶段：</font></p>
<p><font style="color:rgb(77, 77, 77);">1）TM发起并注册全局事务到TC</font></p>
<p><font style="color:rgb(77, 77, 77);">2）TM调用分支事务</font></p>
<p><font style="color:rgb(77, 77, 77);">3）分支事务准备执行业务SQL</font></p>
<p><font style="color:rgb(77, 77, 77);">4）RM拦截业务SQL，根据where条件查询原始数据，形成快照。</font></p>
<p><font style="color:rgb(77, 77, 77);">5）RM执行业务SQL，提交本地事务，释放数据库锁。此时</font><font style="color:rgb(77, 77, 77);"> </font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;money = 90&lt;/font&gt;</code></p>
<p><font style="color:rgb(77, 77, 77);">6）RM报告本地事务状态给TC</font></p>
<p><font style="color:rgb(77, 77, 77);">二阶段：</font></p>
<p><font style="color:rgb(77, 77, 77);">1）TM通知TC事务结束</font></p>
<p><font style="color:rgb(77, 77, 77);">2）TC检查分支事务状态</font></p>
<p><font style="color:rgb(77, 77, 77);">a）如果都成功，则立即删除快照</font></p>
<p><font style="color:rgb(77, 77, 77);">b）如果有分支事务失败，需要回滚。读取快照数据（</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;&#123;&quot;id&quot;: 1, &quot;money&quot;: 100&#125;&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">），将快照恢复到数据库。此时数据库再次恢复为100</font></p>
<p><font style="color:rgb(77, 77, 77);">流程图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685541924-773c552b-0b8a-411f-aebd-c538347de620.png"></p>
<h5 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a><font style="color:rgb(79, 79, 79);">AT与XA的区别</font></h5><p><font style="color:rgb(77, 77, 77);">简述AT模式与XA模式最大的区别是什么？</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">XA模式强一致；AT模式最终一致 中间状态是软提交</font></li>
</ul>
<h5 id="脏写问题"><a href="#脏写问题" class="headerlink" title="脏写问题"></a><font style="color:rgb(79, 79, 79);">脏写问题</font></h5><p>在多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p>
<p>假如多个线程操作同一事务,其中一个线程先拿到数据锁执行完sql 提交事务以后释放锁,另一个线程就能拿到锁在进行一次sql执行,并且线程一刚好完at模式中有个事务失败需要回滚,这个时候数据就脏写了</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685613699-c21e200f-32a7-47e9-a759-5cc24175eaa1.png"></p>
<p>解决思路就是引入了全局锁的概念。</p>
<p>在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1727685625629-d0eb8311-bbe7-4762-809c-a3752dde5983.png"></p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><font style="color:rgb(79, 79, 79);">优缺点</font></h5><p><font style="color:rgb(77, 77, 77);">AT模式的优点：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">一阶段完成直接提交事务,释放数据库资源，性能比较好</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">利用全局锁实现读写隔离</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">没有代码侵入，框架自动完成回滚和提交</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">AT模式的缺点：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">两阶段之间属于软状态，属于最终一致</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">框架的快照功能会影响性能，但比XA模式要好很多</font></li>
</ul>
<p>:::info<br><font style="color:rgb(85, 86, 102);">XA事务的强一致性是通过事务等待来实现的,分支事务等待所有事务完成才能进行提交,提交后才能释放锁sql锁,对性能一致处于消耗,AT模式是直接先进性提交 然后释放sql锁,最后靠全局锁来实现防止脏数据,且回复靠快照,无序等待事务链中所有数据</font></p>
<p>:::</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>在现实的架构设计中分布式事务，我们一般会本地事务表和seata结合使用，本地事务表来实现最终一致性，用来实现可以允许一定程度的不一致，但是最终结果一致的业务，比如涉及到第三方的支付，开票，优惠结算等。seata我们一般使用AT来实现一些要求强一致性的业务，比如下单库存扣减之类的场景。在实际的开发中我们应该尽量避免使用事务，因为涉及到第三方系统的可用性隐患+1，而且数据覆写需要尽量避免掉</p>
<p><font style="color:rgb(79, 79, 79);"></font></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务中的SpringCloudGateway如何传递用户信息</title>
    <url>/2024/10/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84SpringCloudGateway%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>我们在权限验证中提到了在网关中会通过缓存取出用户数据。当我们获取到用户信息后应该怎么传递下去，有两种方案：</p>
<p>一种是通过redis对数据进行存储，在不同的服务中通过同一个redis进行调用。</p>
<p>第二种：在SpringCloudGateway中将数据取出后放入请求头，然后通过请求头进行传输</p>
<span id="more"></span>
<p>第一种方案的弊端很明显，需要多次的进行redis链接，增加了redis的负担，也增加了系统的不稳定性</p>
<p>所以我们这次的实现以第二种方法为主</p>
<p> 代码实现：</p>
<p>网关处获取到用户信息，通过定义header头信息将用户信息进行传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String loginUserKey  = String.format(&quot;%S%S&quot;, SecurityConstants.USER_KEY, token);</span><br><span class="line">      if (distributedCache.hasKey(loginUserKey)) &#123;</span><br><span class="line">          LoginUser loginUser= distributedCache.get(loginUserKey, LoginUser.class);</span><br><span class="line">          if (loginUser != null)&#123;</span><br><span class="line">              addHeader(mutate, SecurityConstants.USER_ID_HEADER, loginUser.getUserId(),false);</span><br><span class="line">              addHeader(mutate, SecurityConstants.USER_NAME_HEADER, loginUser.getUserName(),false);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>在服务中我们通过拦截器对请求进行拦截，通过拦截器来实现header头文件中的用户信息捕捉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserTokenHandlerInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String userId = request.getHeader(SecurityConstants.USER_ID_HEADER);</span><br><span class="line">        String userName = request.getHeader(SecurityConstants.USER_NAME_HEADER);</span><br><span class="line">        RequestHeaderContextHolder.getInstance().setCurrentUser(userId, userName);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        RequestHeaderContextHolder.getInstance().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spring中注册拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WebMvcConfigurerAdaptor implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new UserTokenHandlerInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就可以在服务中获取到用户信息</p>
<p>小结：</p>
<p>本文主要讲的spingcloud gateway中实现健权后如何将用户信息进行传递，通过拦截器以及网关传递轻松的实现了用户身份的传递</p>
]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloudGateway</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign调用时如何传递传递Token并且多线程环境也能适用</title>
    <url>/2024/10/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="为什么要自定义负载均衡"><a href="#为什么要自定义负载均衡" class="headerlink" title="为什么要自定义负载均衡"></a>为什么要自定义负载均衡</h2><p>在实际的开发中总是会遇到如下的场景：A,B两个成员一起开发，A在开发C服务，B在开发D服务，测试环境中也部署有C服务和D服务，A和B的诉求是不互相干扰对方。但是实际中nacos中注册了服务之后默认的负载策略是根据权重来决定访问哪个服务，当权重一致时就是各50%的访问，很容易就对其他成员造成干扰，所以我们需要一个自定义负载均衡器来做一个分流。</p>
<h2 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h2><p>在springcloud的解决方案中负载均衡器使用的LoadBalancer框架，我们需要实现ReactorServiceInstanceLoadBalancer接口来完成自定义负载均衡。所以我们的思路就是在网关中进行打标，然后通过自定义负载均衡器来确定具体调用的服务。</p>
<span id="more"></span>
<h3 id="网关处理打标"><a href="#网关处理打标" class="headerlink" title="网关处理打标"></a>网关处理打标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class LoadBalancerFilter  implements GlobalFilter, Ordered &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloLoadBalancerProperties pomeloLoadBalancerProperties;</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpRequest.Builder mutate = request.mutate();</span><br><span class="line">        //灰度标识分两种情况，1.通过header传过来，2.通过url传过来</span><br><span class="line">        String gray = request.getHeaders().getFirst(&quot;gray&quot;);</span><br><span class="line">        if (StrUtil.isNotEmpty(gray)) &#123;</span><br><span class="line">            HeaderUtils.addHeader(mutate, pomeloLoadBalancerProperties.getHeader(), gray, true);</span><br><span class="line">            return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        String grayUrl = request.getQueryParams().getFirst(&quot;gray&quot;);</span><br><span class="line">        if (StrUtil.isNotEmpty(grayUrl)) &#123;</span><br><span class="line">            HeaderUtils.addHeader(mutate, pomeloLoadBalancerProperties.getHeader(), grayUrl, true);</span><br><span class="line">            return chain.filter(exchange.mutate().request(mutate.build()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自定义负载均衡处理器"><a href="#自定义负载均衡处理器" class="headerlink" title="自定义负载均衡处理器"></a>自定义负载均衡处理器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PomeloLoadBalancer implements ReactorServiceInstanceLoadBalancer &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(PomeloLoadBalancer.class);</span><br><span class="line">    @Resource</span><br><span class="line">    private PomeloLoadBalancerProperties pomeloLoadBalancerProperties;</span><br><span class="line"></span><br><span class="line">    private final ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider;</span><br><span class="line">    private final String serviceId;</span><br><span class="line"></span><br><span class="line">    private final AtomicInteger position;</span><br><span class="line"></span><br><span class="line">    public PomeloLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider</span><br><span class="line">            , String serviceId,PomeloLoadBalancerProperties pomeloLoadBalancerProperties) &#123;</span><br><span class="line">        this(serviceInstanceListSupplierProvider,serviceId,new Random().nextInt(1000),pomeloLoadBalancerProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PomeloLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider,</span><br><span class="line">                              String serviceId, int seedPosition,</span><br><span class="line">                              PomeloLoadBalancerProperties pomeloLoadBalancerProperties) &#123;</span><br><span class="line">        this.serviceId = serviceId;</span><br><span class="line">        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;</span><br><span class="line">        this.position = new AtomicInteger(seedPosition);</span><br><span class="line">        this.pomeloLoadBalancerProperties = pomeloLoadBalancerProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123;</span><br><span class="line">        ServiceInstanceListSupplier supplier = this.serviceInstanceListSupplierProvider</span><br><span class="line">                .getIfAvailable(NoopServiceInstanceListSupplier::new);</span><br><span class="line">        return supplier.get(request).next()</span><br><span class="line">                .map(serviceInstances -&gt; processInstanceResponse(serviceInstances,request));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 灰度处理</span><br><span class="line">     * @param instances</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Response&lt;ServiceInstance&gt; processInstanceResponse(List&lt;ServiceInstance&gt; instances, Request request) &#123;</span><br><span class="line">        if (instances.isEmpty()) &#123;</span><br><span class="line">            return new EmptyResponse();</span><br><span class="line">        &#125;</span><br><span class="line">        DefaultRequestContext requestContext = (DefaultRequestContext) request.getContext();</span><br><span class="line">        RequestData clientRequest = (RequestData) requestContext.getClientRequest();</span><br><span class="line">        HttpHeaders headers = clientRequest.getHeaders();</span><br><span class="line">        // get Request Header</span><br><span class="line">        String reqVersion = headers.getFirst(pomeloLoadBalancerProperties.getHeader());</span><br><span class="line"></span><br><span class="line">        List&lt;ServiceInstance&gt; normalServiceInstances = instances.stream()</span><br><span class="line">                .filter(instance -&gt; !instance.getMetadata().containsKey(pomeloLoadBalancerProperties.getHeader()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        log.debug(&quot;X-Pomelo-LoadBalancer:&#123;&#125;&quot;,reqVersion);</span><br><span class="line">        if (!StrUtil.isEmpty(reqVersion)) &#123;</span><br><span class="line">            // filter service instances</span><br><span class="line">            List&lt;ServiceInstance&gt; gsServiceInstances = instances.stream()</span><br><span class="line">                    .filter(instance -&gt; reqVersion.equals(instance.getMetadata().get(pomeloLoadBalancerProperties.getHeader())))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">            if (gsServiceInstances.size() &gt; 0) &#123;</span><br><span class="line">                return processRibbonInstanceResponse(gsServiceInstances);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return processRibbonInstanceResponse(normalServiceInstances);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 负载均衡器</span><br><span class="line">     * 参考 org.springframework.cloud.loadbalancer.core.RoundRobinLoadBalancer#getInstanceResponse</span><br><span class="line">     */</span><br><span class="line">    private Response&lt;ServiceInstance&gt; processRibbonInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123;</span><br><span class="line">        int pos = Math.abs(this.position.incrementAndGet());</span><br><span class="line">        ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line">        return new DefaultResponse(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>从零搭建一个脚手架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>nacos</tag>
        <tag>脚手架</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装mysql8</title>
    <url>/2023/06/15/Centos7%E5%AE%89%E8%A3%85mysql8/</url>
    <content><![CDATA[<h4 id="1-下载mysql8安装包"><a href="#1-下载mysql8安装包" class="headerlink" title="1.下载mysql8安装包"></a>1.下载mysql8安装包</h4><p> 下载安装包需要到官网上直接下载，下载地址：</p>
<p><a href="https://www.mysql.com/downloads/">https://www.mysql.com/downloads/</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655968595661-5eabc2f9-9c20-48d7-9b40-ad2981566a92.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655969188020-f03f92d2-3da0-4999-b075-b024647674f0.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655969237916-c02ff7c1-1ba2-4c01-bedb-af80b7139851.png"></p>
<span id="more"></span>
<p>选择服务器对应的版本下载RPM</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655969724257-181c08ba-4a94-4972-9688-74dc2faf4be4.png"></p>
<h4 id="2-安装mysql"><a href="#2-安装mysql" class="headerlink" title="2.安装mysql"></a>2.安装mysql</h4><p>解压文件后获得</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655969975657-46e50cd0-ccd4-42e9-8712-77a2c8cabd9a.png"></p>
<p>实际并不需要这么多的包只需要</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655973216196-7db70d10-31a4-4410-a6c6-1e60c703a075.png"></p>
<p>将下载好的文件放入&#x2F;opt&#x2F;server文件夹中</p>
<p>然后查看依赖是否安装</p>
<ul>
<li><font style="color:rgb(51, 51, 51);">libaio</font></li>
</ul>
<p><font style="background-color:#FADB14;">rpm -qa|grep libaio</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655971393997-06dc71b6-95b0-483c-81b1-1f259b8de304.png"></p>
<p><font style="color:rgb(77, 77, 77);">如图，如果存在libaio的字样说明有libaio相关依赖，否则执行下面命令，进行依赖的安装：</font></p>
<p><font style="background-color:#FADB14;">yum install libaio</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">net-tools</font></li>
</ul>
<p><font style="background-color:#FADB14;">rpm -qa|grep net-tools</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655971602253-f483ab6e-beef-4346-98fe-d7f0aec95d80.png"></p>
<p><font style="color:rgb(77, 77, 77);">如图，如果存在</font><font style="color:rgb(51, 51, 51);">net-tools</font><font style="color:rgb(77, 77, 77);">的字样说明有</font><font style="color:rgb(51, 51, 51);">net-tools</font><font style="color:rgb(77, 77, 77);">相关依赖，否则执行下面命令，进行依赖的安装：</font><font style="background-color:#FADB14;">rpm -qa|grep net-tools</font></p>
<p><font style="background-color:#FADB14;"></font></p>
<p>接下来是安装过程：</p>
<p>首先要进入到文件所在的文件下</p>
<p><font style="background-color:#FADB14;">cd &#x2F;opt&#x2F;server&#x2F;mysql</font></p>
<p><font style="background-color:#FADB14;"></font></p>
<p>然后执行安装指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rmp -ivh mysql-community-client-plugins-8.0.29-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-icu-data-files-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-8.0.29-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">在安装第三个包的时候如果出现如下错误：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655973480139-84c03370-8697-4feb-a4e0-705266488e04.png"></p>
<p><font style="color:rgb(77, 77, 77);">需要解除之前安装过的依赖即可，执行下面命令：</font></p>
<p><font style="background-color:#FADB14;">yum remove mysql-libs</font></p>
<p><font style="color:rgb(77, 77, 77);">在安装地五个包的时候如果出现如下错误：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655973545638-bf8a4294-bae2-448c-bf6f-87f4ed90f500.png"></p>
<p><font style="color:rgb(77, 77, 77);">需要安装libnuma依赖，执行如下命令解决：</font></p>
<p><font style="background-color:#FADB14;">yum install libnuma*</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">检测是否安装成功</font></strong></p>
<p><font style="background-color:#FADB14;">rpm -qa|grep -i mysql</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655973593040-c581901d-60c6-4f87-ac2b-97548bcfaf31.png"></p>
<p><font style="color:rgb(77, 77, 77);">如果成功显示上面安装的6个包，说明安装成功。</font></p>
<h4 id="3-设置权限"><a href="#3-设置权限" class="headerlink" title="3.设置权限"></a>3.设置权限</h4><p><font style="color:rgb(77, 77, 77);">如果你是以root身份安装和允许mysql服务，为了保证数据库目录与文件（默认&#x2F;var&#x2F;lib&#x2F;mysql下）的所有者为mysql用户，需要执行下面的命令初始化：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --user=mysql</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">–initialize选项默认以安全模式来初始化，则会为root用户生成一个临时密码，并将该密码标记为过期，登录后不能做其他任何操作，需要重新设置一个新的密码。生成的临时密码会记录在日志中，使用如下命令查看日志：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655974562598-3be22c55-9a64-4951-b213-153e0a91b5ea.png"></p>
<p>先启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start|stop|restart mysqld</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">其中start|stop|restart分别为启动、停止和重启mysql服务。</font></p>
<p><font style="color:rgb(77, 77, 77);">如果需要开机自启动需要：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld</span><br></pre></td></tr></table></figure>

<p>然后先使用临时密码登陆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">回车并输入临时密码登录，登录成功后，执行如下命令修改密码：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Your New Password&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="4-开启远程"><a href="#4-开启远程" class="headerlink" title="4.开启远程"></a>4.开启远程</h4><p>如果是在远程服务器上安装服务需要打开远程设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql</span><br><span class="line">update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-优化配置"><a href="#5-优化配置" class="headerlink" title="5.优化配置"></a>5.优化配置</h4><p><font style="color:rgb(85, 85, 85);">SQL执行慢有时候不一定完全是SQL问题，手动安装一台数据库而不做任何参数调整，再怎么优化SQL都无法让其性能最大化。要让一台数据库实例完全发挥其性能，首先我们就得先优化数据库的实例参数。</font></p>
<p><font style="color:rgb(85, 85, 85);">数据库实例参数优化遵循三句口诀：</font><strong><font style="color:rgb(85, 85, 85);">日志不能小、缓存足够大、连接要够用。</font></strong></p>
<p><font style="color:rgb(85, 85, 85);">所以数据库事务提交后需要将事务对数据页的修改刷（ fsync）到磁盘上，才能保证数据的持久性。这个刷盘，是一个随机写，性能较低，如果每次事务提交都要刷盘，会极大影响数据库的性能。数据库在架构设计中都会采用如下两个优化手法：</font></p>
<ul>
<li><font style="color:rgb(85, 85, 85);">先将事务写到日志文件RedoLog（WAL），将随机写优化成顺序写</font></li>
<li><font style="color:rgb(85, 85, 85);">加一层缓存结构Buffer，将单次写优化成顺序写</font></li>
</ul>
<p><font style="color:rgb(85, 85, 85);">所以日志跟缓存对数据库实例尤其重要。而连接如果不够用，数据库会直接抛出异常，系统无法访问。，以下是常见的优化项或者需要修改的项</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(85, 85, 85);">参数分类</font></strong></th>
<th><strong><font style="color:rgb(85, 85, 85);">参数名</font></strong></th>
<th><strong><font style="color:rgb(85, 85, 85);">参数值</font></strong></th>
<th><strong><font style="color:rgb(85, 85, 85);">备注</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(85, 85, 85);">数据缓存</font></td>
<td><font style="color:rgb(85, 85, 85);">INNODB_BUFFER_POOL_SIZE</font></td>
<td><font style="color:rgb(85, 85, 85);">物理内存50-80%</font></td>
<td><font style="color:rgb(85, 85, 85);">一般来说越大性能越好</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">日志相关</font></td>
<td><font style="color:rgb(85, 85, 85);">Innodb_log_buffer_size</font></td>
<td><font style="color:rgb(85, 85, 85);">16-32M</font></td>
<td><font style="color:rgb(85, 85, 85);">根据运行情况调整</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">日志相关</font></td>
<td><font style="color:rgb(85, 85, 85);">sync_binlog</font></td>
<td><font style="color:rgb(85, 85, 85);">1、100、0</font></td>
<td><font style="color:rgb(85, 85, 85);">1安全性最好</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">监听及连接</font></td>
<td><font style="color:rgb(85, 85, 85);">max_connections</font></td>
<td><font style="color:rgb(85, 85, 85);">根据业务情况调整</font></td>
<td><font style="color:rgb(85, 85, 85);">可以预留一部分值</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">文件读写性能</font></td>
<td><font style="color:rgb(85, 85, 85);">innodb_flush_log_at_trx_commit</font></td>
<td><font style="color:rgb(85, 85, 85);">2</font></td>
<td><font style="color:rgb(85, 85, 85);">安全和性能的折中考虑</font></td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">其他</font></td>
<td><font style="color:rgb(85, 85, 85);">wait_timeout，interactive_timeout</font></td>
<td><font style="color:rgb(85, 85, 85);">28800</font></td>
<td><font style="color:rgb(85, 85, 85);">避免应用连接定时中断</font></td>
</tr>
<tr>
<td>端口</td>
<td><font style="color:rgb(77, 77, 77);">port</font></td>
<td>非3306的值</td>
<td>基于数据库安全</td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">日志相关</font></td>
<td><font style="color:rgb(77, 77, 77);">log-bin</font></td>
<td>&#x2F;opt&#x2F;date</td>
<td>binglog日志的存放地址</td>
</tr>
<tr>
<td><font style="color:rgb(85, 85, 85);">日志相关</font></td>
<td><font style="color:rgb(77, 77, 77);">expire_logs_days </font></td>
<td>7</td>
<td><font style="color:rgb(77, 77, 77);"> 只保留 7 天的日志文件（需要重启mysql数据库）</font></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>工具</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL快速清空数据库中的所有表</title>
    <url>/2023/06/15/MySQL%E7%94%A8truncate%E5%91%BD%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%B8%85%E7%A9%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="先执行sql语句讲要情况的数据库中的数据库变成执行语句"><a href="#先执行sql语句讲要情况的数据库中的数据库变成执行语句" class="headerlink" title="先执行sql语句讲要情况的数据库中的数据库变成执行语句"></a>先执行sql语句讲要情况的数据库中的数据库变成执行语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select CONCAT(&#x27;truncate TABLE &#x27;,table_schema,&#x27;.&#x27;,TABLE_NAME, &#x27;;&#x27;) from INFORMATION_SCHEMA.TABLES where table_schema =&quot;数据库&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="执行sql后将结果复制出来"><a href="#执行sql后将结果复制出来" class="headerlink" title="执行sql后将结果复制出来"></a>执行sql后将结果复制出来</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655362274515-0b955c92-36af-4b47-b88b-98ea9c8a2fe2.png"></p>
<h3 id="再次执行结果拼接成的sql语句"><a href="#再次执行结果拼接成的sql语句" class="headerlink" title="再次执行结果拼接成的sql语句"></a>再次执行结果拼接成的sql语句</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1655362297359-e7698f2a-6388-4c50-bdf9-b40e1e42789b.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用函数</title>
    <url>/2023/06/15/Mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="字符串函数："><a href="#字符串函数：" class="headerlink" title="字符串函数："></a><font style="color:rgb(77, 77, 77);">字符串函数：</font></h4><table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">CANCAT(S1,S2,…Sn)</font></td>
<td><font style="color:rgb(79, 79, 79);">连接 S1,S2,…Sn 为一个字符串</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">LENGTH(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">计算字符串长度函数，返回字符串的字节长度</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">LEFT(s，n)</font></td>
<td><font style="color:rgb(79, 79, 79);">函数返回字符串 s 最左边的 n 个字符，s&#x3D;1表示第一个字符</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">RIGHT(s，n)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">函数返回字符串 s 最右边的 n 个字符</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">LOWER(str)</font></td>
<td><font style="color:rgb(79, 79, 79);">将字符串str中所有字符变为小写</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">UPPER(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">将字符串str中所有字符变为大写</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">LTRIM(str)</font></td>
<td><font style="color:rgb(79, 79, 79);">去掉字符串str左侧的空格</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">RTRIM(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">去掉字符串str行尾的空格</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">REPLACE(str,a,b)</font></td>
<td><font style="color:rgb(79, 79, 79);">用字符串b替换字符串str中所有出现的字符串a</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">TRIM(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">去掉字符串行尾和行头的空格</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">substr&#x2F;substring</font></td>
<td><font style="color:rgb(79, 79, 79);">截取字符串，返回从指定位置开始的指定长度的字符换</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">reverse(str)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</font></td>
</tr>
</tbody></table>
<span id="more"></span>

<p><font style="color:rgb(77, 77, 77);">substring使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 12  6</span><br><span class="line">select length(&#x27;javacode2018&#x27;),length(&#x27;路人&#x27;);</span><br><span class="line">-- 路人    路人甲JAVA </span><br><span class="line">select left(&#x27;路人甲JAVA&#x27;,2),left(&#x27;路人甲JAVA&#x27;,10);</span><br><span class="line">/** 第三个字符之后的子字符串：inese **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27;, 3);</span><br><span class="line">/** 倒数第三个字符之后的子字符串：ese **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27;, -3);</span><br><span class="line">/** 第三个字符之后的两个字符：in **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27;, 3, 2);</span><br><span class="line">/** 倒数第三个字符之后的两个字符：es **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27;, -3, 2);</span><br><span class="line">/** 第三个字符之后的子字符串：inese **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27; FROM 3);</span><br><span class="line">/** 倒数第三个字符之后的子字符串：ese **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27; FROM -3);</span><br><span class="line">/** 第三个字符之后的两个字符：in **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27; FROM 3 FOR 2);</span><br><span class="line">/** 倒数第三个字符之后的两个字符：es **/</span><br><span class="line">SELECT substring(&#x27;chinese&#x27; FROM -3 FOR 2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数:"></a><font style="color:rgb(79, 79, 79);">数值函数:</font></h4><table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">ABS(x)</font></td>
<td><font style="color:rgb(79, 79, 79);">返回 x 的绝对值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">SQRT(x)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">返回 x 的求二次方根</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">CEIL(x)&#x2F;CEILING(x)</font></td>
<td><font style="color:rgb(79, 79, 79);">返回大于 x 的最小整数值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">FLOOR(x)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">返回小于 x 的最大整数值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">MOD(x，y)</font></td>
<td><font style="color:rgb(79, 79, 79);">返回 x&#x2F;y 的模</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">RAND()</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">返回 0 到 1 内的随机值。传入整数参数时，用来产生重复序列</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">ROUND(x,y)</font></td>
<td><font style="color:rgb(79, 79, 79);">返回参数 x 的四舍五入的有 y 位小数的值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">POW(x,y)&#x2F;POWER(x,y)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">返回计算x的y次方</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 5  NULL</span><br><span class="line">select sqrt(25),sqrt(-9);</span><br><span class="line">-- -2  3</span><br><span class="line">select ceil(-2.5),ceiling(2.5);</span><br><span class="line">-- 5  5  -4  -5</span><br><span class="line">select floor(5),floor(5.66),floor(-4),floor(-4.66);</span><br><span class="line">-- -7   -8   3</span><br><span class="line">select round(-6.6),round(-8.44),round(3.44);</span><br><span class="line">-- 0.04   1000</span><br><span class="line">select pow(5,-2),pow(10,3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数:"></a><font style="color:rgb(79, 79, 79);">日期时间函数:</font></h4><table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CURDATE()</font><font style="color:rgb(79, 79, 79);"> &#x2F; </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">current_date()</font></td>
<td><font style="color:rgb(79, 79, 79);">当前日期</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CURTIME()</font><font style="color:rgb(79, 79, 79);"> &#x2F; </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">current_time()</font></td>
<td><font style="color:rgb(79, 79, 79);">当前时间</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">NOW()</font><font style="color:rgb(79, 79, 79);"> &#x2F; </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">sysdate()</font></td>
<td><font style="color:rgb(79, 79, 79);">当前的日期和时间</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">UNIX_TIMESTAMP(date)</font></td>
<td><font style="color:rgb(79, 79, 79);">获取日期date的UNIX 时间戳</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">FROM_UNIXTIME</font></td>
<td><font style="color:rgb(79, 79, 79);">将UNIX 时间戳格式化</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">dayofweek</font></td>
<td><font style="color:rgb(79, 79, 79);">获取指定日期是一周中是第几天，返回值范围是1~7,1&#x3D;周日</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">WEEK(date)</font></td>
<td><font style="color:rgb(79, 79, 79);">日期 date 为一年中的第几周，返回值的范围是否为 0-52 或 1-53</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">dayofyear</font></td>
<td><font style="color:rgb(79, 79, 79);">获取指定曰期是一年中的第几天，返回值范围是1~366</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">YEAR(date)</font></td>
<td><font style="color:rgb(79, 79, 79);">日期 date 的年份</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">dayofmonth</font></td>
<td><font style="color:rgb(79, 79, 79);">获取指定日期是一个月中是第几天，返回值范围是1~31</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">HOUR(time)</font></td>
<td><font style="color:rgb(79, 79, 79);">time 的小时值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">MINUTE(time)</font></td>
<td><font style="color:rgb(79, 79, 79);">time 的分钟值</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATE_FORMAT</font><font style="color:rgb(79, 79, 79);">(date,fmt)</font></td>
<td><font style="color:rgb(79, 79, 79);">按字符串 fmt 格式化日期 date 值</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATE_ADD</font><font style="color:rgb(79, 79, 79);">(date,INTERVAL expr type)&#x2F;adddate</font></td>
<td><font style="color:rgb(79, 79, 79);">一个日期或时间值加上一个时间间隔的时间值</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATE_SUB</font><font style="color:rgb(79, 79, 79);">&#x2F;subdate</font></td>
<td><font style="color:rgb(79, 79, 79);">都是向日期减去指定的时间间隔</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATEDIFF</font><font style="color:rgb(79, 79, 79);">(expr,expr2)</font></td>
<td><font style="color:rgb(79, 79, 79);">起始时间 expr 和结束时间 expr2 之间的天数</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 2019-09-17 16:13:28   2019-09-17 16:13:28</span><br><span class="line">select now(),sysdate();</span><br><span class="line">-- 12</span><br><span class="line">select month(&#x27;2017-12-15&#x27;);</span><br><span class="line">-- 1</span><br><span class="line">select dayofmonth(&#x27;2019-01-01&#x27;);</span><br><span class="line">-- 2019-01-11</span><br><span class="line">select date_add(&#x27;2019-01-01&#x27;,INTERVAL 10 day);</span><br><span class="line">-- 2018-12-22</span><br><span class="line">select date_sub(&#x27;2019-01-01&#x27;,INTERVAL 10 day);</span><br><span class="line">-- 1</span><br><span class="line">select datediff(&#x27;2017-11-30&#x27;,&#x27;2017-11-29&#x27;);</span><br><span class="line">-- 20171130</span><br><span class="line">select date_format(&#x27;2017-11-30&#x27;,&#x27;%Y%m%d&#x27;);</span><br><span class="line">-- 1</span><br><span class="line">select weekday(now());</span><br><span class="line">-- 1303195194 </span><br><span class="line">select unix_timestamp();</span><br><span class="line">-- 2020-06-19 00:00:00</span><br><span class="line">SELECT FROM_UNIXTIME(1592515200, &#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数:"></a><font style="color:rgb(79, 79, 79);">流程函数:</font></h4><p><font style="color:rgb(77, 77, 77);">主要指case…when…函数：</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">IF(expr,v1,v2)</font></td>
<td><font style="color:rgb(79, 79, 79);">当 expr 为真是返回 v1 的值，否则返回 v2</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">IFNULL(v1,v2)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">v1为空返回v2，否则返回v1</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">case</font></td>
<td><font style="color:rgb(79, 79, 79);">多条件判断</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);">case语句有2种写法：</font></p>
<p>:::tips<br>CASE &lt;表达式&gt;</p>
<p> WHEN &lt;值1&gt; THEN &lt;操作&gt;</p>
<p> WHEN &lt;值2&gt; THEN &lt;操作&gt;</p>
<p> …</p>
<p> ELSE &lt;操作&gt;</p>
<p>END CASE;</p>
<p>CASE</p>
<p> WHEN &lt;条件1&gt; THEN &lt;命令&gt;</p>
<p> WHEN &lt;条件2&gt; THEN &lt;命令&gt;</p>
<p> …</p>
<p> ELSE commands</p>
<p>END CASE;</p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1 x yes</span><br><span class="line">select if(1&lt;2,1,0) c1,if(1&gt;5,&#x27;√&#x27;,&#x27;×&#x27;) c2,if(strcmp(&#x27;abc&#x27;,&#x27;ab&#x27;),&#x27;yes&#x27;,&#x27;no&#x27;) c3;</span><br><span class="line">-- 12345  非空</span><br><span class="line">select ifnull(null,&#x27;12345&#x27;),ifnull(&#x27;非空&#x27;,&#x27;为空&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数:"></a><font style="color:rgb(79, 79, 79);">聚合函数:</font></h4><p><font style="color:rgb(77, 77, 77);">分组时，可以使用聚合函数。</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">函数</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">功能</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">max</font></td>
<td><font style="color:rgb(79, 79, 79);">查询指定列的最大值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">min</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">查询指定列的最小值</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">count</font></td>
<td><font style="color:rgb(79, 79, 79);">统计查询结果的行数</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">sum</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">求和，返回指定列的总和</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">avg</font></td>
<td><font style="color:rgb(79, 79, 79);">求平均值，返回指定列数据的平均值</font></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/2023/06/15/Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><font style="color:rgb(77, 77, 77);">Mysql提供了多种数据类型，主要包括数值型、字符串类型、日期和时间类型。接下来以Mysql5.0为例，详细介绍Mysql中的各种数据类型。</font></p>
<span id="more"></span>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a><font style="color:rgb(79, 79, 79);">数值类型</font></h2><h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a><font style="color:rgb(79, 79, 79);">整数类型</font></h5><table>
<thead>
<tr>
<th><font style="color:rgb(79, 79, 79);"></font></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字节</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最小值</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最大值</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);">备注</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">TINYINT</font></td>
<td>1</td>
<td><font style="color:rgb(79, 79, 79);">有符号-128(-2</font><sup><font style="color:rgb(79, 79, 79);">7</font></sup><font style="color:rgb(79, 79, 79);">)</font>   <font style="color:rgb(79, 79, 79);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);">有符号127(2</font><sup><font style="color:rgb(79, 79, 79);">7</font></sup><font style="color:rgb(79, 79, 79);">-1)</font>   <font style="color:rgb(79, 79, 79);">无符号255(2</font><sup><font style="color:rgb(79, 79, 79);">8</font></sup><font style="color:rgb(79, 79, 79);">-1)</font></td>
<td><font style="color:rgb(79, 79, 79);">很小的整数</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">SMALLINT</font></td>
<td>2</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">有符号-32768(-2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">15</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">)</font>   <font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">有符号32767(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">15</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)</font>   <font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">无符号65535(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">16</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">小的整数</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">MEDIUMINT</font></td>
<td>3</td>
<td><font style="color:rgb(79, 79, 79);">   </font><font style="color:rgb(79, 79, 79);">有符号- 8388608(-2</font><sup><font style="color:rgb(79, 79, 79);">23</font></sup><font style="color:rgb(79, 79, 79);">)   </font><font style="color:rgb(79, 79, 79);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);">有符号8388607(2</font><sup><font style="color:rgb(79, 79, 79);">23</font></sup><font style="color:rgb(79, 79, 79);">-1)</font>   <font style="color:rgb(79, 79, 79);">无符号1677215(2</font><sup><font style="color:rgb(79, 79, 79);">24</font></sup><font style="color:rgb(79, 79, 79);">-1)</font></td>
<td><font style="color:rgb(79, 79, 79);">中等大小的整数</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">INT</font><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">、INTEGER</font></td>
<td>4</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">有符号- 2147483648(-2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">31</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">)</font>   <font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">有符号2147483647(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">31</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)</font>   <font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">无符号4294967295(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">32</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">普通大小的整数</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">BIGINT</font></td>
<td>8</td>
<td><font style="color:rgb(79, 79, 79);">有符号-9223372036854775808(-2</font><sup><font style="color:rgb(79, 79, 79);">63</font></sup><font style="color:rgb(79, 79, 79);">)</font>   <font style="color:rgb(79, 79, 79);">无符号0</font></td>
<td><font style="color:rgb(79, 79, 79);">有符号9223372036854775807(2</font><sup><font style="color:rgb(79, 79, 79);">63</font></sup><font style="color:rgb(79, 79, 79);">-1)</font>   <font style="color:rgb(79, 79, 79);">无符号18446744073709551615(2</font><sup><font style="color:rgb(79, 79, 79);">64</font></sup><font style="color:rgb(79, 79, 79);">-1)</font></td>
<td><font style="color:rgb(79, 79, 79);">大的整数</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(77, 77, 77);"> 对于整型数据，Mysql支持在类型名称后面的小括号内指定显示宽度。例如</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">int(5)表示当数值宽度小于5位的时候在数字前面，默认用空格填满宽度，如果不显示指定宽度则默认为int(11)</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">如果需要用哪个数字’0’填充，则需要使用zerofill，并且使用zerofill 时，默认会自动unsigned(无符号)属性，使用unsigned属性后，数值范围是原值的2倍，例如，有符号为-128</font><sub><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">+127，无符号为0</font></sub><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">256。</font></p>
<p>:::</p>
<h5 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a><font style="color:rgb(79, 79, 79);">浮点数类型</font></h5><table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字节</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最小值</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最大值</font></strong></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">FLOAT</font></td>
<td><font style="color:rgb(79, 79, 79);">4</font></td>
<td><font style="color:rgb(79, 79, 79);">±1.175494351E-38</font></td>
<td><font style="color:rgb(79, 79, 79);">±3.402823466E+38</font></td>
<td><font style="color:rgb(79, 79, 79);">单精度浮点型，m总个数，d小数位</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">DOUBLE</font></td>
<td>8</td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">±2.2250738585072014E-308</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">±1.7976931348623157E+308</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">双精度浮点型， m总个数，d小数位</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">DEC(M,D)</font></td>
<td><font style="color:rgb(79, 79, 79);">M+2</font></td>
<td><font style="color:rgb(79, 79, 79);">最大取值范围与DOUBLE相同，给定DECIMAL的有效取值范围由M和D决定</font></td>
<td><font style="color:rgb(79, 79, 79);">压缩严格的定点数</font></td>
<td></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DECIMAL(M,D)</font></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> 对于小数的表示，MySQL分为两种方式：浮点数和定点数。浮点数包括float（单精度）和double（双精度），而定点数则只有decimal一种表示。定点数在MySQL内部以字符串形式存放，比浮点数更精确，适合用来表示金额等精度高的数据。</p>
<p>  浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示，“(M,D)”表示该值一共显示M位数字（整数位+小数位），其中D位于小数点后面。M和D又称为精度和标度。</p>
<p>:::tips<br><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">float和double在不指定精度时，默认会按照实际的精度来显示</font><font style="color:rgb(77, 77, 77);">，而</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DECIMAL在不指定精度时，默认整数为10，小数为0</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">decimal插入的数据超过精度之后会触发警告</font></p>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">decimal采用的是四舍五入</font><font style="color:rgb(77, 77, 77);">。</font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"><br></font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">float和double采用的是四舍六入五成双</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">四舍六入五成双：就是5以下舍弃5以上进位，如果需要处理数字为5的时候，需要看5后面是否还有不为0的任何数字，如果有，则直接进位；如果没有，需要看5前面的数字，若是奇数则进位，若是偶数则将5舍掉。</font></p>
<p><font style="color:rgb(77, 77, 77);">如果将数据库中 float 、 double类型的数据进行计算时，会存在精度问题。而使用decimal时是正常的，所以非int数据，一般decimal用的比较多</font></p>
<p>:::</p>
<h5 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a><font style="color:rgb(79, 79, 79);">日期时间类型</font></h5><table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字节</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最小值</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">最大值</font></strong></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">DATE</font></td>
<td><font style="color:rgb(79, 79, 79);">4</font></td>
<td><font style="color:rgb(79, 79, 79);">1000-01-01</font></td>
<td><font style="color:rgb(79, 79, 79);">9999-12-31</font></td>
<td><font style="color:rgb(79, 79, 79);">YYYY-MM-DD</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DATETIME</font></td>
<td><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">8</font></strong></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">1000-01-01 00:00:00</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">9999-12-31 23:59:59</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">YYYY-MM-DD HH:MM:SS</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">TIMESTAMP</font></td>
<td><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">4</font></strong></td>
<td><font style="color:rgb(79, 79, 79);">19700101080001</font></td>
<td><font style="color:rgb(79, 79, 79);">2038-01-19 03:14:07UTC（格林尼治时间）</font></td>
<td><font style="color:rgb(79, 79, 79);">YYYY-MM-DD HH:MM:SS</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">TIME</font></td>
<td><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">3</font></strong></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-838:59:59</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">838:59:59</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">HH:MM:SS</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">YEAR</font></td>
<td><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">1</font></strong></td>
<td><font style="color:rgb(79, 79, 79);">1901</font></td>
<td><font style="color:rgb(79, 79, 79);">2155</font></td>
<td><font style="color:rgb(79, 79, 79);">YYYY</font></td>
</tr>
</tbody></table>
<p>如果要用来表示年月日，通常用DATE来表示。</p>
<p>  如果要用来表示年月日时分秒，通常用DATETIME表示。</p>
<p>  如果只用来表示时分秒，通常用TIME来表示。</p>
<p>  如果需要经常插入或者更新日期为当前系统时间，则通常使用TIMESTAMP来表示。</p>
<p>  如果只是表示年份，可以用YEAR来表示，它比DATE占用更少的空间。YEAR有2位或4位格式的年。默认是4位格式。在4位格式中，允许的值是1901～2155和0000。在2位格式中，允许的值是70～69，表示从1970～2069年。</p>
<p>  DATETIME是DATE和TIME的组合。</p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> TIMESTAMP还有一个重要特点，就是和时区相关。当插入日期时，会先转换为本地时区后存放；而从数据库里面取出时，也同样需要将日期转换为本地时区后显示。这样，两个不同时区的用户看到的同一个日期可能是不一样的。</font></p>
<p>:::</p>
<p>尽量使用timestamp，空间效率高于datetime（datetime占用8字节，timestamp占用4字节）。</p>
<p>  如果需要存储微秒，可以使用bigint存储。</p>
<p>  DATETIME表示的时间范围较大，TIMESTAMP表示的时间范围较小。</p>
<p>  关于表中的更新时间字段，使用示例（插入数据时为当前时间，更新数据时也会随之更新）：</p>
<h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a><font style="color:rgb(79, 79, 79);">字符串类型</font></h5><table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字节</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">范围</font></strong></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">char</font><font style="color:rgb(79, 79, 79);">(M)</font></td>
<td><font style="color:rgb(79, 79, 79);">m</font></td>
<td><font style="color:rgb(79, 79, 79);">[0,m]，m的范围[0, 2</font><sup><font style="color:rgb(79, 79, 79);">8</font></sup><font style="color:rgb(79, 79, 79);">-1]</font></td>
<td><font style="color:rgb(79, 79, 79);">定长字符串</font></td>
</tr>
<tr>
<td><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">varchar</font><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">(M)</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">m</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">[0,m]，m的范围[0, 2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">16</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1]</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-65535 字节</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">tinyblob</font></td>
<td><font style="color:rgb(79, 79, 79);">L+1</font></td>
<td><font style="color:rgb(79, 79, 79);">0-255(2</font><sup><font style="color:rgb(79, 79, 79);">8</font></sup><font style="color:rgb(79, 79, 79);"> -1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);">不超过 255 个字符的二进制字符串</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">blob</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">L+2</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-65535( 2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">16</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">二进制形式的长文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">mediumblob</font></td>
<td><font style="color:rgb(79, 79, 79);">L+3</font></td>
<td><font style="color:rgb(79, 79, 79);">0-16777215(2</font><sup><font style="color:rgb(79, 79, 79);">24</font></sup><font style="color:rgb(79, 79, 79);"> -1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);">二进制形式的中等长度文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">longblob</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">L+4</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-4294967295( 2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">32</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">二进制形式的极大文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">tinytext</font></td>
<td><font style="color:rgb(79, 79, 79);">L+1</font></td>
<td><font style="color:rgb(79, 79, 79);">0-255( 2</font><sup><font style="color:rgb(79, 79, 79);">8</font></sup><font style="color:rgb(79, 79, 79);">-1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);">短文本字符串</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">text</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">L+2</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-65535(2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">16</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);"> -1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">长文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">mediumtext</font></td>
<td><font style="color:rgb(79, 79, 79);">L+3</font></td>
<td><font style="color:rgb(79, 79, 79);">0-16777215(2</font><sup><font style="color:rgb(79, 79, 79);">24</font></sup><font style="color:rgb(79, 79, 79);"> -1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);">中等长度文本数据</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">longtext</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">L+4</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">0-4294967295( 2</font><sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">32</font></sup><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">-1)字节</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">极大文本数据</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">char类型占用固定长度，如果存放的数据为固定长度的建议使用char类型，如：手机号码、身份证等固定长度的信息</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(77, 77, 77);">表格中的L表示存储的数据本身占用的字节，L 以外所需的额外字节为存放该值的长度所需的字节数。<br></font><font style="color:rgb(77, 77, 77);"> CHAR和VARCHAR很类似，都用来保存MySQL中较短的字符串。二者的主要区别在于存储方式的不同：</font></p>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">CHAR列的长度固定为创建表时声明的长度，长度可以为从0～255的任何值，存储的字符串长度不足时用空格填充到特定长度</font><font style="color:rgb(77, 77, 77);">；</font></p>
<p><font style="color:rgb(77, 77, 77);">而VARCHAR列中的值为可变长字符串，也就是说申请的只是最大长度，占用的空间为实际字符长度+1，最后一个字符存储使用了多长的空间。<br></font><font style="color:rgb(77, 77, 77);"> 在检索效率上来讲,char &gt; varchar。</font></p>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">在检索的时候，CHAR删除了尾部的空格</font><font style="color:rgb(77, 77, 77);">，而VARCHAR则保留这些空格</font></p>
<p><font style="color:rgb(77, 77, 77);">BINARY和VARBINARY类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不包含非二进制字符串。</font></p>
<p><font style="color:rgb(77, 77, 77);">  关于varchar(n)中n的单位，Mysql4.1及之后的版本，VARCHAR的单位是字符；Mysql4.1之前的版本，VARCHAR的单位是字节。</font></p>
<p><font style="color:rgb(77, 77, 77);">  varchar和char的使用策略：</font></p>
<p>:::tips</p>
<ol>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">对于经常变更的数据来说，CHAR</font><font style="color:rgba(0, 0, 0, 0.5);">比VARCHAR</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">更好，因为CHAR不容易产生碎片</font><font style="color:rgba(0, 0, 0, 0.5);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">使用时要注意只分配需要的空间。</font></li>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销</font><font style="color:rgba(0, 0, 0, 0.5);">。</font></li>
</ol>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT也称作 非标准字符串类型。</font></p>
<h4 id="Mysql数据类型相关问题"><a href="#Mysql数据类型相关问题" class="headerlink" title="Mysql数据类型相关问题"></a><font style="color:rgb(79, 79, 79);">Mysql数据类型相关问题</font></h4><h5 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少" class="headerlink" title="若一张表中只有一个字段VARCHAR(N) 类型，utf8编码，则N最大值为多少"></a>若一张表中只有一个字段VARCHAR(N) 类型，utf8编码，则N最大值为多少</h5><p>  由于utf8的每个字符最多占用3个字节。而MySQL定义行的长度不能超过65535，因此N的最大值计算方法为：(65535-1-2)&#x2F;3。</p>
<p> 减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</p>
<h5 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a><font style="color:rgb(79, 79, 79);">选择合适的数据类型</font></h5><h6 id="CHAR与VARCHAR"><a href="#CHAR与VARCHAR" class="headerlink" title="CHAR与VARCHAR"></a>CHAR与VARCHAR</h6><p>  CHAR和VARCHAR类型类似，都用来存储字符串，但它们保存和检索的方式不同。CHAR属于固定长度的字符类型，而VARCHAR属于可变长度的字符类型。</p>
<p>  看一个字符串值保存到CHAR(4)和VARCHAR(4)列的结果对比：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716948693406-7caa2e19-123f-4cca-af84-e307c5e2ebfb.png"></p>
<p>  由于CHAR是固定长度的，所以它的处理速度比VARCHAR快得多，但是缺点是浪费存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较高要求的数据可以考虑使用CHAR类型来存储。</p>
<p>  在MySQL中，不同的存储引擎对CHAR和VARCHAR的使用原则有所不同，简单概括：</p>
<p>:::tips<br>  MyISAM：建议使用固定长度的数据列代替可变长度的数据列。</p>
<p>  MEMORY：目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理。</p>
<p>  InnoDB：建议使用VARCHAR类型。对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I&#x2F;O是比较好的。</p>
<p>:::</p>
<h6 id="浮点数与定点数"><a href="#浮点数与定点数" class="headerlink" title="浮点数与定点数"></a><font style="color:rgba(0, 0, 0, 0.75);">浮点数与定点数</font></h6><p> 浮点数一般用于表示含有小数部分的数值。当一个字段被定义为浮点类型后，如果插入数据的精度超过该列定义的实际精度，则插入值会被四舍五入到实际定义的精度值，然后插入，四舍五入的过程不会报错。在MySQL中float、double（或 real）用来表示浮点数。</p>
<p>  定点数不同于浮点数，定点数实际上是以字符串形式存放的，所以定点数可以更加精确的保存数据。</p>
<p>  浮点数和定点数使用的几个原则：</p>
<p>:::tips</p>
<ol>
<li><font style="color:rgba(0, 0, 0, 0.5);">浮点数存在误差问题；</font></li>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">对货币等对精度敏感的数据，应该用定点数表示或存储</font><font style="color:rgba(0, 0, 0, 0.5);">；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">在编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">要注意浮点数中一些特殊值的处理。</font></li>
</ol>
<p>:::</p>
<h6 id="日期类型选择"><a href="#日期类型选择" class="headerlink" title="日期类型选择"></a><font style="color:rgba(0, 0, 0, 0.75);">日期类型选择</font></h6><p><font style="color:rgba(0, 0, 0, 0.75);">MySQL提供的常用日期类型有DATE、TIME 、DATETIME、TIMESTAMP。使用原则：</font></p>
<p>:::tips<br>根据实际需要选择能够满足应用的最小存储的日期类型。如果应用只需要记录“年份”，那么用1个字节来存储的YEAR类型完全可以满足，而不需要用4个字节来存储的DATE类型。这样不仅仅能节约存储，更能够提高表的操作效率。</p>
<p>如果要记录年月日时分秒，并且记录的年份比较久远，那么最好使用DATETIME，</p>
<p>而不要使用TIMESTAMP。因为TIMESTAMP表示的日期范围比DATETIME要短得多。</p>
<p>如果记录的日期需要让不同时区的用户使用，那么最好使用TIMESTAMP，因为日期类型中只有它能够和实际时区相对应。</p>
<p>:::</p>
<h6 id="ENUM和VARCHAR"><a href="#ENUM和VARCHAR" class="headerlink" title="ENUM和VARCHAR"></a><font style="color:rgba(0, 0, 0, 0.75);">ENUM和VARCHAR</font></h6><p>ENUM类型是非常快和紧凑的。在实际上，其保存的是TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p>
<p>  如果有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，这些字段的取值是有限而且固定的，那么，就应该使用ENUM而不是VARCHAR。</p>
<h5 id="数据类型选择的一些建议"><a href="#数据类型选择的一些建议" class="headerlink" title="数据类型选择的一些建议"></a><font style="color:rgb(79, 79, 79);">数据类型选择的一些建议</font></h5><h6 id="选小不选大"><a href="#选小不选大" class="headerlink" title="选小不选大"></a>选小不选大</h6><p>  一般情况下选择可以正确存储数据的最小数据类型，越小的数据类型通常更快，占用磁盘，内存和CPU缓存更小。</p>
<h6 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h6><p>  简单的数据类型的操作通常需要更少的CPU周期，例如：整型比字符操作代价要小得多，因为字符集和校对规则(排序规则)使字符比整型比较更加复杂。</p>
<h6 id="尽量避免NULL"><a href="#尽量避免NULL" class="headerlink" title="尽量避免NULL"></a>尽量避免NULL</h6><p>  尽量制定列为NOT NULL，除非真的需要NULL类型的值，有NULL的列值会使得索引、索引统计和值比较更加复杂。</p>
<h6 id="浮点类型的建议统一选择decimal"><a href="#浮点类型的建议统一选择decimal" class="headerlink" title="浮点类型的建议统一选择decimal"></a>浮点类型的建议统一选择decimal</h6><h6 id="记录时间的建议使用int或者bigint类型"><a href="#记录时间的建议使用int或者bigint类型" class="headerlink" title="记录时间的建议使用int或者bigint类型"></a>记录时间的建议使用int或者bigint类型</h6><p>将时间转换为时间戳格式，如将时间转换为秒、毫秒，进行存储，方便走索引</p>
<h5 id="使用int做主键和使用string有什么优劣"><a href="#使用int做主键和使用string有什么优劣" class="headerlink" title="使用int做主键和使用string有什么优劣"></a><font style="color:rgb(79, 79, 79);">使用int做主键和使用string有什么优劣</font></h5><p><strong><font style="color:rgba(0, 0, 0, 0.75);">使用整数（int）作为主键</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.75);">优势：</font></p>
<p>:::tips<br>性能：整数类型通常占用较少的存储空间，并且在进行比较和排序操作时速度更快。</p>
<p>索引效率：整数类型的索引通常比字符串类型的索引更加紧凑和高效。</p>
<p>自增属性：许多数据库系统支持整数类型的自增属性，这可以自动为新记录分配一个唯一的标识符，无需应用程序干预。</p>
<p>空间效率：整数类型占用的存储空间较小，有助于减少数据库的总体大小。</p>
<p>:::</p>
<p>劣势：</p>
<p>:::tips</p>
<ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">可读性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：整数类型不如字符串类型直观，不容易从主键值中直接获取有关记录的信息。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">扩展性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：在某些情况下，如果整数主键达到其最大值，可能需要更复杂的方案来处理。</font></li>
</ol>
<p>:::</p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">使用字符串（string）作为主键</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.75);"> 优势：</font></p>
<p>:::tips</p>
<ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">可读性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：字符串类型的主键通常更容易理解，因为它们可能包含描述性信息。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">灵活性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：字符串类型可以容纳更多种类的数据，包括字母、数字和特殊字符，使得它们在处理复杂的主键需求时更加灵活。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.5);">扩展性</font></strong><font style="color:rgba(0, 0, 0, 0.5);">：字符串类型的主键在达到存储限制之前可以容纳更多的信息。</font></li>
</ol>
<p>:::</p>
<p>劣势：</p>
<p>:::tips<br>性能：字符串类型通常比整数类型占用更多的存储空间，并且在进行比较和排序操作时速度较慢。</p>
<p>索引效率：字符串类型的索引通常比整数类型的索引更大且效率较低。</p>
<p>错误风险：在处理字符串类型的主键时，需要更加小心地处理大小写敏感性、空格、特殊字符等问题，以避免潜在的错误。</p>
<p>存储空间：由于字符串的长度可变，因此可能会浪费存储空间，特别是在存储较短的字符串时。</p>
<p>:::</p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">如何选择合适的主键类型</font></strong></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);"> </font></strong><font style="color:rgba(0, 0, 0, 0.75);">1、根据业务需求：根据具体业务场景来选择合适的主键类型。例如，如果业务需求中需要处理大量数值类型的数据，可以使用 int 作为主键；如果需要处理字符串类型的数据，可以使用 string 作为主键。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.75);">  2、考虑数据量的大小：如果数据量较大，可以使用 int 作为主键，以提高查询和更新的效率；如果数据量较小，可以使用 string 作为主键，以提高数据的可读性和可操作性。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.75);">  3、考虑数据类型的稳定性和一致性：如果数据类型需要保持稳定性和一致性，可以使用 int 作为主键；如果数据类型可能会发生变化，可以使用 string 作为主键。 综上所述，使用 int 和 string 作为主键各有优劣。在实际应用中，需要根据具体业务场景和数据特点来选择合适的主键类型，以满足数据的存储、管理和处理需求。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.75);"></font></p>
<p><font style="color:rgba(0, 0, 0, 0.75);"></font></p>
<h2 id="Mysql字符集"><a href="#Mysql字符集" class="headerlink" title="Mysql字符集"></a><font style="color:rgb(79, 79, 79);">Mysql字符集</font></h2><p><font style="color:rgb(77, 77, 77);">简单地说，字符集就是一套文字符号及其编码、比较规则的集合。</font><br><font style="color:rgb(77, 77, 77);"> Mysql常用字符集：</font></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">字符集</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">是否定长</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">编码方式</font></strong></th>
<th><strong><font style="color:rgb(79, 79, 79);background-color:rgb(239, 243, 245);">说明</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(79, 79, 79);">ACSII</font></td>
<td><font style="color:rgb(79, 79, 79);">是</font></td>
<td><font style="color:rgb(79, 79, 79);">单字节 7 位编码</font></td>
<td><font style="color:rgb(79, 79, 79);">最早的奠基性字符集</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">GBK</font></td>
<td><font style="color:rgb(79, 79, 79);">是</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">双字节编码</font></td>
<td></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">UTF-32</font></td>
<td><font style="color:rgb(79, 79, 79);">是</font></td>
<td><font style="color:rgb(79, 79, 79);">4 字节编码</font></td>
<td><font style="color:rgb(79, 79, 79);">目前很少采用</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">UTF-16</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">否</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">2 字节或 4 字节编码</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">Java和Windows XP&#x2F;NT等内部使用UTF-16</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">UTF-8</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">否</font></td>
<td><font style="color:rgb(79, 79, 79);">1 至 4 字节编码</font></td>
<td><font style="color:rgb(79, 79, 79);">互联网和UNIX&#x2F;Linux 广泛支持的Unicode字符集；MySQLServer也使用UTF-8</font></td>
</tr>
<tr>
<td><font style="color:rgb(79, 79, 79);">utf8mb4</font></td>
<td><font style="color:rgb(79, 79, 79);background-color:rgb(247, 247, 247);">否</font></td>
<td><font style="color:rgb(79, 79, 79);"> 4 字节编码</font></td>
<td><font style="color:rgb(13, 13, 13);">完全支持所有Unicode字符，包括Emoji。建议在新项目中使用此字符集。</font></td>
</tr>
</tbody></table>
<h3 id="选择字符集时，要考虑的因素："><a href="#选择字符集时，要考虑的因素：" class="headerlink" title="选择字符集时，要考虑的因素："></a><font style="color:rgb(77, 77, 77);">选择字符集时，要考虑的因素：</font></h3><ol>
<li>满足应用支持语言的需求，如果应用要处理各种各样的文字，或者将发布到使用不同语言的国家或地区，就应该选择Unicode字符集。对MySQL来说，目前就是UTF-8。</li>
<li>如果应用中涉及已有数据的导入，就要充分考虑数据库字符集对已有数据的兼容性。</li>
<li>如果数据库只需要支持一般中文，数据量很大，性能要求也很高，那就应该选择双字节定长编码的中文字符集，比如GBK。因为，相对于UTF-8而言，GBK比较“小”，每个汉字只占2个字节，而UTF-8汉字编码需要3个字节，这样可以减少磁盘I&#x2F;O、数据库cache，以及网络传输的时间，从而提高性能。相反，如果应用主要处理英文字符，仅有少量汉字数据，那么选择UTF-8更好，因为GBK、UCS-2、UTF-16的西文字符编码都是2个字节,会造成很大不必要的开销。</li>
<li>如果数据库需要做大量的字符运算，如比较、排序等，选择定长字符集可能更好，因为定长字符集的处理速度要比变长字符集的处理速度快。</li>
</ol>
<p><font style="color:rgb(77, 77, 77);"> MySQL服务器可以支持多种字符集，在同一台服务器、同一个数据库、甚至同一个表的不同字段都可以指定使用不同的字符集。</font></p>
<p><font style="color:rgb(77, 77, 77);">总的来说，建议在能够完全满足应用的前提下，尽量使用小的字符集。因为更小的字符集意味着能够节省空间、减少网络传输字节数，同时由于存储空间的较小间接地提高了系统的性能。</font></p>
<p><font style="color:rgb(77, 77, 77);">  有很多字符集可以保存汉字，比如utf8、gb2312、gbk等等，但是常用的是gb2312和gbk。因为gb2312字库比gbk字库小，有些偏僻字（如：洺）不能保存。因此在选择字符集时一定要权衡这些偏僻字在应用出现的几率以及造成的影响，不能做出肯定答复的最好选用gbk。</font></p>
<p><font style="color:rgb(77, 77, 77);">  在实际项目开发时，使用utf8mb4即可，即：CHARSET&#x3D;utf8mb4。</font></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL运算符</title>
    <url>/2023/06/15/Mysql%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p><strong><font style="color:rgba(0, 0, 0, 0.75);">算术运算符</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716952872238-4ee53880-6fa9-4013-aa2a-78b906778163.png"></p>
<span id="more"></span>
<p><font style="color:rgb(77, 77, 77);">除法运算和模运算中，如果除数为0，将是非法除数，返回结果为NULL。示例：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716952882465-6298b71b-028f-4e2a-8e4f-021cae62f3d7.png"></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">比较运算符</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716952896033-1bc2f9c6-db83-450e-b1f2-200c851aeef0.png"></p>
<p><font style="color:rgb(77, 77, 77);">BETWEEN的用法格式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">a BETWEEN min AND max</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">逻辑运算符</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716952912817-356dd4c6-4675-4fd7-a997-71d0a2ef9013.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL开启binlog</title>
    <url>/2023/06/15/mysql%E5%BC%80%E5%90%AFbinlog/</url>
    <content><![CDATA[<p>binlog是二进制日志文件，用于记录mysql的数据变更，数据在恢复的时候binlog日志起着至关重要的作用。</p>
<p>开启binlog<br>默认情况下mysql是关闭状态off状态，我的已经设置过了是on状态</p>
<span id="more"></span>

<p>进入mysql，使用下面命令，查看是否开启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;log_%&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果没有开启，需要下面的方法进行开启<br>在linux系统下，修改&#x2F;etc&#x2F;my.cnf文件</p>
<p>#编辑模式进入&#x2F;etc&#x2F;my.cnf<br>vi &#x2F;etc&#x2F;my.cnf</p>
<h1 id="i开始进行编辑"><a href="#i开始进行编辑" class="headerlink" title="i开始进行编辑"></a>i开始进行编辑</h1><h1 id="在-log-bin-后面添加内容"><a href="#在-log-bin-后面添加内容" class="headerlink" title="在#log bin 后面添加内容"></a>在#log bin 后面添加内容</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_id=2</span><br><span class="line">log_bin = mysql-bin</span><br><span class="line">binlog_format = ROW</span><br><span class="line">expire_logs_days = 30</span><br></pre></td></tr></table></figure>

<h1 id="esc-退出编辑，shift-保存"><a href="#esc-退出编辑，shift-保存" class="headerlink" title="esc 退出编辑，shift+:保存"></a>esc 退出编辑，shift+:保存</h1><p>重启mysql服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p>到这里已经开启binlog了，可以用查看命令看一下是否开启  </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语法整理</title>
    <url>/2023/06/11/sql%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a><font style="color:rgb(79, 79, 79);">SQL通用语法</font></h2><ul>
<li><font style="color:rgb(77, 77, 77);">SQL语句可以单行或多行书写，以分号结尾。</font></li>
<li><font style="color:rgb(77, 77, 77);">可使用空格和缩进来增强语句的可读性。</font></li>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">MySQL数据库的SQL语言不区分大小写，关键字建议使用大写</font><font style="color:rgb(77, 77, 77);">，对所有列和表名使用小写，这样做使代码更容易阅读和调试。</font></li>
<li><font style="color:rgb(77, 77, 77);">3种注释：</font><span id="more"></span>
<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">单行注释： – 注释内容<br></font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">单行注释：# 注释内容（mysql特有）<br></font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">多行注释：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">&#x2F;<em>注释</em>&#x2F;</font><!-- more --></li>
</ul>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a><font style="color:rgb(79, 79, 79);">SQL分类</font></h2><p>Mysql中SQL语句的分类可以分成：数据定义语言DDL、数据操纵语言DML、数据控制语言DCL、数据查询语言DQL。</p>
<p>  DDL：数据定义语言，这些语句主要用来创建、修改、删除数据库的逻辑结构，其中包括表结构，视图和索引等。常用的关键字有主要包括create、drop、alter等，truncate也是DDL关键字。</p>
<p>  DML：数据操纵语言，这些语句用于添加、删除、更新和查询数据库中的数据，并检查数据完整性。常用的关键字有insert、delete、update、select等。</p>
<p>  DCL：数据控制语言，这些语句主要用来控制数据库的访问权限。常用的关键字有主要包括grant、revoke、commit、rollback等。DCL主要用来控制数据库的权限。</p>
<p>  DQL：数据查询语言，各种简单查询，连接查询等 都属于DQL。</p>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p><font style="color:rgb(77, 77, 77);">DDL：Data Define Language数据定义语言，主要用来对数据库、表进行一些管理操作。如：建库、删库、建表、修改表、删除表、对列的增删改等等。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建数据库</span><br><span class="line">	CREATE DATABASE dbname</span><br><span class="line">	#查看系统中都有哪些数据库</span><br><span class="line">	SHOW DATABASES</span><br><span class="line">	#建库通用的写法</span><br><span class="line">	drop database if exists 旧库名;</span><br><span class="line">	create database 新库名;</span><br><span class="line">	#选择某个数据库</span><br><span class="line">	USE dbname</span><br><span class="line">	#删除数据库</span><br><span class="line">	DROP DATABASE dbname</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--创建表语法</span><br><span class="line">	create table 表名(</span><br><span class="line">    	字段名1 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],</span><br><span class="line">    	字段名2 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],</span><br><span class="line">    	字段名3 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;]</span><br><span class="line">	)[表的一些设置];</span><br><span class="line"></span><br><span class="line">	--建表示例</span><br><span class="line">	create table test2(</span><br><span class="line">  		a int not null comment &#x27;字段a&#x27;,</span><br><span class="line">  		b int not null default 0 comment &#x27;字段b&#x27;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	#删除表</span><br><span class="line">	DROP TABLE tablename</span><br><span class="line">	#删除表更常见的用法</span><br><span class="line">	DROP TABLE IF EXISTS tablename</span><br><span class="line"></span><br><span class="line">    -- 只复制表结构</span><br><span class="line">    create table 表名 like 被复制的表名;</span><br><span class="line">    -- 复制表结构+数据</span><br><span class="line">   create table 表名 [as] select 字段,... from 被复制的表 [where 条件];</span><br><span class="line"></span><br><span class="line">	#更改表名 </span><br><span class="line">	ALTER TABLE tablename RENAME [TO] new_table</span><br><span class="line">	#示例:将表名由emp改成emp1</span><br><span class="line">	ALTER TABLE emp RENAME emp1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改字段类型</span><br><span class="line">ALTER TABLE tablename MODIFY [COLUMN] column_definition</span><br><span class="line">#示例：将emp字段类型改成VARCHAR(20)</span><br><span class="line">ALTER TABLE emp MODIFY name VARCHAR(20)</span><br><span class="line">#增加字段</span><br><span class="line">ALTER TABLE tablename ADD [column] column_definition</span><br><span class="line">#示例：增加类型为int(3)的age字段</span><br><span class="line">ALTER TABLE emp ADD COLUMN age INT(3)</span><br><span class="line">#删除字段</span><br><span class="line">ALTER TABLE tablename DROP [column] col_name</span><br><span class="line">#修改字段名</span><br><span class="line">ALTER TABLE tablename CHANGE [column] old_col_name column_definition</span><br><span class="line">#示例：将age改名为age1，并修改字段类型</span><br><span class="line">ALTER TABLE emp CHANGE age age1 INT(4)</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);"> 注意：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">modify不能修改列名，change可以修改列名</font><font style="color:rgb(77, 77, 77);">。</font><br><font style="color:rgb(77, 77, 77);"> 使用上面命令增加的字段默认都在表的最后位置，而CHANGE&#x2F;MODIFY不会修改字段的位置。如果要修改字段的位置，要用AFTER&#x2F;FIRST等关键字：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#将birth字段添加到ename之后</span><br><span class="line">	ALTER TABLE emp ADD birth DATE AFTER ename</span><br><span class="line">	#将age字段放在最前面</span><br><span class="line">	ALTER TABLE emp MODIFY age INT(3) FIRST</span><br></pre></td></tr></table></figure>

<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p><font style="color:rgb(77, 77, 77);">DML(Data Manipulation Language)数据操作语言，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是必须要掌握的指令，DML和SQL中的select俗称CRUD（增删改查）。</font></p>
<h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a><font style="color:rgb(77, 77, 77);">新增数据</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#可以不指定字段名称，但value后面的顺序应该和字段的排列顺序一致</span><br><span class="line">	INSERT INTO tablename (field1,field2,...,fieldn) VALUES (value1,value2,...valuen)</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">使用INSERT时，可以一次性插入多条数据：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tablename (field1,field2,...,fieldn) </span><br><span class="line">	VALUES </span><br><span class="line">	(record1_value1,record1_value2,...record1_valuen)</span><br><span class="line">	(record2_value1,record2_value2,...record2_valuen)	</span><br><span class="line">	...</span><br><span class="line">	(recordn_value1,recordn_value2,...recordn_valuen)	</span><br></pre></td></tr></table></figure>

<p>这里有个变种的写法 INSERT INTO SELECT FROM </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#可以不指定字段名称，但value后面的顺序应该和字段的排列顺序一致</span><br><span class="line">	INSERT INTO tablename (field1,field2,...,fieldn) SELECT value1,value2,...valuen FROM SOURETABLE</span><br></pre></td></tr></table></figure>

<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a><font style="color:rgba(0, 0, 0, 0.75);">更新数据</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE tablename SET field1=value1,field2=value2,...,fieldn=valuen</span><br><span class="line">	#示例</span><br><span class="line">	UPDATE emp SET sal=4000 WHERE ename=&#x27;lisa&#x27;</span><br></pre></td></tr></table></figure>

<p>变种写法UPDATE JOIN  SET ，主要用于两张表的数据同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table1</span><br><span class="line">JOIN table2 ON table1.common_column = table2.common_column</span><br><span class="line">SET table1.column_to_update = table2.value</span><br><span class="line">WHERE table1.condition_column = condition_value;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><font style="color:rgba(0, 0, 0, 0.75);">删除数据</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM tablename [WHERE CONDITION]</span><br><span class="line">#示例</span><br><span class="line">DELETE FROM emp WHERE ename=&#x27;tony&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">如果使用DELETE关键字时，后面没加条件，就会把整张表的数据删掉</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="delete、truncate与drop"><a href="#delete、truncate与drop" class="headerlink" title="delete、truncate与drop*"></a><font style="color:rgb(79, 79, 79);">delete、truncate与drop*</font></h5><p><font style="color:rgb(77, 77, 77);"> 三者都可以删除表中的数据，三者的差别：</font></p>
<table>
<thead>
<tr>
<th align="center"><strong><font style="color:rgb(79, 79, 79);">   </font></strong></th>
<th align="center"><strong><font style="color:rgb(79, 79, 79);">delete</font></strong></th>
<th align="center"><strong><font style="color:rgb(79, 79, 79);">truncate</font></strong></th>
<th align="center"><strong><font style="color:rgb(79, 79, 79);">drop</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font style="color:rgb(79, 79, 79);">回滚</font></td>
<td align="center"><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">可回滚</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">不可回滚</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">不可回滚</font></td>
</tr>
<tr>
<td align="center"><font style="color:rgb(79, 79, 79);">删除内容</font></td>
<td align="center"><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">表结构还在，删除表的全部或者一部分数据行</font></td>
<td align="center"><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">表结构还在，删除表中的所有数据</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">从数据库中删除表结果和所有的数据行，索引和权限也会被删除</font></td>
</tr>
<tr>
<td align="center"><font style="color:rgb(79, 79, 79);">删除速度</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">删除速度慢，需要逐行删除</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">删除速度快</font></td>
<td align="center"><font style="color:rgb(79, 79, 79);">删除速度最快</font></td>
</tr>
</tbody></table>
<p><strong><font style="color:rgb(77, 77, 77);">想删除部分数据，用delete</font></strong><font style="color:rgb(77, 77, 77);">；</font><br><strong><font style="color:rgb(77, 77, 77);">保留表结构而删除所有数据，用truncate</font></strong><font style="color:rgb(77, 77, 77);">；</font><br><strong><font style="color:rgb(77, 77, 77);">不再需要一张表，用drop</font></strong><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">delete一次删除一行，会将删除操作作为食物记录在日志中保存以便进行回滚操作，</font><font style="color:rgba(0, 0, 0, 0.75);">TRUNCATE TABLE则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">表和索引所占空间。当表被TRUNCATE后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。DROP语句将表所占用的空间全释放掉。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">一般而言，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">执行速度：DROP&gt;TRUNCATE&gt;DELETE</font><font style="color:rgba(0, 0, 0, 0.75);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">应用范围。TRUNCATE只能对TABLE；DELETE可以是TABLE和VIEW</font></li>
<li><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">TRUNCATE和DELETE只删除数据，而DROP则删除整个表（结构和数据）</font><font style="color:rgba(0, 0, 0, 0.75);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">TRUNCATE与不带 WHERE的DELETE：只删除数据，而不删除表的结构（定义）drop 语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程&#x2F;函数将被保留，但其状态会变为：invalid。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">truncate、drop是ddl，操作立即生效。</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE table_name;</span><br><span class="line"></span><br><span class="line">DROP TABLE table_name;</span><br></pre></td></tr></table></figure>

<h4 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a><font style="color:rgb(79, 79, 79);">SELECT语句</font></h4><h5 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a><font style="color:rgb(79, 79, 79);">简单查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询指定列</span><br><span class="line">SELECT 查询的列1,查询的列2 FROM tablename [WHERE CONDITION]</span><br><span class="line">#查询所有列</span><br><span class="line">select * from 表名</span><br></pre></td></tr></table></figure>

<h5 id="列别名"><a href="#列别名" class="headerlink" title="列别名"></a><font style="color:rgb(79, 79, 79);">列别名</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列 [as] 别名 from 表;</span><br><span class="line">-- 使用双引号创建别名</span><br><span class="line">select a &quot;列1&quot;,b &quot;列2&quot; from test1;</span><br><span class="line">-- 使用单引号创建别名</span><br><span class="line">select a &#x27;列1&#x27;,b &#x27;列2&#x27; from test1;</span><br><span class="line">-- 不用引号创建别名</span><br><span class="line">select a 列1,b 列2 from test1;</span><br><span class="line">-- 使用as创建别名</span><br><span class="line">select a as 列1,b as 列2 from test1;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">建议给列起别名时，使用</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">as</font><font style="color:rgb(77, 77, 77);">关键字，sql易读。</font></p>
<h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a><font style="color:rgb(79, 79, 79);">条件查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 列 运算符 值</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);"> WHERE后面跟的条件中，除了可以使用&#x3D;，还可以使用&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、！&#x3D;等比较运算符，多个条件之间可以用OR、AND等逻辑运算符。</font></p>
<h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a><font style="color:rgb(79, 79, 79);">模糊查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ％对应于0个或更多字符,_只是 LIKE 语句中的一个字符</span><br><span class="line">select 列名 from 表名 where 列 like pattern;</span><br></pre></td></tr></table></figure>

<h5 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a><font style="color:rgb(79, 79, 79);">区间查询</font></h5><p><font style="color:rgb(77, 77, 77);">操作符 BETWEEN … AND 会选取介于两个值之间的数据范围，这些值可以是数值、文本或者日期，属于一个闭区间查询。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selec 列名 from 表名 where 列名 between 值1 and 值2;</span><br></pre></td></tr></table></figure>

<h5 id="IN查询"><a href="#IN查询" class="headerlink" title="IN查询"></a><font style="color:rgb(79, 79, 79);">IN查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 字段 in (值1,值2,值3,值4);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">in后面括号中可以包含多个值，对应记录的字段满足in中任意一个都会被返回。</font><br><font style="color:rgb(77, 77, 77);"> in列表的值类型必须一致或兼容。</font><br><font style="color:rgb(77, 77, 77);"> in列表中不支持通配符。</font></p>
<h5 id="EXIST"><a href="#EXIST" class="headerlink" title="EXIST"></a><font style="color:rgba(0, 0, 0, 0.75);">EXIST</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM a WHERE EXISTS(SELECT 1 FROM b WHERE B.id  = A.id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">等价于：</font></p>
<p><font style="color:#000000;background-color:rgb(238, 240, 244);">1、SELECT * FROM A;<br></font><font style="color:#000000;background-color:rgb(238, 240, 244);">2、SELECT I FROM B WHERE B.id &#x3D; A.id;</font></p>
<p>:::info<br><font style="color:rgb(77, 77, 77);">EXISTS()查询会执行SELECT * FROM A查询，执行A.length次，并不会将  EXISTS()查询结果结果进行缓存，因为EXISTS()查询返回一个布尔值true或flase，它只在乎EXISTS()的查询中是否有记录，与具体的结果集无关。</font></p>
<p><font style="color:rgb(77, 77, 77);">  EXISTS()查询是将主查询的结果集放到子查询中做验证，根据验证结果是true或false来决定主查询数据结果是否得以保存。</font></p>
<p><font style="color:rgb(77, 77, 77);">  可以看出，使用EXIST时，子查询中适合放大表（数据量大的表）。</font></p>
<p>:::</p>
<h5 id="NOT-IN查询"><a href="#NOT-IN查询" class="headerlink" title="NOT IN查询"></a><font style="color:rgb(79, 79, 79);">NOT IN查询</font></h5><p><font style="color:rgb(77, 77, 77);">not in和in刚好相反，in是列表中被匹配的都会被返回，NOT IN是和列表中都不匹配的会被返回。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 字段 not in (值1,值2,值3,值4);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">用 not in 的时候，如果 not in 后面的选项中有 null，不会查询出来任何数据。sql 语句本身直接返回 false。所以使用 not in 的时候，要保证 in 中的条件不会出现 null 的情况。</font></p>
<h5 id="NULL值查询"><a href="#NULL值查询" class="headerlink" title="NULL值查询"></a><font style="color:rgb(79, 79, 79);">NULL值查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 列 is null;</span><br><span class="line">select 列名 from 表名 where 列 is not null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a><font style="color:rgb(79, 79, 79);">排序查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tablename </span><br><span class="line">[WHERE CONDITION] </span><br><span class="line">[ORDER BY field1 [DESC|ASC],field2 [DESC|ASC],...,fieldn [DESC|ASC]]</span><br><span class="line">-- 示例</span><br><span class="line">select * from product order by price desc,order_count asc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">DESC表示按字段进行降序排列，ASC表示升序排列，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">默认是升序排列</font><font style="color:rgb(77, 77, 77);">。支持多个字段进行排序，多字段排序之间用逗号隔开，order by后越靠前的字段排序优先级越高。</font></p>
<h5 id="LIMIT语句"><a href="#LIMIT语句" class="headerlink" title="LIMIT语句"></a><font style="color:rgb(79, 79, 79);">LIMIT语句</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列 from 表 limit [offset,] count;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">offset：表示偏移量，通俗点讲就是跳过多少行，offset可以省略，默认为0，表示跳过0行；范围：[0,+∞)。</font><br><font style="color:rgb(77, 77, 77);"> count：跳过offset行之后开始取数据，取count行记录；范围：[0,+∞)。</font><br><font style="color:rgb(77, 77, 77);"> limit中offset和count的值不能用表达式。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取前n行记录</span><br><span class="line">	select 列 from 表 limit 0,n;</span><br><span class="line">	select 列 from 表 limit n;</span><br><span class="line">	#获取排名第n到m的记录</span><br><span class="line">	select 列 from 表 limit n-1,m-n+1;</span><br><span class="line">	#示例：显示从第2条数据开始的3条数据</span><br><span class="line">	SELECT * FROM emp ORDER BY sal LIMIT 1,3</span><br></pre></td></tr></table></figure>



<h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a><font style="color:rgb(79, 79, 79);">分页查询</font></h5><p>LIMIT经常和ORDER BY一起使用，进行数据的分页显示。</p>
<p>  开发过程中，分页我们经常使用，分页一般有2个参数：</p>
<p>  page：表示第几页，从1开始，范围[1,+∞)。</p>
<p>  pageSize：每页显示多少条记录，范围[1,+∞)。</p>
<p>  如：page &#x3D; 2，pageSize &#x3D; 10，表示获取第2页10条数据。使用limit分页的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列 from 表名 limit (page - 1) * pageSize,pageSize;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">注意事项：</font></p>
<ol>
<li><font style="color:rgba(0, 0, 0, 0.75);">limit中不能使用表达式，只能够跟明确的数字。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">limit后面的2个数字不能为负数。</font></li>
</ol>
<h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a><font style="color:rgb(79, 79, 79);">分组查询</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT [filed1,field2,...,fieldn] fun_name</span><br><span class="line">FROM tablename</span><br><span class="line">[WHERE where_condition]</span><br><span class="line">[GROUP BY field1,field2,...,fieldn]</span><br><span class="line">[HAVING where_condition]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fun_name表示聚合函数，常用的有sum、count(*)、avg、max、min等。GROUP BY后面跟的是要进行分类聚合的字段。HAVING表示对分类后的结果在进行条件过滤。</p>
<p>分组中，select后面只能有两种类型的列：</p>
<p>1）出现在group by后的列；</p>
<p>2）或者使用聚合函数的列。</p>
<p>  Group BY用来创建分组，如果分组中有NULL值，将NULL作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p>
<h5 id="UNION语句"><a href="#UNION语句" class="headerlink" title="UNION语句"></a><font style="color:rgb(79, 79, 79);">UNION语句</font></h5><p><font style="color:rgb(77, 77, 77);">将多个查询的数据合并用到的关键字是UNION&#x2F;UNION ALL：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1</span><br><span class="line">UNION|UNION ALL</span><br><span class="line">SELECT * FROM t2</span><br><span class="line">...</span><br><span class="line">UNION|UNION ALL</span><br><span class="line">SELECT * FROM tn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">UNION和UNION ALL的区别：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.5);">UNION ALL：把结果集直接合并在一起；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.5);">UNION：将UNION ALL的结果进行去重。</font></li>
</ul>
<p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">因为UNION有个去重的过程，所以UNION ALL的效率较高</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="COUNT语句"><a href="#COUNT语句" class="headerlink" title="COUNT语句*"></a><font style="color:rgb(79, 79, 79);">COUNT语句*</font></h5><p><font style="color:rgb(77, 77, 77);">COUNT(*)函数返回表中所有行的数量，包括NULL值行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) FROM students;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">COUNT(column_name)函数返回指定列非NULL值的数量，忽略NULL值行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(age) FROM students;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">COUNT(DISTINCT column_name)返回指定列中不同值的数量，忽略NULL值行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT age) FROM students;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">COUNT(DISTINCT expr,[expr…])函数返回指定表达式中不同非NULL值的数量，忽略NULL值行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT age, gender) FROM students;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">COUNT(IF(condition, column_name, NULL))函数返回满足指定条件的指定列的非NULL值数量。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 这个 SQL 语句的含义是统计学生表中性别为 ‘Female’ 的人数。通过 IF 函数，将所有性别</span><br><span class="line">-- 为 ‘Female’ 的行转换成 1，然后 COUNT 函数就会返回这些 1 的数量，即性别为 ‘Female’ </span><br><span class="line">-- 的学生数量</span><br><span class="line">SELECT COUNT(IF(gender=&#x27;Female&#x27;, 1, NULL)) FROM students;</span><br></pre></td></tr></table></figure>

<p>ount(*)、count(1)、count(列名)的选择</p>
<p>  COUNT(*) 是最常用的方式，它可以统计所有行的数量，包括 NULL 值。</p>
<p>  COUNT(1) 也可以统计所有行的数量，包括 NULL 值。</p>
<p>  COUNT(column_name) 只会统计指定列中非 NULL 值的数量，而忽略 NULL 值。因此，如果需要统计指定列的非 NULL 值数量，那么可以使用 COUNT(column_name)。这种方式的性能相对较低，因为需要扫描整个表，对于每一行都要进行判断。</p>
<h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a><font style="color:rgb(79, 79, 79);">关联查询</font></h4><p><font style="color:rgb(77, 77, 77);">Mysql中常用的关联查询有左外连接、右外连接、全连接、自连接等。</font></p>
<h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a><font style="color:rgb(79, 79, 79);">笛卡尔积</font></h5><p><font style="color:rgb(77, 77, 77);"> 笛卡尔积简单点理解：有两个集合A和B，笛卡尔积表示A集合中的元素和B集合中的元素任意相互关联产生的所有可能的结果。假如A中有m个元素，B中有n个元素，A、B笛卡尔积产生的结果有m*n个结果，相当于循环遍历两个集合中的元素，任意组合。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">过程：拿A集合中的第1行，去匹配集合B中所有的行，然后再拿集合A中的第2行，去匹配集合B中所有的行，最后结果数量为m*n。</font></p>
<h5 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接 (INNER JOIN)"></a><font style="color:rgb(13, 13, 13);">内连接 (INNER JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">内连接返回两个表中满足连接条件的行。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">INNER JOIN departments ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="左连接-LEFT-JOIN"><a href="#左连接-LEFT-JOIN" class="headerlink" title="左连接 (LEFT JOIN)"></a><font style="color:rgb(13, 13, 13);">左连接 (LEFT JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">左连接返回左表中的所有行以及右表中满足连接条件的行。如果右表中没有匹配的行，结果中包含的右表列将包含NULL。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">LEFT JOIN departments ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="右连接-RIGHT-JOIN"><a href="#右连接-RIGHT-JOIN" class="headerlink" title="右连接 (RIGHT JOIN)"></a><font style="color:rgb(13, 13, 13);">右连接 (RIGHT JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">右连接返回右表中的所有行以及左表中满足连接条件的行。如果左表中没有匹配的行，结果中包含的左表列将包含NULL。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">RIGHT JOIN departments ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="全连接-FULL-JOIN"><a href="#全连接-FULL-JOIN" class="headerlink" title="全连接 (FULL JOIN)"></a><font style="color:rgb(13, 13, 13);">全连接 (FULL JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">MySQL不直接支持FULL JOIN，但可以通过使用UNION来模拟。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">LEFT JOIN departments ON employees.department_id = departments.department_id</span><br><span class="line">UNION</span><br><span class="line">SELECT employees.employee_id, employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">RIGHT JOIN departments ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="交叉连接-CROSS-JOIN"><a href="#交叉连接-CROSS-JOIN" class="headerlink" title="交叉连接 (CROSS JOIN)"></a><font style="color:rgb(13, 13, 13);">交叉连接 (CROSS JOIN)</font></h5><p><font style="color:rgb(13, 13, 13);">交叉连接返回两个表的笛卡尔积，即表1中的每一行与表2中的每一行组合。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">CROSS JOIN departments;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="自连接（Self-Join）"><a href="#自连接（Self-Join）" class="headerlink" title="自连接（Self-Join）"></a>自连接（<font style="color:rgb(13, 13, 13);">Self-Join</font>）</h5><p><font style="color:rgb(13, 13, 13);">自连接（Self-Join）是在同一个表中进行的联接查询，用于将表中的一行与另一行相关联。自连接常用于需要比较表中不同行的数据的情况，例如查找员工和他们的经理、产品的父子关系等。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e1.employee_name AS employee, e2.employee_name AS manager</span><br><span class="line">FROM employees e1</span><br><span class="line">LEFT JOIN employees e2 ON e1.manager_id = e2.employee_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(13, 13, 13);">在自连接查询中，使用表别名（如 e1 和 e2）是必需的，以区分表的不同实例。</font></p>
<p><font style="color:rgb(13, 13, 13);">自连接可能对大表进行性能影响，因此在实际应用中需要注意索引和查询优化。</font></p>
<p><font style="color:rgb(13, 13, 13);">根据需求，可以使用不同的连接类型（INNER JOIN、LEFT JOIN等）来决定是否包括没有匹配关系的行。</font></p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a><font style="background-color:rgb(249, 242, 244);">DCL</font></h3><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DCL：数据控制语言，这些语句主要用来控制数据库的访问权限</font><font style="color:rgb(77, 77, 77);">。常用的关键字有主要包括grant、revoke、commit、rollback等。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">DCL主要用来控制数据库的权限</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p><font style="color:rgb(77, 77, 77);">数据查询语言，各种简单查询，连接查询等 都属于DQL。</font></p>
<h2 id="查询语句的书写和执行顺序"><a href="#查询语句的书写和执行顺序" class="headerlink" title="查询语句的书写和执行顺序"></a><font style="color:rgb(79, 79, 79);">查询语句的书写和执行顺序</font></h2><p><font style="color:rgb(77, 77, 77);">Mysql的一般书写顺写为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select  &lt;要返回的数据列&gt;</span><br><span class="line">from   &lt;表名&gt;</span><br><span class="line">&lt;join, left join, right join...&gt; join    &lt;join表&gt;</span><br><span class="line">on   &lt;join条件&gt;</span><br><span class="line">where   &lt;where条件&gt;</span><br><span class="line">group by  &lt;分组条件&gt;</span><br><span class="line">having  &lt;分组后的筛选条件&gt;</span><br><span class="line">order by  &lt;排序条件&gt;</span><br><span class="line">limit  &lt;行数限制&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常见执行顺序"><a href="#常见执行顺序" class="headerlink" title="常见执行顺序*"></a><font style="color:rgb(79, 79, 79);">常见执行顺序*</font></h5><ol>
<li><font style="color:rgb(77, 77, 77);">一个查询语句同时出现了where、group by、having、order by的时候，执行顺序和编写顺序是：</font></li>
<li><font style="color:rgb(77, 77, 77);">执行where xx对全表数据做筛选，返回第1个结果集。</font></li>
<li><font style="color:rgb(77, 77, 77);">针对第1个结果集使用group by分组，返回第2个结果集。</font></li>
<li><font style="color:rgb(77, 77, 77);">针对第2个结果集中的每1组数据执行select xx，有几组就执行几次，返回第3个结果集。</font></li>
<li><font style="color:rgb(77, 77, 77);">针对第3个结集执行having xx进行筛选，返回第4个结果集。</font></li>
<li><font style="color:rgb(77, 77, 77);">针对第4个结果集排序。</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);">按照执行顺序的关键词首字母分别是W（where）-&gt;G（Group）-&gt;S（Select）-&gt;H（Having）-&gt;O（Order），对应汉语首字母可以编成容易记忆的顺口溜：我(W)哥(G)是(SH)偶(O)像。</font></p>
<h5 id="完整执行顺序"><a href="#完整执行顺序" class="headerlink" title="完整执行顺序"></a><font style="color:rgb(79, 79, 79);">完整执行顺序</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from </span><br><span class="line">    &lt;表名&gt;          # 笛卡尔积</span><br><span class="line">on </span><br><span class="line">    &lt;筛选条件&gt;          #对笛卡尔积的虚表进行筛选</span><br><span class="line">&lt;join, left join, right join...&gt; join </span><br><span class="line">    &lt;join表&gt;  #指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中</span><br><span class="line">where </span><br><span class="line">    &lt;where条件&gt;     #对上述虚表进行筛选</span><br><span class="line">group by</span><br><span class="line">    &lt;分组条件&gt;      #分组</span><br><span class="line">&lt;sum()等聚合函数&gt;   #用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的</span><br><span class="line">having </span><br><span class="line">    &lt;分组筛选&gt;      #对分组后的结果进行聚合筛选</span><br><span class="line">select </span><br><span class="line">    &lt;返回数据列表&gt;       #返回的单列必须在group by子句中，聚合函数除外</span><br><span class="line">distinct</span><br><span class="line">order by </span><br><span class="line">    &lt;排序条件&gt;      #排序</span><br><span class="line">limit </span><br><span class="line">    &lt;行数限制&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">执行流程：</font></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">from：select * from table_1, table_2; 与 select * from table_1 join table_2; 的结果一致，都是表示求笛卡尔积；</font></li>
<li><font style="color:rgb(77, 77, 77);">  用于直接计算两个表笛卡尔积，得到虚拟表VT1，这是所有select语句最先执行的操作，其他操作时在这个表上进行的，也就是from操作所完成的内容。</font></li>
<li><font style="color:rgb(77, 77, 77);">on：从VT1表中筛选符合条件的数据，形成VT2表；</font></li>
<li><font style="color:rgb(77, 77, 77);">join：将该join类型的数据补充到VT2表中，例如left join会将左表的剩余数据添加到虚表VT2中，形成VT3表；若表的数量大于2，则会重复1-3步；</font></li>
<li><font style="color:rgb(77, 77, 77);">where：执行筛选，（不能使用聚合函数）得到VT4表；</font></li>
<li><font style="color:rgb(77, 77, 77);">group by：对VT4表进行分组，得到VT5表；其后处理的语句，如select，having，所用到的列必须包含在group by条件中，没有出现的需要用聚合函数；</font></li>
<li><font style="color:rgb(77, 77, 77);">having：筛选分组后的数据，得到VT6表；</font></li>
<li><font style="color:rgb(77, 77, 77);">select：返回列得到VT7表；</font></li>
<li><font style="color:rgb(77, 77, 77);">distinct：用于去重得到VT8表；</font></li>
<li><font style="color:rgb(77, 77, 77);">order by：用于排序得到VT9表；</font></li>
<li><font style="color:rgb(77, 77, 77);">limit：返回需要的行数，得到VT10。</font></li>
</ul>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式*"></a><font style="color:rgb(79, 79, 79);">三大范式*</font></h2><p><font style="color:rgb(77, 77, 77);">数据库的三大范式的设计目的是</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">减少数据冗余</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a><font style="color:rgb(79, 79, 79);">第一范式</font></h5><p>第一范式是最基本的范式。如果数据库表中的所有字段值都不可再分解（列不可再分），就说明该数据库表满足了第一范式，确保数据库表字段的原子性。</p>
<p>  第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</p>
<h5 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a><font style="color:rgb(79, 79, 79);">第二范式</font></h5><p><font style="color:rgb(77, 77, 77);">第二范式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">表必须有一个主键，非主键列必须完全依赖于主键，而不能只依赖于主键的一部分</font><font style="color:rgb(77, 77, 77);">。</font></p>
<h5 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a><font style="color:rgb(79, 79, 79);">第三范式</font></h5><p><font style="color:rgb(77, 77, 77);">满足第三范式（3NF）必须先满足第二范式（2NF）。</font><br><font style="color:rgb(77, 77, 77);"> 第三范式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">非主键列必须直接依赖于主键，不能存在传递依赖</font><font style="color:rgb(77, 77, 77);">。即不能存在：非主键列A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</font></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">2NF和3NF的区别</font></strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font><font style="color:rgba(0, 0, 0, 0.75);">2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。<br></font><font style="color:rgba(0, 0, 0, 0.75);">3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。</font></li>
</ul>
<h5 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a><font style="color:rgb(79, 79, 79);">简单总结</font></h5><ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">1、第一范式：</font><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">列不可分</font><font style="color:rgba(0, 0, 0, 0.75);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">2、第二范式：</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">列必须直接依赖主键</font><font style="color:rgba(0, 0, 0, 0.75);">。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">3、第三范式： </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">表里面的列不能出现其它表的非主键字段</font></li>
</ul>
<h5 id="范式化和反范式化设计的优缺点"><a href="#范式化和反范式化设计的优缺点" class="headerlink" title="范式化和反范式化设计的优缺点"></a><font style="color:rgb(79, 79, 79);">范式化和反范式化设计的优缺点</font></h5><ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">范式化</font></strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font><font style="color:rgba(0, 0, 0, 0.75);">优点：可以尽量得减少数据冗余，使得更新快，体积小。<br></font><font style="color:rgba(0, 0, 0, 0.75);">缺点：对于查询需要多个表进行关联，减少写得效率增加读得效率。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">反范式化</font></strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font><font style="color:rgba(0, 0, 0, 0.75);">优点：可以减少表得关联，可以更好得进行索引优化。<br></font><font style="color:rgba(0, 0, 0, 0.75);">缺点：数据冗余，数据的修改需要更多的成本。</font></li>
</ul>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a><font style="color:rgb(79, 79, 79);">约束</font></h2><p><font style="color:rgb(77, 77, 77);">创建表的时候，同时可以指定所插入数据的一些规则，比如说某个字段不能为空值，某个字段的值（比如年龄）不能小于零等等，这些规则称为约束。</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">约束是在表上强制执行的数据校验规则</font><font style="color:rgb(77, 77, 77);">。</font><br><font style="color:rgb(77, 77, 77);"> 数据库中的五大约束：</font></p>
<ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">主键约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);">： 唯一，非空【常用】；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">唯一约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：唯一，可以为空，但只能有一个【常用】；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">非空约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：非空【常用】；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">默认约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：该列数据的默认值；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">外键约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 两表间的关系；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">检查约束</font></strong><font style="color:rgba(0, 0, 0, 0.75);"> ： 检查字段值是否符合要求。</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);"> 约束示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--添加主键约束</span><br><span class="line">Alter table 表名 add Constraint 主键名 primary key(字段)</span><br><span class="line">--添加唯一约束</span><br><span class="line">Alter table 表名 add Constraint 约束名 unique(字段)</span><br><span class="line">--添加默认约束</span><br><span class="line">Alter table 表名 add Constraint 约束名 default(默认内容) for 字段名</span><br><span class="line">--添加检查约束</span><br><span class="line">Alter table 表名 add Constraint 约束名 check (字段表达)</span><br><span class="line">--添加外键约束</span><br><span class="line">Alter table 表名 add Constraint 约束名 foreign key(字段) references 表名(字段名)</span><br><span class="line">--约束常常在建表时添加，如对某个极端添加非空约束</span><br><span class="line">`account_name` varchar(64) NOT NULL COMMENT &#x27;账户名称&#x27;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SQL相关问题"><a href="#SQL相关问题" class="headerlink" title="SQL相关问题"></a><font style="color:rgb(79, 79, 79);">SQL相关问题</font></h2><h5 id="HAVNG和WHERE的区别"><a href="#HAVNG和WHERE的区别" class="headerlink" title="HAVNG和WHERE的区别*"></a><font style="color:rgb(79, 79, 79);">HAVNG和WHERE的区别*</font></h5><ul>
<li><p>语法</p>
<pre><code>   where用表中列名，having用select结果别名；
</code></pre>
</li>
<li><p>是否能使用索引</p>
<pre><code>    where可以使用索引，having不能使用索引，只能在临时结果集操作；
</code></pre>
</li>
<li><p>是否能使用聚集函数</p>
</li>
</ul>
<p>where 后面不能使用聚集函数，having是专门使用聚集函数的。</p>
<ul>
<li>一个聚集函数从多个输入行中计算出一个结果，比如count（数目）， sum（和），avg（ 均值 ）， max（最大值）和min（最小值）。</li>
<li>HAVING是对聚合(数据分组)后的结果进行条件的过滤，而WHERE是在聚合(数据分组)前就对记录进行过滤。如果逻辑允许，尽可能用WHERE先过滤条件，因为这样结果集减小，聚合的效率将大大提高，最后再根据逻辑看是否用HAVING进行过滤。</li>
</ul>
<h5 id="SELECT-和-SELECT-全部字段-的区别1、是否解析数据字典"><a href="#SELECT-和-SELECT-全部字段-的区别1、是否解析数据字典" class="headerlink" title="[SELECT *] 和 [SELECT 全部字段]的区别1、是否解析数据字典"></a><font style="color:rgb(79, 79, 79);">[SELECT *] 和 [SELECT 全部字段]的区别</font><font style="color:rgb(79, 79, 79);">1、是否解析数据字典</font></h5><p><font style="color:rgb(79, 79, 79);">1、前者要解析数据字典（数据字典是指对数据的数据项、数据结构、数据流、数据存储、处理逻辑、外部实体等进行定义和描述，其目的是对数据流程图中的各个元素做出详细的说明），后者不需要数据字典。</font></p>
<p><font style="color:rgb(79, 79, 79);">2、是否可指定输出顺序</font></p>
<p><font style="color:rgb(79, 79, 79);">  前者与建表列顺序相同（建表后不增删字段的话），后者可以指定字段顺序。</font></p>
<p><font style="color:rgb(79, 79, 79);">3、表字段改名，前者不需要修改，后者需要改。</font></p>
<p><font style="color:rgb(79, 79, 79);">4、是否可优化</font></p>
<p><font style="color:rgb(79, 79, 79);">  后者可以建立索引进行优化，前者无法优化。</font></p>
<p><font style="color:rgb(79, 79, 79);">5、可读性</font></p>
<p><font style="color:rgb(79, 79, 79);">  后者的可读性比前者要高。</font></p>
<h5 id="Mysql分组中的坑"><a href="#Mysql分组中的坑" class="headerlink" title="Mysql分组中的坑"></a><font style="color:rgb(79, 79, 79);">Mysql分组中的坑</font></h5><p> 分组中select后面的列只能有2种：1）出现在group by后面的列；2）使用聚合函数的列。</p>
<p>  这是在Mysql后期版本加上的功能，在早期版本中没这个要求。建议：在写分组查询的时候，最好按照标准的规范来写，即：select后面出现的列必须在group by中或者必须使用聚合函数。</p>
<h2 id="数据库开发规范"><a href="#数据库开发规范" class="headerlink" title="数据库开发规范"></a><font style="color:rgb(79, 79, 79);">数据库开发规范</font></h2><h5 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a><font style="color:rgb(79, 79, 79);">基础规范</font></h5><p> 1）必须使用InnoDB存储引擎解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高。</p>
<p>  2）必须使用UTF8字符集解读：万国码，无需转码，无乱码风险，节省空间。</p>
<p>  3）数据表、数据字段必须加入中文注释。</p>
<p>  4）禁止使用存储过程、视图、触发器、Event解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。</p>
<p>  5）禁止存储大文件或者大照片解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URL。</p>
<h5 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a><font style="color:rgb(79, 79, 79);">命名规范</font></h5><p> 1）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用.</p>
<p>  2）表名t_xxx，非唯一索引名uniq_xxx，唯一索引名idx_xxx.</p>
<p>  3）单实例表数目必须小于500。</p>
<p>  4）单表列数目必须小于30。</p>
<p>  5）表必须有主键，例如自增主键：</p>
<p><font style="color:rgb(77, 77, 77);">      6）禁止使用外键，如果有外键完整性约束，需要应用程序控制解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率。</font></p>
<p>:::</p>
<h5 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a><font style="color:rgb(79, 79, 79);">字段设计规范</font></h5><p><font style="color:rgb(77, 77, 77);">1）必须把字段定义为NOT NULL并且提供默认值：</font></p>
<p>:::tips<br> a）null的列使索引&#x2F;索引统计&#x2F;值比较都更加复杂，对MySQL来说更难优化。</p>
<p>  b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多。</p>
<p>  c）null值需要更多的存储空间，无论是表还是索引中每行中的null的列都需要额外的空间来标识。</p>
<p>  d）对null 的处理时候，只能采用is null或is not null，而不能采用&#x3D;、in、&lt;、&lt;&gt;、!&#x3D;、not in这些操作符号。</p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">2）禁止使用TEXT、BLOB类型解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能。</font><br><font style="color:rgb(77, 77, 77);"> 3）禁止使用小数存储货币解读，小数容易导致钱对不上。</font><br><font style="color:rgb(77, 77, 77);"> 4）必须使用varchar(20)存储手机号：</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">a）涉及到区号或者国家代号，可能出现±。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）varchar可以支持模糊查询，例如：like“138%”。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">5）禁止使用ENUM，可使用TINYINT代替：</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> a）增加新的ENUM值要做DDL操作。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）ENUM的内部实际存储就是整数。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">6）单表索引建议控制在5个以内。</font><br><font style="color:rgb(77, 77, 77);"> 7）单索引字段数不允许超过5个。字段超过5个时，实际已经起不到有效过滤数据的作用了。</font><br><font style="color:rgb(77, 77, 77);"> 8）禁止在更新十分频繁、区分度不高的属性上建立索引：</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);">9）建立组合索引，必须把区分度高的字段放在前面解读：能够更加有效的过滤数据。</font><br><font style="color:rgb(77, 77, 77);"> 10）禁止使用SELECT *，只获取必要的字段，需要显示说明列属性：</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">a）读取不需要的列会增加CPU、IO、NET消耗。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）不能有效的利用覆盖索引。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> c）使用SELECT *容易在增加或者删除字段后出现程序BUG。</font></p>
<p>:::</p>
<p>11）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性解读：容易在增加或者删除字段后出现程序BUG。</p>
<p>  12）禁止使用属性隐式转换解读：SELECT uid FROM t_user WHERE phone&#x3D;13800000000 会导致全表扫描，而不能命中phone索引。</p>
<p>  13）禁止在WHERE条件的属性上使用函数或者表达式：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;&#x3D;’2017-01-15’会导致全表扫描，正确的写法是：SELECT uid FROM t_user WHERE day&gt;&#x3D;unix_timestamp(‘2017-01-15 00:00:00’)。</p>
<p>  14）禁止负向查询，以及%开头的模糊查询：</p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">a）负向查询条件：NOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描。</font><br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> b）%开头的模糊查询，会导致全表扫描。</font></p>
<p>:::</p>
<p>15）禁止使用OR条件，必须改为IN查询解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p>
<p>  16）应用程序必须捕获SQL异常，并有相应处理.</p>
<p>  17）同表的增删字段、索引合并一条DDL语句执行，提高执行效率，减少与数据库的交互。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title>too many connections 解决方法</title>
    <url>/2023/06/15/too%20many%20connections%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>mysql -u root -p<font style="color:rgb(77, 77, 77);"> 回车输入密码进入mysql</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<h1 id="too-many-connections-解决方法"><a href="#too-many-connections-解决方法" class="headerlink" title="too many connections 解决方法"></a><font style="color:rgb(38, 38, 38);">too many connections 解决方法</font></h1><p><font style="background-color:rgb(247, 247, 247);">mysql -u root -p</font><font style="color:rgb(77, 77, 77);"> 回车输入密码进入mysql</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25873401/1646018837018-04475fb7-2931-430a-80fc-e6c91d289b2c.png"></p>
<span id="more"></span>
<p><font style="color:rgb(38, 38, 38);">show processlist;</font></p>
<p><font style="color:rgb(38, 38, 38);">查看连接数，可以发现有很多连接处于sleep状态，这些其实是暂时没有用的，所以可以kill掉</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">show variables like “max_connections”;</font></p>
<p><font style="color:rgb(38, 38, 38);">查看最大连接数，应该是与上面查询到的连接数相同，才会出现too many connections的情况</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">set GLOBAL max_connections&#x3D;1000;</font></p>
<p><font style="color:rgb(38, 38, 38);">修改最大连接数，但是这不是一劳永逸的方法，应该要让它自动杀死那些sleep的进程。</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">show global variables like ‘wait_timeout’;</font></p>
<p><font style="color:rgb(38, 38, 38);">这个数值指的是mysql在关闭一个非交互的连接之前要等待的秒数，默认是28800s</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">set global wait_timeout&#x3D;300;</font></p>
<p><font style="color:rgb(38, 38, 38);">修改这个数值，这里可以随意，最好控制在几分钟内</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1646018837062-a511ca3d-05f7-4cb2-addb-9cb0e82d0562.png"></p>
<p><font style="color:rgb(38, 38, 38);">set global interactive_timeout&#x3D;500;</font></p>
<p><font style="color:rgb(38, 38, 38);">修改这个数值，表示mysql在关闭一个连接之前要等待的秒数，至此可以让mysql自动关闭那些没用的连接，但要注意的是，正在使用的连接到了时间也会被关闭，因此这个时间值要合适</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">批量kill之前没用的sleep连接，在网上搜索的方法对我都不奏效，因此只好使用最笨的办法，一个一个kill</font></p>
<font style="color:rgb(38, 38, 38);">  
</font>

<p><font style="color:rgb(38, 38, 38);">select concat(‘KILL ‘,id,’;’) from information_schema.processlist where user&#x3D;’root’; 先把要kill的连接id都查询出来</font></p>
<p><font style="color:rgb(38, 38, 38);">复制中间的kill id;内容到word文档</font></p>
<p><font style="color:rgb(38, 38, 38);">替换掉符号“|”和回车符（在word中查询^p即可查询到回车符）</font></p>
<p><font style="color:rgb(38, 38, 38);">把修改过的内容复制回终端，最后按回车执行！</font></p>
<p><font style="color:rgb(38, 38, 38);">原文链接：<a href="https://blog.csdn.net/qq_31454017/article/details/71108278">https://blog.csdn.net/qq_31454017/article/details/71108278</a></font></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>事务处理</title>
    <url>/2023/06/13/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="		事务的四大特性"></a><font style="color:rgb(79, 79, 79);">		事务的四大特性</font></h4><ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">原子性(Atomicity) </font></strong><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">事务是最小的执行单位，不允许分割</font><font style="color:rgba(0, 0, 0, 0.75);">。事务的原子性确保动作要么全部完成，要么完全不起作用；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">一致性(Consistency) </font></strong><font style="color:rgba(0, 0, 0, 0.75);">一致性是指</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">事务必须使数据库从一个一致性状态变换到另一个一致性状态</font><font style="color:rgba(0, 0, 0, 0.75);">，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</font><span id="more"></span>
:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</font></li>
</ol>
<p>:::</p>
<ol start="3">
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">隔离性(Isolation) </font></strong><font style="color:rgba(0, 0, 0, 0.75);">并发访问数据库时，即一个事务内部的操作及使用的数据对并发的其他事务是隔离</font><strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font></strong><font style="color:rgba(0, 0, 0, 0.75);">的，并发执行的各个事务之间不能互相干扰。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">持久性(Durability) </font></strong><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">一个事务被提交之后。它对数据库中数据的改变是持久的</font><font style="color:rgba(0, 0, 0, 0.75);">，即使数据库发生故障也不应该对其有任何影响</font></li>
</ol>
<h4 id="事务产生的问题"><a href="#事务产生的问题" class="headerlink" title="事务产生的问题"></a><font style="color:rgb(79, 79, 79);">事务产生的问题</font></h4><h5 id="脏读-Drity-Read"><a href="#脏读-Drity-Read" class="headerlink" title="脏读(Drity Read)"></a>脏读<font style="color:rgb(79, 79, 79);">(Drity Read)</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">已知有两个事务A和B, A读取了已经被B更新但还没有被提交的数据。之后，B回滚事务，A读取的数据就是脏数据</font><font style="color:rgb(77, 77, 77);">。即：一个事务在执行的过程中读取到了其他事务还没有提交的数据。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">此处的”脏”主要指由于回滚，导致了数据的无效性，也就是读到了脏数据。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);"> 脏读，可以简单理解为读到了无效数据。</font></p>
<h5 id="不可重复读-Non-repeatable-read"><a href="#不可重复读-Non-repeatable-read" class="headerlink" title="不可重复读(Non-repeatable read)"></a>不可重复读<font style="color:rgb(79, 79, 79);">(Non-repeatable read)</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">已知有两个事务A和B，A多次读取同一数据，B在A多次读取的过程中对数据作了修改并提交，导致A多次读取同一数据时，结果不一致</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">此处的”重复”指的是由于修改，某个事务重复读取的某个值发生了变化。</font></p>
<p><font style="color:rgb(77, 77, 77);">不可重复读，可简单理解为多次重复读取，读取到了不一样的数据。</font></p>
<h5 id="幻读-Phantom-Read"><a href="#幻读-Phantom-Read" class="headerlink" title="幻读(Phantom Read)"></a>幻读<font style="color:rgb(79, 79, 79);">(Phantom Read)</font></h5><p> 幻读在可重复读的模式下才会出现，其他隔离级别中不会出现。</p>
<p>  有两个事务A和B，A从一个表中读取了数据，然后B在该表中插入了一些新数据，导致A再次读取同一个表, 就会多出几行。简单地说，一个事务中先后读取一个范围的记录，但每次读取的纪录数不同，多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<h5 id="不可重复读和幻读区别"><a href="#不可重复读和幻读区别" class="headerlink" title="不可重复读和幻读区别"></a><font style="color:rgba(0, 0, 0, 0.75);">不可重复读和幻读区别</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);"> 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</font></p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a><font style="color:rgb(79, 79, 79);">事务的隔离级别</font></h4><p><font style="color:rgb(77, 77, 77);">了解决多个事务之间数据可见性及数据正确性的问题，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted(读未提交)、Read committed(读已提交)、Repeatable read(可重复读)、Serializable(串行)。</font></p>
<p><font style="color:rgb(77, 77, 77);">事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。<br></font><font style="color:rgb(77, 77, 77);"> InnoDB存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</font></p>
<h5 id="查看隔离级别命令"><a href="#查看隔离级别命令" class="headerlink" title="查看隔离级别命令"></a><font style="color:rgb(77, 77, 77);">查看隔离级别命令</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看隔离级别命令</span><br><span class="line">   show variables like &#x27;transaction_isolation&#x27;;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">要修改隔离级别的话，可以进行全局修改，也就是修改配置文件（my.ini），示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transaction-isolation=READ-UNCOMMITTED</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);"> 也可以通过命令修改当前session的隔离级别：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set session transaction isolation level 事务级别;</span><br></pre></td></tr></table></figure>

<h5 id="各种隔离级别中会出现的问题"><a href="#各种隔离级别中会出现的问题" class="headerlink" title="各种隔离级别中会出现的问题"></a><font style="color:rgb(79, 79, 79);">各种隔离级别中会出现的问题</font></h5><ul>
<li>读未提交  存在脏读，不可重复读，幻读的问题 </li>
<li>读已提交  处理了脏读的问题但是存在不可重复读和幻读的问题</li>
<li>可重复读  处理了不可重复读的问题，幻读依然存在 ，但是mysql中的这一级别因为mvcc的存在已经将幻读的问题也处理了</li>
<li>串型化   都一个一个处理了肯定不存在脏读 重复读 幻读的问题</li>
</ul>
<h5 id="READ-UNCOMMITTED-读未提交"><a href="#READ-UNCOMMITTED-读未提交" class="headerlink" title="READ-UNCOMMITTED(读未提交)"></a><font style="color:rgb(79, 79, 79);">READ-UNCOMMITTED(读未提交)</font></h5><p><font style="color:rgb(77, 77, 77);">最低的隔离级别，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">允许一个事务可以读取另外一个事务未提交的事务</font><font style="color:rgb(77, 77, 77);">。多次读取结果不一样，会出现了脏读、不可重复读问题。</font><br><font style="color:rgb(77, 77, 77);"> 这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用。</font></p>
<h5 id="READ-COMMITTED-读已提交"><a href="#READ-COMMITTED-读已提交" class="headerlink" title="READ-COMMITTED(读已提交)*"></a><font style="color:rgb(79, 79, 79);">READ-COMMITTED(读已提交)*</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">允许一个事务读取另一个并发事务已经提交的数据</font><font style="color:rgb(77, 77, 77);">。读已提交情况下，无法读取到其他事务还未提交的数据，可以读取到其他事务已经提交的数据，多次读取结果不一样，未出现脏读，出现了读已提交、不可重复读。</font></p>
<h5 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE-READ(可重复读)*"></a><font style="color:rgb(79, 79, 79);">REPEATABLE-READ(可重复读)*</font></h5><p>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。即使数据被其他事务修改， 当前事务也不会读取到新的数据。重复读事务中的查询看到的是事务开始时的快照， 而不是该事务当前查询开始时的快照。</p>
<p>  可重复读情况下，未出现脏读，未读取到其他事务已提交的数据，多次读取结果一致，即可重复读。</p>
<h5 id="SERIALIZABLE-串行"><a href="#SERIALIZABLE-串行" class="headerlink" title="SERIALIZABLE(串行)*"></a><font style="color:rgb(79, 79, 79);">SERIALIZABLE(串行)*</font></h5><p><font style="color:rgb(77, 77, 77);">最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰（多个事务之间读写、写读、写写会产生互斥，效果就是串行执行，多个事务之间的读读不会产生互斥）。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">该级别可以防止脏读、不可重复读以及幻读。</font></p>
<p>:::</p>
<h4 id="Mysql中的事务操作"><a href="#Mysql中的事务操作" class="headerlink" title="Mysql中的事务操作"></a><font style="color:rgb(79, 79, 79);">Mysql中的事务操作</font></h4><p> Mysql中事务默认是隐式事务，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。</p>
<p>:::tips<br>  事务分为隐式事务和显式事务。是否开启隐式事务是由变量 autocommit 控制的。可以通过set session autoCommit &#x3D; on&#x2F;off来设置mysql事务是否自动开启。如果我们设置autoCommit为off的时候，需要手动开启mysql事务。</p>
<p>:::</p>
<h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a><font style="color:rgb(79, 79, 79);">隐式事务</font></h5><h5 id="事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。"><a href="#事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。" class="headerlink" title="事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。"></a><font style="color:rgb(77, 77, 77);">事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。</font></h5><p><font style="color:rgb(77, 77, 77);"> 实际项目开发时，用隐式事务即可。</font></p>
<h5 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a><font style="color:rgb(79, 79, 79);">显式事务</font></h5><p><font style="color:rgb(77, 77, 77);">需要手动开启、提交或回滚，由开发者自己控制。有两种方式：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式1</span><br><span class="line">//设置不自动提交事务</span><br><span class="line">set autocommit=0;</span><br><span class="line">//执行事务操作</span><br><span class="line">commit|rollback;</span><br><span class="line"></span><br><span class="line">-- 方式2</span><br><span class="line">start transaction;//开启事务</span><br><span class="line">//执行事务操作</span><br><span class="line">commit|rollback;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a><font style="color:rgb(79, 79, 79);">savepoint</font></h5><p><font style="color:rgb(77, 77, 77);">如果在事务中我们执行了一大批操作，可只想回滚部分数据。此时可以将一大批操作分为几个部分，然后指定回滚某个部分，通过savepoint(保存点)来实现。示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into test1 values (1);</span><br><span class="line">-- 设置一个保存点</span><br><span class="line">savepoint part1;</span><br><span class="line">insert into test1 values (2);</span><br><span class="line">-- 将savepint = part1的语句到当前语句之间所有的操作回滚</span><br><span class="line">rollback to part1;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a><font style="color:rgb(79, 79, 79);">只读事务</font></h5><p><font style="color:rgb(77, 77, 77);">表示在事务中执行的是一些只读操作，如查询，但是不会做insert、update、delete操作。开启只读事务后，执行修改操作会报错。</font></p>
<h5 id="查看变量-autocommit-是否开启了自动提交命令："><a href="#查看变量-autocommit-是否开启了自动提交命令：" class="headerlink" title="查看变量 autocommit 是否开启了自动提交命令："></a><font style="color:rgb(77, 77, 77);">查看变量 autocommit 是否开启了自动提交命令：</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;autocommit&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ACID的保证"><a href="#ACID的保证" class="headerlink" title="ACID的保证"></a><font style="color:rgb(79, 79, 79);">ACID的保证</font></h4><p><font style="color:rgb(77, 77, 77);"> 事务的原子性是通过 undo log 来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的持久性是通过 redo log 来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的隔离性是通过 (读写锁+MVCC)来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的一致性是通过原子性、持久性、隔离性来实现的。</font></p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><font style="color:rgba(0, 0, 0, 0.75);">原子性</font></h5><p>1、每条数据变更(insert&#x2F;update&#x2F;delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上。</p>
<p>2、所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</p>
<h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><font style="color:rgba(0, 0, 0, 0.75);">持久性</font></h5><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716974826311-3b0e8907-86d6-44db-a7cb-7d738e3f4780.png"></p>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><font style="color:rgba(0, 0, 0, 0.75);">隔离性</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);">MySQL定义了4种隔离级别。隔离性是要做到什么呢？ 隔离性是要管理多个并发读写请求的访问顺序。MVCC和读写锁都能达到一定的隔离效果。</font></p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><font style="color:rgba(0, 0, 0, 0.75);">一致性</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);">数据库总是从一个一致性的状态转移到另一个一致性的状态。通过回滚，以及恢复，和在并发环境下的隔离可以达到一致性的效果。</font></p>
<h4 id="InnoDB的幻读问题"><a href="#InnoDB的幻读问题" class="headerlink" title="InnoDB的幻读问题"></a><font style="color:rgb(79, 79, 79);">InnoDB的幻读问题</font></h4><p><font style="color:rgb(79, 79, 79);">隔离级别REPEATABLE-READ（可重复读）的时候，并没有解决幻读的问题，串行的话性能无法保证，所以在InnoDB引擎中引入了mvcc和间隙锁以及行锁来处理</font></p>
<h6 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a><font style="color:rgb(79, 79, 79);">快照读</font></h6><p><font style="color:rgb(79, 79, 79);">InnoDB引擎通过mvcc来解决快照读的幻读问题，生成一个ReadView然后结合undo日志来解决幻读的问题</font></p>
<h6 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a><font style="color:rgb(79, 79, 79);">当前读</font></h6><p><font style="color:rgb(79, 79, 79);">InnoDB引擎通过间隙锁来解决幻读问题，事务A和事务B产生并发，事务A未提交时阻塞事务B，这样就不会产生幻读问题</font></p>
<h4 id="MVCC基础概念"><a href="#MVCC基础概念" class="headerlink" title="MVCC基础概念"></a><font style="color:rgb(79, 79, 79);">MVCC基础概念</font></h4><p>:::tips<br><font style="color:black;">数据库通过</font><strong><font style="color:rgb(37, 132, 181);">加锁</font></strong><font style="color:black;">，可以实现事务的隔离性，</font><strong><font style="color:rgb(37, 132, 181);">串行化隔离级别就是加锁实现的</font></strong><font style="color:black;">，但是加锁会</font><strong><font style="color:rgb(37, 132, 181);">降低数据库性能</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">因此，数据库引入了</font><strong><font style="color:rgb(37, 132, 181);">MVCC多版本并发控制</font></strong><font style="color:black;">，在读取数据不用加锁的情况下，实现读取数据的同时可以修改数据，修改数据时同时可以读取数据。</font></p>
<p>:::</p>
<h5 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h5><p><font style="color:rgb(79, 79, 79);">MVCC(Mutil-Version Concurrency Control)，多版本并发控制。是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。用于支持读已提交(RC）和可重复读(RR）隔离级别的实现。</font></p>
<p>:::tips<br><font style="color:rgb(79, 79, 79);">MVCC</font><font style="color:rgb(79, 79, 79);">在</font><font style="color:rgb(79, 79, 79);">MySQL InnoDB</font><font style="color:rgb(79, 79, 79);">引擎中的实现主要是为了在处理读-写冲突时提高数据库并发性能，记录读已提交和可重复读这两种隔离级别下事务操作版本连的过程。</font></p>
<p>:::</p>
<ul>
<li><font style="color:rgb(79, 79, 79);">数据库并发场景一般有三种：</font><ul>
<li><font style="color:rgb(79, 79, 79);">读-读</font><font style="color:rgb(79, 79, 79);">：不存在任何问题，不需要并发控制</font></li>
<li><font style="color:rgb(79, 79, 79);">读-写</font><font style="color:rgb(79, 79, 79);">：有线程安全问题，可能会造成事务隔离性问题，可能会有脏读，幻读，不可重复读</font></li>
<li><font style="color:rgb(79, 79, 79);">写-写</font><font style="color:rgb(79, 79, 79);">：有线程安全问题，可能会存在更新丢失问题。</font></li>
</ul>
</li>
<li><font style="color:rgb(79, 79, 79);">MVCC主要是用来解决【</font><font style="color:rgb(79, 79, 79);">读-写</font><font style="color:rgb(79, 79, 79);">】冲突的</font><font style="color:rgb(79, 79, 79);">无锁并发控制</font><font style="color:rgb(79, 79, 79);">，可以解决以下问题：</font><ul>
<li><font style="color:rgb(79, 79, 79);">在并发读写数据时，可以做到在读操作时不用阻塞写操作，写操作不用阻塞读操作，提高数据库并发读写的性能</font><font style="color:rgb(79, 79, 79);">。</font></li>
<li><font style="color:rgb(79, 79, 79);">可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决【写-写】引起的更新丢失问题</font><font style="color:rgb(79, 79, 79);">。</font></li>
</ul>
</li>
<li><font style="color:rgb(79, 79, 79);">MVCC与锁的组合</font><font style="color:rgb(79, 79, 79);">：</font></li>
</ul>
<p><font style="color:rgb(79, 79, 79);">一般数据库中都会采用以上MVCC与锁的两种组合来解决并发场景的问题，以此最大限度的提高数据库性能</font><font style="color:rgb(79, 79, 79);">。</font></p>
<pre><code>- &lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC + 悲观锁&lt;/font&gt;&lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC解决读-写冲突，悲观锁解决写-写冲突。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC + 乐观锁MVCC解决读-写冲突，乐观锁解决写-写冲突。&lt;/font&gt;
</code></pre>
<p>:::tips<br><font style="color:rgb(0, 0, 0);">通过上述描述，MVCC的作用可以概括为就是为了解决【读写冲突】，提高数据库性能的，而MVCC的实现又依赖于六个概念：【隐式字段】【undo日志】【版本链】【快照读和当前读】【读视图】。</font></p>
<p>:::</p>
<h5 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h5><p><strong><font style="color:rgb(37, 132, 181);">在InnoDB存储引擎，针对每行记录都有固定的两个隐藏列【DB_TRX_ID】【DB_ROLL_PTR】以及一个可能存在的隐藏列【DB_ROW_ID】</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039295214-f6b578a9-f5b8-42ad-a084-574eadda6268.webp"></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(248, 248, 248);">隐式字段</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);">描述</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);">是否必须存在</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">DB_TRX_ID</font></td>
<td><font style="color:rgb(0, 0, 0);">事物Id，也叫事物版本号，占用6byte的标识，</font><strong><font style="color:rgb(37, 132, 181);">事务开启之前，从数据库获得一个自增长的事务ID，用其判断事务的执行顺序</font></strong></td>
<td><font style="color:rgb(0, 0, 0);">是</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">DB_ROLL_PTR</font></td>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">占用7byte，</font><strong><font style="color:rgb(37, 132, 181);background-color:rgb(248, 222, 203);">回滚指针，指向这条记录的上一个版本的undo log记录，存储于回滚段（rollback segment）中</font></strong></td>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">是</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">DB_ROW_ID</font></td>
<td><font style="color:rgb(0, 0, 0);">隐含的自增ID（隐藏主键），如果表中没有主键和非NULL唯一键时，则会生成一个</font><strong><font style="color:rgb(37, 132, 181);">单调递增的行ID作为聚簇索引</font></strong></td>
<td><font style="color:rgb(0, 0, 0);">否</font></td>
</tr>
</tbody></table>
<p><font style="color:black;">表中的数据会因此分为两种形式：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">有主键或唯一非空字段</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039890546-106f9f7f-79d2-40c7-b110-1bec3c7d5758.webp"></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">没有主键且没有唯一非空字段</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039898106-00a40ce6-3800-47f8-a8cc-ce1156f47093.webp"><font style="color:black;"><br></font></p>
<h5 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h5><p><strong><font style="color:rgb(37, 132, 181);">一种用于撤销回退的日志，在事务开始之前，会先记录存放到 Undo 日志文件里，备份起来，当事务回滚时或者数据库崩溃时用于回滚事务。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">undo日志的主要作用是事务回滚和实现MVCC快照读</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">undo log日志分为两种</font></strong><font style="color:black;">：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">insert undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">代表事务在</font></strong></strong><font style="color:rgb(30, 107, 184);">insert</font><strong><strong><font style="color:rgb(37, 132, 181);">新记录时产生的</font></strong></strong><font style="color:rgb(30, 107, 184);">undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">, 仅用于事务回滚，并且在事务提交后可以被立即丢弃</font></strong></strong><font style="color:rgb(1, 1, 1);">。</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">update undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">事务在进行</font></strong></strong><font style="color:rgb(30, 107, 184);">update</font><strong><strong><font style="color:rgb(37, 132, 181);">或</font></strong></strong><font style="color:rgb(30, 107, 184);">delete</font><strong><strong><font style="color:rgb(37, 132, 181);">时产生的</font></strong></strong><font style="color:rgb(30, 107, 184);">undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">; 不仅在事务回滚时需要，在实现MVCC快照读时也需要</font></strong></strong><font style="color:rgb(1, 1, 1);">；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被清理线程统一清除。</font></strong></li>
</ul>
<p><font style="color:black;">MVCC实际上是使用的</font><font style="color:rgb(30, 107, 184);">update undo log</font><font style="color:black;"> 实现的快照读。</font></p>
<p>:::tips<br><strong><font style="color:rgb(37, 132, 181);">InnoDB 并不会真正地去开辟空间存储多个版本的行记录，只是借助 undo log 记录每次写操作的反向操作。所以B+ 索引树上对应的记录只会有一个最新版本，InnoDB 可以根据 undo log 得到数据的历史版本，从而实现多版本控制。</font></strong></p>
<p>:::</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039960367-31d88ae9-d08e-4582-aa7d-5f4b07627fec.webp"></p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>:::tips<br><font style="color:rgb(0, 0, 0);">一致性非锁定读是通过 </font><strong><font style="color:rgb(37, 132, 181);">MVCC</font></strong><font style="color:rgb(0, 0, 0);"> 来实现的。但是MVCC 没有一个统一的实现标准，所以各个存储引擎的实现机制不尽相同。InnoDB 存储引擎中 MVCC 的实现是通过 </font><strong><font style="color:rgb(37, 132, 181);">undo log</font></strong><font style="color:rgb(0, 0, 0);"> 来完成的</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(37, 132, 181);">当事务对某一行数据进行改动时，会产生一条Undo日志，多个事务同时操作一条记录时，就会产生多个版本的Undo日志，这些日志通过回滚指针（DB_ROLL_PTR）连成一个链表，称为版本链</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717040314866-11d5dd8b-e6dd-440b-92d2-0a384c1d896b.webp"></p>
<p><font style="color:black;">只要有事务写入数据时，就会产生一条对应的 undo log，一条 undo log 对应这行数据的一个版本，当这行数据有多个版本时，就会有多条 undo log 日志，undo log 之间通过回滚指针（DB_ROLL_PTR）连接，这样就形成了一个 undo log 版本链。</font></p>
<h5 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a><font style="color:rgb(0, 0, 0);">快照读和当前读</font></h5><h6 id="快照读："><a href="#快照读：" class="headerlink" title="快照读："></a><font style="color:rgb(79, 79, 79);">快照读：</font></h6><p><strong><font style="color:rgb(51, 51, 51);">也叫普通读，读取的是记录数据的可见版本，不加锁，不加锁的普通select语句都是快照读，即不加锁的非阻塞读</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">快照读的执行方式是生成 ReadView，直接利用 MVCC 机制来进行读取，并不会对记录进行加锁</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<h6 id="当前读："><a href="#当前读：" class="headerlink" title="当前读："></a><font style="color:rgb(79, 79, 79);">当前读：</font></h6><p><strong><font style="color:rgb(51, 51, 51);">也称锁定读【Locking Read】，读取的是记录数据的最新版本，并且需要先获取对应记录的锁</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE;  # 共享锁</span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ...  # 排他锁</span><br><span class="line">DELETE FROM student WHERE ...  # 排他锁</span><br><span class="line">UPDATE student SET ...  # 排他锁</span><br></pre></td></tr></table></figure>

<h5 id="读视图"><a href="#读视图" class="headerlink" title="读视图"></a><font style="color:rgb(0, 0, 0);">读视图</font></h5><p><strong><font style="color:rgb(37, 132, 181);">Read View提供了某一时刻事务系统的快照，主要是用来做</font><strong><strong><font style="color:rgb(30, 107, 184);">可见性</font></strong></strong><font style="color:rgb(37, 132, 181);">判断, 里面保存了【对本事务不可见的其他活跃事务】</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">当事务在开始执行的时候，会产生一个读视图（Read View），用来判断当前事务可见哪个版本的数据，即可见性判断</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">实际上在innodb中，每个SQL语句执行前都会生成一个Read View</font></strong><font style="color:black;">。</font></p>
<h6 id="读视图的四个属性"><a href="#读视图的四个属性" class="headerlink" title="读视图的四个属性"></a><font style="color:black;">读视图的四个属性</font></h6><p><font style="color:rgb(0, 0, 0);">MySQL</font><font style="color:rgb(30, 107, 184);">5.7</font><font style="color:rgb(0, 0, 0);">源码中对</font><font style="color:rgb(30, 107, 184);">Read View</font><font style="color:rgb(0, 0, 0);">定义了四个属性，如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ReadView &#123;</span><br><span class="line">	private:</span><br><span class="line">		/** The read should not see any transaction with trx id &gt;= this</span><br><span class="line">		value. In other words, this is the &quot;high water mark&quot;. */</span><br><span class="line">		trx_id_t	m_low_limit_id;</span><br><span class="line"></span><br><span class="line">		/** The read should see all trx ids which are strictly</span><br><span class="line">		smaller (&lt;) than this value.  In other words, this is the</span><br><span class="line">		low water mark&quot;. */</span><br><span class="line">		trx_id_t	m_up_limit_id;</span><br><span class="line"></span><br><span class="line">		/** trx id of creating transaction, set to TRX_ID_MAX for free</span><br><span class="line">		views. */</span><br><span class="line">		trx_id_t	m_creator_trx_id;</span><br><span class="line"></span><br><span class="line">		/** Set of RW transactions that was active when this snapshot</span><br><span class="line">		was taken */</span><br><span class="line">		ids_t		m_ids;</span><br><span class="line"></span><br><span class="line">		/** The view does not need to see the undo logs for transactions</span><br><span class="line">		whose transaction number is strictly smaller (&lt;) than this value:</span><br><span class="line">		they can be removed in purge if not needed by other views */</span><br><span class="line">		trx_id_t	m_low_limit_no;</span><br><span class="line"></span><br><span class="line">		/** AC-NL-RO transaction view that has been &quot;closed&quot;. */</span><br><span class="line">		bool		m_closed;</span><br><span class="line"></span><br><span class="line">		typedef UT_LIST_NODE_T(ReadView) node_t;</span><br><span class="line"></span><br><span class="line">		/** List of read views in trx_sys */</span><br><span class="line">		byte		pad1[64 - sizeof(node_t)];</span><br><span class="line">		node_t		m_view_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(37, 132, 181);">creator_trx_id </font>****<font style="color:rgb(0, 0, 0);">创建当前read view的事务ID</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_ids </font>****<font style="color:rgb(0, 0, 0);">当前系统中所有的活跃事务的 id，活跃事务指的是当前系统中开启了事务，但还没有提交的事务;</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_low_limit_id  </font>****<font style="color:rgb(0, 0, 0);">表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_up_limit_id  </font>****<font style="color:rgb(0, 0, 0);">当前系统中事务的 id 值最大的那个事务 id 值再加 1，也就是系统中下一个要生成的事务 id。</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">ReadView 会根据这 4 个属性，结合 undo log 版本链，来实现 MVCC 机制，决定一个事务能读取到数据那个版本</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p>:::tips<br><font style="color:black;">假设现在有事务 A 和事务 B 并发执行，事务 A 的事务 id 为 10，事务 B 的事务 id 为 20。</font></p>
<p><font style="color:black;">事务A的ReadView ：m_ids&#x3D;[10,20]，m_low_limit_id&#x3D;10，m_up_limit_id&#x3D;21，creator_trx_id&#x3D;10。</font></p>
<p><font style="color:black;">事务B的ReadView ：m_ids&#x3D;[10,20]，m_low_limit_id&#x3D;10，m_up_limit_id&#x3D;21，creator_trx_id&#x3D;20。</font></p>
<p>:::</p>
<h6 id="读视图可见性判断规则"><a href="#读视图可见性判断规则" class="headerlink" title="读视图可见性判断规则"></a><font style="color:black;">读视图可见性判断规则</font></h6><p><font style="color:black;">将Read View中的活跃事务Id按照大小放在坐标轴上表示的话，如下图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717040599275-ea807cb7-1694-4ca0-8396-60c6dc9c385c.webp"></p>
<p><font style="color:black;">当一个事务读取某条数据时，会</font><strong><font style="color:rgb(37, 132, 181);">通过DB_TRX_ID【Uodo日志的事务Id】在坐标轴上的位置</font></strong><font style="color:black;">来进行可见性规则判断，如下：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID &lt; m_low_limit_id</font></strong></li>
</ul>
<p><strong><font style="color:black;">表示DB_TRX_ID对应这条数据【Undo日志】是在当前事务开启之前，其他的事务就已经将该条数据修改了并提交了事务(事务的 id 值是递增的)，所以当前事务【开启Read View的事务】能读取到。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID &gt;&#x3D; m_up_limit_id</font></strong></li>
</ul>
<p><strong><font style="color:black;">表示在当前事务【creator_trx_id】开启以后，有新的事务开启，并且新的事务修改了这行数据的值并提交了事务，因为这是【creator_trx_id】后面的事务修改提交的数据，所以当前事务【creator_trx_id】是不能读取到的。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">m_low_limit_id &#x3D;&lt; DB_TRX_ID &lt; m_up_limit_id</font></strong><ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID  在 m_ids 数组中</font></strong></li>
</ul>
</li>
</ul>
<p><font style="color:rgb(0, 0, 0);"></font><font style="color:rgb(0, 0, 0);">表</font><font style="color:rgb(0, 0, 0);">示DB_TRX_ID【</font><font style="color:rgb(0, 0, 0);">写Undo日志的事务】 和当前事务【creator_trx_id】是在同一</font><font style="color:rgb(0, 0, 0);">时</font><font style="color:rgb(0, 0, 0);">刻开启</font><font style="color:rgb(0, 0, 0);">的</font><font style="color:rgb(0, 0, 0);">事</font><font style="color:rgb(0, 0, 0);">务</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID  不等于creator_trx_id</font></strong></p>
<p><strong><font style="color:rgb(0, 0, 0);">DB_TRX_ID事务修改了数据的值，并提交了事务，所以当前事务【creator_trx_id】不能读取到。</font></strong><font style="color:black;"></font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;DB_TRX_ID  等于creator_trx_id&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt;&lt;/font&gt;
</code></pre>
<p><font style="color:black;"></font><font style="color:rgb(0, 0, 0);">表明数据【Undo日志】 是自己生成的，因此是</font><strong><font style="color:rgb(37, 132, 181);">可见</font></strong><font style="color:rgb(0, 0, 0);">的</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;DB_TRX_ID  不在 m_ids 数组中&lt;/font&gt;**
</code></pre>
<p><strong><font style="color:black;">表示的是在当前事务【creator_trx_id】开启之前，其他事务【DB_TRX_ID】将数据修改后就已经提交了事务，所以当前事务能读取到。</font></strong></p>
<h6 id="读视图可见性判断规则案例说明"><a href="#读视图可见性判断规则案例说明" class="headerlink" title="读视图可见性判断规则案例说明"></a><font style="color:black;">读视图可见性判断规则案例说明</font></h6><p><font style="color:black;">了解了读视图可见性判断规则，下面通过一个场景案例图解的方式来详细逐条验证上述规则。一般来说，我们的行数据结构都为一下模式：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048524181-8e1e70d4-c0b1-49f5-8cb1-32e3dbbb4ed5.webp"></p>
<p><font style="color:black;">假设有一个事物【DB_TRX_ID &#x3D; 10】在表中插入了一条数据，则它的数据结构为为：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048524123-cd2cf78d-57d4-433c-a3d0-c4860e769979.webp"></p>
<ul>
<li><strong><font style="color:black;">【第一步】：假设现在有事务 A【DB_TRX_ID &#x3D; 20】 和事务 B 【DB_TRX_ID &#x3D; 30】并发执行</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">select name from user where id = 1;</span><br><span class="line">#事物B：</span><br><span class="line">update user set name = &#x27;edwin&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">事物开始后分别生成ReadView</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:black;&quot;&gt;事务A的ReadView ：m_ids=[20,30]，m_low_limit_id=20，m_up_limit_id=31，creator_trx_id=20。&lt;/font&gt;**
- **&lt;font style=&quot;color:black;&quot;&gt;事务B的ReadView ：m_ids=[20,30]，m_low_limit_id=20，m_up_limit_id=31，creator_trx_id=30。&lt;/font&gt;**
</code></pre>
<ul>
<li><strong><font style="color:black;">【第二步】：事物A开启事物之后通过版本链</font><strong><strong><font style="color:rgb(37, 132, 181);">第一次</font></strong></strong><font style="color:black;">读取数据，版本链中的DB_TRX_ID &#x3D; 10，小于事物A的【DB_TRX_ID &#x3D; 20】，说明DB_TRX_ID &#x3D; 10这条数据是事物A开启之前就已经写入，并提交了事物，所以事物A可以读取到。</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559781-c6ab3c4f-fc28-41fc-b4cf-25bf985a0d6b.webp"></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">【第三步】：事务 B 【DB_TRX_ID &#x3D; 30】修改数据，将name修改为Edwin，修改后写入Undo Log日志，</font><strong><strong><font style="color:rgb(37, 132, 181);">此时还没有提交事务B</font></strong></strong><font style="color:rgb(1, 1, 1);">。示意图如下：</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559736-8999a648-def3-46d1-8be3-ab48d174d901.webp"></p>
<ul>
<li><strong><font style="color:black;">【第四步】：事务A【DB_TRX_ID &#x3D; 20】</font><strong><strong><font style="color:rgb(37, 132, 181);">第二次</font></strong></strong><font style="color:black;">去读取数据</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">在 undo log版本链中，数据最新版本的事务id为30，这个值处于事务A的 ReadView 里 m_low_limit_id 和 m_up_limit_id 并且存在于m_ids 数组中，表示这个版本的数据是和自己同一时刻启动的事务修改的，因此这个版本的数据，数据 A 读取不到</font>****<font style="color:black;">。</font></strong></p>
<p><font style="color:black;">此时需要沿着 undo log 的版本链向前找，接着会找到该行数据的上一个版本db_trx_id&#x3D;10，由于db_trx_id&#x3D;10小于 m_low_limit_id的值，因此事务 A 能读取到该版本的值，即事务 A 读取到的值是星之码。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559623-6cee2ece-15a0-4afc-b749-8562c3693d60.webp"></p>
<ul>
<li><strong><font style="color:black;">【第五步】：现在事务 B 提交，此时系统中活跃的事务只有事物A，事物A</font><strong><strong><font style="color:rgb(37, 132, 181);">第三次</font></strong></strong><font style="color:black;">读取，读取到内容就有两种可能性：</font></strong></li>
</ul>
<p><strong><font style="color:black;">这里留一个问题一：造成这两种情况的原因是什么？</font></strong></p>
<p><strong><font style="color:black;">我们留到本文第三节【不同隔离级别MVCC实现原理】中说明，继续案例</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;读已提交（RC）隔离级别：读取到是事物B提交的Edwin&lt;/font&gt;****&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;可重复读（RR）隔离级别：读取到是原始数据提交的星河之码&lt;/font&gt;****&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;**
</code></pre>
<ul>
<li><strong><font style="color:black;">【第六步】：新的事物C【DB_TRX_ID &#x3D; 40】修改数据，将name修改为彬</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事物C：</span><br><span class="line">update user set name = &#x27;彬&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">执行脚本前生成的ReadView如下，执行脚本后，提交事物C。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">事务C的ReadView ：m_ids&#x3D;[20,40]，m_low_limit_id&#x3D;20，m_up_limit_id&#x3D;41，creator_trx_id&#x3D;40</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559795-7654eac6-debc-4019-867e-87fd9bd6fe0d.webp"></p>
<ul>
<li><strong><font style="color:black;">【第七步】：事务 A【DB_TRX_ID &#x3D; 20】</font><strong><strong><font style="color:rgb(37, 132, 181);">第四次</font></strong></strong><font style="color:black;">读取数据，</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时由于事物A，由于事物A的m_up_limit_id&#x3D;31，而日志中的DB_TRX_ID&#x3D;40，根据可见性判断规则可以知到，事物A不能读取到DB_TRX_ID&#x3D;40的记录，按照版本链的DB_POLL_PTR继续往上找，找到DB_TRX_ID&#x3D;30的记录，虽然30在事物A的的m_ids&#x3D;[20,30]，但是</font><strong><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID&#x3D;30不等于事物A的creator_trx_id&#x3D;20</font></strong></strong><font style="color:black;">，所以还是不能读取，继续往上找，最终读取到了DB_TRX_ID&#x3D;10的记录，name&#x3D;星河之码</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559686-29a20060-b95e-483a-8701-ba33a77ea3b2.webp"></p>
<p>:::tips<br><font style="color:black;">实际上，这里事务A在不同场景下也是可以读取到DB_TRX_ID&#x3D;40得数据的。</font></p>
<p><font style="color:black;">这里也留一个问题二：在什么场景下能够读取到DB_TRX_ID&#x3D;40得数据name&#x3D;彬呢？</font></p>
<p><font style="color:black;">我们留到本文第三节【不同隔离级别MVCC实现原理】中说明，继续案例</font></p>
<p>:::</p>
<ul>
<li><strong><font style="color:black;">【第八步】：事务 A【DB_TRX_ID &#x3D; 20】开始修改数据，将name 修改为 ‘法外狂徒张三’</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">update user set name = &#x27;法外狂徒张三&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">此时事务A还没有提交，但是已经写入了Undo 日志，新的版本链如下</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048833158-398a5518-357e-412b-914d-4790a49e8c93.webp"></p>
<ul>
<li><strong><font style="color:black;">【第九步】：事务 A</font><strong><strong><font style="color:rgb(37, 132, 181);">第五次</font></strong></strong><font style="color:black;">读取数据</font></strong></li>
</ul>
<p><strong><font style="color:black;">由于Undo日志中的最新数据DB_TRX_ID&#x3D;20等于事物A的creator_trx_id&#x3D;20，说明是自己修改的数据，可以查到，name&#x3D;法外狂徒张三</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048832921-a527647d-5789-49a2-bd67-24a5434a9466.webp"></p>
<p><font style="color:black;">通过以上九个步骤图解的方式，对读视图可见性判断规则做了分析，通过ReadView 和 undo log分析了MVCC 的实现原理，接下来结合事务的隔离级别，看看MVCC是怎么读取数据的。</font></p>
<h5 id="不同隔离级别MVCC实现原理"><a href="#不同隔离级别MVCC实现原理" class="headerlink" title="不同隔离级别MVCC实现原理"></a>不同隔离级别MVCC实现原理</h5><h6 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h6><p><font style="color:black;">通过上述对【Read View】的分析可以总结出：</font><strong><font style="color:rgb(37, 132, 181);">InnoDB 实现MVCC是通过</font><strong><strong><font style="color:rgb(30, 107, 184);"> </font></strong></strong><font style="color:rgb(30, 107, 184);">Read View与Undo Log</font><strong><strong><font style="color:rgb(37, 132, 181);"> </font></strong></strong><font style="color:rgb(37, 132, 181);">实现的，Undo Log 保存了历史快照，形成版版本链，Read View可见性规则判断当前版本的数据是否可见</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">InnnoDB执行查询语句的具体步骤为</font></strong><font style="color:black;">：</font></p>
<ul>
<li><strong><font style="color:black;">执行语句之前获取查询事务自己的事务Id，即事务版本号。</font></strong></li>
<li><strong><font style="color:black;">通过事务id获取Read View</font></strong></li>
<li><strong><font style="color:black;">查询存储的数据，将其事务Id与Read View中的事务版本号进行比较</font></strong></li>
<li><strong><font style="color:black;">不符合Read View的可见性规则，则读取Undo log中历史快照数据</font></strong></li>
<li><strong><font style="color:black;">找到当前事务能够读取的数据返回</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">而在实际的使用过程中，Read View在不同的隔离级别下是得工作方式是不一样</font></strong><font style="color:black;">。</font></p>
<h6 id="读已提交（RC）MVCC实现原理"><a href="#读已提交（RC）MVCC实现原理" class="headerlink" title="读已提交（RC）MVCC实现原理"></a>读已提交（RC）MVCC实现原理</h6><p><strong><font style="color:rgb(37, 132, 181);">在读已提交(Read committed)的隔离级别下实现MVCC，同一个事务里面，【每一次查询都会产生一个新的Read View副本】，这样可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">还是按照上述案例来说明一下：</font></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">【第一步】：准备一条原始数据</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717049082035-9b10eb14-bac6-4727-b729-554586cc0f3b.webp"></p>
<ul>
<li><strong><font style="color:black;">【第二步】：假设现在有事务 A【DB_TRX_ID &#x3D; 20】 和事务 B 【DB_TRX_ID &#x3D; 30】并发执行</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">select name from user where id = 1;</span><br><span class="line">#事物B：</span><br><span class="line">update user set name = &#x27;edwin&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">执行过程为</font></strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong><font style="color:rgb(1, 1, 1);">开始事务</font></strong></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 222, 203);">第一次查询：select name from user where id &#x3D; 1;</font></strong></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);">开始事务</font></strong></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 248, 248);">执行修改：update user set name &#x3D; ‘edwin’ where id &#x3D; 1;</font></strong></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);">   </font>****<font style="color:rgb(1, 1, 1);">提交事务</font></strong></td>
</tr>
<tr>
<td>6</td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 248, 248);">第二次查询：select name from user where id &#x3D; 1;</font></strong></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td><strong><font style="color:rgb(1, 1, 1);">提交事务</font></strong></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong><font style="color:black;">版本链为：</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717049340079-d389ca08-a8b4-47fb-a95e-1b69427149a0.webp"></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例结果分析</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">上述案例在</font><strong><font style="color:rgb(37, 132, 181);">在读已提交(Read committed)的隔离级别下实现，同一个事务里面，【每一次查询都会产生一个新的Read View副本】</font></strong><font style="color:black;">。所以第二步实际上产生了三个Read View</font></p>
<table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_ids</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_low_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_up_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">creator_trx_id</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">事务A：第一次查询Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>20</td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">事务B：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>30</td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">事务A：第二次查询Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>20</td>
</tr>
</tbody></table>
<p><font style="color:black;">通过可见性判断：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第一次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">日志事务Id【DB_TRX_ID &#x3D; 10】 &lt; 最小活跃事务ID【m_low_limit_id&#x3D;20】，因此可以读取到DB_TRX_ID &#x3D; 10这条版本链中的数据。即name &#x3D; 星河之码。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第二次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时事务B已经提交，版本链中最新版本为DB_TRX_ID &#x3D; 30，而可见性规则中虽然满足</font></strong></p>
<p><strong><font style="color:black;">【m_low_limit_id&#x3D;20】&#x3D;&lt;【DB_TRX_ID&#x3D;30】&lt;【m_up_limit_id&#x3D;31】但是【DB_TRX_ID&#x3D;30】不在m_ids集合[20]中，因此事务A的第二次查询可以读取【DB_TRX_ID&#x3D;30】的数据，即name &#x3D; edwin。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例总结</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">通过上述案例说明，</font><strong><font style="color:rgb(37, 132, 181);">同一个事务A的两个相同查询，第一次结果为星河之码，第二次结果为edwin，因此在读已提交（RC）隔离级别下，存在不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<h6 id="可重复读（RR）MVCC实现原理"><a href="#可重复读（RR）MVCC实现原理" class="headerlink" title="可重复读（RR）MVCC实现原理"></a>可重复读（RR）MVCC实现原理</h6><p><strong><font style="color:rgb(37, 132, 181);">在可重复读(Repeatable read)的隔离级别下实现MVCC，【同一个事务里面，多次查询，都只会产生一个共用Read View】，以此不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">案例与读已提交一样，这里就不重复赘述，可以再看一遍读已提交的【第一步】【第二步】，直接进行案例分析</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例结果分析</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">由于同一个事物只会产生一个共用Read View，所以可重复读的隔离级别下第二步只产生了两个Read View</font></p>
<p><font style="color:black;">上述案例在</font><strong><font style="color:rgb(37, 132, 181);">可重复读(Repeatable read)，【每一次查询都会产生一个新的Read View副本】</font></strong><font style="color:black;">。所以第二步实际上产生了三个Read View</font></p>
<table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_ids</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_low_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_up_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">creator_trx_id</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">事务A：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td><font style="color:rgb(0, 0, 0);">31</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">事务B：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td><font style="color:rgb(0, 0, 0);">31</font></td>
<td><font style="color:rgb(0, 0, 0);">30</font></td>
</tr>
</tbody></table>
<p><font style="color:black;">通过可见性判断：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第一次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">日志事务Id【DB_TRX_ID &#x3D; 10】 &lt; 最小活跃事务ID【m_low_limit_id&#x3D;20】，因此可以读取到DB_TRX_ID &#x3D; 10这条版本链中的数据。即name &#x3D; 星河之码。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第二次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时事务B已经提交，版本链中最新版本为DB_TRX_ID &#x3D; 30，而可见性规则中虽然满足</font></strong></p>
<p><strong><font style="color:black;">【m_low_limit_id&#x3D;20】&#x3D;&lt;【DB_TRX_ID&#x3D;30】&lt;【m_up_limit_id&#x3D;20】并且【DB_TRX_ID&#x3D;30】也在m_ids集合[20，30]中，但是【DB_TRX_ID&#x3D;30】不等于事物A的【creator_trx_id&#x3D;20】，说明</font><strong><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID&#x3D;30是同一时刻其他事物提交的，事物A不能读取到</font></strong></strong><font style="color:black;">，因此事物A只能按照版本链继续往上找，最终读取到【DB_TRX_ID&#x3D;10】的数据，即name &#x3D; 星河之码。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例总结</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">通过上述案例说明，</font><strong><font style="color:rgb(37, 132, 181);">同一个事务A的两个相同查询，结果都为星河之码，因此在可重复读（RR）隔离级别下，解决了不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<p>:::tips<br><font style="color:black;">其实读已经提交与可重复读的可见性判断的区别就在于事务A第二次查询时使用的Read View不同。</font></p>
<p>:::</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/2023/06/14/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p><font style="color:rgb(34, 34, 34);">MySQL官方对索引定义：是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护工作。</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">索引是物理数据页存储，在数据文件中（InnoDB，ibd文件），利用数据页(page)存储。</font></li>
<li><font style="color:rgb(34, 34, 34);">索引可以加快检索速度，但是同时也会降低增删改操作速度，索引维护需要代价。</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">索引涉及的理论知识：二分查找法、Hash和B+Tree。</font></p>
<span id="more"></span>
<h2 id="理论知识补充"><a href="#理论知识补充" class="headerlink" title="理论知识补充"></a><font style="color:rgb(34, 34, 34);">理论知识补充</font></h2><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a><font style="color:rgb(34, 34, 34);">二分查找法</font></h3><p><font style="color:rgb(34, 34, 34);">二分查找法也叫作折半查找法，它是在有序数组中查找指定数据的搜索算法。它的优点是等值查询、范围查询性能优秀，缺点是更新数据、新增数据、删除数据维护成本高。</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">首先定位left和right两个指针</font></li>
<li><font style="color:rgb(34, 34, 34);">计算(left+right)&#x2F;2</font></li>
<li><font style="color:rgb(34, 34, 34);">判断除2后索引位置值与目标值的大小比对</font></li>
<li><font style="color:rgb(34, 34, 34);">索引位置值大于目标值就-1，right移动；如果小于目标值就+1，left移动</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">举个例子，下面的有序数组有17 个值，查找的目标值是7，过程如下：</font><font style="color:rgb(34, 34, 34);">第一次查找：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582381776-4e840986-b812-4e5f-a60f-827f05d8e8c4.png"></p>
<p><font style="color:rgb(34, 34, 34);">第二次查找：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582381804-ca77fbb7-3dc6-4ca0-b733-e5408695b5c9.png"></p>
<h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a><font style="color:rgb(34, 34, 34);">Hash结构</font></h3><p><font style="color:rgb(34, 34, 34);">Hash底层实现是由Hash表来实现的，是根据键值 &lt;key,value&gt; 存储数据的结构。非常适合根据key查找value值，也就是单个key查询，或者说等值查询。其结构如下所示：</font></p>
<p><font style="color:rgb(34, 34, 34);">从上面结构可以看出，Hash索引可以方便的提供等值查询，但是对于范围查询就需要全表扫描了。</font><font style="color:rgb(34, 34, 34);">Hash索引在MySQL 中Hash结构主要应用在Memory原生的Hash索引 、InnoDB 自适应哈希索引。InnoDB自适应哈希索引是为了提升查询效率，InnoDB存储引擎会监控表上各个索引页的查询，当InnoDB注意到某些索引值访问非常频繁时，会在内存中基于B+Tree索引再创建一个哈希索引，使得内存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。</font><font style="color:rgb(34, 34, 34);">InnoDB自适应哈希索引：在使用Hash索引访问时，一次性查找就能定位数据，等值查询效率要优于B+Tree。</font><font style="color:rgb(34, 34, 34);">自适应哈希索引的建立使得InnoDB存储引擎能自动根据索引页访问的频率和模式自动地为某些热点页建立哈希索引来加速访问。另外InnoDB自适应哈希索引的功能，用户只能选择开启或关闭功能，无法进行人工干涉。</font></p>
<p><font style="color:rgb(34, 34, 34);">show engine innodb status \G; show variables like ‘%innodb_adaptive%’;</font></p>
<h3 id="B-Tree结构"><a href="#B-Tree结构" class="headerlink" title="B+Tree结构"></a><font style="color:rgb(34, 34, 34);">B+Tree结构</font></h3><p><font style="color:rgb(34, 34, 34);">MySQL数据库索引采用的是B+Tree结构，在B-Tree结构上做了优化改造。</font><strong><font style="color:rgb(34, 34, 34);">B-Tree结构：</font></strong></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">索引值和data数据分布在整棵树结构中</font></li>
<li><font style="color:rgb(34, 34, 34);">每个节点可以存放多个索引值及对应的data数据</font></li>
<li><font style="color:rgb(34, 34, 34);">树节点中的多个索引值从左到右升序排列</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582445512-084761dc-a43d-4fa7-a324-b486a9bd9f2c.png"></p>
<p><font style="color:rgb(34, 34, 34);">B树的搜索：从根节点开始，对节点内的索引值序列采用二分法查找，如果命中就结束查找。没有命中会进入子节点重复查找过程，直到所对应的的节点指针为空，或已经是叶子节点了才结束。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">B+Tree结构：</font></strong></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">非叶子节点不存储data数据，只存储索引值，这样便于存储更多的索引值</font></li>
<li><font style="color:rgb(34, 34, 34);">叶子节点包含了所有的索引值和data数据</font></li>
<li><font style="color:rgb(34, 34, 34);">叶子节点用指针连接，提高区间的访问性能</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582445510-500a20d8-3412-44cb-9757-1d2eb6059062.png"></p>
<p><font style="color:rgb(34, 34, 34);">相比B树，B+树进行范围查找时，只需要查找定位两个节点的索引值，然后利用叶子节点的指针进行遍历即可。而B树需要遍历范围内所有的节点和数据，显然B+Tree效率高。</font></p>
<h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a><font style="color:rgb(34, 34, 34);">索引基础</font></h2><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><pre><code>- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;索引减小了需要扫描的数据量，从而大大加快数据的检索速度（创建索引的最主要的原因）&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;可以加速表与表的连接&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;可以显著的减少查询中分组和排序的时间&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;索引可以帮助服务器避免排序和创建临时表&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;索引可以将随机IO变成顺序IO&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">索引既然有这么多优点，那为什么不对表中每个列都建一个索引呢，这样不是更加能提升性能吗，实际上这是不可取的，索引虽然有诸多优点，但是也有很多缺点</font></p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong><font style="color:rgb(1, 1, 1);">对表中的数据进行增、删、改的时候，索引也要动态的维护，降低了数据的写入速度</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">随着数据量的增加，创建索引和维护索引要耗费时间也会越来越长，影响性能</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">索引的存储需要占物理空间，每一个索引都要占用一定的物理空间</font></strong></li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><font style="color:black;">MySQL索引的类型其实只有五种，但是我们经常会听到很多种不同的索引，那其实是在不同维度划分的类型：</font></p>
<ul>
<li><strong><font style="color:black;">存储结构维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">B Tree索引、Hash索引、B + Tree索引</font></strong></p>
<ul>
<li><strong><font style="color:black;">应用层次维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">普通索引、唯一索引、主键索引、复合索引、全文索引，空间索引</font></strong></p>
<ul>
<li><strong><font style="color:black;">索引键值类型维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">主键索引、辅助索引（二级索引）</font></strong></p>
<ul>
<li><strong><font style="color:black;">数据存储和索引键值逻辑关系维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">聚集索引（聚簇索引）、非聚集索引（非聚簇索引）</font></strong></p>
<ul>
<li><strong><font style="color:black;">索引组成维度划分</font></strong></li>
</ul>
<p><strong><font style="color:black;">组合索引（复合索引）、单一索引</font></strong></p>
<p><strong><font style="color:black;">因为只是分类的维度不同那我们以普通索引、唯一索引、主键索引、复合索引，空间索引为例</font></strong></p>
<h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a><font style="color:black;">普通索引</font></h4><p><font style="color:rgb(34, 34, 34);">这是最基本的索引类型，基于普通字段建立的索引，没有任何限制。是辅助索引的一种。对应逻辑关系中的非聚集索引。索引列单独保存，查询的时候根据索引查到数据后再从主键索引中将完整的数据取出，这个过程称为回表查询。创建普通索引的方法如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名);</span><br><span class="line">ALTER TABLE tablename ADD INDEX [索引的名字] (字段名);</span><br><span class="line">CREATE TABLE tablename ( [...], INDEX [索引的名字] (字段名) );</span><br></pre></td></tr></table></figure>

<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a><font style="color:black;">唯一索引</font></h4><p><font style="color:rgb(34, 34, 34);">与”普通索引”类似，不同的就是：索引字段的值必须唯一，但允许有空值 。在创建或修改表时追加唯一约束，就会自动创建对应的唯一索引。创建唯一索引的方法如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX &lt;索引的名字&gt; ON tablename (字段名);</span><br><span class="line">ALTER TABLE tablename ADD UNIQUE INDEX [索引的名字] (字段名);</span><br><span class="line">CREATE TABLE tablename ( [...], UNIQUE [索引的名字] (字段名) ;</span><br></pre></td></tr></table></figure>

<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a><font style="color:black;">主键索引</font></h4><p><font style="color:rgb(34, 34, 34);">它是一种特殊的唯一索引，不允许有空值。在创建或修改表时追加主键约束即可，每个表只能有一个主键。对应逻辑关系划分中的聚集索引。索引的数据和索引保存在一起</font></p>
<p><font style="color:rgb(34, 34, 34);">创建主键索引的方法如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tablename ( [...], PRIMARY KEY (字段名) );</span><br><span class="line">ALTER TABLE tablename ADD PRIMARY KEY (字段名);</span><br></pre></td></tr></table></figure>

<h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p><font style="color:rgb(34, 34, 34);">复合索引是普通索引的一种，单一索引是指索引列为一列的情况，即新建索引的语句只实施在一列上；用户可以在多个列上建立索引，这种索引叫做组复合索引（组合索引）。复合索引可以代替多个单一索引，相比多个单一索引复合索引所需的开销更小。索引同时有两个概念叫做窄索引和宽索引，窄索引是指索引列为1-2列的索引，宽索引也就是索引列超过2列的索引，设计索引的一个重要原则就是能用窄索引不用宽索引，因为窄索引往往比组合索引更有效。创建组合索引的方法如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX &lt;索引的名字&gt; ON tablename (字段名1，字段名2...);</span><br><span class="line">ALTER TABLE tablename ADD INDEX [索引的名字] (字段名1，字段名2...);</span><br><span class="line">CREATE TABLE tablename ( [...], INDEX [索引的名字] (字段名1，字段名2...) );</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(34, 34, 34);">复合索引使用注意事项：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">何时使用复合索引，要根据where条件建索引，注意不要过多使用索引，过多使用会对更新操作效率有很大影响。</font></li>
<li><font style="color:rgb(34, 34, 34);">如果表已经建立了(col1，col2)，就没有必要再单独建立（col1）；如果现在有(col1)索引，如果查询需要col1和col2条件，可以建立(col1,col2)复合索引，对于查询有一定提高。</font></li>
<li><font style="color:rgb(34, 34, 34);">复合索引在生效时OrderBy中有复合索引中的字段会增加查询速度</font></li>
<li><font style="color:rgb(34, 34, 34);">额外介绍一下覆盖索引：当查询结果需要的字段都在复合索引中就不需要回表查询</font></li>
</ul>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a><font style="color:black;">全文索引</font></h4><p><font style="color:rgb(34, 34, 34);">查询操作在数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果使用全文索引，查询速度会比like快很多倍。在MySQL 5.6 以前的版本，只有MyISAM存储引擎支持全文索引，从MySQL 5.6开始MyISAM和InnoDB存储引擎均支持。</font><font style="color:rgb(34, 34, 34);">创建全文索引的方法如下：</font></p>
<p><font style="color:rgb(0, 0, 0);">CREATE</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">FULLTEXT</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">INDEX</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(152, 26, 26);">&lt;</font><font style="color:rgb(0, 0, 0);">索引的名字</font><font style="color:rgb(152, 26, 26);">&gt;</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">ON</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 255);">tablename</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">(</font><font style="color:rgb(0, 0, 0);">字段名</font><font style="color:rgb(34, 34, 34);">);</font><font style="color:rgb(34, 34, 34);"><br></font><font style="color:rgb(0, 0, 0);">ALTER</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">TABLE</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">tablename</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">ADD</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">FULLTEXT</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">[</font><font style="color:rgb(0, 0, 0);">索引的名字</font><font style="color:rgb(34, 34, 34);">] (</font><font style="color:rgb(0, 0, 0);">字段名</font><font style="color:rgb(34, 34, 34);">);</font><font style="color:rgb(34, 34, 34);"><br></font><font style="color:rgb(0, 0, 0);">CREATE</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">TABLE</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 255);">tablename</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">( […],</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">FULLTEXT</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(0, 0, 0);">KEY</font><font style="color:rgb(34, 34, 34);"> </font><font style="color:rgb(34, 34, 34);">[</font><font style="color:rgb(0, 0, 0);">索引的名字</font><font style="color:rgb(34, 34, 34);">] (</font><font style="color:rgb(0, 0, 0);">字段名</font><font style="color:rgb(34, 34, 34);">) ;</font></p>
<p><font style="color:rgb(34, 34, 34);">和常用的like模糊查询不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如</font></p>
<p><font style="color:rgb(34, 34, 34);">select * from user where match(name) against(‘aaa’);</font></p>
<p><font style="color:rgb(34, 34, 34);">全文索引使用注意事项：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">全文索引必须在字符串、文本字段上建立。</font></li>
<li><font style="color:rgb(34, 34, 34);">全文索引字段值必须在最小字符和最大字符之间的才会有效。（innodb：3-84；myisam：4-84）</font></li>
<li><font style="color:rgb(34, 34, 34);">全文索引字段值要进行切词处理，按syntax字符进行切割，例如b+aaa，切分成b和aaa</font></li>
<li><font style="color:rgb(34, 34, 34);">全文索引匹配查询，默认使用的是等值匹配，例如a匹配a，不会匹配ab,ac。如果想匹配可以在布尔模式下搜索a*</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">select * from user where match(name) against(‘a*’ in boolean mode);</font></p>
<h3 id="索引创建准则"><a href="#索引创建准则" class="headerlink" title="索引创建准则"></a>索引创建准则</h3><p><font style="color:rgb(0, 0, 0);">基于以上索引的介绍，我们知道索引优缺点都很明显，</font><strong><font style="color:rgb(37, 132, 181);">我们不能在表数据中所有的列都添加索引，需要根据具体场景选择创建索引的列与类型</font></strong><font style="color:rgb(0, 0, 0);">。那么具体应该在那些列中添加索引，那些列中不能添加索引呢？</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">能创建索引的列</font></strong><ul>
<li><strong><font style="color:rgb(1, 1, 1);">主键索引，在MySQL中，主键列会默认的当成唯一性索引</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">在业务场景中被【</font><strong><strong><font style="color:rgb(37, 132, 181);">当成条件查询的列</font></strong></strong><font style="color:rgb(1, 1, 1);">】创建索引，可以提高查询效率</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">外键索引，比如需要【</font><strong><strong><font style="color:rgb(37, 132, 181);">用于JOIN的列</font></strong></strong><font style="color:rgb(1, 1, 1);">】创建索引，可以提高连接的速度</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">由于索引是已经排序的，所以在经常【</font><strong><strong><font style="color:rgb(37, 132, 181);">用于范围查询的列</font></strong></strong><font style="color:rgb(1, 1, 1);">】和需要【</font><strong><strong><font style="color:rgb(37, 132, 181);">排序的列</font></strong></strong><font style="color:rgb(1, 1, 1);">】创建索引，可以避免排序，提高查询效率</font></strong></li>
</ul>
</li>
<li><strong><font style="color:rgb(37, 132, 181);">不能创建索引的列</font></strong><ul>
<li><strong><font style="color:rgb(1, 1, 1);">经常用于计算的列</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">数据值很少或者大量重复的列</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">大字段的列</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">经常修改的列</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">很少使用的字段</font></strong></li>
</ul>
</li>
</ul>
<p>:::tips<br><strong><font style="color:rgb(0, 0, 0);">以上几种情况的列，一般不建议创建索引，非但不能提高查询速度，反而增加索引后提高了数据的维护时间成本和空间成本。</font></strong></p>
<p>:::</p>
<h3 id="索引创建与删除"><a href="#索引创建与删除" class="headerlink" title="索引创建与删除"></a>索引创建与删除</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><strong><font style="color:rgb(0, 0, 0);">索引的创建方式有三种：建表时创建索引，已存在的表上直接创建索引，已存在的表上新增列并创建索引</font></strong></p>
<h5 id="建表时创建索引："><a href="#建表时创建索引：" class="headerlink" title="建表时创建索引："></a>建表时创建索引：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">    字段名1  数据类型 [完整性约束条件…],</span><br><span class="line">    字段名2  数据类型 [完整性约束条件…],</span><br><span class="line">    [NORMAL | UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY</span><br><span class="line">    [索引名]  (字段名[(长度)]  [ASC | DE</span><br></pre></td></tr></table></figure>

<h5 id="已存在的表上直接创建索引"><a href="#已存在的表上直接创建索引" class="headerlink" title="已存在的表上直接创建索引"></a><font style="color:rgb(0, 0, 0);">已存在的表上直接创建索引</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE  [NORMAL | UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名  ON 表名 (字段名[(长度)]  [ASC | DESC]) </span><br></pre></td></tr></table></figure>

<h5 id="已存在的表上新增列并创建索引（修改表结构）"><a href="#已存在的表上新增列并创建索引（修改表结构）" class="headerlink" title="已存在的表上新增列并创建索引（修改表结构）"></a><font style="color:rgb(0, 0, 0);">已存在的表上新增列并创建索引（修改表结构）</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD  [NORMAL | UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)]  [ASC | DESC]) ;</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li><strong><font style="color:black;">NORMAL | UNIQUE | FULLTEXT | SPATIAL</font></strong></li>
</ul>
<p><strong><font style="color:black;">可选参数，Normal 普通索引，Unique 唯一索引，Full Text 全文索引，SPATIAL 空间索引</font></strong></p>
<ul>
<li><strong><font style="color:black;">INDEX | KEY</font></strong></li>
</ul>
<p><strong><font style="color:black;">同义词，作用相同，用来指定创建索引</font></strong></p>
<ul>
<li><strong><font style="color:black;">ASC | DESC</font></strong></li>
</ul>
<p><strong><font style="color:black;">指定升序或降序的索引值存储</font></strong></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX 索引名 ON 表名字;</span><br></pre></td></tr></table></figure>

<h3 id="相关SQL"><a href="#相关SQL" class="headerlink" title="相关SQL"></a>相关SQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看表结构</span><br><span class="line">desc table_name;</span><br><span class="line"></span><br><span class="line">//查看生成表的SQL</span><br><span class="line">show create table table_name;</span><br><span class="line"></span><br><span class="line">//查看索引结构信息</span><br><span class="line">show index from  table_name;</span><br><span class="line"></span><br><span class="line">//查看SQL执行时间</span><br><span class="line">set profiling = 1;</span><br><span class="line">select * from user where id=1; </span><br><span class="line">show profiles;</span><br></pre></td></tr></table></figure>







<p><font style="color:rgb(34, 34, 34);"></font></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>索引分析与优化</title>
    <url>/2023/06/15/%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a><font style="color:rgb(34, 34, 34);">EXPLAIN</font></h3><p><font style="color:rgb(34, 34, 34);">MySQL 提供了一个 EXPLAIN 命令，它可以对 SELECT 语句进行分析，并输出 SELECT 执行的详细信息，供开发人员有针对性的优化。例如：</font></p>
<p><font style="color:rgb(34, 34, 34);">EXPLAIN SELECT * from user WHERE id &lt; 3;</font></p>
<p><font style="color:rgb(34, 34, 34);">EXPLAIN 命令的输出内容大致如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582561774-3eca4d5a-9d80-402a-9bf5-941d77d94c23.png"></p>
<span id="more"></span>
<p><strong><font style="color:rgb(34, 34, 34);">1. select_type</font></strong><font style="color:rgb(34, 34, 34);">:</font><font style="color:rgb(34, 34, 34);">表示查询的类型。常用的值如下：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">SIMPLE ： 表示查询语句不包含子查询或union</font></li>
<li><font style="color:rgb(34, 34, 34);">PRIMARY：表示此查询是最外层的查询</font></li>
<li><font style="color:rgb(34, 34, 34);">UNION：表示此查询是UNION的第二个或后续的查询</font></li>
<li><font style="color:rgb(34, 34, 34);">DEPENDENT UNION：UNION中的第二个或后续的查询语句，使用了外面查询结果</font></li>
<li><font style="color:rgb(34, 34, 34);">UNION RESULT：UNION的结果</font></li>
<li><font style="color:rgb(34, 34, 34);">SUBQUERY：SELECT子查询语句</font></li>
<li><font style="color:rgb(34, 34, 34);">DEPENDENT SUBQUERY：SELECT子查询语句依赖外层查询的结果。</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">最常见的查询类型是SIMPLE，表示我们的查询没有子查询也没用到UNION查询。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">2.type</font></strong><font style="color:rgb(34, 34, 34);">表示存储引擎查询数据时采用的方式。比较重要的一个属性，通过它可以判断出查询是全表扫描还是基于索引的部分扫描。常用属性值如下，从上至下效率依次增强。</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">ALL：表示全表扫描，性能最差。</font></li>
<li><font style="color:rgb(34, 34, 34);">index：表示基于索引的全表扫描，先扫描索引再扫描全表数据。</font></li>
<li><font style="color:rgb(34, 34, 34);">range：表示使用索引范围查询。使用&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、in等等。</font></li>
<li><font style="color:rgb(34, 34, 34);">ref：表示使用非唯一索引进行单值查询。</font></li>
<li><font style="color:rgb(34, 34, 34);">eq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录，都只能匹配后面表的一行结果。</font></li>
<li><font style="color:rgb(34, 34, 34);">const：表示使用主键或唯一索引做等值查询，常量查询。</font></li>
<li><font style="color:rgb(34, 34, 34);">NULL：表示不用访问表，速度最快。</font></li>
</ul>
<p><strong><font style="color:rgb(34, 34, 34);">3. possible_keys</font></strong><font style="color:rgb(34, 34, 34);">表示查询时能够使用到的索引。注意并不一定会真正使用，显示的是索引名称。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">4. key</font></strong><font style="color:rgb(34, 34, 34);">表示查询时真正使用到的索引，显示的是索引名称。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">5. rows</font></strong><font style="color:rgb(34, 34, 34);">MySQL查询优化器会根据统计信息，估算SQL要查询到结果需要扫描多少行记录。原则上rows是越少效率越高，可以直观的了解到SQL效率高低。</font></p>
<p><strong><font style="color:rgb(34, 34, 34);">6. key_len</font></strong><font style="color:rgb(34, 34, 34);">表示查询使用了索引的字节数量。可以判断是否全部使用了组合索引。key_len的计算规则如下：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">字符串类型</font><font style="color:rgb(34, 34, 34);">字符串长度跟字符集有关：latin1&#x3D;1、gbk&#x3D;2、utf8&#x3D;3、utf8mb4&#x3D;4</font><font style="color:rgb(34, 34, 34);">char(n)：n*字符集长度</font><font style="color:rgb(34, 34, 34);">varchar(n)：n * 字符集长度 + 2字节</font></li>
<li><font style="color:rgb(34, 34, 34);">数值类型</font><font style="color:rgb(34, 34, 34);">TINYINT：1个字节</font><font style="color:rgb(34, 34, 34);">SMALLINT：2个字节</font><font style="color:rgb(34, 34, 34);">MEDIUMINT：3个字节</font><font style="color:rgb(34, 34, 34);">INT、FLOAT：4个字节</font><font style="color:rgb(34, 34, 34);">BIGINT、DOUBLE：8个字节</font></li>
<li><font style="color:rgb(34, 34, 34);">时间类型</font><font style="color:rgb(34, 34, 34);">DATE：3个字节</font><font style="color:rgb(34, 34, 34);">TIMESTAMP：4个字节</font><font style="color:rgb(34, 34, 34);">DATETIME：8个字节</font></li>
<li><font style="color:rgb(34, 34, 34);">字段属性</font><font style="color:rgb(34, 34, 34);">NULL属性占用1个字节，如果一个字段设置了NOT NULL，则没有此项。</font></li>
</ul>
<p><strong><font style="color:rgb(34, 34, 34);">7. Extra</font></strong><font style="color:rgb(34, 34, 34);">Extra表示很多额外的信息，各种操作会在Extra提示相关信息，常见几种如下：</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">Using where</font><font style="color:rgb(34, 34, 34);">表示查询需要通过索引回表查询数据。</font></li>
<li><font style="color:rgb(34, 34, 34);">Using index</font><font style="color:rgb(34, 34, 34);">表示查询需要通过索引，索引就可以满足所需数据。</font></li>
<li><font style="color:rgb(34, 34, 34);">Using filesort</font><font style="color:rgb(34, 34, 34);">表示查询出来的结果需要额外排序，数据量小在内存，大的话在磁盘，因此有Using filesort建议优化。</font></li>
<li><font style="color:rgb(34, 34, 34);">Using temprorary查询使用到了临时表，一般出现于去重、分组等操作。</font></li>
</ul>
<h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a><font style="color:rgb(34, 34, 34);">回表查询</font></h3><p><font style="color:rgb(34, 34, 34);">InnoDB索引有聚簇索引和辅助索引。聚簇索引的叶子节点存储行记录，InnoDB必须要有，且只有一个。辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记录，通常情况下，需要扫码两遍索引树。先通过辅助索引定位主键值，然后再通过聚簇索引定位行记录，这就叫做</font><strong><font style="color:rgb(34, 34, 34);">回表查询</font></strong><font style="color:rgb(34, 34, 34);">，它的性能比扫一遍索引树低。总结：通过索引查询主键值，然后再去聚簇索引查询记录信息</font></p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><font style="color:rgb(34, 34, 34);">覆盖索引</font></h3><p><font style="color:rgb(34, 34, 34);">在MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为Using</font><font style="color:rgb(34, 34, 34);">index时，能够触发索引覆盖。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/25873401/1656582583684-130fc794-b0d8-4a44-b0c4-995a7b1499ea.png"></p>
<p><strong><font style="color:rgb(34, 34, 34);">只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫做索引覆盖</font></strong><font style="color:rgb(34, 34, 34);">。实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。</font></p>
<p><font style="color:rgb(34, 34, 34);"></font></p>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a><strong><font style="color:black;">最左前缀原则</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「组合索引使用时遵循最左前缀原则，最左前缀顾名思义，就是最左优先，即查询中使用到最左边的列， 那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717061817669-5ea5e340-a576-4631-9ab0-5af75552ac2b.webp"></p>
<h3 id="索引与排序"><a href="#索引与排序" class="headerlink" title="索引与排序"></a><font style="color:rgb(34, 34, 34);">索引与排序</font></h3><p><font style="color:rgb(34, 34, 34);">MySQL查询支持filesort和index两种方式的排序，</font></p>
<ul>
<li><font style="color:rgb(34, 34, 34);">filesort是先把结果查出，然后在缓存或磁盘进行排序操作，效率较低。</font></li>
<li><font style="color:rgb(34, 34, 34);">index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。</font></li>
</ul>
<h4 id="排序方式的选择"><a href="#排序方式的选择" class="headerlink" title="排序方式的选择"></a><font style="color:black;">排序方式的选择</font></h4><h5 id="使用index排序的场景"><a href="#使用index排序的场景" class="headerlink" title="使用index排序的场景"></a>使用<font style="color:rgb(34, 34, 34);">index排序的场景</font></h5><p><font style="color:black;">ORDER BY 子句索引列组合满足索引最左前列</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select id from user order by id; //对应(id)、(id,name)索引有效</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">WHERE子句+ORDER BY子句索引列组合满足索引最左前缀</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age,name)组合索引</span><br><span class="line">explain select id from user where age=18 order by name;</span><br></pre></td></tr></table></figure>

<h5 id="使用filesort方式的排序的场景"><a href="#使用filesort方式的排序的场景" class="headerlink" title="使用filesort方式的排序的场景"></a>使用filesort方式的排序的场景</h5><p><font style="color:black;">对索引列</font>同时使用了<font style="color:black;">ASC和DESC</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age,name)组合索引</span><br><span class="line">explain select id from user order by age asc,name desc;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">WHERE子句和ORDER BY子句满足最左前缀，但where子句使用了范围查询（例如&gt;、&lt;、in 等）</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age,name)组合索引</span><br><span class="line">explain select id from user where age&gt;10 order by name;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">ORDER BY或者WHERE+ORDER BY索引列没有满足索引最左前缀</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age,name)组合索引</span><br><span class="line">explain select id from user order by name;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">使用了不同的索引，MySQL每次只采用一个索引，ORDER BY涉及了两个索引</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(name)、(age)两个索引</span><br><span class="line">explain select id from user order by name,age;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">WHERE子句与ORDER BY子句，使用了不同的索引</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(name)、(age)索引</span><br><span class="line">explain select id from user where name=&#x27;tom&#x27; order by age;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">WHERE子句或者ORDER BY子句中索引列使用了表达式，包括函数表达式</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对应(age)索引</span><br><span class="line">explain select id from user order by abs(age);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(0, 0, 0);"></font></p>
<h4 id="filesort排序"><a href="#filesort排序" class="headerlink" title="filesort排序"></a><font style="color:rgb(34, 34, 34);">filesort排序</font></h4><p><strong><font style="color:rgb(34, 34, 34);">filesort有两种排序算法：双路排序和单路排序。</font></strong></p>
<h5 id="双路排序"><a href="#双路排序" class="headerlink" title="双路排序"></a><font style="color:rgb(34, 34, 34);">双路排序</font></h5><p><font style="color:rgb(34, 34, 34);">需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序；第二次去读取其他字段数据。</font></p>
<h5 id="单路排序"><a href="#单路排序" class="headerlink" title="单路排序"></a><font style="color:rgb(34, 34, 34);">单路排序</font></h5><p><font style="color:rgb(34, 34, 34);">从磁盘查询所需的所有列数据，然后在内存排序将结果返回。</font></p>
<p><font style="color:rgb(34, 34, 34);"></font></p>
<p><font style="color:rgb(34, 34, 34);">如果查询数据超出缓存sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。</font></p>
<p><font style="color:rgb(34, 34, 34);">解决方案：少使用select *；增加sort_buffer_size容量和max_length_for_sort_data容量。</font></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>索引失效场景</title>
    <url>/2023/06/11/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<ol>
<li>没有遵从最左原则：因为常用的索引是B+树结构的，而B+树是有序的，而这个有序是根据索引最左边的字段排序的，所以相对的组合索引中其他的字段并不是有序的</li>
<li>范围查询放在最后（这里需要注意并不是在写语句的时候讲范围查询放在最后，而是将索引字段中可能出现范围查询的字段放在最后）</li>
<li>使用select  from table 聚合索引和非聚合索引的差距就在于聚合索引的根保存的是完整的数据，而非聚合索引保存的是索引的值+聚合索引的Key，所以这里就引出了覆盖索引的概念，当你搜索的值都是索引列，就会用到覆盖索引，直接返回结果，不用再使用聚合索引的key去回表查询，效率就会有所提高。select * 大概率是要回表的。</li>
<li>索引列上有计算。+ - 等</li>
<li>索引列上使用了函数  sum  cover</li>
<li>索引列是字符串的搜索的时候没有加’’ 比如 123 - ‘123’</li>
<li>在不可为空列中使用is null 和 is not null</li>
<li>like 左边有%</li>
<li>or两边的列不一致会导致索引实现  可以使用union</li>
</ol>
<span id="more"></span>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>锁</title>
    <url>/2023/06/11/%E9%94%81/</url>
    <content><![CDATA[<p><font style="color:rgb(0, 0, 0);">MySQL中的锁有很多种，各种锁应用在不同的地方。</font><strong><font style="color:rgb(145, 109, 213);">「MySQL依靠锁机制可以让多个事务更新一行数据的时候串行化」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h3 id="MySQL中锁总的来说有两种概念：Lock和Latch"><a href="#MySQL中锁总的来说有两种概念：Lock和Latch" class="headerlink" title="MySQL中锁总的来说有两种概念：Lock和Latch"></a><font style="color:black;">MySQL中锁总的来说有两种概念：Lock和Latch</font></h3><h4 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a><font style="color:black;">Latch</font></h4><p><font style="color:black;">称为闩锁（轻量级的锁），因为Latch要求锁定的时间非常短。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。在InnoDB引擎中，Latch又分为mutex（互斥量）和rwlock（读写锁）。</font></p>
<p><font style="color:black;">mutex：互斥量；有时候有些资源需要共享和并发，但是又不是分频繁，所以向操作系统申请一个mutex，mutex都是排他的。</font></p>
<p><font style="color:black;"> RW-LATCH : 读写锁</font></p>
<span id="more"></span>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><font style="color:black;">Lock</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「Lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行」</font></strong><font style="color:black;">。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。</font></p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a><font style="color:black;">锁的分类</font></h3><p><font style="color:rgb(0, 0, 0);">实际上MySQL的锁在不同的维度上划分是多种多样的，在特地的场景下，发挥不一样的作用，下面来看看锁的分类。</font></p>
<h3 id="按照粒度划分："><a href="#按照粒度划分：" class="headerlink" title="按照粒度划分："></a>按照粒度划分：</h3><h4 id="全局锁："><a href="#全局锁：" class="headerlink" title="全局锁："></a>全局锁：</h4><p><strong><font style="color:rgb(145, 109, 213);">「全局锁，即对整个数据库实例加锁」</font></strong><font style="color:rgb(0, 0, 0);">。一般当我们需要让整个库处于只读状态的时候，可以给数据库加上全局锁。</font><strong><font style="color:rgb(145, 109, 213);">「加上全局锁之后其他线程的：数据更新语句（增删改）、数据定义语句（包括建表、修改表结构等）都会被阻塞」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h4 id="表级锁（粒度大，性能开销小，并发量小）："><a href="#表级锁（粒度大，性能开销小，并发量小）：" class="headerlink" title="表级锁（粒度大，性能开销小，并发量小）："></a>表级锁（粒度大，性能开销小，并发量小）：</h4><p><strong><font style="color:rgb(145, 109, 213);">「表级别的锁定是MySQL各【存储引擎中】最大颗粒度的锁定机制」</font></strong><font style="color:rgb(0, 0, 0);">。由于直接锁定一张表，所以获取锁和释放锁的速度很快，避免了死锁问题，但是出现锁定资源争用的概率也最高，并发量降低。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「表锁的加锁语法」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#隐式上锁（默认，自动加锁自动释放</span><br><span class="line">insert、update、delete //上写锁</span><br><span class="line">#显式上锁（手动）</span><br><span class="line">lock table tableName read;//读锁</span><br><span class="line">lock table tableName write;//写锁</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「表锁的释放锁语法」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">客户端断开的时候也会自动释放锁。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「查看表上加过的锁」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show open tables;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「MyISAM引擎默认的锁是表锁」</font></strong><font style="color:rgb(0, 0, 0);">。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。</font></p>
<h5 id="「表级读锁」"><a href="#「表级读锁」" class="headerlink" title="「表级读锁」"></a><font style="color:rgb(145, 109, 213);">「表级读锁」</font></h5><p><font style="color:rgb(0, 0, 0);">当前表加read锁，当前连接和其他的连接都可以读操作；但是当前连接写操作会报错，其他连接写操作会被阻塞。</font></p>
<h5 id="「表级写锁」"><a href="#「表级写锁」" class="headerlink" title="「表级写锁」"></a><font style="color:rgb(145, 109, 213);">「表级写锁」</font></h5><p><font style="color:rgb(0, 0, 0);">当前表加write锁，当前连接可以对表做读写操作，其他连接对该表所有操作（读写操作）都被阻塞。</font></p>
<h5 id="「意向锁」"><a href="#「意向锁」" class="headerlink" title="「意向锁」"></a><font style="color:rgb(145, 109, 213);">「意向锁」</font></h5><h6 id="意向锁是什么"><a href="#意向锁是什么" class="headerlink" title="意向锁是什么"></a><font style="color:black;">意向锁是什么</font></h6><p><strong><font style="color:rgb(145, 109, 213);">「意向锁（Intention Lock）简称I锁，是一种表级锁」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB 实现了标准的行级锁，包括：共享锁（S锁）、排它锁（X锁）」</font></strong><font style="color:black;">，那么为什么需要引入意向锁呢？意向锁解决了什么问题？</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">假设，事务A获取了某一行记录的排它锁，事物A尚未提交,事务B想要获取表锁时，则事物B必须要确认表的每一行都不存在排他锁，需要进行全表扫描，效率很低，此时就引入意向锁</font></p>
<p>:::</p>
<ul>
<li><font style="color:rgb(1, 1, 1);">如果事务A获取了某一行记录的排它锁，实际此时表存在两种锁，行记录的排他锁和表上的意向排他锁。</font></li>
<li><font style="color:rgb(1, 1, 1);">如果事务B试图在该表加表级锁时，则会被意向锁阻塞，因此事物B不必检查各个页锁或行锁，而只需检查表上的意向即可。</font></li>
</ul>
<p><font style="color:rgb(0, 0, 0);">如上，数据库中存储数据，范围由大到小：表–&gt;页–&gt;行，加锁也是分别加在表–&gt;页–&gt;行中，当我们把锁加在更大一级范围时，也就不需要全表扫描下一级的某些锁，可以很大程度提升性能。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，即意向锁」</font></strong></p>
<p><font style="color:black;">通过上述描述我们知道</font><strong><font style="color:rgb(145, 109, 213);">「意向锁是加在表上，用于防止全表扫描的一种锁，即意向锁是表锁」</font></strong><font style="color:black;">。意向锁分为两种类型：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「意向共享锁（intention shared lock）」</font></strong><font style="color:rgb(1, 1, 1);">简称IS锁，事务想要给某一个数据行加行级共享锁（S锁）之前必须先获取该表的IS锁（表级锁）</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「意向排他锁（intention exclusive lock）」</font></strong><font style="color:rgb(1, 1, 1);">简称IX锁，事务想要给某一个数据行加行级排他锁（X锁）之前必须先获取该表的IX锁（表级锁）</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「【意向锁都是InnoDB存储引擎自己维护的,用户是无法操作意向锁的】」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「在为数据行加共享锁&#x2F;排他锁之前，InooDB会先获取该数据行所在在数据表的对应意向锁(表级锁)」</font></strong><font style="color:black;">，如果没有获取到，否则等待innodb_lock_wait_timeout超时后根据innodb_rollback_on_timeout决定是否回滚事务。</font></p>
<p>:::tips<br><font style="color:black;">从锁粒度角度：InnoDB 允许行级锁与表级锁共存,而意向锁是表锁；</font></p>
<p><font style="color:black;">从锁模式角度：意向锁是一种独立类型，辅助解决记录锁效率不及的问题；</font></p>
<p><font style="color:black;">从兼容性角度：意向锁包含了共享&#x2F;排他两种。</font></p>
<p>:::</p>
<h6 id="意向锁的兼容互斥性"><a href="#意向锁的兼容互斥性" class="headerlink" title="意向锁的兼容互斥性"></a><font style="color:black;">意向锁的兼容互斥性</font></h6><ul>
<li><font style="color:rgb(1, 1, 1);">意向锁之间的兼容互斥性：意向锁之间是互相兼容的</font></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:black;">   </font></strong></th>
<th align="left"><strong><font style="color:black;">意向共享锁（IS）</font></strong></th>
<th align="left"><strong><font style="color:black;">意向排他锁（IX）</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:black;">意向共享锁（IS）</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
</tr>
<tr>
<td align="left"><font style="color:black;">意向排他锁（IX）</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
</tr>
</tbody></table>
<ul>
<li><font style="color:rgb(1, 1, 1);">意向锁与其他锁兼容互斥性：意向锁与普通的排他锁&#x2F;共享锁互斥</font></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:black;">   </font></strong></th>
<th align="left"><strong><font style="color:black;">意向共享锁（IS）</font></strong></th>
<th align="left"><strong><font style="color:black;">意向排他锁（IX）</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:black;">表级共享锁（S）</font></td>
<td align="left"><font style="color:black;">兼容</font></td>
<td align="left"><font style="color:black;">互斥</font></td>
</tr>
<tr>
<td align="left"><font style="color:black;">表级排他锁（X）</font></td>
<td align="left"><font style="color:black;">互斥</font></td>
<td align="left"><font style="color:black;">互斥</font></td>
</tr>
</tbody></table>
<p><strong><font style="color:rgb(145, 109, 213);">「上述的排他锁（X锁）共享锁（S锁）指的都是表锁，意向锁不会与行级的共享锁&#x2F;排他锁互斥」</font></strong></p>
<h5 id="「自增锁」"><a href="#「自增锁」" class="headerlink" title="「自增锁」"></a><font style="color:rgb(145, 109, 213);">「自增锁」</font></h5><p>所有插入数据的方式总共分三类，分别是：</p>
<ul>
<li>Simple inserts （简单插入），可以预先确定要插入的行数。</li>
<li>Bulk inserts (批量插入)，事先不知道要插入的行数。</li>
<li>Mixed-mode-inserts (混合模式插入)，只指定了部分id的值，还有未知id。</li>
</ul>
<p>在插入时，mysql采用自增锁的方式来实现。当向使用auto_increment列插入数据时需要获取一种特殊的表级锁，在插入语句时加一个自增锁。然后再语句执行后，再把自增锁释放掉。一个事务再持有锁时，其他事务的插入语句都要被阻塞，所以并发性并不高。所以innodb通过innodb_autoinc_lock_mode的不同取值来提供不同的锁定机制。</p>
<p>0 （传统锁定模式），并发差，就如上面所说的流程。</p>
<p>1 （连续锁定模式） ，mysql8.0之前默认的模式。对于插入数量已知情况下，只在分配过程中保持，而不是直到语句完成。</p>
<p>2 （交错锁定模式），在这种模式下，所有类insert语句都不会使用表级自增锁。自动递增保证在所有并发执行中是唯一且单调递增的。但是可能存在间隙。</p>
<h5 id="「元数据锁」"><a href="#「元数据锁」" class="headerlink" title="「元数据锁」"></a><font style="color:rgb(145, 109, 213);">「元数据锁」</font></h5><p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">当我们查询查询一个表中的数据时，另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构就不一致了，这肯定是允许。这里就用到了元数据锁</font></p>
<p>:::</p>
<p><font style="color:black;">在MySQL 5.5版本中引入了MDL，</font><strong><font style="color:rgb(145, 109, 213);">「元数据锁(MDL) 不需要显式使用，在访问一个表的时候会被自动加上」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「当对一个表做增删改查的时候会加上【MDL读锁】」</font></strong></li>
</ul>
<p><font style="color:black;">读锁之间不互斥，因此可以有多个线程同时对一张表增删改查操作。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「当对一个表做结构变更的时候会加上【MDL写锁】」</font></strong></li>
</ul>
<p><font style="color:black;">读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。</font></p>
<h4 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h4><p><strong><font style="color:rgb(145, 109, 213);">「每次锁定相邻的一组记录」</font></strong><font style="color:black;">，锁定粒度、开销和加锁时间都界于表锁和行锁之间，并发度一般。</font></p>
<p><font style="color:black;">应用在BDB 存储引擎中</font></p>
<h4 id="行级锁（粒度小，加锁开销大，并发量好）："><a href="#行级锁（粒度小，加锁开销大，并发量好）：" class="headerlink" title="行级锁（粒度小，加锁开销大，并发量好）："></a>行级锁（粒度小，加锁开销大，并发量好）：</h4><p><strong><font style="color:rgb(145, 109, 213);">「行锁顾名思义就是对数据行进行加锁。行锁的锁定颗粒度在 MySQL中是最细的，应用于 InnoDB 存储引擎，通过对索引数据页上的记录加锁实现的【即行锁是针对索引加锁】」</font></strong></p>
<h5 id="「行锁的优缺点」"><a href="#「行锁的优缺点」" class="headerlink" title="「行锁的优缺点」"></a><font style="color:rgb(145, 109, 213);">「行锁的优缺点」</font></h5><p><font style="color:rgb(0, 0, 0);">并发情况下，产生锁等待的概率较低，支持较大的并发数，但开销大，加锁慢，而且会出现死锁。</font></p>
<h5 id="「行锁的前提条件」"><a href="#「行锁的前提条件」" class="headerlink" title="「行锁的前提条件」"></a><font style="color:rgb(145, 109, 213);">「行锁的前提条件」</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「检索数据时需要通过索引，【因为 InnoDB 是通过给索引的索引项加锁来实现行锁的】」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">在不通过索引条件查询的时候，InnoDB 会使用表锁，表锁会产生锁冲突</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「行锁是针对索引加锁」</font></strong><font style="color:rgb(1, 1, 1);">，所以即使访问的不同记录，只要使用的是同一索引项，也可能会出现锁冲突。</font></li>
</ul>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">MySQL会比较不同执行计划，当全表扫描比索引效率更高时，InnoDB就使用表锁。因此不一定使用了索引就一定会使用行锁，也有可能使用表锁。</font></p>
<p>:::</p>
<h5 id="「行锁会产生死锁」"><a href="#「行锁会产生死锁」" class="headerlink" title="「行锁会产生死锁」"></a><font style="color:rgb(145, 109, 213);">「行锁会产生死锁」</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「实际上InnoDB 的行锁也是分为两步获得的：锁住主键索引，锁住非主键索引」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p>:::tips<br><font style="color:black;">当两个事务同时执行时，</font></p>
<p><font style="color:black;">一个锁住了主键索引，在等待其他索引；</font></p>
<p><font style="color:black;">另一个锁住了非主键索引，在等待主键索引，</font></p>
<p><font style="color:black;">这样就可能会发生死锁。</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB可以检测到这种死锁，检测到后会让其中一个事务释放锁回退，另一个获取锁完成事务」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h5 id="「行锁的实现算法」"><a href="#「行锁的实现算法」" class="headerlink" title="「行锁的实现算法」"></a><font style="color:rgb(145, 109, 213);">「行锁的实现算法」</font></h5><p><font style="color:black;">前面讲到</font><strong><font style="color:rgb(145, 109, 213);">「InnoDB行锁是通过对 索引数据页上的记录加锁实现的」</font></strong><font style="color:black;">，接下来看看它具体是怎么实现，</font></p>
<p><font style="color:black;">InnoDB存储引擎有3种实现行锁的算法：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「【Record Lock】：记录锁，单个行记录上的锁」</font></strong></li>
</ul>
<p><font style="color:black;">RC、RR隔离级别都支持，如果表中没有主键和任何一个索引，那InnoDB会使用隐式的主键来进行锁定。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「【Gap Lock】：间隙锁，锁定一个范围，但不包含记录本身」</font></strong></li>
</ul>
<p><font style="color:black;">范围锁，锁定索引记录范围，确保索引记录的间隙不变，RR隔离级别支持</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「【Next-Key Lock】：Gap Lock与Record Lock的组合」</font></strong></li>
</ul>
<p><font style="color:black;">锁定数据前后范围，并且锁定记录本身，RR隔离级别支持</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「在RR隔离级别，InnoDB对于行的查询都是采用【Next-Key Lock】的组合锁定算法」</font></strong><font style="color:black;">，但是</font><strong><font style="color:rgb(145, 109, 213);">「在查询的列是唯一索引（包含主键索引）的情况下，Next-key Lock会降级为Record Lock，仅锁住索引本身而非范围」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:rgb(0, 0, 0);">下面具体看下针对不同的sql语句采用的是那种加锁方式：</font></p>
<p><font style="color:rgb(0, 0, 0);">查询语句类型一</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... from  ...</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「对于普通的select语句，InnoDB引擎采用MVCC机制实现非阻塞读，【InnoDB引擎不加锁】」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">查询语句类型二</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... from ... lock in share mode</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「添加共享锁，InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">查询语句类型三</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... from ... for update</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「添加排他锁，InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">修改语句</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update ... from ... where  ...</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">删除语句</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete ... from ... where</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB会使用Next-Key Lock锁进行处理，扫描如果有唯一索引，则降级为RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:rgb(0, 0, 0);">插入语句</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert ... from  ...</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB会在将要插入的那一行设置一个排他的RecordLock锁」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h5 id="「行锁的分类」"><a href="#「行锁的分类」" class="headerlink" title="「行锁的分类」"></a><font style="color:rgb(145, 109, 213);">「行锁的分类」</font></h5><h6 id="「共享锁（Shared-Lock）又称为读锁，简称S锁，是一种行级锁」"><a href="#「共享锁（Shared-Lock）又称为读锁，简称S锁，是一种行级锁」" class="headerlink" title="「共享锁（Shared Lock）又称为读锁，简称S锁，是一种行级锁」"></a><font style="color:rgb(145, 109, 213);">「共享锁（Shared Lock）又称为读锁，简称S锁，是一种行级锁」</font><font style="color:rgb(0, 0, 0);"></font></h6><p><font style="color:rgb(0, 0, 0);">顾名思义：</font><strong><font style="color:rgb(145, 109, 213);">「共享锁就是多个事务对于同一数据共享一把锁，都能访问到数据，但是只能读不能修改」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「加锁方式」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... from ... lock in share mode</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「释放方式」</font></strong><font style="color:black;">：</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「共享锁工作原理」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「一个事务获取了一条记录的共享锁后，其他事务也能获得该记录对应的共享锁，但不能获得排他锁」</font></strong><font style="color:black;">。即一个事务使用了共享锁（读锁），其他事务只能读取，不能写入，写操作被阻塞。</font></p>
<h6 id="「排他锁（EXclusive-Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」"><a href="#「排他锁（EXclusive-Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」" class="headerlink" title="「排他锁（EXclusive Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」"></a><font style="color:rgb(145, 109, 213);">「排他锁（EXclusive Lock）又称为写锁，简称X锁，是一种行锁也可以是表锁」</font></h6><p><font style="color:black;">顾名思义：</font><strong><font style="color:rgb(145, 109, 213);">「排他锁就是不能与其他锁并存，即当前写操作没有完成前，会阻断其他写锁和读锁」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「加锁方式」</font></strong></li>
</ul>
<p><font style="color:black;">innodb引擎默认会在update，delete语句加上 for update</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ...  # 排他锁</span><br><span class="line">DELETE FROM student WHERE ...  # 排他锁</span><br><span class="line">UPDATE student SET ...  # 排他锁</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「释放方式」</font></strong><font style="color:black;">：</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「共享锁工作原理」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「如一个事务获取了一条记录的排他锁，其他事务就不能对该行记录做其他操作，也不能获取该行的锁（共享锁、排他锁），但是获取到排他锁的事务可以对数据进行读写操作」</font></strong><font style="color:black;">。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">这里要注意一下，其他事务不加锁的读是不会被阻塞的，阻塞的是加锁的读</font></p>
<p>:::</p>
<h6 id="「间隙锁-Gap-Locks」"><a href="#「间隙锁-Gap-Locks」" class="headerlink" title="「间隙锁 Gap Locks」"></a><font style="color:rgb(145, 109, 213);">「间隙锁 </font><a href="https://so.csdn.net/so/search?q=Gap&spm=1001.2101.3001.7020"><font style="color:rgb(145, 109, 213);">Gap</font></a><font style="color:rgb(145, 109, 213);"> Locks」</font></h6><p>间隙锁（Gap Locks）是数据库中用于锁定索引范围的一种锁。它们的主要目的是防止其他事务在给定范围内插入新的数据，保证范围内数据的一致性和避免幻读现象。</p>
<p>:::tips<br><strong><font style="color:rgb(25, 27, 31);">间隙锁的锁定范围是指在索引范围之间的间隙</font></strong></p>
<p>:::</p>
<p><font style="color:rgb(25, 27, 31);">举个简单例子来说明：</font></p>
<p><font style="color:rgb(25, 27, 31);">假设有一个名为</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">products</font><font style="color:rgb(25, 27, 31);">的表，其中有一个整型列</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">product_id</font><font style="color:rgb(25, 27, 31);">作为主键索引。现在有两个并发事务：事务A和事务B。</font></p>
<p><font style="color:rgb(25, 27, 31);">事务A执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM `products` WHERE `product_id` BETWEEN 100 and 200 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">事务B执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">INSERT INTO `products` (`product_id`, `name`) VALUES (150, &#x27;Product 150&#x27;);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">在这种情况下，事务A会在</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">products</font><font style="color:rgb(25, 27, 31);">表中</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">product_id</font><font style="color:rgb(25, 27, 31);">值在 100 和 200 之间的范围上设置间隙锁。因此，在事务A运行期间，其他事务无法在这个范围内插入新的数据，在事务B尝试插入</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">product_id</font><font style="color:rgb(25, 27, 31);">为150的记录时，由于该记录位于事务A锁定的间隙范围内，事务B将被阻塞，直到事务A释放间隙锁为止。</font></p>
<p><font style="color:rgb(25, 27, 31);">触发条件：</font></p>
<p><font style="color:rgb(25, 27, 31);">在可重复读（Repeatable Read）事务隔离级别下，以下情况会产生间隙锁：</font></p>
<ul>
<li><font style="color:rgb(25, 27, 31);">使用普通索引锁定：当一个事务使用普通索引进行条件查询时，MySQL会在满足条件的索引范围之间的间隙上生成间隙锁。</font></li>
<li><font style="color:rgb(25, 27, 31);">使用多列唯一索引：如果一个表存在多列组成的唯一索引，并且事务对这些列进行条件查询时，MySQL会在满足条件的索引范围之间的间隙上生成间隙锁。</font></li>
<li><font style="color:rgb(25, 27, 31);">使用唯一索引锁定多行记录：当一个事务使用唯一索引来锁定多行记录时，MySQL会在这些记录之间的间隙上生成间隙锁，以确保其他事务无法在这个范围内插入新的数据。</font></li>
</ul>
<p><font style="color:rgb(25, 27, 31);">需要注意的是，上述情况仅在可重复读隔离级别下才会产生间隙锁。在其他隔离级别下，如读提交（Read Committed）隔离级别，MySQL可能会使用临时的意向锁来避免并发问题，而不是生成真正的间隙锁。</font></p>
<p><font style="color:rgb(25, 27, 31);">为什么这里强调的是普通索引呢？因为对唯一索引锁定并不会触发间隙锁，请看下面这个例子：</font></p>
<p><font style="color:rgb(25, 27, 31);">假设我们有一个名为</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">students</font><font style="color:rgb(25, 27, 31);">的表，其中有两个字段：id 和 name。id是主键，现在有两个事务同时进行操作：</font></p>
<p><font style="color:rgb(25, 27, 31);">事务A执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM students WHERE id = 1 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">事务B执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO students (id, name) VALUES (2, &#x27;John&#x27;);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">由于事务A使用了唯一索引锁定，它会锁定id为1的记录，不会触发间隙锁。同时，在事务B中插入id为2的记录也不会受到影响。这是因为唯一索引只会锁定匹配条件的具体记录，而不会锁定不存在的记录（如间隙）。</font></p>
<p><strong><font style="color:rgb(25, 27, 31);">当使用唯一索引锁定一条存在的记录时，会使用记录锁，而不是间隙锁</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">但是当搜索条件仅涉及到多列唯一索引的一部分列时，可能会产生间隙锁。以下是一个例子：</font></p>
<p><font style="color:rgb(25, 27, 31);">假设</font><font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">students</font><font style="color:rgb(25, 27, 31);">表，包含三个列：id、name和age。我们在(name, age)上创建了一个唯一索引。</font></p>
<p><font style="color:rgb(25, 27, 31);">现在有两个事务同时进行操作：</font></p>
<p><font style="color:rgb(25, 27, 31);">事务A执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM students WHERE name = &#x27;John&#x27; FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">事务B执行以下语句：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO students (id, name, age) VALUES (2, &#x27;John&#x27;, 25);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">在这种情况下，事务A搜索的条件只涉及到了唯一索引的一部分列（name），而没有涉及到完整的索引列（name, age）。因此，MySQL会对匹配的记录加上行锁，并且还会对与该条件范围相邻的间隙加上间隙锁。</font></p>
<p><font style="color:rgb(25, 27, 31);">间隙锁加锁规则：</font></p>
<p><font style="color:rgb(25, 27, 31);">间隙锁有以下加锁规则：</font></p>
<ul>
<li><font style="color:rgb(25, 27, 31);">规则1：加锁的基本单位是 Next-Key Lock，左开右闭区间。</font></li>
<li><font style="color:rgb(25, 27, 31);">规则2：查找过程中访问到的对象才会加锁。</font></li>
<li><font style="color:rgb(25, 27, 31);">规则3：唯一索引上的范围查询会上锁到不满足条件的第一个值为止。</font></li>
<li><font style="color:rgb(25, 27, 31);">规则4：唯一索引等值查询，并且记录存在，Next-Key Lock 退化为行锁。</font></li>
<li><font style="color:rgb(25, 27, 31);">规则5：索引上的等值查询，会将距离最近的左边界和右边界作为锁定范围，如果索引不是唯一索引还会继续向右匹配，直到遇见第一个不满足条件的值，如果最后一个值不等于查询条件，Next-Key Lock 退化为间隙锁。</font></li>
</ul>
<p><font style="color:rgb(25, 27, 31);">案例演示</font></p>
<p><font style="color:rgb(25, 27, 31);">环境：MySQL，InnoDB，RR隔离级别。</font></p>
<p><font style="color:rgb(25, 27, 31);">数据表：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `age` int DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">   KEY `age` (`age`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(25, 27, 31);">数据：</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">id</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">age</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">name</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">小明</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">小王</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">7</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">7</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">小张</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">11</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">11</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">小陈</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">在进行测试之前，我们先来看看 user 表中存在的隐藏间隙：</font></p>
<ul>
<li><font style="color:rgb(25, 27, 31);">(-∞, 1]</font></li>
<li><font style="color:rgb(25, 27, 31);">(1, 5]</font></li>
<li><font style="color:rgb(25, 27, 31);">(5, 7]</font></li>
<li><font style="color:rgb(25, 27, 31);">(7, 11]</font></li>
<li><font style="color:rgb(25, 27, 31);">(11, +∞]</font></li>
</ul>
<p><font style="color:rgb(25, 27, 31);">案例一：唯一索引等值锁定存在的数据</font></p>
<p><font style="color:rgb(25, 27, 31);">如下是事务A和事务B执行的顺序：</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &#x3D; 5 for update</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(3,3,”小黑”) —不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(6,6,”小蓝”) —不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">根据规则4，加的是记录锁，不会使用间隙锁，所以只会锁定 5 这一行记录。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例二：索引等值锁定</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &#x3D; 3 for update — 不存在的数据</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(6,6,”小蓝”) — 不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(2,2,”小黄”) — 阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">这是一个索引等值查询，根据规则1和规则5，加锁范围是（ 1，5 ] ，又由于向右遍历时最后一个值 5 不满足查询需求，Next-Key Lock 退化为间隙锁。也就是最终锁定范围区间是 （ 1，5 ）。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例三：唯一索引范围锁定</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &gt;&#x3D; 5 and id&lt;6 for update</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(7,7,”小赵”) — 阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">根据规则3，会上锁到不满足条件的第一个值为止，也就是7，所以最终加锁范围是 [ 5，7 ]。</font></p>
<p><font style="color:rgb(25, 27, 31);">其实这里可以分为两个步骤，第一次用 id&#x3D;5 定位记录的时候，其实加上了间隙锁 （ 1，5 ]，又因为是唯一索引等值查询，所以退化为了行锁，只锁定 5。</font></p>
<p><font style="color:rgb(25, 27, 31);">第二次用 id&lt;6 定位记录的时候，其实加上了间隙锁（ 5，7 ]，所以最终合起来锁定区间是 [ 5，7 ]。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例四：非唯一索引范围锁定</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where age &gt;&#x3D; 5 and age&lt;6 for update</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(8,8,”小青”) — 不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(2,2,”小黄”) — 阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">参考上面那个例子。</font></p>
<p><font style="color:rgb(25, 27, 31);">第一次用 age &#x3D;5 定位记录的时候，加上了间隙锁 （ 1，5 ]，不是唯一索引，所以不会退化为行锁，根据规则5，会继续向右匹配，所以最终合起来锁定区间是 （ 1，7 ]。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例五：间隙锁死锁</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &#x3D; 3 for update</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">select * from user where id &#x3D; 4 for update</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(2,2,”小黄”) — 阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(4,4,”小紫”) — 阻塞</font></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">间隙锁之间不是互斥的，如果一个事务A获取到了（ 1,5 ] 之间的间隙锁，另一个事务B仍然可以获取到（ 1,5 ] 之间的间隙锁。这时就可能会发生死锁问题。</font></p>
<p><font style="color:rgb(25, 27, 31);">在事务A事务提交，间隙锁释放之前，事务B也获取到了间隙锁（ 1,5 ] ，这时两个事务就处于死锁状态。</font></p>
<p><font style="color:rgb(25, 27, 31);">案例六：limit对加锁的影响</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">时刻</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务A</font></strong></th>
<th align="left"><strong><font style="color:rgb(25, 27, 31);">事务B</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T1</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">begin</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T2</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">deletet user where age &#x3D; 6 limt 1</font></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T3</font></td>
<td align="left"></td>
<td align="left"><font style="color:rgb(25, 27, 31);">insert into user value(7,7,”小赵”) — 不阻塞</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T4</font></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(25, 27, 31);">T5</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
<td align="left"><font style="color:rgb(25, 27, 31);">commit</font></td>
</tr>
</tbody></table>
<p><font style="color:rgb(25, 27, 31);">根据规则5，锁定区间应该是 ( 5，7 ]，但是因为加了 limit 1 的限制，因此在遍历到 age&#x3D;6 这一行之后，循环就结束了。</font></p>
<p><font style="color:rgb(25, 27, 31);">根据规则2，查找过程中访问到的对象才会加锁，所以最终锁定区间应该是：( 5，6 ]。</font></p>
<p><font style="color:rgb(25, 27, 31);">总结</font></p>
<p><font style="color:rgb(25, 27, 31);">在本文中，我们讨论了间隙锁的加锁规则。间隙锁是MySQL中用于保护范围查询和防止并发问题的重要机制，了解间隙锁的加锁规则对于优化数据库性能、减少数据冲突以及提高并发性能非常重要。</font></p>
<h6 id="「临界锁-Next-Key-locks」"><a href="#「临界锁-Next-Key-locks」" class="headerlink" title="「临界锁 Next-Key locks」"></a><font style="color:rgb(145, 109, 213);">「临界锁 Next-Key locks」</font></h6><p>临界锁是记录锁和该记录之前间隙锁的组合。</p>
<p>当InnoDB在查询或者遍历一个索引时，它会给所有遍历的行添加共享锁或者排它锁，这就是行级锁。因此，行级锁就是记录锁。临界锁(Next-key lock)就是记录锁加上该记录前的间隙锁。如果一个会话在R记录上持有共享锁或者排它锁，另一个会话不能在R之前的间隙插入数据。加入一个索引包含值为10,11,13,20，那么可能得临界锁范围是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">小括号表示不包含该值，大括号表示包含该值</font><strong><font style="color:rgb(77, 77, 77);">左开右闭</font></strong><font style="color:rgb(77, 77, 77);">。InnoDB默认使用可重复读(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">REPEATABLE READ</font><font style="color:rgb(77, 77, 77);">)的隔离级别，且使用临界锁防止幻读(</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">Phantom rows</font><font style="color:rgb(77, 77, 77);">)</font></p>
<p><font style="color:rgb(77, 77, 77);">临界锁在事务数据中的表现为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`</span><br><span class="line">trx id 10080 lock_mode X</span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>



<h6 id="「插入意向锁-Insert-Intention-Locks-」"><a href="#「插入意向锁-Insert-Intention-Locks-」" class="headerlink" title="「插入意向锁(Insert Intention Locks)」"></a><font style="color:rgb(145, 109, 213);">「插入意向锁(Insert Intention Locks)」</font></h6><p>插入意向锁是INSERT语句中，在行写入之前添加的一种间隙锁。多个事务在写入同一个索引间隙时，如果他们插入的不是同一个位置，那么就不会相互阻塞。比如有两个索引记录为4和7，不同的事务分别准备写入数据5和6，他们都会在4-7上增加插入意向锁锁住这个间隙，但是不会相互阻塞，因为他们写入的是不同的行。</p>
<p><font style="color:rgb(77, 77, 77);">下面这个例子表明，事务在获取排它锁之前会先获取插入意向锁。ClientA新建两条行记录90和102</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;</span><br><span class="line">mysql&gt; INSERT INTO child (id) values (90),(102);</span><br><span class="line"></span><br><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</span><br><span class="line">+-----+</span><br><span class="line">| id  |</span><br><span class="line">+-----+</span><br><span class="line">| 102 |</span><br><span class="line">+-----+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">此时ClientA使用排它间隙锁锁住了(100, 102]。ClientB开启一个事务，并尝试插入101。ClientB会被ClientA的间隙阻塞，等待获取排它锁。这个时候，ClientB获取了插入意向锁。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; INSERT INTO child (id) VALUES (101);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">插入意向锁在事务数据中的表现为：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`</span><br><span class="line">trx id 8731 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000066; asc    f;;</span><br><span class="line"> 1: len 6; hex 000000002215; asc     &quot; ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure>

<h3 id="按照情绪情况来划分："><a href="#按照情绪情况来划分：" class="headerlink" title="按照情绪情况来划分："></a>按照情绪情况来划分：</h3><p><strong><font style="color:rgb(145, 109, 213);">「乐观锁&#x2F;悲观锁其实都是概念上的，只是在并发下防止数据被修改的一种加锁形式」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><font style="color:rgb(0, 0, 0);">悲观锁</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「对数据的修改抱有悲观态度的一种并发控制方式，悲观的认为自己(当前线程)拿到的数据是被修改过的，所以在操作数据之前先加锁」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「悲观锁的形式（类型）」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「数据库的行锁、表锁、读锁、写锁、共享锁、排他锁等，以及syncronized 实现的锁都是悲观锁的范畴」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717493025735-21d37d3d-d44f-4630-9c74-164d49c9a0a5.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「优点」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「可以保证数据的独占性和正确性」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「缺点」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「每次请求都需要加锁、释放锁，这个过程会降低系统性能」</font></strong><font style="color:black;">。</font></p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><font style="color:black;">乐观锁</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「乐观锁是对于数据冲突保持一种乐观态度，每次读取数据的时都认为其他线程不会修改数据，所以不上锁，只是在数据修改后提交时才通过【版本号机制或者CAS算法】来验证数据是否被其他线程更新」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p><font style="color:black;">因为乐观锁中并没有【加锁和解锁】操作，因此乐观锁策略也被称为</font><strong><font style="color:rgb(145, 109, 213);">「无锁编程」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「乐观锁实现的关键点」</font></strong><font style="color:black;">：检测冲突</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「乐观锁实现方式」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">版本号机制（常用）</font></li>
<li><font style="color:rgb(1, 1, 1);">CAS算法实现</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「优点」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「没有加锁和解锁操作，可以提高吞吐量」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「缺点」</font></strong></li>
</ul>
<p><font style="color:black;">乐观锁需要自己实现，且外部系统不受控制</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「乐观锁的应用」</font></strong></li>
</ul>
<p><font style="color:black;">在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「适用场景」</font></strong><font style="color:black;">：读多写少</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「注意」</font></strong></li>
</ul>
<p><font style="color:black;">乐观锁不是数据库提供的功能，需要开发者自己去实现。</font></p>
<p>:::tips<br><font style="color:black;">除了开发者自己手动实现乐观锁之外，很多数据库访问框架也封装了乐观锁的实现</font></p>
<p><font style="color:black;">比如 hibernate框架，MyBatis框架的OptimisticLocker插件。</font></p>
<p>:::</p>
<h5 id="版本号机制实现乐观锁"><a href="#版本号机制实现乐观锁" class="headerlink" title="版本号机制实现乐观锁"></a><font style="color:black;">版本号机制实现乐观锁</font></h5><p><font style="color:black;">版本号机制有两种方式：使用版本字段（version）和使用时间戳（Timestamp），两者实现原理是一样的。</font></p>
<p><font style="color:black;">前文中提到</font><strong><font style="color:rgb(145, 109, 213);">「乐观锁需要开发者自己去实现，所以版本号实现时通过在表中加字段的形式实现的」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「使用版本字段（version）」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「在数据表增加一个版本(version) 字段，每操作一次，将那条记录的版本号加 1」</font></strong><font style="color:black;">。version 是用来查看被读的记录有无变化，防止记录在业务处理期间被其他事务修改。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「使用时间戳（Timestamp）」</font></strong></li>
</ul>
<p><font style="color:black;">与使用version版本字段基本一致，</font><strong><font style="color:rgb(145, 109, 213);">「同样需要给在数据表增加一个字段，字段类型使用timestamp时间戳，通过时间戳比较数据版本」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717493194895-993157fd-0135-475f-9273-d775d95f816d.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「乐观锁实现案例」</font></strong></li>
</ul>
<p><font style="color:black;">修改用户表中Id为1的用户姓名</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;第一步：查询记录信息&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用版本字段（version)</span><br><span class="line">select name,version from user where id=1;</span><br><span class="line">#使用时间戳（Timestamp）</span><br><span class="line">select name,timestamp from user where id=1;</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;第二步：逻辑处理之后，修改姓名为张三&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用版本字段（version)</span><br><span class="line">update user set name = &#x27;张三&#x27;,version=version+1 where id=1 and version = #&#123;version&#125;;#version 为第一步查询的值</span><br><span class="line"></span><br><span class="line">#使用时间戳（timestamp）</span><br><span class="line">update user set name = &#x27;张三&#x27;,timestamp=now() where id=1 and time</span><br></pre></td></tr></table></figure>

<h5 id="CAS算法实现乐观锁"><a href="#CAS算法实现乐观锁" class="headerlink" title="CAS算法实现乐观锁"></a><font style="color:black;">CAS算法实现乐观锁</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是无锁编程」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「特点」</font></strong></li>
</ul>
<p><font style="color:black;">不加锁，即使没有线程被阻塞的情况下实现变量的同步，也叫非阻塞同步</font></p>
<p><font style="color:black;">CAS算法涉及到三个操作数</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作」</font></strong><font style="color:black;">（比较和替换是一个原子操作），一般情况下是一个自旋操作，即不断的重试。</font></p>
<ul>
<li><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717493323068-f9450a45-f4b2-4fc6-89bc-22581c433220.webp"><ul>
<li><font style="color:rgb(1, 1, 1);">变量当前内存值 V</font></li>
<li><font style="color:rgb(1, 1, 1);">旧的预期值 A</font></li>
<li><font style="color:rgb(1, 1, 1);">要写入的新值 B</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「CAS缺点」</font></strong><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「ABA问题」</font></strong></li>
</ul>
</li>
</ul>
<p>:::tips<br><font style="color:black;background-color:rgb(244, 238, 255);">当线程1读到某变量的值为A，在其逻辑处理的过程中，另外一个线程2将该变量的值从A先修改为B、然后又将其从B修改回A。此时，当线程1通过CAS操作进行新值写入虽然可以成功，而实际上线程1执行CAS操作时预期值的A 和读取该变量当前值的A已经不是同一个了，后者是线程2修改的</font></p>
<p>:::</p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「CPU开销大」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">虽然CAS算法是非阻塞的，但如果CAS操作一直不成功不断循环，会浪费CPU资源</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「只能保证一个共享变量的原子性」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">当对多个变量进行操作时，CAS算法无法保证原子性。</font></p>
<p>:::tips<br><font style="color:black;background-color:rgb(244, 238, 255);">可以将多个变量封装为一个对象再使用CAS算法（Java中的AtomicReference）</font></p>
<p>:::</p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a><font style="color:black;">死锁和死锁检测</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「死锁是指两个或两个以上的事务在执行过程等中，因争夺资源而造成的一种相互等待的现象」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「死锁产生本质原因」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">系统资源有限</font></li>
<li><font style="color:rgb(1, 1, 1);">进程推进顺序不合理</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「死锁产生的4个必要条件」</font></strong><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「互斥条件（Mutual exclusion，简称Mutex）」</font></strong><font style="color:rgb(1, 1, 1);">资源要么被一个线程占用,要么是可用状态</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「不可抢夺（No preemption）」</font></strong><font style="color:rgb(1, 1, 1);">资源被占用后,除非占有线程主动释放,其他线程不能把它从该线程占用中抢夺</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「占有和等待（Hold and wait）」</font></strong><font style="color:rgb(1, 1, 1);">一个进程必须占有至少一个资源，并等待另一资源，而该资源被其他进程占用</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「循环等待（Circular wait）」</font></strong><font style="color:rgb(1, 1, 1);">一组等待进程{P0, P1…Pn-1, Pn}，P0等待资源被P1占有，P1等待资源被P2占有，Pn-1等待资源被Pn占有，Pn等待资源被P0占有，循环等待，则形成环形结构。</font></li>
</ul>
</li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「死锁发生的以上四个条件缺一都无法导致死锁，而由于互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，所以恢复死锁主要是破坏产生死锁的其他三个条件」</font></strong><font style="color:black;">。</font></p>
<h4 id="常见死锁现象和解决方案"><a href="#常见死锁现象和解决方案" class="headerlink" title="常见死锁现象和解决方案"></a><font style="color:black;">常见死锁现象和解决方案</font></h4><h5 id="表级锁死锁"><a href="#表级锁死锁" class="headerlink" title="表级锁死锁"></a><font style="color:black;">表级锁死锁</font></h5><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「案例」</font></strong></li>
</ul>
<p><font style="color:black;">有线程A、B分别需要访问用户表与订单表，访问表的时候都会加表级锁。线程A访用户表，并对用户表加锁（线程A锁住了用户表），然后又访问订单表；此时线程B先访问订单表，并对订单表加锁（线程B锁住了订单表），然后线程想访问用户表。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「产生原因」</font></strong></p>
<p><font style="color:black;">上述案例由于线程B已经锁住订单表，线程A必须等待线程B释放订单表能继续，同样线程B要等线程A释放用户表才能继续，</font><strong><font style="color:rgb(145, 109, 213);">「线程A、B相互等待对方释放锁，就产生了死锁」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717493783109-fa03c60a-317e-44b3-a7ba-fe41d1efa5f4.webp"></li>
<li><strong><font style="color:rgb(145, 109, 213);">「解决方案」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「这种死锁是由于程序的BUG产生的，比较常见，只能通过调整程序的逻辑来解决」</font></strong><font style="color:black;">。</font></p>
<h5 id="行级锁死锁"><a href="#行级锁死锁" class="headerlink" title="行级锁死锁"></a><font style="color:black;">行级锁死锁</font></h5><p><font style="color:black;">行级锁产生死锁有两种情况，一直是资源争夺，一种是行级锁升级为表级锁</font></p>
<ul>
<li><font style="color:black;">资源争夺</font><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「产生原因」</font></strong></li>
</ul>
</li>
</ul>
<p><font style="color:black;">当事务中某个查询没有走索引时，就会走全表扫描，把行级锁上升为全表记录锁定（等价于表级锁），并发下多个线程同时执行，就可能会产生死锁和阻塞</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「解决方案」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">SQL语句中尽量不要有太复杂的多表关联查询，并通过执行对SQL语句进行分析，建立索引优化，避免全表扫描和全表锁定。</font></p>
<ul>
<li><font style="color:black;">行级锁升级为表级锁</font></li>
</ul>
<font style="color:rgb(1, 1, 1);">  
</font>

<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「产生原因」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717494031661-8f50afb4-dfd1-4c3f-b5b8-1ad2bfcd08aa.webp"></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「解决方案」&lt;/font&gt;**
    * &lt;font style=&quot;color:black;&quot;&gt;在同一个事务中，尽量一次锁定需要的所有资源&lt;/font&gt;
    * &lt;font style=&quot;color:black;&quot;&gt;将每个资源编号，通过资源编号的线性顺序来预防死锁，当一个进程占有编号为i的资源时，那么它下一次只能申请编号大于i的资源。&lt;/font&gt;
</code></pre>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717494031436-fb63f286-d50a-441e-86d4-258f1846b377.webp"></p>
<h5 id="共享锁转换为排他锁"><a href="#共享锁转换为排他锁" class="headerlink" title="共享锁转换为排他锁"></a><font style="color:black;">共享锁转换为排他锁</font></h5><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「案例」</font></strong></li>
</ul>
<p><font style="color:black;">事务A有两个操作，首先查询一条纪录M，然后更新纪录M；此时事务B在事物A查询之后更新之前去更新纪录M，此时事物A获取了记录M的共享锁，事物B获取了记录M的排他锁， 事务B的排他锁由于事务A有共享锁，必须等A释放共享锁后才可以获取，事物B只能排队等待。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「产生原因」</font></strong></li>
</ul>
<p><font style="color:black;">案例中事物B已经进入等待，事物A更新M需要排他锁，而此时事务B已经有一个排他锁请求，并且正在等待事务A释放其共享锁，因此无法给事物A授予排他锁锁请求，事物A也进入排队等待</font></p>
<p>:::tips<br>注意：这里事物B还没有拿到M的排它锁，只是进入排队等到状态</p>
<p>:::</p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「解决方案」</font></strong></li>
</ul>
<p><font style="color:black;">通过</font><strong><font style="color:rgb(145, 109, 213);">「手动实现乐观锁」</font></strong><font style="color:black;">进行控制，乐观锁的无锁机制可以避免长事务中的数据库加锁开销，增大并发量，提升系统性能。</font></p>
<h5 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a><font style="color:black;">死锁排查</font></h5><p><font style="color:rgb(0, 0, 0);">MySQL提供了几个与锁有关的参数和命令，可以辅助我们优化锁操作，减少死锁发生。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看近期死锁日志信息」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717494286146-4dc235b7-cb95-4295-8a6b-9ab2efae8976.webp"></p>
<p><font style="color:black;">通过以上命令查看近期死锁日志信息，然后使用执行计划进行SQL优化</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看锁状态变量」</font></strong></li>
</ul>
<p><font style="color:black;">通过以下命令可以检查锁状态变量，从而分析系统中的行锁的争夺情况</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show status like&#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717494286117-bd00a4e5-f604-4a47-ba66-6b8816e34a52.webp"></p>
<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_current_waits：当前正在等待锁的数量&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_time：从系统启动到现在锁定总时间长度&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_time_avg：每次等待锁的平均时间&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;Innodb_row_lock_waits：系统启动后到现在总共等待的次数&lt;/font&gt;
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「如果等待次数高，而且每次等待时间长，则需要对其进行分析优化」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1717494286096-e778a408-9b71-4257-be1e-b5ee19f36a64.png"></p>
<p><strong>星河之码</strong></p>
<p>不惟有超世之才，亦必有坚忍不拔之志。</p>
<p>94篇原创内容</p>
<p>公众号</p>
<p><strong><font style="color:rgb(145, 109, 213);"><br></font></strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>项目可用性提升思考</title>
    <url>/2025/01/15/%E9%A1%B9%E7%9B%AE%E5%8F%AF%E7%94%A8%E6%80%A7%E6%8F%90%E5%8D%87%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>项目是一个在运营中的项目，在后续新功能开发的时候线上总是出现各种问题，让客户对项目的信任度降低很多，也对公司造成了经济损失。于是就有了一个任务，提高项目的可用性。经过一段时间的实践，总结出来了一个公式</p>
<p><strong>提升系统的稳定性&#x3D;减少故障的数量+提升发现速度+提升恢复速度</strong></p>
<h3 id="减少故障的数量"><a href="#减少故障的数量" class="headerlink" title="减少故障的数量"></a>减少故障的数量</h3><p>线上的故障主要分为依赖类故障、变更类故障、容量类故障、固件类故障</p>
<h4 id="依赖类故障"><a href="#依赖类故障" class="headerlink" title="依赖类故障"></a>依赖类故障</h4><p><font style="color:rgba(0, 0, 0, 0.9);">在现在分布式架构盛行的背景下，一个微服务的直接和间接依赖是非常多的。下游的某个服务、缓存、DB如果挂了，自己就会被“牵连”，无法提供正常服务。</font></p>
<span id="more"></span>
<h5 id="下游服务异常"><a href="#下游服务异常" class="headerlink" title="下游服务异常"></a><font style="color:rgba(0, 0, 0, 0.9);">下游服务异常</font></h5><p>下游服务异常的时候会造成服务异常，那我们可以通过降级和流控来处理</p>
<p>可以使用Sentinel来进行降级和流控，Sentinel是面向分布式服务框架的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。</p>
<p>Sentinel具有以下特征：</p>
<p>（1）丰富的运用场景</p>
<p>（2）完备的实时监控</p>
<p>（3）广泛的开源生态</p>
<p>（4）完善的SPI扩展点</p>
<h6 id="降级Degrade"><a href="#降级Degrade" class="headerlink" title="降级Degrade"></a>降级Degrade</h6><p><font style="color:rgba(0, 0, 0, 0.9);">所谓【降级】，就是</font><strong><font style="color:rgb(0, 82, 255);">对下游的依赖从强依赖变成弱依赖</font></strong><font style="color:rgba(0, 0, 0, 0.9);">。</font></p>
<p>熔断策略</p>
<ul>
<li>慢调用比例（平均响应时间）：选择以慢调用比例作为阈值，需要设置允许的慢调用RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。档单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测回复状态（HALF-OPEN状态），若接下来的一个请求响应时间小于设置的慢调用RT则结束熔断，若大于设置的慢调用RT则会再次被熔断。</li>
<li>异常比例（ERROR_RATIO）：当单位统计时长（satIntervalMs）内请求数且大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是[0.0,1.0]，代表0%-100%。</li>
<li>异常数（ERROR_COUNT）：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li>
</ul>
<h6 id="流控SentinelResource"><a href="#流控SentinelResource" class="headerlink" title="流控SentinelResource"></a>流控SentinelResource</h6><p>流控又分为限流，以及控流。</p>
<h6 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h6><h6 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h6><p>限流的定义就是只允许指定的流量通过，举个例子就是有50个苹果，一天只能吃10个，把剩下丢掉就是限流</p>
<p><font style="color:rgba(0, 0, 0, 0.9);">常见的实现方式包括【令牌桶限流】【计数限流】【线程池控制】等。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.9);">令牌桶限流 每分钟生成多少个令牌，拿到令牌的请求就继续，没有获得到令牌的直接抛弃掉</font></li>
<li><font style="color:rgba(0, 0, 0, 0.9);">计数限流  期初设置一个阈值比如5，来一个请求先判断这个值是否大于0，大于0则-1，等于0则抛弃请求，处理完了+1。集群计数就面临着网络开销，就算中间件再快，网络总在那里。作为一个计数服务，可想而知请求量是怎样的。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.9);">线程池控制 类似计数限流，用的时候取一个，用完还回来。相信大家对线程池都比较了解了，就不再往下细说。</font></li>
</ul>
<p><font style="color:rgba(0, 0, 0, 0.9);">【计数限流】和【线程池控制】本质上是控制并发。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">假设每个请求平均是10ms返回，线程池设置的数量是5。1秒钟&#x3D;100个10ms，每个10ms有5个线程可以处理5个请求，那1秒就可以处理100 * 5 &#x3D; 500个请求，qps&#x3D;500。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">所以，控制计数和线程池本质上是控制并发，不要和QPS搞混了。</font></p>
<h6 id="控流"><a href="#控流" class="headerlink" title="控流"></a>控流</h6><p>控流的定义就是允许流量通过一定的速度通过。举个例子就是有50个苹果，一天只能吃10个，把剩下的存起来分5天吃，常见的队列就是这种形式</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>这样就可以很明显的看到限流和控流的差别，限流直接将多余的流量抛弃，而流控是将多余的流量保存起来，慢慢处理。所以使用限流还是控流可以按照业务场景来进行选择，如果业务的请求可以直接抛弃就用限流，如果类似于转账之类的关乎到收入的业务还是选择控流更合适</p>
<h5 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a><font style="color:rgba(0, 0, 0, 0.9);">缓存异常</font></h5><p>限流防止穿透，集群防止雪崩。</p>
<h5 id="DB宕机"><a href="#DB宕机" class="headerlink" title="DB宕机"></a><font style="color:rgba(0, 0, 0, 0.9);">DB宕机</font></h5><p>对DB进行高可用建设，</p>
<h4 id="变更类故障"><a href="#变更类故障" class="headerlink" title="变更类故障"></a>变更类故障</h4><p><font style="color:rgba(0, 0, 0, 0.9);">变更不只是【代码变更】，还包括【配置变更】和【数据变更】。这些变更，无论是参数改错了，还是DB数据订正错了，都可能导致严重的故障。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">在各种系统中有大部分是变更类故障，而变更类故障各式各样，解决起来也不能使用同一种方案处理，并且无法根本解决，下面从代码、配置、数据这三个方面讲一下我们要怎么做</font></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a><font style="color:rgba(0, 0, 0, 0.9);">代码</font></h5><p>代码的变更基本上每个需求的更新都会产生，在刚到公司的时候最怕的就是变更，每次总是会出现各种的问题，代码版本问题，发布的代码版本不对，甚至出现过线上跑的版本落后现有版本1年的情况。通过观察发现出现这些情况的原因有手工发布代码，代码提交混乱，代码冲突，新旧版本兼容度问题。于是通过制定代码管理规范、自动发布，加强测试规范，对接口进行兼容性硬性规定来处理这些问题</p>
<h6 id="代码管理规范"><a href="#代码管理规范" class="headerlink" title="代码管理规范"></a>代码管理规范</h6><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1718354954470-2c43f0b4-d1c5-4d19-a7bf-ef60171c8ae1.png"></p>
<p>首先是对代码分支的管理，避免出现线上代码分支不对的情况，也防止测试代码和实际发布代码不一致的问题出现</p>
<h6 id="自动发布"><a href="#自动发布" class="headerlink" title="自动发布"></a>自动发布</h6><p>在比较常见的问题中有一个手工打包，复制到服务器并启动，每个人理解不一样及时有sh脚本辅助也难免会出现打包打错了，目录放错了等问题出现，为了避免出现类似的问题，引入Jenkins来做自动构建发布部署。</p>
<p>Jenkins可以最大程度的保证每次打包的环境一致性，以及可以提供快捷的回滚</p>
<h6 id="加强测试规范"><a href="#加强测试规范" class="headerlink" title="加强测试规范"></a>加强测试规范</h6><p>从测试目的来看，测试的目的有三块【测试新功能是否正常】【测试老功能是否正常】【测试服务的兼容性】，针对目的可以得出测试其实可以分为三大块</p>
<ul>
<li>功能测试  <font style="color:rgba(0, 0, 0, 0.9);">针对这次新增或修改的功能。</font></li>
<li>回归测试 <font style="color:rgba(0, 0, 0, 0.9);">针对老功能的验证</font></li>
<li>兼容性测试 <font style="color:rgba(0, 0, 0, 0.9);">验证新旧功能同时存在时的正确性。为什么要做兼容性测试，当程序发布出现异常时需要回滚如果没有兼容性那就会在发布时出现异常，还有当程序发布时程序没有兼容性就需要按照固定的顺序来发布如果出现循环依赖那在发布时就会出现异常</font></li>
</ul>
<h5 id="代码审核"><a href="#代码审核" class="headerlink" title="代码审核"></a>代码审核</h5><p>代码审核的目的是**<font style="color:rgb(51, 51, 51);">找出安全、性能、依赖和兼容性等测试不易发现的问题。及时识别出代码设计的缺陷，找到需要重构的地方</font>**</p>
<p><font style="color:rgb(51, 51, 51);">防止出现一些常见的错误写法导致泄漏问题的出现。</font></p>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><font style="color:rgba(0, 0, 0, 0.9);">配置文件</font></h5><p>是不是经常听到：测试环境就可以呀，为什么到了线上就不行了。当你听到这句话的时候大概率就是配置文件在作祟了 。</p>
<p>配置文件的问题在开发周期长的项目中尤其容易出现。在避免出现配置文件出现问题这个到现在也没有找到100%避免的方法，是能通过流程来尽量的避免问题的出现。</p>
<ol>
<li>要求开发写需求的上线文档，在文档中标注上线服务的前后顺序，配置文件，需要执行的sql</li>
<li>在提测时要求测试按照开发写的文档对测试环境的配置文件进行配置</li>
<li>功能测试完毕后，预发布环境按照文档再次进行配置</li>
<li>上线的前一天开上线大会对上线文档进行复盘</li>
</ol>
<p>通过多次的确认来防止配置异常的问题。</p>
<h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a><font style="color:rgba(0, 0, 0, 0.9);">数据</font></h5><p>主要是Flyway来做数据库管理，Flyway 是一款开源的数据库版本管理工具，它更倾向于规约优于配置的方式。Flyway 可以独立于应用实现管理并跟踪数据库变更，支持数据库版本自动升级，并且有一套默认的规约，不需要复杂的配置，Migrations 可以写成 SQL 脚本，也可以写在 Java 代码中，不仅支持 Command Line 和 Java API，还支持 Build 构建工具和 Spring Boot 等，同时在分布式环境下能够安全可靠地升级数据库，同时也支持失败恢复。主要步骤为</p>
<ol>
<li>开发编写脚本，并分别拷贝到dev，test，prod三个配置文件中指定的文件夹下，并需要根据配置文件中的语句在上线文档中预留回滚脚本</li>
<li>测试在部署时会验证一次语句的正确性</li>
<li>在上线大会对prod进行一次确认</li>
</ol>
<p>通过工具+人工验证来保证正确性</p>
<p>具体可以参考</p>
<p><a href="https://www.yuque.com/u25495771/leupuu/ki0b7wfp37nm2z35">Flyway</a></p>
<h4 id="容量类故障"><a href="#容量类故障" class="headerlink" title="容量类故障"></a>容量类故障</h4><p>容量指的是服务器的磁盘  cpu  内存 各种连接池因不同的原因满足不了业务的需求，比如业务流量突然增加，线上队列数据堆积，日志输出增加、图片数量堆积等都可以造成故障，使服务无法提供正常的服务，在主流程的接口或者方法需要修改时一定要注意兼容性的问题.</p>
<h6 id="业务流量的突然增加："><a href="#业务流量的突然增加：" class="headerlink" title="业务流量的突然增加："></a>业务流量的突然增加：</h6><p>日常中并不是很常见，一般只有做类似于秒杀场景的时候可能会遇到，遇到类似的情况我们需要及时的做好压测，做好容量评估。上线后对服务器进行监控</p>
<h6 id="线上队列数据堆积："><a href="#线上队列数据堆积：" class="headerlink" title="线上队列数据堆积："></a>线上队列数据堆积：</h6><p>线上数据堆积也可能会出现磁盘被占满的情况，可以调整队列配置，设置合理的磁盘空间，并监控队列的使用情况，并及时的报警。队列的堆积很大的可能是因为下游消费端出现了问题，早日报警由人员的介入可以早日解决问题。</p>
<h6 id="日志输出增加、图片数量堆积："><a href="#日志输出增加、图片数量堆积：" class="headerlink" title="日志输出增加、图片数量堆积："></a>日志输出增加、图片数量堆积：</h6><p>当我们使用docker的时候如果docker的日志文件并未做限制的时候，经过时间的更迭，docker容器占用的磁盘会越来越多。要解决这个问题需要限制docker容器的日志大小，如果应用需要留存日志等文件，可以通过挂载的形式将文件挂载到宿主机。</p>
<p>图片或者上传文件的问题，可以通过分布式存储模式把文件分片存储防止出现类似问题</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>容量类故障可以通过运维手段来进行缓解，但是主体还是需要做好监控告警，并对可以预想到的问题进行充足的压测，并预留好容量</p>
<h4 id="固件类故障"><a href="#固件类故障" class="headerlink" title="固件类故障"></a>固件类故障</h4><p>在现实社会中总是充满着意外，网络有可能会中断，服务器硬件可能会损坏。多机备份是解决这类问题的办法，经验不多，这里就不深聊此类问题</p>
<h3 id="提升发现速度"><a href="#提升发现速度" class="headerlink" title="提升发现速度"></a>提升发现速度</h3><p>提升发现速度主要是通过监控，监控又可以分为运维监控和变更监控</p>
<h4 id="运维监控"><a href="#运维监控" class="headerlink" title="运维监控"></a>运维监控</h4><p>运维监控告警可以通过Prometheus+Grafana来实现，而做好监控要从不同的维度进行</p>
<h5 id="机器维度："><a href="#机器维度：" class="headerlink" title="机器维度："></a>机器维度：</h5><p>机器维度的监控指标包括CPU、Load、内存、网络、IO、磁盘等相关指标，可以通过设定这些指标的异常值，通过触发来进行告警。</p>
<h5 id="应用维度："><a href="#应用维度：" class="headerlink" title="应用维度："></a>应用维度：</h5><p>  应用维度的监控指标包括JVM使用情况、线程池使用情况：JVM情况主要包括YGC次数、时间，FullGC次数、时间，新生代老年代占比；线程池情况主要包括的线程池大小、最大线程数、活跃线程数、队列大小等。</p>
<h5 id="服务维度"><a href="#服务维度" class="headerlink" title="服务维度"></a>服务维度</h5><p>服务维度的监控指标包括error日志报错情况、服务接口调用量、耗时、成功率，调用接口调用量、耗时、成功率，dal层操作调用量、耗时、成功率。</p>
<h5 id="外部依赖维度"><a href="#外部依赖维度" class="headerlink" title="外部依赖维度"></a>外部依赖维度</h5><p> 外部依赖维度主要指应用系统常见的外部依赖的监控情况，主要包括数据库、缓存、消息队列等，这些一般情况都会独立进行部署，对应的机器监控同上面列举的机器维度监控；另外数据库还需要关注连接数、内存使用、SQL调用量、耗时、成功率，慢SQL等；缓存需要关注调用量、成功率，命中率、内存使用等；消息队列需要关注调用量、成功率，队列积压情况、死信队列等</p>
<h4 id="变更监控"><a href="#变更监控" class="headerlink" title="变更监控"></a>变更监控</h4><p>变更监控可以更加细分一下分为【对旧：观察异常运行情况】、【对新：观察更新是够生效】</p>
<h6 id="对旧：观察异常运行情况"><a href="#对旧：观察异常运行情况" class="headerlink" title="对旧：观察异常运行情况"></a>对旧：观察异常运行情况</h6><p>实现观察异常运行情况主要是观察变更之后，没有变更的服务是否有心得异常发生，可以通过日志埋点，关键业务逻辑检测，接口埋点的情况，通过规则判断是否受到影响，如果有影响需要尽快的修复</p>
<h6 id="对新：观察更新是够生效"><a href="#对新：观察更新是够生效" class="headerlink" title="对新：观察更新是够生效"></a>对新：观察更新是够生效</h6><p>观察更新是否生效可以从检测新接口的各项指标。新接口打点的日志输出情况来确认，因为功能的大小，无法有效的指定详细的规则，一般会通过人工对频率和异常进行分析最后得出结论</p>
<h4 id="慢查询监控"><a href="#慢查询监控" class="headerlink" title="慢查询监控"></a>慢查询监控</h4><p>在运维监控中其实是包含了慢查询监控的，但是这里还是需要强调一下，服务运行中，当数据慢慢增多出现慢查询的可能性逐步增大，日常中需要进行优化的地方多出现在这里。所以在日常中更需要对慢查询格外的关注，根据不同的数据库有不同的统计方法，mysql可以通过配置开启慢查询监控</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在监控告警中有一个问题需要特别的注意，就是告警疲劳，狼来了的故事告诉我们只有真正发生了问题才应该告警，而不是频繁的告警当真正的问题出现时无法正确的处理</p>
<h3 id="提升恢复速度"><a href="#提升恢复速度" class="headerlink" title="提升恢复速度"></a>提升恢复速度</h3><p>借用蚂蚁的<font style="color:rgba(0, 0, 0, 0.9);">变更三板斧【变更可监控】【变更可回滚】【变更可灰度】，其中变更可监控是用来提升发现速度的，而提升恢复速度主要是变更可回滚。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">提升恢复速度也可以分为运维期恢复，变更期恢复</font></p>
<h5 id="运维期恢复"><a href="#运维期恢复" class="headerlink" title="运维期恢复"></a><font style="color:rgba(0, 0, 0, 0.9);">运维期恢复</font></h5><h6 id="应急处理"><a href="#应急处理" class="headerlink" title="应急处理"></a>应急处理</h6><p>运维期间的恢复在排除容量类问题，大部分是可以通过对应用进行重启来解决的，所以定时探测+脚本重启服务可以作为一种应急的处理方法，可以自己手写脚本，也可以使用k8s。</p>
<h6 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h6><p>也可以启动多份服务，当一个服务因为一场原因宕机后，将流量打入其他存活的服务中</p>
<h5 id="变更期恢复"><a href="#变更期恢复" class="headerlink" title="变更期恢复"></a><font style="color:rgba(0, 0, 0, 0.9);">变更期恢复</font></h5><h6 id="变更可回滚"><a href="#变更可回滚" class="headerlink" title="变更可回滚"></a>变更可回滚</h6><p><font style="color:rgba(0, 0, 0, 0.9);">大家可能会问：</font><em><font style="color:rgba(0, 0, 0, 0.9);">回滚不就是用原来的代码重新部署一遍就行了吗？</font></em></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">回顾上面的更新故障解决部分的时候，可以看到很多回滚的字样，整理一下回滚中可能存在的问题，并思考一下怎么解决</font></p>
<h6 id="发布依赖"><a href="#发布依赖" class="headerlink" title="发布依赖"></a><font style="color:rgba(0, 0, 0, 0.9);">发布依赖</font></h6><p>当我们需要考虑发布顺序的时候，就会遇到发布依赖的问题。当服务A更新完之后才能更新服务B时，回滚就需要服务B回滚完毕然后再回滚服务A，这时服务A就无法快速回滚了。</p>
<h6 id="数据异常"><a href="#数据异常" class="headerlink" title="数据异常"></a><font style="color:rgba(0, 0, 0, 0.9);">数据异常</font></h6><p>当变更有数据结构变更的时候，这时老的系统如果不兼容现有的数据结构就会阻碍回滚，在更新故障解决部分我们要求更新时提供数据库回滚语句的原因就是这个，但是回滚了数据结构后，在回滚期间还是会产生脏数据，这些脏数据可以处理但是需要时间，这就无法实现快速回滚的诉求了</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a><font style="color:rgba(0, 0, 0, 0.9);">解决</font></h6><p><strong><font style="color:rgba(0, 0, 0, 0.9);">【新数据在旧代码中兼容】</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">更好的兼容性设计，在设计新功能的数据库变更的时候要考虑到旧版本对新版本的数据结构支持，比如新增功能与原来功能关联时新增关联表，需要修改表内容时增加列冗余</font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.9);">【使用开关控制回滚】</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">“部署”与“生效”分离。</font><font style="color:rgba(0, 0, 0, 0.9);">相比代码</font><font style="color:rgba(0, 0, 0, 0.9);">回滚，</font><font style="color:rgba(0, 0, 0, 0.9);">使用开关回滚会快很多。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9);">此外，使用开关回滚的方案，也可以解决上线代码被多次覆盖后不可回滚的问题。</font></p>
<h6 id="变更可灰度"><a href="#变更可灰度" class="headerlink" title="变更可灰度"></a>变更可灰度</h6><p>在使用开关控制回滚提到了部署与生效隔离，灰度就是分离很有效的手段。当服务A和服务B上线时我们在灰度环境中部署一套新版本的服务A和服务B，这时我们可以设置公司内部环境为灰度环境，当我们测试有异常时我们可以将灰度关闭，这样流量就不会进入灰度环境，以实现快速回滚。同样的例子我们可以把灰度服务逐步开放，一旦发现服务异常可以直接关闭灰度环境实现快速回滚。</p>
<p>而且可灰度还可以分开观察新版本和老版本的差异，</p>
<p>多次修改后的系统也可以回滚，如果单纯的代码回滚如果更新多次的服务可能就无法回滚了</p>
]]></content>
      <categories>
        <category>架构思想</category>
      </categories>
      <tags>
        <tag>可用性</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Change buffer</title>
    <url>/2024/07/15/Change%20Buffer/</url>
    <content><![CDATA[<p><font style="color:black;">在之前的文章</font><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDU5OTU1Mw==&mid=2247485666&idx=1&sn=dc06d531d29d8916f53954be63710f9d&scene=21#wechat_redirect">《InnoDB的存储结构》</a><font style="color:black;">介绍的InnoDB的存储结构的组成中，我们知道Change Buffer也是用InnoDB内存结构的组成部分。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717731138693-8900ff09-52fa-4a9f-99b1-bd7fa82c5e18.webp"></p>
<p><font style="color:black;">Change Buffer主要是为了在写入是减少磁盘IO而存在的，</font></p>
<span id="more"></span>
<h2 id="一、什么是什么是Change-Buffer"><a href="#一、什么是什么是Change-Buffer" class="headerlink" title="一、什么是什么是Change Buffer"></a><strong><font style="color:black;">一、什么是什么是Change Buffer</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「在</font></strong><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDU5OTU1Mw==&mid=2247486351&idx=1&sn=bcafc8b2862545396401fc7c7e75c907&scene=21#wechat_redirect">《Buffer Pool》</a><strong><font style="color:rgb(145, 109, 213);">中介绍了buffer pool会缓存热的数据页和索引页，减少磁盘读操作，而对于磁盘的写操作，innoDB同样也有类似的策略，即通过change buffer缓解磁盘写操作产生的磁盘IO」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「Change Buffer是在【非唯一普通索引页】不在buffer pool中时，当对页进行了写操作时，在不影响数据一致性的前提下。InnoDB会将数据先写入Change Buffer中，等未来数据被读取时，再将 change buffer 中的操作merge到原数据页中」</font></strong><font style="color:black;">。</font></li>
<li><font style="color:black;">在MySQL5.5之前，只针对insert做了优化，叫插入缓冲(insert buffer)，后面进行了优化，对delete和update也有效，叫做写缓冲(change buffer)。</font></li>
</ul>
<h2 id="二、Change-buffer-执行过程"><a href="#二、Change-buffer-执行过程" class="headerlink" title="二、Change buffer 执行过程"></a><strong><font style="color:black;">二、Change buffer 执行过程</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「我们知道当执行写操作时，数据页存在于Buffer Pool中时，会直接修改数据页。那如果数据页不存在于Buffer Pool中时，过程会有一些不一样，这种情况会将写操作缓存到Change Buffer中，等未来在特定条件下其合并到Buffer Pool中」</font></strong><font style="color:black;">。因此当需要执行一个写入操作时，一般分为走Change buffer和不走Change buffer两种情况。</font></p>
<h3 id="2-1-写入的数据页在内存中"><a href="#2-1-写入的数据页在内存中" class="headerlink" title="2.1 写入的数据页在内存中"></a><font style="color:black;">2.1 写入的数据页在内存中</font></h3><p><font style="color:black;background-color:rgb(244, 238, 255);">这种情况在在</font><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDU5OTU1Mw==&mid=2247486351&idx=1&sn=bcafc8b2862545396401fc7c7e75c907&scene=21#wechat_redirect">《Buffer Pool》</a><font style="color:black;background-color:rgb(244, 238, 255);">的第4.3.2节 Flush链表写入过程中已经提过了，感兴趣的可以去看看，不看也没关系，这里在写一遍，凑一下字数~~</font></p>
<p><font style="color:black;">当我们在写入数据的时候，写入的数据页在内存中，MySQL不会直接更新直接更新磁盘，而是经过以下两个步骤：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">第一步：更新Buffer Pool中的数据页，一次内存操作；</font></li>
<li><font style="color:rgb(1, 1, 1);">第二步：将更新操作顺序写Redo log，一次磁盘顺序写操作；</font></li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">这样的效率是最高的。顺序写Redo log，每秒几万次，问题不大。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717731138683-85db925a-008d-4cc6-9cc0-89ce4bc2a619.webp"></p>
<p><strong><font style="color:rgb(145, 109, 213);">「这种情况是被更新的数据已经别加载到Buffer Pool的前提下」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「是否会产生数据一致性问题」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「因此写入的数据页在内存中这中情况不会产生数据一致性问题」</font></strong></p>
<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;读取数据，会命中缓冲池的页（已经被修改）。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;缓冲池LRU数据淘汰，则会将【脏页】刷回磁盘。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;数据库奔溃，redo log可以恢复数据。&lt;/font&gt;
</code></pre>
<h3 id="2-2-写入的数据页不在内存中"><a href="#2-2-写入的数据页不在内存中" class="headerlink" title="2.2 写入的数据页不在内存中"></a><font style="color:black;">2.2 写入的数据页不在内存中</font></h3><p><font style="color:black;">当我们修改的数据所在的数据页之前没有别读取过，或者干脆就是一条插入语句，则会经过以下两个步骤：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">第一步：在Change buffer中记录这个写入操作，一次内存操作。</font></li>
<li><font style="color:rgb(1, 1, 1);">第二步：将写入操作顺序写Redo log，一次磁盘顺序写操作；</font></li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">可以看到，这种方式跟上面的方式</font><strong><font style="color:rgb(145, 109, 213);background-color:rgb(244, 238, 255);">「仅仅只是第一步写入的位置不一样而已，而且都是内存操作」</font></strong><font style="color:black;background-color:rgb(244, 238, 255);">。</font></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">如果没有Change buffer，那更新可能会变成</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);background-color:rgb(244, 238, 255);">第一步：先从磁盘读取所在数据页加载到缓冲池，一次磁盘随机读操作；</font></li>
<li><font style="color:rgb(1, 1, 1);background-color:rgb(244, 238, 255);">第二步：更新Buffer Pool中的数据页，一次内存操作；</font></li>
<li><font style="color:rgb(1, 1, 1);background-color:rgb(244, 238, 255);">第三步：将更新操作顺序写Redo log，一次磁盘顺序写操作；</font></li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">也就是会多一次磁盘IO，磁盘IO相比较内存操作时很慢的，并发下性能就会急剧下降。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717731138699-76962f40-0371-4185-82d4-f35d5e2cf6c1.webp"></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">这种方式的效率跟第一次差不多，写缓冲是降低磁盘IO，提升数据库写性能的一种机制。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「是否会产生数据一致性问题」</font></strong></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">读取数据，会将Change Buffer中的数据合并到Buffer Pool中。</font></li>
<li><font style="color:rgb(1, 1, 1);">如果没有读取，Change也会被被定期刷盘到写缓冲系统表空间。</font></li>
<li><font style="color:rgb(1, 1, 1);">数据库奔溃，redo log可以恢复数据。</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「因此写入的数据页不在内存中这中情况也不会产生数据一致性问题」</font></strong><font style="color:black;">。</font></p>
<h2 id="三、Change-Buffer大小配置"><a href="#三、Change-Buffer大小配置" class="headerlink" title="三、Change Buffer大小配置"></a><strong><font style="color:black;">三、Change Buffer大小配置</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「从下图中可以看出，Change Buffer被包含在了Buffer Pool中的，change buffer用的是buffer pool里的内存，由于Buffer Pool的内存大小是有限制的，所以change buffer大小也是有限制的，可通过参数innodb_change_buffer_max_size设置」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717731138694-f9807fa8-4ddd-4186-bf14-ddd91abe9771.webp"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_change_buffer_max_size%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717731138685-640c1bcf-716c-446b-8a11-531c87bbae3f.webp"></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">innodb_change_buffer_max_size表示允许change_buffer占Buffer Pool总大小的百分比，默认值为25%，最大可设置为50%。</font><ul>
<li><font style="color:rgb(1, 1, 1);">当在系统中有大量插入，更新和删除操作时，可以增大innodb_change_buffer_max_size，以提高系统的写入性能。</font></li>
<li><font style="color:rgb(1, 1, 1);">当在系统中有大量查询操作时，可以减小innodb_change_buffer_max_size，以减少Buffer Pool中数据页的淘汰的概率，提高系统的读取性能。</font></li>
</ul>
</li>
<li><font style="color:rgb(1, 1, 1);">innodb_change_buffer_max_size 设置是动态的，它允许修改设置而无需重新启动服务器。</font></li>
</ul>
<h2 id="四、配置Change-Buffer的类型"><a href="#四、配置Change-Buffer的类型" class="headerlink" title="四、配置Change Buffer的类型"></a><strong><font style="color:black;">四、配置Change Buffer的类型</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「前面说到Change Buffer在MySQL5.5之后可以支持新增、删除、修改的写入，对于受I&#x2F;O限制的操作（大量DML、如批量插入）有很大的性能提升价值。但是对于一些特定的场景，可以通过修改innodb_change_buffering来变更Change Buffer支持的类型，分别为插入，删除，清除启用或禁用缓冲，更新操作是插入和删除的组合」</font></strong><font style="color:black;">。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_change_buffering%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717731139052-e32dbcae-7a8e-48d1-ab9f-ca806bb5c100.webp"></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">all ：默认值，缓冲区插入，删除和清除。</font></li>
<li><font style="color:rgb(1, 1, 1);">none：不缓存任何操作</font></li>
<li><font style="color:rgb(1, 1, 1);">inserts：缓冲区插入操作。</font></li>
<li><font style="color:rgb(1, 1, 1);">deletes：缓冲区删除标记操作。</font></li>
<li><font style="color:rgb(1, 1, 1);">changes：缓冲区插入和删除标记操作。</font></li>
<li><font style="color:rgb(1, 1, 1);">purges：缓冲区在后台发生的物理删除操作。</font></li>
</ul>
<h2 id="五、Change-buffer被merge的时机"><a href="#五、Change-buffer被merge的时机" class="headerlink" title="五、Change buffer被merge的时机"></a><strong><font style="color:black;">五、Change buffer被merge的时机</font></strong></h2><p><font style="color:black;">既然Change buffer是单独内存中，写入之后会被合并到Buffer Pool中,那么是时候时候会被merge呢？</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「Change buffer会被merge触发时机」</font></strong></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">读取Change buffer中记录的数据页时，会将Change buffer合并到buffer Pool 中，然后被刷新到磁盘。</font></li>
<li><font style="color:rgb(1, 1, 1);">当系统空闲或者slow shutdown时，后台master线程发起merge。</font></li>
<li><font style="color:rgb(1, 1, 1);">change buffer的内存空间用完了，后台master线程会发起merge。</font></li>
<li><font style="color:rgb(1, 1, 1);">redo log写满了，但是一般不会发生。</font></li>
</ul>
<h2 id="六、Change-buffer为什么只对非唯一普通索引页有效"><a href="#六、Change-buffer为什么只对非唯一普通索引页有效" class="headerlink" title="六、Change buffer为什么只对非唯一普通索引页有效"></a><strong><font style="color:black;">六、Change buffer为什么只对非唯一普通索引页有效</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「不知道大家有没有印象，在本文第一节就重点说了一个词【非唯一普通索引页】，Change buffer只有在非唯一普通索引页时才生效，这是为什么呢？」</font></strong></p>
<p><font style="color:black;">相信大家在日常工作中会经常遇到一个问题：</font><strong><font style="color:rgb(145, 109, 213);">「主键冲突」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「主键索引，唯一索引」</font></strong></li>
</ul>
<p><font style="color:black;">实际上对于【唯一索引】的更新，插入操作都会</font><strong><font style="color:rgb(145, 109, 213);">「先判断当前操作是否违反唯一性约束」</font></strong><font style="color:black;">，而这个操作就必须要将索引页读取到内存中，此时既然已经读取到内存了，那直接更新即可，没有需要在用Change buffer了。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「非唯一普通索引」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「不需要判断当前操作是否违反唯一性约束」</font></strong><font style="color:black;">，也就不需要将数据页读取到内存，因此可以直接使用 change buffer 更新。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「基于此，Change buffer只有对普通索引可以使用，对唯一索引的更新无法生效」</font></strong><font style="color:black;">。</font></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>6大日志介绍</title>
    <url>/2024/07/15/6%E5%A4%A7%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="物理日志和逻辑日志"><a href="#物理日志和逻辑日志" class="headerlink" title="物理日志和逻辑日志"></a>物理日志和逻辑日志</h2><p><font style="color:rgb(0, 0, 0);">日志一般分为逻辑日志与物理日志两类</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「逻辑日志」</font></strong><font style="color:rgb(1, 1, 1);">：即执行过的事务中的sql语句，执行的sql语句（增删改）</font><strong><font style="color:rgb(145, 109, 213);">「反向」</font></strong><font style="color:rgb(1, 1, 1);">的信息</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「物理日志」</font></strong><font style="color:rgb(1, 1, 1);">：</font><strong><font style="color:rgb(145, 109, 213);">mysql</font></strong><font style="color:rgb(1, 1, 1);"> 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 </font></p>
<span id="more"></span>
<p><strong><font style="color:rgb(145, 109, 213);">「</font><strong><strong><font style="color:rgb(145, 109, 213);">mysql</font></strong></strong><font style="color:rgb(145, 109, 213);">数据库中日志是重要组成部分，记录着数据库运行期间各种状态信息」</font></strong><font style="color:black;">。主要有6类：</font></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">二进制日志</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">重做日志</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">撤销日志</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">错误日志</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">查询日志</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">中继日志</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「而我们一般比较关注的是二进制日志( binlog )和事务日志(包括重做日志redo log 和撤销日志 undo log )」</font></strong><font style="color:black;">。</font></p>
<h3 id="物理日志"><a href="#物理日志" class="headerlink" title="物理日志"></a><font style="color:rgb(145, 109, 213);">物理日志</font></h3><h4 id="重做日志（Redo-Log）"><a href="#重做日志（Redo-Log）" class="headerlink" title="重做日志（Redo Log）"></a><font style="color:black;">重做日志（Redo Log）</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「重做日志（Redo Log）是InnoDB存储引擎所特有的日志」</font></strong><font style="color:black;">。</font></p>
<h5 id="Redo-log基本概念"><a href="#Redo-log基本概念" class="headerlink" title="Redo log基本概念"></a><font style="color:black;">Redo log基本概念</font></h5><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间修正不完整事务写入的数据」</font></strong><font style="color:black;">。</font></li>
<li><font style="color:black;">MySQL以循环方式写入重做日志文件，记录InnoDB中所有对Buffer Pool修改的日志。</font></li>
</ul>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">当出现实例故障，导致数据未能更新到数据文件，则数据库重启时须redo，重新把数据更新到数据文件。读写事务在执行的过程中，都会不断的产生redo log。默认情况下，重做日志在磁盘上由两个名为ib_logfile0和ib_logfile1的文件物理表示。</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong><font style="color:black;"> </font><font style="color:black;">包括两部分</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">一个是内存中的日志缓冲(</font><font style="color:rgb(1, 1, 1);"> </font><strong><font style="color:rgb(145, 109, 213);">redo log buffer</font></strong><font style="color:rgb(1, 1, 1);"> </font><font style="color:rgb(1, 1, 1);">)，临时性</font></li>
<li><font style="color:rgb(1, 1, 1);">一个是磁盘上的日志文件( </font><strong><font style="color:rgb(145, 109, 213);">redo log file</font></strong><font style="color:rgb(1, 1, 1);">)，永久性。</font></li>
</ul>
<h5 id="Redo-Log解决了什么问题"><a href="#Redo-Log解决了什么问题" class="headerlink" title="Redo Log解决了什么问题"></a><font style="color:rgb(1, 1, 1);">Redo Log解决了什么问题</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，如果每次读写数据都需要磁盘I&#x2F;O，效率会很低。」</font></strong></p>
<p><font style="color:black;">为提高读写效率，InnoDB添加了缓存池（Buffer Pool）作为访问数据库的缓冲，其包含了磁盘中部分数据页的映射。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则需要从磁盘中读取然后放入 Buffer Pool；」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（即：刷脏）」</font></strong><font style="color:rgb(1, 1, 1);">。</font></li>
</ul>
<p><em><font style="color:rgb(145, 109, 213);">Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证</font></em><font style="color:rgb(0, 0, 0);">。而Redo Log 解决了这个问题。</font></p>
<h5 id="为什么需要Redo-log"><a href="#为什么需要Redo-log" class="headerlink" title="为什么需要Redo log"></a><font style="color:rgb(1, 1, 1);">为什么需要Redo log</font></h5><ul>
<li><font style="color:black;">事务的四大特性ACID中有一个是</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">「持久性」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态」</font></strong><font style="color:black;"> </font><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「</font><strong><strong><font style="color:rgb(145, 109, 213);">mysql</font></strong></strong><font style="color:rgb(145, 109, 213);">是如何保证一致性」</font></strong></li>
</ul>
<p><font style="color:black;">最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有性能瓶颈，主要体现在两个方面：</font></p>
<ul>
<li><font style="color:black;">因为</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">Innodb</font></strong><font style="color:black;"> </font><font style="color:black;">是以</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">页</font></strong><font style="color:black;"> </font><font style="color:black;">为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</font></li>
<li><font style="color:black;">一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机I&#x2F;O写入性能太差！</font></li>
</ul>
<p><font style="color:black;">因此 </font><strong><font style="color:rgb(145, 109, 213);">mysql</font></strong><font style="color:black;"> 设计了 </font><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong><font style="color:black;"> ， </font><strong><font style="color:rgb(145, 109, 213);">「redo log是物理日志，只记录事务对数据页做了哪些修改，而不是某一行或某几行修改成什么样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)，相对而言文件更小并且是顺序IO」</font></strong><font style="color:black;">。</font></p>
<h5 id="Redo-log效率为什么快"><a href="#Redo-log效率为什么快" class="headerlink" title="Redo log效率为什么快"></a><font style="color:rgb(1, 1, 1);">Redo log效率为什么快</font></h5><p><font style="color:black;">Redo Log 默认是在事务提交的时候将日志写入磁盘，为什么它比直接将 Buffer Pool中修改的数据写入磁盘要快呢？</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「磁盘刷脏操作是随机I&#x2F;O，因为每次修改的数据的位置都是随机的，但是写redo log是追加操作，顺序I&#x2F;O」</font></strong><font style="color:rgb(1, 1, 1);">。</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「磁盘刷脏是以数据页为单位的（Page），MySQL默认页的大小是16KB，一个page上一个小修改都要整页写入；而 redo log中只包含真正修改的部分，不会有无效I&#x2F;O」</font></strong><font style="color:rgb(1, 1, 1);">。</font></li>
</ul>
<h5 id="Redo-log写磁盘的方式"><a href="#Redo-log写磁盘的方式" class="headerlink" title="Redo log写磁盘的方式"></a><font style="color:black;">Redo log写磁盘的方式</font></h5><p><strong><font style="color:rgb(145, 109, 213);">mysql</font></strong><font style="color:black;"> </font><font style="color:black;">每执行一条</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">DML</font></strong><font style="color:black;"> </font><font style="color:black;">语句，先将记录写入</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">redo log buffer</font></strong><font style="color:black;">，后续</font><strong><font style="color:rgb(145, 109, 213);">「某个时间点再一次性将多个操作记录写到</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">redo log file</font>****<font style="color:rgb(145, 109, 213);">」</font></strong><font style="color:black;">。这种</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">「先写日志，再写磁盘」</font></strong><font style="color:black;"> </font><font style="color:black;">的技术就是</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">「「预写式日志」」</font></strong><font style="color:black;">（</font><strong><font style="color:rgb(145, 109, 213);">Write-Ahead Logging</font></strong><font style="color:black;"> </font><font style="color:black;">，缩写 WAL）。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「在计算机操作系统中，用户空间(</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">user space</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">)下的缓冲区数据是无法直接写入磁盘的，中间必须经过操作系统内核空间(</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">kernel space</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">)的缓冲区(</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">OS Buffer</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">)」</font></strong><font style="color:black;">。因此，</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">redo log buffer</font></strong><font style="color:black;"> </font><font style="color:black;">写入</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">redo log file</font></strong><font style="color:black;"> </font><font style="color:black;">实际上是</font><strong><font style="color:rgb(145, 109, 213);">「先写入</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">OS Buffer</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">，然后再通过系统调用</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">fsync()</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">将其刷到</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">redo log file</font>****<font style="color:rgb(145, 109, 213);">中」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717557424972-957b86ed-fd92-421b-84f8-62318c1ae4c4.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「redo log file刷盘时机」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「mysql 支持三种将 redo log buffer 写入 redo log file 的时机」</font></strong><font style="color:black;">，可以通过 </font><strong><font style="color:rgb(145, 109, 213);">innodb_flush_log_at_trx_commit</font></strong><font style="color:black;"> 参数配置：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%innodb_flush_log_at_trx_commit%&#x27;;</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| Variable_name                  | Value |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| innodb_flush_log_at_trx_commit | 1     |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;速度较快，比0安全，只有在&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「操作系统崩溃或者系统断电」&lt;/font&gt;**&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;的情况下，上一秒钟所有事务数据才可能丢失。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;最安全，但也是最慢，即使mysql挂掉也不会丢失数据，但是IO频繁，性能下降。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;速度最快，不太安全，在mysql挂掉的时候，会丢失一秒钟的数据。&lt;/font&gt;
- &lt;font style=&quot;color:black;&quot;&gt;当&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;innodb_flush_log_at_trx_commit&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt; &lt;/font&gt;&lt;font style=&quot;color:black;&quot;&gt; = 0&lt;/font&gt;
</code></pre>
<p><font style="color:black;">【</font><strong><font style="color:rgb(145, 109, 213);">「延迟写」</font></strong><font style="color:black;">】：</font><strong><font style="color:rgb(145, 109, 213);">「提交事务时不会立即将数据</font><strong><strong><font style="color:rgb(145, 109, 213);">redo log buffer</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">写入到</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">OS Buffer</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">，而是通过 InnoDB 的主线程每秒写入</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">OS Buffer</font></strong></strong><font style="color:rgb(145, 109, 213);">并调用</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">fsync()</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">将其刷到</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">redo log file</font>****<font style="color:rgb(145, 109, 213);">中」</font></strong><font style="color:black;">。</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;当&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;innodb_flush_log_at_trx_commit&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt; &lt;/font&gt;&lt;font style=&quot;color:black;&quot;&gt; = 1&lt;/font&gt;
</code></pre>
<p><font style="color:black;">【</font><strong><font style="color:rgb(145, 109, 213);">「实时写实时刷」</font></strong><font style="color:black;">】：</font><strong><font style="color:rgb(145, 109, 213);">「每次提交事务时都会将数据</font><strong><strong><font style="color:rgb(145, 109, 213);">redo log buffer</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">写入到</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">OS Buffer</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">并立即调用</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">fsync()</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">将其刷到</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">redo log file</font></strong></strong><font style="color:rgb(145, 109, 213);">中」</font></strong><font style="color:black;">。</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;当&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;innodb_flush_log_at_trx_commit&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt; &lt;/font&gt;&lt;font style=&quot;color:black;&quot;&gt; = 2&lt;/font&gt;
</code></pre>
<p><font style="color:black;">【</font><strong><font style="color:rgb(145, 109, 213);">「实时写延迟刷」</font></strong><font style="color:black;">】：</font><strong><font style="color:rgb(145, 109, 213);">「每次提交事务时都会将数据</font><strong><strong><font style="color:rgb(145, 109, 213);">redo log buffer</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">写入到</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">OS Buffer</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);"> 中，然后每间隔一秒调用</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">fsync()</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">将其刷到</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">redo log file</font></strong></strong><font style="color:rgb(145, 109, 213);">中」</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717557455008-e48cb91c-723c-4073-b8b7-bc70ec5a1df7.webp"></p>
<h5 id="Redo-log写入形式"><a href="#Redo-log写入形式" class="headerlink" title="Redo log写入形式"></a><font style="color:black;">Redo log写入形式</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「在innodb中，既有</font><strong><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">需要刷盘，还有</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">数据页</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">也需要刷盘，</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong></strong><font style="color:rgb(145, 109, 213);">存在的意义主要就是降低对</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">数据页</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">刷盘的要求」</font></strong><font style="color:black;"> </font><font style="color:black;"> 。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「</font><strong><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong></strong><font style="color:rgb(145, 109, 213);">实现上采用了【大小固定，循环写入】的方式，当写到结尾时，会回到开头循环写日志」</font></strong><font style="color:black;">。如下图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717557804160-e7ffc4f2-e064-4204-bcdb-340fa33eb5ce.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">write pos</font></strong><font style="color:black;"> </font><font style="color:black;">：表示</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong><font style="color:black;"> </font><font style="color:black;">当前记录的</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">LSN</font></strong><font style="color:black;"> </font><font style="color:black;">(逻辑序列号)位置</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">check point</font></strong><font style="color:black;"> </font><font style="color:black;">：表示</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">「数据页更改记录」</font></strong><font style="color:black;"> </font><font style="color:black;">刷盘后对应</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong><font style="color:black;"> </font><font style="color:black;">所处的</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">LSN</font></strong><font style="color:black;">(逻辑序列号)位置。</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">write pos</font></strong><font style="color:black;"> </font><font style="color:black;">到</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">check point</font></strong><font style="color:black;"> </font><font style="color:black;">之间的部分是</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong><font style="color:black;"> </font><font style="color:black;">空着的部分，用于记录新的记录；</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">check point</font></strong><font style="color:black;"> </font><font style="color:black;">到</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">write pos</font></strong><font style="color:black;"> </font><font style="color:black;">之间是</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">redo log</font></strong><font style="color:black;"> </font><font style="color:black;">待落盘的数据页更改记录。</font></p>
<p><font style="color:black;">当 </font><strong><font style="color:rgb(145, 109, 213);">write pos</font></strong><font style="color:black;">追上</font><strong><font style="color:rgb(145, 109, 213);">check point</font></strong><font style="color:black;"> 时，会先推动 </font><strong><font style="color:rgb(145, 109, 213);">check point</font></strong><font style="color:black;"> 向前移动，空出位置再记录新的日志。</font></p>
<p>:::tips<br><font style="color:black;">启动</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">innodb</font></strong><font style="color:black;"> </font><font style="color:black;">的时候，无论上次是正常关闭或异常关闭，都会进行恢复操作。</font></p>
<p><font style="color:black;">重启</font><strong><font style="color:rgb(145, 109, 213);">innodb</font></strong><font style="color:black;"> </font><font style="color:black;">时，首先会检查磁盘中数据页的</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">LSN</font></strong><font style="color:black;"> </font><font style="color:black;">，如果数据页的</font><strong><font style="color:rgb(145, 109, 213);">LSN</font></strong><font style="color:black;"> </font><font style="color:black;">小于日志中的</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">LSN</font></strong><font style="color:black;"> </font><font style="color:black;">，则会从</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">checkpoint</font></strong><font style="color:black;"> </font><font style="color:black;">开始恢复。</font></p>
<p><font style="color:black;">如果在宕机前正处于</font><strong><font style="color:rgb(145, 109, 213);">check point</font></strong><font style="color:black;"> 的刷盘过程，且</font><strong><font style="color:rgb(145, 109, 213);">「数据页的刷盘进度超过了日志页的刷盘进度」</font></strong><font style="color:black;">，此时会出现数据页中记录的 </font><strong><font style="color:rgb(145, 109, 213);">LSN</font></strong><font style="color:black;"> 大于日志中的 </font><strong><font style="color:rgb(145, 109, 213);">LSN</font></strong><font style="color:black;">，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</font></p>
<p>:::</p>
<h5 id="Redo-Log和BinLog的比较"><a href="#Redo-Log和BinLog的比较" class="headerlink" title="Redo Log和BinLog的比较"></a><font style="color:rgb(1, 1, 1);">Redo Log和BinLog的比较</font></h5><p><font style="color:black;">redo log 主要用来。binlog是用来进行归档的。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「一个更新的sql先执行到redo log内为预提交状态，binlog写入，写入之后通知redo log改提交状态」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「作用不同」</font></strong><ul>
<li><font style="color:black;">redo log是用于【崩溃恢复】的，保证MySQL宕机也不会影响持久性。</font></li>
</ul>
</li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">redo log 主要用来数据库宕机恢复数据的</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;binlog是【用于时间点恢复】的，保证服务器可以基于时间点恢复数据或者用于主从复制。&lt;/font&gt;
</code></pre>
<p><font style="color:black;background-color:rgb(244, 238, 255);">binlog是用来进行归档的</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「层次不同」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">redo log是InnoDB存储引擎实现的，innodb独享</font></li>
<li><font style="color:rgb(1, 1, 1);">binlog是MySQL的服务器层实现的服务，全局引擎共享</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「内容不同」</font></strong><ul>
<li><font style="color:black;">redo log是物理日志，内容基于磁盘的数据Page，</font><strong><font style="color:rgb(145, 109, 213);">「记录该数据页更新状态内容」</font></strong></li>
</ul>
</li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">比如：「将第6页、第8行、第7个位置改成aaaa」这种</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;bin log是逻辑日志，内容是二进制的，根据binlog＿format参数的不同，分为不同的模式，可能基于SQL 语句、基于数据本身、或者二者的混合，&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「记录更新过程」&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt;。&lt;/font&gt;
</code></pre>
<p><font style="color:black;background-color:rgb(244, 238, 255);">比如：insert into t values (null, 4, ‘2022-03-24’);  也跟bin log日志格式有关</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「写入时机不同」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">bin log是在事务提交完成后进行一次写入</font></li>
<li><font style="color:rgb(1, 1, 1);">redo log的写入时机有三种（具体在上文中有介绍）</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「写入方式不同」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">binlog在写满或者重启之后，会生成新的binlog文件，旧的日志数据会一直保留。</font></li>
<li><font style="color:rgb(1, 1, 1);">redo log是循环使用，会清理旧的日志数据。</font></li>
</ul>
</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><h6 id="为什么要两阶段提交"><a href="#为什么要两阶段提交" class="headerlink" title="为什么要两阶段提交"></a>为什么要两阶段提交</h6><p><font style="color:rgb(1, 1, 1);">首先我们要明确一点，redo log是innoDB下的日志记录，binlog是mysql下的二级制文件，他们都可以表示事务的提交状态，</font><font style="color:rgb(68, 68, 68);">而两阶段提交就是让这两个状态保持逻辑上的一致</font></p>
<h6 id="两段提交的流程"><a href="#两段提交的流程" class="headerlink" title="两段提交的流程"></a><font style="color:rgb(68, 68, 68);">两段提交的流程</font></h6><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1717571952239-697cac80-69f0-401a-9c26-cc04e839d18c.png"></p>
<ol>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<h3 id="逻辑日志"><a href="#逻辑日志" class="headerlink" title="逻辑日志"></a><font style="color:rgb(145, 109, 213);">逻辑日志</font></h3><h4 id="二进制日志-binlog"><a href="#二进制日志-binlog" class="headerlink" title="二进制日志(binlog)"></a><font style="color:black;">二进制日志(binlog)</font></h4><h5 id="什么是binlog"><a href="#什么是binlog" class="headerlink" title="什么是binlog"></a><font style="color:black;">什么是binlog</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「记录对MySQL数据库执行的更改操作，包括语句的发生时间、执行时长，主要用于数据库恢复和主从复制」</font></strong><font style="color:black;">。但不记录select、show等不修改数据库的SQL。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「</font><strong><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong></strong><font style="color:rgb(145, 109, 213);">是逻辑日志，在</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">mysql Server</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">层进行记录，属于</font><strong><strong><font style="color:rgb(145, 109, 213);">mysql</font></strong></strong><font style="color:rgb(145, 109, 213);">全局日志，无论使用什么存储引擎都会记录</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">binlog</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">日志」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「binlog产生的时机」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「binlog记录方式」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「</font><strong><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font>****<font style="color:rgb(145, 109, 213);">是通过追加的方式记录数据库执行的写操作(不包括读操作)信息，以二进制保存在磁盘中。」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「开启binlog」</font></strong></li>
</ul>
<p><font style="color:black;">在my.inf主配置文件中添加如下配置</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#打开binlog日志 默认是OFF</span><br><span class="line">log_bin=ON</span><br><span class="line">#binlog日志的基本文件名，后面会追加标识来表示每一个文件 例如：mysql-bin.000094</span><br><span class="line">log_bin_basename=/var/lib/mysql/mysql-bin</span><br><span class="line">#指定的是binlog文件的索引文件  管理所有的binlog文件的目录 记录有多少个binlog文件等</span><br><span class="line">log_bin_index=/var/lib/mysql/mysql-bin.index</span><br><span class="line"></span><br><span class="line">#或者将以上三个配置合二为一</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br><span class="line">#mysql会根据这个配置自动设置log_bin为on状态，自动设置log_bin_index文件为指定文件名后跟.index</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717572150360-39c5e28d-93c3-43ef-bdd8-2e794566123e.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「binlog大小设置与过期时间」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「</font><strong><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font>****<font style="color:rgb(145, 109, 213);">是通过追加的方式进行写入的，有两个参数需要控制binlog大小设置与过期时间」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">expire_logs_days = 7</span><br><span class="line">max_binlog_size = 104857600</span><br><span class="line"></span><br><span class="line">set global max_binlog_size=104857600;#100M</span><br><span class="line">show variables like &#x27;%max_binlog_size%&#x27;;</span><br><span class="line">show variables like &#x27;%expire_logs_days%&#x27;;</span><br><span class="line">expire_logs_days</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global max_binlog_size=104857600;#100M</span><br><span class="line">set global expire_logs_days = 7;</span><br><span class="line">show variables like &#x27;%max_binlog_size%&#x27;;</span><br><span class="line">show variables like &#x27;%expire_logs_days%&#x27;;</span><br></pre></td></tr></table></figure>

<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「查看配置」&lt;/font&gt;**
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%max_binlog_size%&#x27;;</span><br><span class="line">show variables like &#x27;%expire_logs_days%&#x27;;</span><br></pre></td></tr></table></figure>

<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「命令配置」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">及时生效，重启失效，</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「max_binlog_size」&lt;/font&gt;**
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「</font><strong><strong><font style="color:rgb(145, 109, 213);">max_binlog_size</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">代表每个</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong></strong><font style="color:rgb(145, 109, 213);">文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志，默认值是1GB」</font></strong><font style="color:black;">。</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「expire_logs_days」&lt;/font&gt;**
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「mysql自动清除过期binlog日志的天数。默认值为0,表示没有自动删除」</font></strong><font style="color:black;">。</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「配置文件配置」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">永久性，需要重启，修改my.conf：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717572150361-d4b542ce-dd94-4252-b1ec-1c2503940d50.webp"></p>
<h5 id="binlog使用场景"><a href="#binlog使用场景" class="headerlink" title="binlog使用场景"></a><font style="color:black;">binlog使用场景</font></h5><p><font style="color:black;">在实际应用中，</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:black;"> </font><font style="color:black;">的主要使用场景有两个，分别是</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">「主从复制」</font></strong><font style="color:black;"> </font><font style="color:black;">和</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">「数据恢复」</font></strong><font style="color:black;"> </font><font style="color:black;">。</font></p>
<ol>
<li><strong><font style="color:rgb(145, 109, 213);">「数据复制」</font></strong><font style="color:black;"> </font><font style="color:black;">：</font></li>
</ol>
<p><font style="color:black;">在</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">Master</font></strong><font style="color:black;"> </font><font style="color:black;">端开启</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:black;"> </font><font style="color:black;">，然后将</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:black;">发送到各个</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">Slave</font></strong><font style="color:black;"> </font><font style="color:black;">端，</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">Slave</font></strong><font style="color:black;"> </font><font style="color:black;">端执行</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:black;"> </font><font style="color:black;">从而达到主从数据一致。</font></p>
<ol start="2">
<li><strong><font style="color:rgb(145, 109, 213);">「数据恢复」</font></strong></li>
</ol>
<p><font style="color:black;">通过使用 </font><strong><font style="color:rgb(145, 109, 213);">mysqlbinlog</font></strong><font style="color:black;"> 工具来恢复数据。</font></p>
<h5 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a><font style="color:black;">binlog刷盘时机</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「对于</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">InnoDB</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">存储引擎而言，只有在事务提交时才会记录</font><strong><strong><font style="color:rgb(145, 109, 213);">biglog</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font>****<font style="color:rgb(145, 109, 213);">日志」</font></strong><font style="color:black;">，此时记录还在内存中，那么</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">biglog</font></strong><font style="color:black;">是什么时候刷到磁盘中的呢？</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「</font><strong><strong><font style="color:rgb(145, 109, 213);">mysql</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">通过</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">sync_binlog</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">参数控制</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">biglog</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">的刷盘时机，取值范围是</font></strong></strong><font style="color:rgb(145, 109, 213);"> </font><strong><strong><font style="color:rgb(145, 109, 213);">0-N</font></strong></strong><font style="color:rgb(145, 109, 213);">：」</font></strong></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">0：不去强制要求，由系统自行判断何时写入磁盘；</font></li>
<li><font style="color:rgb(1, 1, 1);">1：每次</font><font style="color:rgb(1, 1, 1);"> </font><strong><font style="color:rgb(145, 109, 213);">commit</font></strong><font style="color:rgb(1, 1, 1);"> </font><font style="color:rgb(1, 1, 1);">的时候都要将</font><font style="color:rgb(1, 1, 1);"> </font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:rgb(1, 1, 1);"> </font><font style="color:rgb(1, 1, 1);">写入磁盘；</font></li>
<li><font style="color:rgb(1, 1, 1);">N：每N个事务，才会将</font><font style="color:rgb(1, 1, 1);"> </font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:rgb(1, 1, 1);"> </font><font style="color:rgb(1, 1, 1);">写入磁盘。</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%sync_binlog%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717572177159-fcac7c69-f05d-4470-bcc7-7dc09fde4b6e.webp"></p>
<p><strong><font style="color:rgb(145, 109, 213);">「MySQL 5.7.7之后版本的 sync_binlog 默认值是 1 ，配置为1也是数据最不容易丢失的，但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。」</font></strong></p>
<h5 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a><font style="color:black;">binlog日志格式</font></h5><p><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:rgb(0, 0, 0);"> 日志格式通过 </font><strong><font style="color:rgb(145, 109, 213);">binlog_format</font></strong><font style="color:rgb(0, 0, 0);"> 指定，有三种格式，分别为 </font><strong><font style="color:rgb(145, 109, 213);">STATMENT</font></strong><font style="color:rgb(0, 0, 0);"> 、 </font><strong><font style="color:rgb(145, 109, 213);">ROW</font></strong><font style="color:rgb(0, 0, 0);"> 和 </font><strong><font style="color:rgb(145, 109, 213);">MIXED</font></strong><font style="color:rgb(0, 0, 0);">。日志。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">在 </font><strong><font style="color:rgb(145, 109, 213);">MySQL 5.7.7</font></strong><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);"> 之前，默认的格式是 </font><strong><font style="color:rgb(145, 109, 213);">STATEMENT</font></strong><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);"> ， </font><strong><font style="color:rgb(145, 109, 213);">MySQL 5.7.7</font></strong><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);"> 之后，默认值是 </font><strong><font style="color:rgb(145, 109, 213);">ROW</font></strong><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">。</font></p>
<p>:::</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%binlog_format%&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「STATMENT」</font></strong></p>
<p><font style="color:black;">基于</font><strong><font style="color:rgb(145, 109, 213);">SQL</font></strong><font style="color:black;"> </font><font style="color:black;">语句的复制(</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">statement-based replication, SBR</font></strong><font style="color:black;"> </font><font style="color:black;">)，每一条修改数据的sql语句会记录到</font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:black;"> </font><font style="color:black;">中  。</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">缺点：在某些情况下会导致主从数据不一致，比如执行sysdate() 、  slepp()  等 。</font></li>
<li><font style="color:rgb(1, 1, 1);">优点：不需要记录每一行数据的变化，减少了 binlog 日志量，节约 IO  , 从而提高了性能；</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「ROW」</font></strong></p>
<p><font style="color:black;">基于行的复制(</font><strong><font style="color:rgb(145, 109, 213);">row-based replication, RBR</font></strong><font style="color:black;"> )，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">缺点：会产生大量的日志，尤其是</font><strong><font style="color:rgb(145, 109, 213);">alter table</font></strong><font style="color:rgb(1, 1, 1);"> 的时候会让日志暴涨</font></li>
<li><font style="color:rgb(1, 1, 1);">优点：能清楚记录每一个行数据的修改细节，能完全实现主从数据同步和数据的恢复；</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「MIXED」</font></strong></p>
<p><font style="color:rgb(0, 0, 0);">基于</font><strong><font style="color:rgb(145, 109, 213);">STATMENT</font></strong><font style="color:rgb(0, 0, 0);"> 和 </font><strong><font style="color:rgb(145, 109, 213);">ROW</font></strong><font style="color:rgb(0, 0, 0);"> 两种模式的混合复制(</font><strong><font style="color:rgb(145, 109, 213);">mixed-based replication, MBR</font></strong><font style="color:rgb(0, 0, 0);"> )，一般的复制使用</font><strong><font style="color:rgb(145, 109, 213);">STATEMENT</font></strong><font style="color:rgb(0, 0, 0);"> 模式保存 </font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong><font style="color:rgb(0, 0, 0);"> ，对于 </font><strong><font style="color:rgb(145, 109, 213);">STATEMENT</font></strong><font style="color:rgb(0, 0, 0);"> 模式无法复制的操作使用 </font><strong><font style="color:rgb(145, 109, 213);">ROW</font></strong><font style="color:rgb(0, 0, 0);"> 模式保存 </font><strong><font style="color:rgb(145, 109, 213);">binlog</font></strong></p>
<h4 id="撤销日志（Undo-Logs）"><a href="#撤销日志（Undo-Logs）" class="headerlink" title="撤销日志（Undo Logs）"></a><font style="color:black;">撤销日志（Undo Logs）</font></h4><p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">世间没有后悔药，但是在MySQL中实现了重头开始，撤销日志（Undo Logs）就是MySQL的后悔药。</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">「撤消日志是在事务开始之前保存的被修改数据的备份，用于回滚事务」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">撤消日志属于逻辑日志，根据每行记录进行记录。</font></p>
<p><font style="color:black;">撤消日志存在于系统表空间、撤消表空间和临时表空间中。</font></p>
<h4 id="什么是Undo-log"><a href="#什么是Undo-log" class="headerlink" title="什么是Undo log"></a><font style="color:black;">什么是Undo log</font></h4><p><font style="color:black;">Undo：意为撤销或取消，undo即返回指定某个状态的操作</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「undo log」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「一种用于撤销回退的日志，在事务开始之前，会先记录存放到 Undo 日志文件里，备份起来，当事务回滚时或者数据库崩溃时用于回滚事务」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「undo log记录的是什么」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「undo log中记录的是当前事务操作中的相反操作」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">undo日志属于逻辑日志，记录的是一个操作过程，sql执行delete或者update操作都会记录一条undo日志</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一条insert语句在undo log中会对应一条delete语句，</span><br><span class="line">  一条delete语句在undo log中会对应一条insert语句，</span><br><span class="line">  update语句会在undo log中对应相反的update语句，</span><br></pre></td></tr></table></figure>

<h4 id="Undo-log存储方式"><a href="#Undo-log存储方式" class="headerlink" title="Undo log存储方式"></a><font style="color:black;">Undo log存储方式</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「Undo log的存储由InnoDB存储引擎实现」</font></strong><font style="color:black;">，数据保存在InnoDB的数据文件中，innodb存储引擎对undo的管理采用回滚段（rollback segment）的数据结构。</font></p>
<p><font style="color:black;">回滚段（rollback segment）中有1024个undo log segment，</font></p>
<ul>
<li><font style="color:black;">MySQL5.5版本之前</font></li>
</ul>
<p><font style="color:black;">只支持1个rollback segment，即只能存储1024个undo log segment</font></p>
<ul>
<li><font style="color:black;">MySQL5.5版本之后</font></li>
</ul>
<p><font style="color:black;">支持128个rollback segment（innodb_undo_logs配置项），即能存储128*1024个undo log segment</font></p>
<h4 id="Undo-log相关的变量"><a href="#Undo-log相关的变量" class="headerlink" title="Undo log相关的变量"></a><font style="color:black;">Undo log相关的变量</font></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%innodb_undo%&#x27;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_undo_directory    | .\    |</span><br><span class="line">| innodb_undo_log_truncate | OFF   |</span><br><span class="line">| innodb_undo_logs         | 128   |</span><br><span class="line">| innodb_undo_tablespaces  | 0     |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">4 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><font style="color:black;">innodb_undo_directory</font></li>
</ul>
<p><font style="color:black;">定义存储的目录路径，默认值.\，表示datadir，</font></p>
<p><font style="color:black;">datadir参数在my.in中配置</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=&quot;D:\mysql-8.0.13-winx64\data&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><font style="color:black;">innodb_undo_log_truncate</font></li>
</ul>
<p><font style="color:black;">开启1(ON)&#x2F;关闭0(OFF)在线回收（收缩）undo log日志文件，支持动态设置，默认关闭</font></p>
<ul>
<li><font style="color:black;">innodb_undo_logs</font></li>
</ul>
<p><font style="color:black;">回滚段rollback segment的数量，Mysql5.5版本后默认设置为128</font></p>
<ul>
<li><font style="color:black;">innodb_undo_tablespaces</font></li>
</ul>
<p><font style="color:black;">默认值为0，表示undo log全部写入一个表空间文件，可以设置这个变量，平均分配到多少个文件中。</font></p>
<h4 id="Undo-log的工作原理"><a href="#Undo-log的工作原理" class="headerlink" title="Undo log的工作原理"></a><font style="color:black;">Undo log的工作原理</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「undo log在事务开启之前产生，当事务提交后，InnoDB会将事务对应的undo日志保存在删除list中，后台通过清除线程进行回收处理」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">以一条sql执行update、select过程，如图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717575120869-055b093a-cc5e-4a3b-b3f7-90ac90fac7f5.webp"></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">执行update操作，事务A提交时候（事务还没提交），会将数据进行备份，备份到对应的undo buffer，</font></li>
<li><font style="color:rgb(1, 1, 1);">Undo Log保存了未提交之前的操作日志，User表数据肯定就是持久保存到InnoDB的数据文件IBD，默认情况。</font></li>
<li><font style="color:rgb(1, 1, 1);">此时事务B进行查询操作，直接读undo buffer缓存，事务A还没提交事务，如需要回滚，不读磁盘，先直接从undo buffer缓存读取</font></li>
</ul>
<h4 id="Undo-log作用说明"><a href="#Undo-log作用说明" class="headerlink" title="Undo log作用说明"></a><font style="color:black;">Undo log作用说明</font></h4><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「实现事务的原子性」</font></strong><font style="color:black;">undo log可以用于实现事务的原子性， 如果事务处理过程中要执行回滚（rollback）操作，可以利用undo log将数据恢复到事务开始之前</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「实现多版本并发控制（MVCC）」</font></strong><font style="color:black;">Undo Log 在 MySQL InnoDB 存储引擎中用来实现多版本并发控制，事务没提交之前，undo日志可以作为高并发情况下其它并发事务进行快照读。</font></li>
</ul>
<h4 id="Undo-log的清理"><a href="#Undo-log的清理" class="headerlink" title="Undo log的清理"></a><font style="color:black;">Undo log的清理</font></h4><h5 id="Undo-log类型"><a href="#Undo-log类型" class="headerlink" title="Undo log类型"></a><font style="color:black;">Undo log类型</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「在回滚段中，每个 undo log 段都有一个类型字段，共有两种类型」</font></strong><font style="color:black;">：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「insert undo log」</font><strong><strong><font style="color:rgb(145, 109, 213);">「代表事务在</font></strong></strong><font style="color:rgb(145, 109, 213);">insert</font><strong><strong><font style="color:rgb(145, 109, 213);">新记录时产生的</font></strong></strong><font style="color:rgb(145, 109, 213);">undo log</font>****<font style="color:rgb(145, 109, 213);">, 其回滚段类型为 insert undo logs，仅用于事务回滚，并且在事务提交后可以被立即丢弃」</font></strong><font style="color:rgb(1, 1, 1);">。</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「update undo log」「事务在进行update或delete时产生的undo log，其回滚段类型为 update undo logs; 不仅在事务回滚时需要，在实现MVCC快照读时也需要」</font></strong></li>
</ul>
<h5 id="Undo-log清理类型"><a href="#Undo-log清理类型" class="headerlink" title="Undo log清理类型"></a><font style="color:black;">Undo log清理类型</font></h5><p><font style="color:black;">Undo log的清理也分为两种情况</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「事务 rollback」</font></strong></li>
</ul>
<p><font style="color:black;">如果事务rollback，innodb 通过执行 undo log中的所有反向操作，实现事务回滚，随后就会删除该事务关联的所有 undo log 段。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「事务 commit」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">对于 insert undo logs，事务回滚后，innodb会直接清除该事务关联的所有 undo log 段。</font></li>
<li><font style="color:rgb(1, 1, 1);">对于 update undo logs，只有当前没有任何活跃事务存在时，innodb 的 purge 线程才会清理这些 undo log 段</font></li>
</ul>
</li>
</ul>
<h5 id="purge-线程"><a href="#purge-线程" class="headerlink" title="purge 线程"></a><font style="color:black;">purge 线程</font></h5><p><font style="color:black;">上述提到的</font><font style="color:black;"> </font><strong><font style="color:rgb(145, 109, 213);">「purge 线程，是一个周期运行的垃圾收集线程，主要用来收集 undo log 段」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「innodb 会将所有需要清理的任务添加到 purge 队列中，」</font></strong></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">可以通过 innodb_max_purge_lag 配置项设定 purge 队列的大小</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">「purge 线程会在周期执行时，对 purge 队列中的任务进行清理，」</font></strong></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">可以通过innodb_max_purge_lag_delay 配置项设定 purge 线程的执行周期间隔</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">「尽量缩短使用中每个事务的持续时间，可以让 purge 线程有更大概率回收已经没有存在必要的 undo log 段，从而尽量释放磁盘空间的占用」</font></strong></p>
<h4 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志(error log)"></a><font style="color:black;">错误日志(error log)</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「错误日志(error log)：记录mysql服务的启停时正确和错误的信息，还记录启动、停止、运行过程中的错误信息。」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「指定错误日志文件」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「在my.ini的[mysqld]下：添加代码：log-error&#x3D;file_name.txt。」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log-error=E:\log-error.txt。</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(145, 109, 213);">「如果没有指定file_name，则默认的错误日志文件为datadir目录下的</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">hostname</font>****<font style="color:rgb(145, 109, 213);">.err ，hostname表示当前的主机名。」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看错误日志位置」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;log_error&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717575254013-180b3541-a69b-4c87-aa8e-965c6121a98e.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「错误日志的产生」</font></strong><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「MySQL 5.5.7之前」</font></strong></li>
</ul>
</li>
</ul>
<p><font style="color:black;">刷新日志操作(如flush logs)会备份旧的错误日志(以_old结尾)，并创建一个新的错误日志文件并打开。</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「在MySQL 5.5.7之后」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">执行刷新日志的操作时，错误日志</font><strong><font style="color:rgb(145, 109, 213);">「会关闭并重新打开」</font></strong><font style="color:black;">，如果错误日志不存在，则会先创建。</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「MySQL正在运行状态下」&lt;/font&gt;**
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「在运行状态下删除错误日志后，不会自动创建错误日志，只有在刷新日志的时候才会创建一个新的错误日志文件」</font></strong></p>
<h4 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a><font style="color:black;">查询日志</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「查询日志分为一般查询日志和慢查询日志」</font></strong><font style="color:black;">。通过查询是否超出变量</font><strong><font style="color:rgb(145, 109, 213);">「long_query_time」</font></strong><font style="color:black;">指定时间的值来判定的。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「在超时时间内完成的查询是一般查询，可以将其记录到一般查询日志中，超出时间的查询是慢查询，可以将其记录到慢查询日志中。」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「long_query_time」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定慢查询超时时长，超出此时长的属于慢查询，会记录到慢查询日志中</span><br><span class="line">long_query_time = 10 </span><br><span class="line"># 定义一般查询日志和慢查询日志的输出格式，不指定时默认为file</span><br><span class="line">log_output=&#123;TABLE|FILE|NONE&#125;</span><br></pre></td></tr></table></figure>

<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「TABLE：表示记录日志到表中」&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「FILE：表示记录日志到文件中」&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「NONE：表示不记录日志」&lt;/font&gt;**
</code></pre>
<h5 id="一般查询日志-general-log"><a href="#一般查询日志-general-log" class="headerlink" title="一般查询日志(general log)"></a><font style="color:black;">一般查询日志(general log)</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「记录了服务器接收到的每一个查询或是命令」</font></strong><font style="color:black;">，无论这些查询或是命令是否正确甚至是否包含语法错误，general log 都会将其记录下来 。</font></p>
<p><font style="color:black;">开启General logmysql服务器需要不断地记录日志，会产生一定的系统开销。 所有Mysql默认关闭一般查询日志。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「开启general log」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global general_log=on;#为全局变量</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「开启general log」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global general_log=off;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看general log是否开启」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global variables like &#x27;general_log&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717575395829-a665fba8-286b-4a4f-be0a-378f3d89c616.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「设置日志文件路径」</font></strong></li>
</ul>
<p><font style="color:black;">默认是库文件路径下主机名加上.log</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global general_log_file=&#x27;/tmp/general.log&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看日志输出格式」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;log_output&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717575395829-0dfab655-3400-48f6-b7de-b2a5deff681c.webp"></p>
<h5 id="慢查询日志-slow-log"><a href="#慢查询日志-slow-log" class="headerlink" title="慢查询日志(slow log)"></a><font style="color:black;">慢查询日志(slow log)</font></h5><p><strong><font style="color:rgb(145, 109, 213);">「慢查询日志记录执行时间超过long_query_time和没有使用索引的查询语句，并且只会记录执行成功的语句。」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);">「查询超出变量 long_query_time 指定时间值的为慢查询。不包含查询获取锁(包括锁等待)的时间」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看慢查询指定时间」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「默认10s」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like  &#x27;long_query_time&#x27;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看慢查询的条数」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &quot;%slow_queries%&quot;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Slow_queries  | 4     |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">以上Slow_queries &#x3D; 4 说明查询超过10秒的查询有4个</font></p>
<p>:::</p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「启用慢查询日志」</font></strong></li>
</ul>
<p><font style="color:black;">1与ON等价，0与OFF等价。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set @@global.slow_query_log=on;</span><br><span class="line">#或者  </span><br><span class="line">mysql&gt; set @@global.slow_query_log=1;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看是否启用慢查询日志」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;slow_query%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717575429450-d168858b-936d-47b2-b83e-42689aca17be.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「slow_query_log」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slow_query_log=&#123;1|ON|0|OFF&#125; 与  log_slow_queries=&#123;``yes``|no&#125; 都是表示是否启用慢查询日志，两个同时变化。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「slow_query_log_file」</font></strong></li>
</ul>
<p><font style="color:black;">日志文件位置，默认路径为库文件目录下主机名加上-slow.log</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「【MySQL记录慢查询日志是在查询执行完毕且已经完全释放锁之后记录的】，因此慢查询日志记录的顺序和执行的SQL查询语句顺序可能会不一致（先执行完先记录）」</font></strong><font style="color:black;">。</font></p>
<h4 id="中继日志-relay-log"><a href="#中继日志-relay-log" class="headerlink" title="中继日志(relay log)"></a><font style="color:black;">中继日志(relay log)</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「主要作用：主从复制」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);">「【从服务器I&#x2F;O线程】将主服务器的【二进制日志】读取过来记录到从服务器本地文件，然后【从服务器SQL线程】会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「查看relay log配置」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%relay%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717575453864-636fa078-ba3e-4f0c-a829-398c26b3f5e4.webp"></p>
<h4 id="Bin-log、redo-log、Undo-如何协同"><a href="#Bin-log、redo-log、Undo-如何协同" class="headerlink" title="Bin log、redo log、Undo 如何协同"></a><font style="color:black;">Bin log、redo log、Undo 如何协同</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「先来回顾一下几个日志的主要作用」</font></strong></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">Buffer Pool 是MySQL的一个非常重要的组件，因为针对数据库的增删改操作都是在Buffer Pool完成的</font></li>
<li><font style="color:rgb(1, 1, 1);">Undo log 记录的是数据操作前的样子</font></li>
<li><font style="color:rgb(1, 1, 1);">Redo log 记录的是数据被操作后的样子</font></li>
<li><font style="color:rgb(1, 1, 1);">Bin log 记录的是整个操作记录</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「准备更新一条数据到事务的提交的流程描述：」</font></strong></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">首先执行器根据MySQL的执行计划来查询数据，先是从缓存池(Buffer Pool)中查询数据，如果没有就会去 数据库中查询，如果查询到了就将其放到缓存池中。</font></li>
<li><font style="color:rgb(1, 1, 1);">在数据被缓存到缓存池的同时，会写入 undo log 日志文件</font></li>
<li><font style="color:rgb(1, 1, 1);">更新的动作是在BufferPool中完成的，同时会将更新后的数据添加到redo log buffer中</font></li>
<li><font style="color:rgb(1, 1, 1);">完成以后就可以提交事务，在提交的同时会做以下三件事</font><ul>
<li><font style="color:rgb(1, 1, 1);">将redo log buffer中的数据刷入到redo log 文件中</font></li>
<li><font style="color:rgb(1, 1, 1);">将本次操作记录写入到bin log文件中</font></li>
<li><font style="color:rgb(1, 1, 1);">将bin log 文件名字和更新内容在bin log中的位置记录到redo log中，同时在redo log 最后添加 commit 标记</font></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717575499651-60f7355b-2b72-4929-9d8d-b553a2d424f1.webp"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>buffer pool</title>
    <url>/2024/07/15/Buffer%20Pool/</url>
    <content><![CDATA[<ul>
<li><font style="color:rgb(1, 1, 1);">在应用系统中，我们为加速数据访问，会把高频的数据放在</font><strong><font style="color:rgb(145, 109, 213);">「缓存」</font></strong><font style="color:rgb(1, 1, 1);">(Redis、MongoDB)里，减轻数据库的压力。</font></li>
<li><font style="color:rgb(1, 1, 1);">在操作系统中，为了减少磁盘IO，引入了</font><strong><font style="color:rgb(145, 109, 213);">「缓冲池」</font></strong><font style="color:rgb(1, 1, 1);">(buffer pool)机制。</font></li>
<li><font style="color:rgb(1, 1, 1);">MySQL作为一个存储系统，为提高性能，减少磁盘IO，同样具有</font><strong><font style="color:rgb(145, 109, 213);">「缓冲池」</font></strong><font style="color:rgb(1, 1, 1);">(buffer pool)机制。</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717656410928-52fce218-aa63-4b49-b4d5-45e9ad4d7248.webp"></p>
<span id="more"></span>
<p><strong><font style="color:rgb(145, 109, 213);">「上述结构图中展示了Buffer Pool作为InnoDB内存结构的四大组件之一，不属于MySQL的Server层，是InnoDB存储引擎层的缓冲池」</font></strong><font style="color:black;">。因此这个跟MySQL8.0删掉的【查询缓存】功能是不一样的。</font></p>
<h2 id="什么是Buffer-Pool"><a href="#什么是Buffer-Pool" class="headerlink" title="什么是Buffer Pool"></a><strong><font style="color:black;">什么是Buffer Pool</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool即【缓冲池，简称BP】，BP以Page页为单位，缓存最热的数据页(data page)与索引页(index page)，Page页默认大小16K，BP的底层采用链表数据结构管理Page」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717656447440-b372594b-3bc8-4ac3-a008-dd6be65c55c3.webp"></p>
<p><font style="color:black;">上图描述了Buffer Pool在innoDB中的位置，通过它所在的位置我们可以大概知道它的工作流程：</font></p>
<hr>
<p><font style="color:black;">所有数据页的读写操作都需要通过buffer pool进行，</font></p>
<ul>
<li><font style="color:black;">innodb 读操作，先从buffer_pool中查看数据的数据页是否存在，如果不存在，则将page从磁盘读取到buffer pool中。</font></li>
<li><font style="color:black;">innodb 写操作，先把数据和日志写入 buffer pool 和 log buffer，再由后台线程以一定频率将 buffer 中的内容刷到磁盘，</font><strong><font style="color:rgb(145, 109, 213);">「这个刷盘机制叫做Checkpoint」</font></strong><font style="color:black;">。</font></li>
</ul>
<p><font style="color:black;">写操作的事务持久性由redo log 落盘保证，buffer pool只是为了提高读写效率。</font></p>
<hr>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717656447499-d5f9f2d4-c329-4a91-ae37-ba4a370b1411.webp"></p>
<p><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><font style="color:black;">Buffer Pool是一块内存区域，是一种</font><strong><font style="color:rgb(145, 109, 213);">「降低磁盘访问的机制」</font></strong><font style="color:black;">。</font></li>
<li><font style="color:black;">数据库的读写都是在buffer pool上进行，和undo log&#x2F;redo log&#x2F;redo log buffer&#x2F;binlog一起使用，后续会把数据刷到硬盘上。</font></li>
<li><font style="color:black;">Buffer Pool默认大小 128M，用于缓存数据页（16KB）。</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717656447437-0265f185-fe35-468b-b691-dc94bdc0e714.webp"></p>
<hr>
<p><font style="color:black;">Buffer Pool 是 innodb的数据缓存， 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「buffer pool绝大多数page都是 data page（包括index page）」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「innodb 还有日志缓存 log buffer，保存redo log」</font></strong><font style="color:black;">。</font></p>
<hr>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717656447477-fc5caad1-fcd6-408d-a849-00d9503ef7ca.webp"></p>
<h2 id="Buffer-Pool的控制块"><a href="#Buffer-Pool的控制块" class="headerlink" title="Buffer Pool的控制块"></a><strong><font style="color:black;">Buffer Pool的控制块</font></strong></h2><p><font style="color:black;">Buffer Pool中缓存的是数据页，数据页大小跟磁盘默认数据页大小一样（16K），为了更好管理的缓存页，Buffer Pool有一个</font><strong><font style="color:rgb(145, 109, 213);">「描述数据的区域」</font></strong><font style="color:black;"> </font><font style="color:black;">：</font></p>
<hr>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB 为每一个缓存的数据页都创建了一个单独的区域，记录的数据页的元数据信息，包括数据页所属表空间、数据页编号、缓存页在Buffer Pool中的地址，链表节点信息、一些锁信息以及 LSN 信息等，这个区域被称之为控制块」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边」</font></strong><font style="color:black;">，</font></p>
<p><font style="color:black;">控制块大概占缓存页大小的5%，16 * 1024 * 0.05 &#x3D; 819个字节左右。</font></p>
<hr>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657257613-6b52c015-648e-4604-9d3f-760be58868c7.webp"></p>
<p><font style="color:black;">上图展示了控制块与数据页的对应关系，可以看到在控制块和数据页之间有一个碎片空间。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">这里可能会有疑问，为什么会有碎片空间呢？</font></p>
<p>:::</p>
<p><font style="color:rgb(0, 0, 0);">上面说到，数据页大小为16KB，控制块大概为800字节，当我们划分好所有的控制块与数据页后，可能会有剩余的空间不够一对控制块和缓存页的大小，这部分就是多余的碎片空间。如果把 Buffer Pool 的大小设置的刚刚好的话，也可能不会产生碎片。</font></p>
<h2 id="Buffer-Pool的管理"><a href="#Buffer-Pool的管理" class="headerlink" title="Buffer Pool的管理"></a><strong><font style="color:black;">Buffer Pool的管理</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool里有三个链表，LRU链表，free链表，flush链表，InnoDB正是通过这三个链表的使用来控制数据页的更新与淘汰的」</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<h3 id="Buffer-Pool的初始化"><a href="#Buffer-Pool的初始化" class="headerlink" title="Buffer Pool的初始化"></a><font style="color:black;">Buffer Pool的初始化</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「当启动 Mysql 服务器的时候，需要完成对 Buffer Pool 的初始化过程，即分配 Buffer Pool 的内存空间，把它划分为若干对控制块和缓存页」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「申请空间」</font></strong></li>
</ul>
<p><font style="color:black;">Mysql 服务器启动，就会根据设置的Buffer Pool大小（innodb_buffer_pool_size）超出一些，去操作系统</font><strong><font style="color:rgb(145, 109, 213);">「申请一块连续内存区域」</font></strong><font style="color:black;">作为Buffer Pool的内存区域。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">这里之所以申请的内存空间会比innodb_buffer_pool_size大一些，主要是因为里面还要存放每个缓存页的控制块。</font></p>
<p>:::</p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「划分空间」</font></strong></li>
</ul>
<p><font style="color:black;">当内存区域申请完毕之后，数据库就会按照默认的缓存页的16KB的大小以及对应的800个字节左右的控制块的大小，在Buffer Pool中划分</font><strong><font style="color:rgb(145, 109, 213);">「成若干个【控制块&amp;缓冲页】对」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">划分空间后Buffer Pool的缓存页是都是空的，里面什么都没有，当要对数据执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入Buffer Pool中的缓存页中。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657310845-72f1fbae-3977-4b6d-8559-2e3499e18d61.webp"></p>
<h3 id="Free链表"><a href="#Free链表" class="headerlink" title="Free链表"></a><font style="color:black;">Free链表</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「在Buffer pool刚被初始化出来的时候，里面的数据页以及控制块都是空的」</font></strong><font style="color:rgb(0, 0, 0);">，当执行读写的时候磁盘的数据页会加载到Buffer pool的数据页中，当BufferPool中间有的页数据持久化到硬盘后，这些数据页又会被空闲出来。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">以上的过程中会有一个问题，如何知道那些数据页是空的，那些是有数据的，只有找到空的数据页，才能吧数据写进去，一种方式是遍历所有的数据页，根据经验，一般只要是全部遍历，对于一个有追求的码农肯定是不能忍的，innoDB的开发者无疑更加不能忍，所以就有了free链表。</font></p>
<p>:::</p>
<h4 id="Free链表是个啥"><a href="#Free链表是个啥" class="headerlink" title="Free链表是个啥"></a><font style="color:black;">Free链表是个啥</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「Free链表即空闲链表，是一个双向链表，由一个基础节点和若干个子节点组成，记录空闲的数据页对应的控制块信息」</font></strong><font style="color:black;">。如下</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657356501-a83c7794-11e5-4653-abf2-646f6b50701f.webp"></p>
<ul>
<li><font style="color:black;">Free链表作用：帮助找到空闲的缓存页</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「基节点」</font></strong><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「是一块单独申请的内存空间（约占40字节）。并不在Buffer Pool的连续内存空间里」</font></strong><font style="color:black;">。</font></li>
<li><font style="color:black;">包含链表中子节点中头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「子节点」</font></strong><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「每个节点就是个空闲缓存页的控制块，即只要一个缓存页空闲，那它的控制块就会被放入free链表」</font></strong></li>
<li><font style="color:rgb(1, 1, 1);">每个控制块块里都有两个指针free_pre（指向上一个节点），free_next（指向下一个节点）</font></li>
</ul>
</li>
</ul>
<p><font style="color:black;">Free链表存在的意义就是描述Buffer Pool中的数据页，所以Free链表跟数据页的是一一对应的关系，如下图所示：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657356449-a8be7e80-6de2-48ef-840e-b900a1e98deb.webp"></p>
<p><font style="color:black;">上图就是Free链表记录空闲数据页的对应关系，这里可能会有一个误区，以为这个控制块，在Buffer Pool里有一份，在free链表里也有一份，似乎在内存里有两个一模一样的控制块，</font><strong><font style="color:rgb(145, 109, 213);">「如果这么想就大错特错了」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「误区说明」</font></strong></p>
<hr>
<p><strong><font style="color:rgb(145, 109, 213);">「free链表本身其实就是由Buffer Pool里的控制块组成的，前文中说到每个控制块里都有free_pre&#x2F;free_next两个指针，分别指向自己的上一个free链表的节点，以及下一个free链表的节点。」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool中的控制块通过两个指针，就可以把所有的控制块串成一个free链表。上面为了画图看起来更加清晰，所以把free链表单独画了一份出来，表示他们之间的指针引用关系。」</font></strong></p>
<hr>
<p><strong><font style="color:rgb(145, 109, 213);">「基于此，真正的关系图应该下图」</font></strong><font style="color:black;">：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657356457-5340eafa-8ed2-424d-9735-363ac5ae768b.webp"></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">这里之所以会把两个图都画画出来，是因为网上很多博客画的图都是类似上面哪一种，</font><strong><font style="color:rgb(145, 109, 213);background-color:rgb(244, 238, 255);">「会给人产生在Buffer Pool和free链表各有一个控制块的误区」</font></strong><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">，我在开始的时候也产生了这样的疑问，所以在这里说明记录一下。</font></p>
<p>:::</p>
<h4 id="磁盘页加载到BufferPool的缓存也流程"><a href="#磁盘页加载到BufferPool的缓存也流程" class="headerlink" title="磁盘页加载到BufferPool的缓存也流程"></a><font style="color:black;">磁盘页加载到BufferPool的缓存也流程</font></h4><p><font style="color:black;">通过free链表只需要三步就可以将磁盘页加载到BufferPool的缓存中：</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「步骤一」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);">「从free链表中取出一个空闲的控制块以及对应缓冲页」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657393636-3d327a03-fe7a-4294-80f3-3d7eab10d1ff.webp"></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「步骤二」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);">「把磁盘上的数据页读取到对应的缓存页，同时把相关的一些描述数据写入缓存页的控制块（例如：页所在的表空间、页号之类的信息）」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657393702-738c6140-b8af-49bd-a13f-adcc4597bf40.webp"></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「步骤三」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);">「把该控制块对应的free链表节点从链表中移除，表示该缓冲页已经被使用了」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657393644-fc3acbef-4b18-464b-8d44-9584d02d92a9.webp"></li>
</ul>
<p><font style="color:black;">下面用一个伪代码来描述一下控制块是如何在free链表节点中移除的，假设控制块的结构如下</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  控制块</span><br><span class="line"> */</span><br><span class="line">publicclass CommandBlock &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  控制块id,也就是自己，可以理解为当前控制块的地址，</span><br><span class="line">     */</span><br><span class="line">    private  String blockId;</span><br><span class="line">    /**</span><br><span class="line">     *  Free链表中当前控制块的上一个节点地址</span><br><span class="line">     */</span><br><span class="line">    private  String freePre;</span><br><span class="line">    /**</span><br><span class="line">     *  Free链表中当前控制块的下一个节点地址</span><br><span class="line">     */</span><br><span class="line">    private  String freeNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">假设有一个控制块n-1，他的上一个节点是描述数据块n-2，下一个节点是描述数据块n，则它的数据结构如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  控制块 n-1</span><br><span class="line"> */</span><br><span class="line">publicclass CommandBlock &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  控制块id,也就是自己，可以理解为当前控制块的地址 block_n-1，</span><br><span class="line">     */</span><br><span class="line">    blockId = block_n-1;</span><br><span class="line">    /**</span><br><span class="line">     *  Free链表中当前控制块的上一个节点地址 block_n-2</span><br><span class="line">     */</span><br><span class="line">    freePre = block_n-2;</span><br><span class="line">    /**</span><br><span class="line">     *  Free链表中当前控制块的下一个节点地址 block_n</span><br><span class="line">     */</span><br><span class="line">    freeNext = block_n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">上图我们使用了控制块N，要从free链表中移除，则只需要把block_n-1中的freeNext设置为null即可， block_n就失去了链表的引用了。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  控制块 n-1</span><br><span class="line"> */</span><br><span class="line">publicclass CommandBlock &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  控制块id,也就是自己，可以理解为当前控制块的地址 block_n-1，</span><br><span class="line">     */</span><br><span class="line">    blockId = block_n-1;</span><br><span class="line">    /**</span><br><span class="line">     *  Free链表中当前控制块的上一个节点地址 block_n-2</span><br><span class="line">     */</span><br><span class="line">    freePre = block_n-2;</span><br><span class="line">    /**</span><br><span class="line">     *  Free链表中当前控制块的下一个节点地址 block_n</span><br><span class="line">     */</span><br><span class="line">    freeNext = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何确定数据页是否被缓存"><a href="#如何确定数据页是否被缓存" class="headerlink" title="如何确定数据页是否被缓存"></a><font style="color:black;">如何确定数据页是否被缓存</font></h4><p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">了解了磁盘页是通过Free加载到Buffer Pool 的缓存页的过程，不能所有的数据都去磁盘读取然后通过Free链表写入缓存页中，有可能在缓存页中已经有了这个数据页了，那么怎么确定应不应该去缓存数据页呢？</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">「数据库提供了一个数据页缓存哈希表，以表空间号+数据页号作为key，缓存页控制块的地址作为value」</font></strong><font style="color:black;">。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#注意：value是控制块的地址，不是缓存页地址</span><br><span class="line">&#123;表空间号+数据页号:控制块的地址&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><font style="color:black;">当使用数据页时，会先在数据页缓存哈希表中查找，如果找到了，则直接根据value定位控制块，然后根据控制块找到缓存页，如果没有找到，则读取磁盘数据页写入缓存，最后写入数据页缓存哈希表。</font></p>
<hr>
<p><strong><font style="color:rgb(145, 109, 213);">「在这个过程中一条语句要执行，大致会经历以下几个过程」</font></strong><font style="color:black;">：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">通过sql语句中的数据库名和表名可以知道要加载的数据页处于哪个表空间。</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「根据表空间号，表名称本身通过一致性算法得到索引根节点数据页号」</font></strong><font style="color:rgb(1, 1, 1);">。</font></li>
<li><font style="color:rgb(1, 1, 1);">进而根据根节点数据页号，找到下一层的数据页，可以从数据页缓存哈希表得到对应缓存页地址。</font></li>
<li><font style="color:rgb(1, 1, 1);">通过缓存页地址就可以在Buffer Pool池中定位到缓存页。</font></li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">重点误区！！！重点误区！！！重点误区！！！</font></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">重要的事情说三遍：</font></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">上面说的一致性哈希算法</font><strong><font style="color:rgb(145, 109, 213);background-color:rgb(244, 238, 255);">「指在数据字典中【根节点的页号，不是当前查找的数据的数据页号】」</font></strong><font style="color:black;background-color:rgb(244, 238, 255);">，当我们得到根节点页号后，通过B+tree一层一层往下找，在找下一层之前会通过数据缓存哈希表去buffer pool里面看看这个层的数据页存不存在，不存在则去磁盘加载。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「下文所有的图解都是查找buffer pool的过程，不包含索引的树状结构的查找」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);">「下文所有的图解都是查找buffer pool的过程，不包含索引的树状结构的查找」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);">「下文所有的图解都是查找buffer pool的过程，不包含索引的树状结构的查找」</font></strong></p>
<p><font style="color:black;">流程图如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657432648-0b50446c-a18f-4559-9951-6bd2b96e002b.webp"></p>
<h3 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a><font style="color:black;">LRU链表</font></h3><p><font style="color:black;">了解LRU链表之前，我们先来考虑两个问题：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">第一个问题：前面说到当从磁盘中读取数据页到Buffer Pool的时候，会将对应的控制块从Free链表中移除，那这个控制块移除之后被放到哪里去了呢？</font></li>
<li><font style="color:rgb(1, 1, 1);">第二个问题：Buffer Pool的大小是128MB，当Buffer Pool中空闲数据页全部别加载数据之后，新的数据要怎么处理呢？</font></li>
</ul>
<p><font style="color:black;">以上两个问题都需要LRU链表来解决，下面带着这两个问题来看看LRU链表。</font></p>
<h4 id="LRU链表是个啥"><a href="#LRU链表是个啥" class="headerlink" title="LRU链表是个啥"></a><font style="color:black;">LRU链表是个啥</font></h4><p><font style="color:black;">Buffer pool 作为一个innodb自带的一个缓存池，数据的读写都是buffer pool中进行的，操作的都是Buffer pool中的数据页，但是Buffer Pool  的大小是有限的（默认128MB），所以对于一些频繁访问的数据是希望能够一直留在 Buffer Pool 中，而一些访问比较少的数据，我们希望能将它够释放掉，空出数据页缓存其他数据。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「基于此，InnoBD采用了LRU（Least recently used）算法，将频繁访问的数据放在链表头部，而不怎么访问的数据链表末尾，空间不够的时候就从尾部开始淘汰，从而腾出空间」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657477386-d7c25d2d-6484-4b2f-8455-f5704215da2a.webp"></p>
<p><strong><font style="color:rgb(145, 109, 213);">「LRU链表本质上也是有控制块组成的」</font></strong><font style="color:black;">。</font></p>
<h4 id="LRU链表的写入过程"><a href="#LRU链表的写入过程" class="headerlink" title="LRU链表的写入过程"></a><font style="color:black;">LRU链表的写入过程</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「当数据库从磁盘加载一个数据页到Buffer Pool中的时候，会将一些变动信息也写到</font><strong><strong><font style="color:rgb(145, 109, 213);">控制块</font></strong></strong><font style="color:rgb(145, 109, 213);">中，并且将控制块从Free链表中脱离加入到LRU链表中」</font></strong><font style="color:black;">。过程如下：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657493136-30883479-0dae-4d2b-aabc-f042ab8bfc08.webp"></p>
<p><font style="color:black;">梳理一下整个过程：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「步骤一：根据表空间号，表名称本身通过一致性算法得到数据页号(这里省略了树状查找过程)」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「步骤二：通过数据页缓存哈希表判断数据页是否被加载」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「步骤三：从Free链表中获取一个控制块」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「步骤四：读取磁盘数据」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「步骤六：将数据写到空闲的缓存页中」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「步骤七：将缓存页的信息写回控制块」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「步骤八：将回控制块从Free链表中移除」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「步骤九：将从Free中移除的控制块节点加入到LRU链表中」</font></strong></li>
</ul>
<h4 id="LRU链表的淘汰机制"><a href="#LRU链表的淘汰机制" class="headerlink" title="LRU链表的淘汰机制"></a><font style="color:black;">LRU链表的淘汰机制</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「LRU算法的设计思路就是：链表头部的节点是最近使用的，链表末尾的节点是最久没被使用的，当空间不够的时候就淘汰末尾最久没被使用的节点，从而腾出空间」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「LRU算法的目的就是为让被访问的缓存页能够尽量排到靠前的位置」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「LRU 算法的设计思路」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">当访问的页在 Buffer Pool  里，就将该页对应的控制块移动到 LRU 链表的头部节点。</font></li>
<li><font style="color:rgb(1, 1, 1);">当访问的页不在 Buffer Pool 里，除了要把控制块放入到 LRU 链表的头部，还要淘汰  LRU 链表末尾的节点。</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「LRU 的实现过程」</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657510322-553d5589-c51d-495d-9543-a8dce9305a44.webp"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657510333-bdfb0408-67e1-46ec-a4cb-56c2635088f4.webp"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657510224-d710fd0e-7740-400a-b0e2-4fdf0c6a79fd.webp"></p>
<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;有一次数据访问，访问了数据页23，数据页23不在Buffer Pool  里，因此在磁盘加载之后会将末尾的22号页淘汰，然后将23加载到链表的头部。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;此时，数据页7被访问了，因为数据页7就在链表中，也就是页在 Buffer Pool  里，所以直接将数据页7移动到链表的头部即可。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;如下图， LRU 链表长度为 22，节点分别为1到22的数据页控制块，初始状态如下&lt;/font&gt;
</code></pre>
<p><font style="color:black;">以上就是LUR链表的实现过程，但是这种方式对于MySQL来说会有问题，所以MySQL并没有直接使用LRU链表的简单实现，而是对其做了一些改进，具体做了哪些改进，我们在下文中继续解释。</font></p>
<h3 id="Flush链表"><a href="#Flush链表" class="headerlink" title="Flush链表"></a><font style="color:black;">Flush链表</font></h3><p><font style="color:black;">前面解释了我们</font><strong><font style="color:rgb(145, 109, 213);">「对数据的读写都是先对Buffer Pool中的缓存页进行操作，然后在通过后台线程将脏页写入到磁盘，持久化到磁盘中，即刷脏」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「脏页：当执行写入操作时，先更新的是缓存页，此时缓存页跟磁盘页的数据就会不一致，这就是常说的脏页」</font></strong><font style="color:black;">。</font></p>
<hr>
<p><font style="color:black;">既然产生了脏页，那就是需要更新磁盘，也就是常说的刷脏，那如何确定那些缓存页需要刷脏呢？也不能吧所有的缓存页都重新刷新一百年磁盘，或者挨个遍历比对，这种方式肯定是不可取的，此时就需要Flush链表了。</font></p>
<h4 id="Flush链表是个啥"><a href="#Flush链表是个啥" class="headerlink" title="Flush链表是个啥"></a><font style="color:black;">Flush链表是个啥</font></h4><p><strong><font style="color:rgb(145, 109, 213);">「Flush链表与Free链表的结构很类似，也由基节点与子节点组成」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">Flush链表是一个双向链表，链表结点是被修改过的缓存页对应的控制块（更新过的缓存页）</font></li>
<li><font style="color:rgb(1, 1, 1);">Flush链表作用：帮助定位脏页，需要刷盘的缓存页</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「基节点」</font></strong><font style="color:black;">：和free链表一样，链接首尾结点，并存储了有多少个描述信息块</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「子节点」</font></strong><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「每个节点是脏页对应的控制块，即只要一个缓存页被修改，那它的控制块就会被放入Flush链表」</font></strong></li>
<li><font style="color:rgb(1, 1, 1);">每个控制块块里都有两个指针pre（指向上一个节点），next（指向下一个节点）</font></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657547900-4ffee01e-e6ba-472f-8954-f52eda14d2ab.webp"></p>
<p><strong><font style="color:rgb(145, 109, 213);">「前面说了控制块其实是在Buffer Pool中的，控制块是通过上下节点的引用，组成一个链表，所以只需要通过基节点挨个遍历子节点，找到需要刷脏的数据页即可」</font></strong><font style="color:black;">。</font></p>
<h4 id="Flush链表写入过程"><a href="#Flush链表写入过程" class="headerlink" title="Flush链表写入过程"></a><font style="color:black;">Flush链表写入过程</font></h4><p><font style="color:black;">当我们在写入数据的时候，我们知道磁盘IO的效率很慢，所以MySQL不会直接更新直接更新磁盘，而是经过以下两个步骤：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">第一步：更新Buffer Pool中的数据页，一次内存操作；</font></li>
<li><font style="color:rgb(1, 1, 1);">第二步：将更新操作顺序写Redo log，一次磁盘顺序写操作；</font></li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">这样的效率是最高的。顺序写Redo log，每秒几万次，问题不大。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657561801-469aca1f-42e2-4912-80ba-cd797e76e723.webp"></p>
<p><font style="color:black;">上图中描述了在更新数据页的时候，Flush链表的写入过程，其实这只是在被更新的数据已经别加载到Buffer Pool的前提下，如果我们要更新的数据没有别预先加载，那这个过程是不是会先去读取磁盘呢？实际上并不会，MySQL为了提高性能，减少磁盘IO，做了很多的优化，当数据页不存在Buffer Pool中的时候，会使用写缓冲(change buffer)来做更新操作，具体的实现原理下一篇文章再展开解释。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「当控制块被加入到Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;"></font></p>
<h3 id="Buffer-Pool-的数据页"><a href="#Buffer-Pool-的数据页" class="headerlink" title="Buffer Pool 的数据页"></a><font style="color:black;">Buffer Pool 的数据页</font></h3><p><font style="color:black;">上述了解了三种链表以及它们的使用方式，我们可以总结一下，</font><strong><font style="color:rgb(145, 109, 213);">「其实Buffer Pool 里有三种数据页页和链表来管理数据」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657580795-93b71839-18af-487b-a3aa-34b4e36f4f67.webp"></p>
<ul>
<li><font style="color:black;">Free Page（空闲页）</font></li>
</ul>
<p><font style="color:black;">表示此数据页未被使用，是空的，其控制块位于 Free 链表；</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「Clean Page（干净页）」</font></strong></li>
</ul>
<p><font style="color:black;">表示此数据页已被使用，缓存了数据， 其控制块位于LRU 链表。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「Dirty Page（脏页）」</font></strong></li>
</ul>
<p><font style="color:black;">表示此数据页【已被使用】且【已经被修改】，数据页中数据和磁盘上的数据已经不一致。</font></p>
<p><font style="color:black;">当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「脏页的控制块同时存在于 LRU 链表和 Flush 链表」</font></strong><font style="color:black;">。</font></p>
<h2 id="MySQL对LRU算法的改进"><a href="#MySQL对LRU算法的改进" class="headerlink" title="MySQL对LRU算法的改进"></a><strong><font style="color:black;">MySQL对LRU算法的改进</font></strong></h2><p><font style="color:black;">在前文中我们说到了简单的LRU算法会对于MySQL来说会有问题，因此MySQL对LRU算法进行了改进，接下来就来看看LRU算法存在什么问题，MySQL又是怎么改进的。</font></p>
<p><font style="color:black;">先来说说LRU 算法存在的问题：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「预读失效」</font></strong></li>
<li><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool  污染」</font></strong></li>
</ul>
<h3 id="什么是预读"><a href="#什么是预读" class="headerlink" title="什么是预读"></a><font style="color:black;">什么是预读</font></h3><p><font style="color:black;">既然LRU 算法存在预读失效的问题，先来看看什么是预读。</font></p>
<p><font style="color:black;">前面说到，为了减少磁盘IO，innoDB会把数据从磁盘读取到内存中使用，一般而言，数据的读取会遵循【集中读写】的原则，也就是当我们使用一些数据的时候，很大概率也会使用附件的数据，即【局部性原理】，它表明提前加载是有效的，能够减少磁盘IO。因此：</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「磁盘数据读取到内存，并不是按需读取，而是按页读取，一次至少读一页数据（16K），如果未来要读取的数据就在页中，直接读取内存即可，不需要磁盘IO，提高效率」</font></strong><font style="color:black;">。这也就是常说的</font><strong><font style="color:rgb(145, 109, 213);">「预读」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">通过预读我们就可以事先先把数据读取放在内存中，下面来看一下</font><strong><font style="color:rgb(145, 109, 213);">「buffer pool的工作流程图」</font></strong><font style="color:black;">:</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657610284-e58ab01a-778e-405c-a51d-587b4fd9a56f.webp"></p>
<p><font style="color:black;">buffer pool的工作流程图中以查询id为1的用户数据为例，大致可以分为三步：</font></p>
<ul>
<li><font style="color:black;">第一步：先查询buffer pool是否存在对应的数据页，有的话则直接返回</font></li>
<li><font style="color:black;">第二步：buffer pool不存在对应的数据页，则去磁盘中查找，并把结果copy一份到buffer pool中，然后返回给客户端</font></li>
<li><font style="color:black;">第三步：下次有同样的查询，就可以直接查找buffer pool返回数据</font></li>
</ul>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">例如：当id&#x3D;1与id&#x3D;2都在这个数据页中，那么下次查询Id&#x3D;2的时候，就可以直接通过buffer pool返回。</font></p>
<p>:::</p>
<p><font style="color:rgb(0, 0, 0);">这个过程看起来，感觉buffer pool跟缓存很类似，实际上它的缓存淘汰机制也跟Redis很类似。</font></p>
<h3 id="什么是预读失效"><a href="#什么是预读失效" class="headerlink" title="什么是预读失效"></a><font style="color:black;">什么是预读失效</font></h3><p><font style="color:black;">解释了什么是预读，那预读失效就很好理解了，</font><strong><font style="color:rgb(145, 109, 213);">「那些被提前加载进来的数据页并一直没有被访问，相当于预读是白费功夫，即预读失效」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「通过简单的LRU链表的实现过程我们知道，预读的数据会被放到 LRU 链表头部，而当  Buffer Pool空间不够的时候，需要把末尾的页淘汰掉。如果这些预读的数据一直没有被使用，而把被使用的数据挤到了链表的尾部，进而被淘汰，那缓存的命中率就会大大降低」</font></strong><font style="color:black;">。这样的话，预读就适得其反了。</font></p>
<h3 id="如何提高缓存的命中率"><a href="#如何提高缓存的命中率" class="headerlink" title="如何提高缓存的命中率"></a><font style="color:black;">如何提高缓存的命中率</font></h3><p><font style="color:black;">预读的数据被使用到的时候，会减少磁盘IO，但是预读失效的时候，也会降低缓存的命中率，不能因为预读失效，而将预读机制去掉，所以我们要在保留预读这个机制的前提下提高缓存的命中率。</font></p>
<hr>
<p><font style="color:black;">前面将在LRU链表的时候就解释了我们在读到数据之后，把对应的数据页放到LRU链表头部，因此想要提高缓存的命中率，只需要</font><strong><font style="color:rgb(145, 109, 213);">「让真正被访问的页才移动到 LRU 链表的头部，使其在 Buffer Pool 里停留的时间尽可能长，尽可能缩短预读的页停留在 Buffer Pool 里的时间」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「提高缓存的命中率」</font></strong></li>
</ul>
<p><font style="color:black;">MySQL基于这种设计思路对LRU 算法进行了改进，将 LRU 划分了 2 个区域：</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「划分old和young两个区域后，预读的页会被加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部」</font></strong><font style="color:black;">。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">如果预读的页一直没有被访问，会一直存在old 区域，直到被移除，不会影响 young 区域中的热点数据。</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">「old 区域」</font></strong><font style="color:black;">：在LRU 链表的后半部分</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「young 区域」</font></strong><font style="color:black;">：在 LRU 链表的前半部分</font></p>
<pre><code>- ![](https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657665132-776e22c4-1082-45fc-8fbb-fe5dff901f5a.webp)
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「old 区域占整个 LRU 链表长度的比例可以通过</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">innodb_old_blocks_pc</font><strong><strong><font style="color:rgb(145, 109, 213);"> </font></strong></strong><font style="color:rgb(145, 109, 213);">参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37」</font></strong><font style="color:black;">。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_old_blocks_pc%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657665126-94ce9d5e-e906-434b-b2e0-2ac57c617eb9.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「提高缓存的命中率案例说明」</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657665233-9f1cf8c9-18b5-4822-b24c-646ad09e2a97.webp"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657665503-66e47cba-d45e-403b-953c-8ee48a3dd89f.webp"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657665278-b21a115a-1f43-49bd-bc89-078a8b725f99.webp"></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;紧接着23号页被读取了，那么此时23号页就会被加入到young 区域的头部，而18号页则会被移动到Old区域的头部，这个过程不会有数据页被淘汰。&lt;/font&gt;
</code></pre>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">如果数据页23一直没有被读取，它就会一直存在于Old区，直到其他预读数据加载，慢慢将它淘汰。</font></p>
<p>:::</p>
<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;假设现在有一个数据页23被预读到Buffer Pool中了，那23号页会被加载到old 区域头部，而old区域末尾的22号页会被淘汰掉&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;还是以刚才LRU链表长度为 22，节点分别为1到22的数据页控制块为案例，划分区域后初始状态如下：&lt;/font&gt;
</code></pre>
<p><font style="color:black;">由此可见，通过对LRU区域的划分，可以很多好的解决了预读失效的问题，提高了提高缓存的命中率。</font></p>
<h3 id="什么是Buffer-Pool-污染"><a href="#什么是Buffer-Pool-污染" class="headerlink" title="什么是Buffer Pool  污染"></a><font style="color:black;">什么是Buffer Pool  污染</font></h3><p><font style="color:black;">预读失效的问题解决了，接下来看看什么是Buffer Pool  污染。</font></p>
<p><font style="color:black;">我们知道当Sql执行的时候，</font><strong><font style="color:rgb(145, 109, 213);">「会数据加载到Buffer Pool ，而Buffer Pool的大小是有限的，如果加载大量数据，就会将Buffer Pool 里的所有页都替换出去，导致原本的热数据被淘汰」</font></strong><font style="color:black;">。下次访问的时候，又要重新去磁盘读取，导致数据库性能下降，这个过程就是</font><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool  污染」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「什么时候会加载大量数据呢」</font></strong><ul>
<li><font style="color:black;">SQL 语句扫描了大量的数据，并返回。</font></li>
<li><font style="color:black;">对大表进行全表扫描，比如：</font></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where name like &quot;%星河&quot;;</span><br><span class="line">select * from user where id+1 = 6</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">这两个sql 会导致索引失效而走全表扫描，导致全量加载数据到Buffer Pool中</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool加载大量数据」</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657724901-a03a0161-8415-441b-8af0-2c5917ac1d2f.webp"></p>
<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;从磁盘读取数据页加入到 LRU 链表的 old 区域头部&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;从数据页中读取行记录进行where进行匹配，这个过程会访问数据页，也就会将数据页加入到 young 区域头部。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;由于是全表扫描，&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「因此所有数据都会被按照逐个加入young 区域头部，从而替换淘汰原有的 young 区域数据」&lt;/font&gt;**&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;
</code></pre>
<h3 id="如何解决Buffer-Pool污染"><a href="#如何解决Buffer-Pool污染" class="headerlink" title="如何解决Buffer Pool污染"></a><font style="color:black;">如何解决Buffer Pool污染</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool污染跟预读失效都是一样的会导致LRU的热点数据被替换和淘汰」</font></strong><font style="color:black;">，接下来看看如何解决Buffer Pool  污染而导致缓存命中率下降的问题？</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「问题分析」</font></strong></li>
</ul>
<p>:::tips<br><font style="color:black;">其实我们可以针对以上全表扫描的情况进行分析，</font></p>
<p><font style="color:black;">全表扫描之所以会替换淘汰原有的LRU链表young 区域数据，主要是因为我们将原本只会访问一次的数据页加载到young 区。</font></p>
<p><font style="color:black;">这些数据实际上刚刚从磁盘被加载到Buffer Pool，然后就被访问，之后就不会用，基于此，我们是不是可以将数据放young 区的门槛提高有点，从而吧这种访问一次就不会用的数据过滤掉，把它挡在Old区，这样就不会污染young 区的热点数据了。</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(145, 109, 213);">「解决Buffer Pool污染方案」</font></strong></p>
<p><font style="color:black;">MySQL 解决方式就是提高了数据从Old区域进入到 young 区域门槛：</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「先设定一个间隔时间innodb_old_blocks_time，然后将Old区域数据页的第一次访问时间在其对应的控制块中记录下来」</font></strong><font style="color:black;">。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">这样看，其实</font><strong><font style="color:rgb(145, 109, 213);background-color:rgb(244, 238, 255);">「这个间隔时间innodb_old_blocks_time就是数据页必须在 old 区域停留的时间」</font></strong><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">。</font></p>
<p>:::</p>
<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;如果后续的访问时间与第一次访问的时间&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「小于innodb_old_blocks_time」&lt;/font&gt;**&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;，则&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「不将该缓存页从 old 区域移动到 young 区域」&lt;/font&gt;**&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;如果后续的访问时间与第一次访问的时间&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「大于innodb_old_blocks_time」&lt;/font&gt;**&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;，才&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「会将该缓存页移动到 young 区域的头部」&lt;/font&gt;**&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_old_blocks_time%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657781427-e3b896ce-ab2c-4c73-8dc3-d58f64837bcb.webp"></p>
<p><font style="color:black;">如上，innodb_old_blocks_time默认是 1s。</font></p>
<p><font style="color:black;">即：</font><strong><font style="color:rgb(145, 109, 213);">「当同时满足「数据页被访问」与「数据页在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">通过这种方式，就过滤了上述那种全表扫描导致的将只会访问一次的数据页加载到young 区造成的Buffer Pool  污染的问题 。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「young 区域优化」</font></strong></p>
<p><font style="color:black;">MySQL为了防止 young 区域节点频繁移动到头部，对 young 区域也做了一个优化：</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4被访问了才会」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657781536-42a8a964-ee75-467c-b6e5-aed02151fb9f.webp"><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657781466-743f5ac1-c314-4780-aebc-af5720dd2756.webp"><ul>
<li><font style="color:rgb(1, 1, 1);">当访问前面4个数据页时（比如3号数据页），并不会将数据页移动到young 区的头部</font></li>
<li><font style="color:rgb(1, 1, 1);">当访问8号数据页，由于8数据页在后 3&#x2F;4的young 区，所以8号会被移动到头部</font></li>
<li><font style="color:rgb(1, 1, 1);">比如访问如下LRU链表，young 区域一共有18个数据页，当我们访问young 区的数据页时：</font></li>
</ul>
</li>
</ul>
<h2 id="脏页的刷盘时机"><a href="#脏页的刷盘时机" class="headerlink" title="脏页的刷盘时机"></a><strong><font style="color:black;">脏页的刷盘时机</font></strong></h2><p><font style="color:black;">通过对上述三种链表的描述，我们知道</font><strong><font style="color:rgb(145, 109, 213);">「当我们对数据进行修改时，其实修改的是Buffer Pool  中数据所在缓存页，修改后将其设置为脏页，并将脏页的控制块同时存在于 LRU 链表和 Flush 链表」</font></strong><font style="color:black;">。然后通过刷脏将修改同步至磁盘。</font></p>
<p><font style="color:black;">刷脏不是每次修改都进行的，那样性能会很差，因此刷脏是通过一定的时机触发进行批量刷盘的。</font></p>
<p><font style="color:black;">脏页的刷盘时机总的来说就分为以下种：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</font></li>
<li><font style="color:rgb(1, 1, 1);">MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</font></li>
<li><font style="color:rgb(1, 1, 1);">Buffer Pool 空间不足时，会淘汰一部分数据页，如果淘汰的是脏页，需要先将其同步到磁盘。</font></li>
<li><font style="color:rgb(1, 1, 1);">MySQL 空闲时，后台线程会定期脏页刷盘</font></li>
</ul>
<p><font style="color:black;">下面主要来看一下Buffer Pool 空间不足和后台线程的脏页刷盘过程</font></p>
<h3 id="Buffer-Pool内存不足触发刷脏"><a href="#Buffer-Pool内存不足触发刷脏" class="headerlink" title="Buffer Pool内存不足触发刷脏"></a><font style="color:black;">Buffer Pool内存不足触发刷脏</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「刷脏的目的是将修改的数据同步磁盘，释放Buffer Pool内存空间」</font></strong><font style="color:black;">。因此我们肯定是需要将访问的最少的数据页刷会磁盘，释放其数据页内存。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「基于这样的原则，我们只需要根据LRU链表，将其Old区域尾部节点输盘即可」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">我们在前面的描述中已经说了</font><strong><font style="color:rgb(145, 109, 213);">「对于修改的数据页的控制块同时存在于 LRU 链表和 Flush 链表，对于只有读取访问的数据页的控制块存在于 LRU 链表」</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657823706-f9abf7c8-034c-4caf-9676-d05afb091a15.webp"></p>
<p><font style="color:black;">如上图，Buffer Pool内存不足脏页刷盘分为两种情况：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「若缓存页同时在flush链表和lru链表中，说明数据被修改过，则需要刷脏，释放掉缓存页的内存，将控制块重新添加到</font><strong><strong><font style="color:rgb(145, 109, 213);">free链表中</font></strong></strong><font style="color:rgb(145, 109, 213);">」</font></strong><font style="color:rgb(1, 1, 1);">。</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「若缓存页只是存在于LRU链表中，说明数据没有被修改过，则不需要刷脏，直接释放掉缓存页的内存，将控制块重新添加到free链表中」</font></strong><font style="color:rgb(1, 1, 1);">。</font></li>
</ul>
<h3 id="后台线程会定期脏页刷盘"><a href="#后台线程会定期脏页刷盘" class="headerlink" title="后台线程会定期脏页刷盘"></a><font style="color:black;">后台线程会定期脏页刷盘</font></h3><p><font style="color:black;">为了避免缓冲池内存不够，MySQL在后台有一个定时任务，通过单独的后台线程，不断从LRU链表Old区尾部的缓存页刷回至磁盘中并同时释放缓存页。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657840121-f5b3f96f-df8f-480a-96cc-315c51c2d545.webp"></p>
<h2 id="多实例Buffer-Pool"><a href="#多实例Buffer-Pool" class="headerlink" title="多实例Buffer Pool"></a><strong><font style="color:black;">多实例Buffer Pool</font></strong></h2><p><font style="color:black;">通过上述的描述我们知道：</font><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool本质是InnoDB向操作系统申请的一块</font><strong><strong><font style="color:rgb(145, 109, 213);">连续的内存空间</font></strong></strong><font style="color:rgb(145, 109, 213);">」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">既然是内存空间，那么在多线程环境下，为保证数据的安全性，访问Buffer Pool中的数据都需要</font><strong><font style="color:rgb(145, 109, 213);">加锁</font></strong><font style="color:black;">处理。</font></p>
<h3 id="什么是多实例Buffer-Pool"><a href="#什么是多实例Buffer-Pool" class="headerlink" title="什么是多实例Buffer Pool"></a><font style="color:black;">什么是多实例Buffer Pool</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「当多线程并发访问量特别高时，单一的Buffer Pool可能会影响请求的处理速度。因此当Buffer Pool的内存空间很大的时候，可以将单一的Buffer Pool</font><strong><strong><font style="color:rgb(145, 109, 213);">拆分成若干个小的Buffer Pool</font></strong></strong><font style="color:rgb(145, 109, 213);">，每个Buffer Pool都称为一个独立的实例，各自去申请内存空间以及管理各种链表」</font></strong><font style="color:black;">。以此保证在多线程并发访问时不会相互影响，从而提高并发处理能力。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「innodb_buffer_pool_instances」</font></strong></li>
</ul>
<p><font style="color:black;">通过设置</font><strong><font style="color:rgb(145, 109, 213);">「innodb_buffer_pool_instances的值来修改Buffer Pool实例的个数，默认为1，最大可以设置为64」</font></strong><font style="color:black;">。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_buffer_pool_instances%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717657879792-8f1c7c75-4e45-42a2-ba73-152e35427714.webp"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">如上配置表示创建2个buffer pool实例（缓冲池总量大小不变，即每个buffer pool的大小为原来的一半）</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「每个Buffer Pool的内存空间」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「单个缓冲池实际占用内存空间 &#x3D; 缓冲池大小 ÷ 缓冲池实例的个数，即」</font></strong><font style="color:black;"> </font><font style="color:black;">:</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「单个缓冲池实际占用内存空间 &#x3D; innodb_buffer_pool_size ÷ innodb_buffer_pool_instances」</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">如上配置表示创建2个buffer pool实例（缓冲池总量大小不变，即每个buffer pool的大小为原来的一半）</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">由于管理Buffer Pool需要性能开销，因此</font><strong><font style="color:rgb(145, 109, 213);">「并不是实例越多越好」</font></strong><font style="color:rgb(1, 1, 1);">。</font></li>
<li><font style="color:black;">在IInnoDB中，</font><strong><font style="color:rgb(145, 109, 213);">「当innodb_buffer_pool_size小于1GB时，innodb_buffer_pool_instances无效」</font></strong><font style="color:black;">。</font></li>
</ul>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">当innodb_buffer_pool_size小于1GB，即使设置的innodb_buffer_pool_instances不为1，InnoDB默认也会把它改为1，这也是考虑到多实例管理的性能开销。</font></p>
<p>:::</p>
<h3 id="Buffer-Pool的配置"><a href="#Buffer-Pool的配置" class="headerlink" title="Buffer Pool的配置"></a><font style="color:black;">Buffer Pool的配置</font></h3><p><font style="color:black;">我们先来理解一下一个配置项：innodb_buffer_pool_chunk_size</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「innodb_buffer_pool_chunk_size」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">默认值</font><strong><font style="color:rgb(145, 109, 213);">128MB</font></strong><font style="color:rgb(1, 1, 1);">。可以按照</font><strong><font style="color:rgb(145, 109, 213);">1MB</font></strong><font style="color:rgb(1, 1, 1);">的单位进行增加或减小。</font></li>
<li><font style="color:rgb(1, 1, 1);">可以简单的理解成是Buffer Pool的总大小增加或缩小最小单位。</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「innodb_buffer_pool_size的调整」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool的总大小，必须是innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances的倍数」</font></strong><font style="color:black;">。</font></p>
<p>:::tips<br><font style="color:rgb(0, 0, 0);background-color:rgb(244, 238, 255);">当innodb_buffer_pool_size不等于innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances的倍数时，服务器会自动把innodb_buffer_pool_size的值调整为【innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances】结果的整数倍</font></p>
<p>:::</p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;如果配置&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># buffer_pool最小单位为128MB</span><br><span class="line">innodb_buffer_pool_chunk_size=128MB</span><br><span class="line"># Buffer Pool实例的个数为16</span><br><span class="line">innodb_buffer_pool_instances=16</span><br><span class="line"># buffer_pool总大小为3GB</span><br><span class="line">innodb_buffer_pool_size=3GB</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;由于&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances =128MB * 16 = 2GB</span><br><span class="line"></span><br><span class="line">而2GB 不等于 innodb_buffer_pool_size=3GB</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;则InnoDB会调整&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># InnoDB会调整buffer_pool总大小为4GB</span><br><span class="line">innodb_buffer_pool_size = 4GB</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「innodb_buffer_pool_chunk_size的调整」</font></strong></li>
</ul>
<p><font style="color:black;">在服务启动的时候，会进行如下计算，并判断结果调整innodb_buffer_pool_chunk_size的大小：</font></p>
<p><font style="color:black;">如果不等式成立：</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances &gt; innodb_buffer_pool_size」</font></strong></p>
<p><font style="color:black;">则修改：</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「innodb_buffer_pool_chunk_size  &#x3D;  innodb_buffer_pool_size &#x2F;innodb_buffer_pool_instances」</font></strong></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;例如：如果配置&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># buffer_pool最小单位为128MB</span><br><span class="line">innodb_buffer_pool_chunk_size=256MB</span><br><span class="line"># Buffer Pool实例的个数为16</span><br><span class="line">innodb_buffer_pool_instances=16</span><br><span class="line"># buffer_pool总大小为3GB</span><br><span class="line">innodb_buffer_pool_size=3GB</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;由于&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances =256MB * 16 = 4GB</span><br><span class="line"></span><br><span class="line">而4GB 大于 innodb_buffer_pool_size=3GB</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;则InnoDB会调整&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># InnoDB会调整innodb_buffer_pool_chunk_size的大小为192MB</span><br><span class="line">innodb_buffer_pool_chunk_size = innodb_buffer_pool_size / innodb_bu</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB线程模型的组成</title>
    <url>/2024/07/15/InnoDB%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<p><font style="color:black;">在Innodb存储引擎中，后台线程的主要作用是</font><strong><font style="color:rgb(145, 109, 213);">「负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据」</font></strong><font style="color:black;">。此外它会将已经修改的数据文件刷新到磁盘文件中，保证在发生异常的情况下，Innodb能够恢复到正常的运行状态。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641606756-d474dbda-3cd1-4bc3-b52f-b39a3a81999e.webp"></p>
<span id="more"></span>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB存储引擎是多线程的模型，所以有多个不同的后台线程，负责处理不同的任务」</font></strong><font style="color:black;">。主要有：</font></p>
<p><font style="color:black;">Master Thread、IO Thread、Purge Thread、Page Cleaner Thread四种。</font><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641606664-77f40ed4-80bb-4b7f-a557-f9700fb8f5eb.webp"></p>
<h2 id="二-Master-Thread"><a href="#二-Master-Thread" class="headerlink" title="二 Master Thread"></a><strong><font style="color:black;">二 Master Thread</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「Master thread是InnoDB的主线程，负责调度其他各线程，优先级最高」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「主要作用」</font></strong></li>
</ul>
<p><font style="color:black;">将缓冲池中的数据一步刷新到磁盘，保证数据的一致性。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「主要工作」</font></strong></li>
</ul>
<p><font style="color:black;">脏页的刷新（page cleaner thread）、undo页回收（purge thread）、redo日志刷新（log thread）、合并写缓冲等。</font></p>
<p><font style="color:black;">Master thread内部有两个主要处理时机，分别是每隔1秒和10秒处理。</font></p>
<ul>
<li><font style="color:black;">每隔1秒</font><ul>
<li><font style="color:rgb(1, 1, 1);">innodb_max_dirty_pages_pct</font></li>
<li><font style="color:black;">innodb_io_capacity</font></li>
</ul>
</li>
</ul>
<p><font style="color:black;">合并插入缓冲时,每秒合并插入缓冲的数量为 innodb_io_capacity值的5%，默认就是 200*5%&#x3D;10</font></p>
<p><font style="color:black;">在从缓冲区刷新脏页时,每秒刷新脏页的数量就等于innodb_io_capacity的值，默认200</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;刷新日志缓冲区，刷到磁盘&lt;/font&gt;
- &lt;font style=&quot;color:black;&quot;&gt;合并写缓冲区数据，根据IO读写压力来决定是否操作&lt;/font&gt;
- &lt;font style=&quot;color:black;&quot;&gt;刷新脏页数据到磁盘，根据脏页比例达到75%才操作，此处涉及两个参数&lt;/font&gt;
</code></pre>
<p><font style="color:black;background-color:rgb(244, 238, 255);">脏页比例通过innodb_max_dirty_pages_pct配置，innodb_max_dirty_pages_pct参数值保存在变量srv_max_buf_pool_modified_pct 里面，这是一个全局变量，初始值为 75.0</font></p>
<ul>
<li><font style="color:black;">每隔10秒</font><ul>
<li><font style="color:rgb(1, 1, 1);">刷新脏页数据到磁盘</font></li>
<li><font style="color:rgb(1, 1, 1);">合并写缓冲区数据</font></li>
<li><font style="color:rgb(1, 1, 1);">刷新日志缓冲区</font></li>
<li><font style="color:rgb(1, 1, 1);">删除无用的undo页</font></li>
</ul>
</li>
</ul>
<h2 id="三、-IO-Thread"><a href="#三、-IO-Thread" class="headerlink" title="三、 IO Thread"></a><strong><font style="color:black;">三、 IO Thread</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「为了提高数据库的性能，在InnoDB中使用了大量的AIO（Async IO）来做读写处理」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">一共有4种总共10个IO Thread：</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「read thread」</font></strong><font style="color:black;">（4个）</font></li>
</ul>
<p><font style="color:black;">负责读取操作，将数据从磁盘加载到Buffer Pool的Page页。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「write thread」</font></strong><font style="color:black;">（4个）</font></li>
</ul>
<p><font style="color:black;">负责写操作，将Buffer Pool的dirty page刷新到磁盘。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &quot;%innodb%io_threads%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641606667-0bc36226-ee89-404c-807f-a225cfdeeba3.webp"></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「log thread」</font></strong><font style="color:black;">（1个）</font></li>
</ul>
<p><font style="color:black;">负责将Log Buffer内容刷新到磁盘。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「insert buffer thread」</font></strong><font style="color:black;">（1个）</font></li>
</ul>
<p><font style="color:black;">负责将Change Buffer内容刷新到磁盘。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看当前IO线程的工作状态</span><br><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641606701-3a498537-d81b-4cd9-96fc-a3f97c872c4c.webp"></p>
<h2 id="四-Purge-Thread"><a href="#四-Purge-Thread" class="headerlink" title="四 Purge Thread"></a><strong><font style="color:black;">四 Purge Thread</font></strong></h2><p><font style="color:black;">事务提交之后，其使用的undo日志将不再需要，因此需要Purge Thread回收已经分配的undo 页。</font></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">早前的版本只支持一个Purge Thread，目前mysql 5.7版本支持多个Purge Thread，目的是为了进一步加快undo数据页的回收速度。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_purge_threads%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641606691-be7d9a17-1738-48ac-b75c-d1f7a8269d47.webp"></p>
<h2 id="五-Page-Cleaner-Thread"><a href="#五-Page-Cleaner-Thread" class="headerlink" title="五 Page Cleaner Thread"></a><strong><font style="color:black;">五 Page Cleaner Thread</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「作用是将脏数据放入到单独的线程中刷新到磁盘，脏数据刷盘后相应的redo log也就可以覆盖，即可以同步数据，又能达到redo log循环使用的目的」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">减轻原来的Master Thread的工作，同时可以缓解用户查询线程的阻塞，进一步提高Innodb 存储引擎的性能。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_page_cleaners%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641606939-47f431c3-0e2b-49c6-98e4-7bd7b04fb8d1.webp"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>存储引擎</tag>
        <tag>InnoDb</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB的存储结构</title>
    <url>/2024/07/15/InnoDB%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong><font style="color:rgb(145, 109, 213);">「MySQL存储引擎最大的特点就是【插件化】，可以根据自己的需求使用不同的存储引擎，innodb存储引擎支持行级锁以及事务特性，也是多种场合使用较多的存储引擎。」</font></strong></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">当官方的存储引擎不足以满足时，我们通过抽象的API接口实现自己的存储引擎。</font></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">抽象存储引擎API接口是通过抽象类handler来实现，handler类提供诸如打开&#x2F;关闭table、扫表、查询Key数据、写记录、删除记录等基础操作方法。</font></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">每一个存储引擎通过继承handler类，实现以上提到的方法，在方法里面实现对底层存储引擎的读写接口的转调。</font></p>
<span id="more"></span>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB是为处理巨大数据量时的最大性能设计。它的CPU效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的」</font></strong><font style="color:black;">。这是官网给出的一句话，可见InnoDB在mysql中的地位。</font></p>
<ul>
<li><font style="color:black;">在MYSQL5.5版本，具体是在5.5.8版本之后,，</font><strong><font style="color:rgb(145, 109, 213);">「InnoDB代替MYISAM称为MYSQL的默认存储引擎」</font></strong><font style="color:black;">。</font></li>
<li><font style="color:black;">InnoDB存储引擎支持事务，具有自动崩溃恢复的特性，特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁，在日常开发中使用非常广泛。</font></li>
</ul>
<h2 id="一、InnoDB架构组成"><a href="#一、InnoDB架构组成" class="headerlink" title="一、InnoDB架构组成"></a><strong><font style="color:black;">一、InnoDB架构组成</font></strong></h2><p><font style="color:black;">InnoDB的存储结构分为</font><strong><font style="color:rgb(145, 109, 213);">「内存结构(左)和磁盘结构(右)两大部分」</font></strong><font style="color:black;">，</font></p>
<p><font style="color:black;">官方的InnoDB引擎架构图如下：</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">MySQL 5.7以前的版本</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641572383-136b49bf-eb93-41b0-9b95-38874c5bcd94.webp"></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">MySQL 5.7 版本</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641572373-8acb8e9d-fcd7-4906-87da-2cdd223aeb51.webp"></p>
<p><font style="color:black;">由上面两张架构图可以看出，</font><strong><font style="color:rgb(145, 109, 213);">「InnoDB存储结构在MySQL 5.7 版本之后做了一些调整」</font></strong></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">将 Undo日志表空间从共享表空间 ibdata 文件中分离出来，可以在安装MySQL 时由用户自行指定文件大小和数量。</font></li>
<li><font style="color:rgb(1, 1, 1);">增加了 temporary 临时表空间，里面存储着临时表或临时查询结果集的数据。</font></li>
<li><font style="color:rgb(1, 1, 1);">Buffer Pool 大小可以动态修改，无需重启数据库实例。</font></li>
</ul>
<h2 id="二、-InnoDB内存结构"><a href="#二、-InnoDB内存结构" class="headerlink" title="二、 InnoDB内存结构"></a><strong><font style="color:black;">二、 InnoDB内存结构</font></strong></h2><p><font style="color:black;">从架构图中可以看出【</font><strong><font style="color:rgb(145, 109, 213);">「内存结构主要包括Buffer Pool、Change Buffer、Adaptive Hash Index和Log Buffer四大组件」</font></strong><font style="color:black;">】。</font></p>
<h3 id="2-1-Buffer-Pool"><a href="#2-1-Buffer-Pool" class="headerlink" title="2.1 Buffer Pool"></a><font style="color:black;">2.1 Buffer Pool</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「即【缓冲池，简称BP】。BP以Page页为单位，默认大小16K，BP的底层采用链表数据结构管理Page」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁 盘IO操作，提升效率。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「Page管理机制」</font></strong></li>
</ul>
<p><font style="color:black;">Page根据状态可以分为三种类型：</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB通过三种链表结构来维护和管理上述三种page类型」</font></strong></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;【free list】：空闲缓冲区，管理free page&lt;/font&gt;
- &lt;font style=&quot;color:black;&quot;&gt;【flush list】：刷新到磁盘的缓冲区，管理dirty page&lt;/font&gt;
</code></pre>
<p><font style="color:black;">内部page按修改时间排序。脏页即存在于flush链表，也在LRU链表中，两种互不影响，</font><strong><font style="color:rgb(145, 109, 213);">「LRU链表负责管理page的可用性和释放，而flush链表负责管理脏页的刷盘操作」</font></strong><font style="color:black;"> </font><font style="color:black;">。</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;【lru list】：正在使用的缓冲区，管理clean page和dirty page&lt;/font&gt;
</code></pre>
<p><font style="color:black;">缓冲区以midpoint为基点：</font></p>
<p><font style="color:black;">前面链表称为new列表区，存放经常访问的数据，占63%；</font></p>
<p><font style="color:black;">后面的链表称为old列表区，存放使用较少数据，占37%。</font></p>
<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;【free page】 ：空闲page，未被使用&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;【clean page】：被使用page，数据没有被修改过&lt;/font&gt;
- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;【dirty page】：脏页，page的数据被修改过，页中数据和磁盘的数据产生了不 一致&lt;/font&gt;
</code></pre>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「改进型LRU算法维护」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);background-color:rgb(244, 238, 255);">「每当有新的page数据读取到buffer pool时，InnoDb引擎会判断是否有空闲页，是否足够，如果有就将free page从free list列表删除，放入到LRU列表中。没有空闲页，就会根据LRU算法淘汰LRU链表默认的页，将内存空间释放分配给新的页。」</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「普通LRU」&lt;/font&gt;**
</code></pre>
<p><font style="color:black;">末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「改性LRU」&lt;/font&gt;**
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「链表分为new和old两个部分，加入元素时并不是从表头插入，而是从中间midpoint位置插入」</font></strong><font style="color:black;">，如果数据很快被访问，那么page就会向new列表头部移动，如果数据没有被访问，会逐步向old尾部移动，等待淘汰。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「Buffer Pool配置参数」</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_page_size%&#x27;;</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;查看page页大小&lt;/font&gt;
</code></pre>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641572335-aed40968-c335-4097-85a0-c3995be5d733.webp"></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">查看lru list中old列表参数</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_old%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641572342-4ae82348-ec26-499a-b813-5dc66fe77507.webp"></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">查看buffer pool参数</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_buffer%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641572361-25a6aaec-14c2-4d87-903c-a76e215530ad.webp"></p>
<p><strong><font style="color:rgb(145, 109, 213);">「一般我们将innodb_buffer_pool_size设置为总内存大小的60%-80%， innodb_buffer_pool_instances可以设置为多个避免缓存争夺。」</font></strong></p>
<h3 id="2-2-Change-Buffer"><a href="#2-2-Change-Buffer" class="headerlink" title="2.2 Change Buffer"></a><font style="color:black;">2.2 Change Buffer</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「写【缓冲区，简称CB】。在进行DML操作时，如果BP没有其相应的Page数据， 并不会立刻将磁盘页加载到缓冲池，而是在CB记录缓冲变更，等未来数据被读取时，再将数据合并恢复到BP中。」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「ChangeBuffer占用BufferPool空间」</font></strong><font style="color:rgb(1, 1, 1);">，默认占25%，最大允许占50%，可以根据读写业务量来进行调整。</font></li>
</ul>
<p><font style="color:black;">调整参数为：innodb_change_buffer_max_size</font></p>
<p><strong><font style="color:rgb(145, 109, 213);background-color:rgb(244, 238, 255);">「当更新一条记录时，该记录在BufferPool存在，直接在BufferPool修改，一次内存操作。」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);background-color:rgb(244, 238, 255);">「如果该记录在BufferPool不存在（没有命中），会直接在ChangeBuffer进行一次内存操作，不用再去磁盘查询数据，避免一次磁盘IO。」</font></strong></p>
<p><strong><font style="color:rgb(145, 109, 213);background-color:rgb(244, 238, 255);">「当下次查询记录时，会先进行磁盘读取，然后再从 ChangeBuffer中读取信息合并，最终载入BufferPool中。」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「写缓冲区仅适用于非唯一普通索引页」</font></strong></li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">如果在索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘， 做一次IO操作。会直接将记录查询到BufferPool中，然后在缓冲池修改，不会在 ChangeBuffer操作。</font></p>
<h3 id="2-3-Adaptive-Hash-Index"><a href="#2-3-Adaptive-Hash-Index" class="headerlink" title="2.3 Adaptive Hash Index"></a><font style="color:black;">2.3 Adaptive Hash Index</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「即【自适应哈希索引】，用于优化对BP数据的查询」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「InnoDB存储引擎会监控对表索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立自适应哈希索引，所以称之为自适应」</font></strong><font style="color:black;">。InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。</font></p>
<p><font style="color:black;">实现本质上就是一个从某个检索条件到某个数据页的【哈希表】。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%hash%&#x27;;</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">| Variable_name                    | Value |</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">| innodb_adaptive_hash_index       | ON    |</span><br><span class="line">| innodb_adaptive_hash_index_parts | 8     |</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「innodb_adaptive_hash_index」</font></strong></li>
</ul>
<p><font style="color:black;">控制innodb自适应哈希索引特性是否开启参数</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「innodb_adaptive_hash_index_parts」</font></strong></li>
</ul>
<p><font style="color:black;">凡是缓存都会涉及多个缓存消费者间的锁竞争。</font></p>
<p><font style="color:black;">MySQL通过设立多个AHI分区，每个分区使用独立的锁，来减少锁竞争。</font></p>
<h3 id="2-4-Log-Buffer"><a href="#2-4-Log-Buffer" class="headerlink" title="2.4 Log Buffer"></a><font style="color:black;">2.4 Log Buffer</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「即【日志缓冲区】，用来保存要写入磁盘上log文件（Redo&#x2F;Undo）的数据」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">日志缓冲区刷盘时机：</font></p>
<ul>
<li><font style="color:black;">日志缓冲区的内容</font><strong><font style="color:rgb(145, 109, 213);">「定期刷新」</font></strong><font style="color:black;">到磁盘log文件中。</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「日志缓冲区满时会自动将其刷新」</font></strong><font style="color:black;">到磁盘，可以改变innodb_log_buffer_size参数大小，减少磁盘IO频率。</font></li>
</ul>
<p><font style="color:black;">当遇到BLOB类型或多行更新的大事务操作时，增加日志缓冲区可以节省磁盘I&#x2F;O。</font></p>
<p><font style="color:black;">LogBuffer主要是用于记录InnoDB引擎日志，在DML操作时会产生Redo和Undo日志。</font></p>
<h2 id="三、-InnoDB磁盘结构"><a href="#三、-InnoDB磁盘结构" class="headerlink" title="三、 InnoDB磁盘结构"></a><strong><font style="color:black;">三、 InnoDB磁盘结构</font></strong></h2><p><font style="color:black;">InnoDB磁盘主要包含【Tablespaces，InnoDB Data Dictionary，Doublewrite Buffer、Redo Log 和Undo Logs】五部分组成。</font></p>
<h3 id="3-1-表空间（Tablespaces）"><a href="#3-1-表空间（Tablespaces）" class="headerlink" title="3.1 表空间（Tablespaces）"></a><font style="color:black;">3.1 表空间（Tablespaces）</font></h3><p><font style="color:black;">innodb存储引擎在存储设计上模仿了Oracle的存储结构，其数据是按照表空间进行管理的。</font><strong><font style="color:rgb(145, 109, 213);">「表空间用于存储表结构和数据」</font></strong><font style="color:black;">。表空间又分为系统表空间、独立表空间、 通用表空间、临时表空间、Undo表空间等多种类型。</font></p>
<h4 id="3-1-1-表空间组成"><a href="#3-1-1-表空间组成" class="headerlink" title="3.1.1 表空间组成"></a><font style="color:black;">3.1.1 表空间组成</font></h4><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「物理结构组成」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「在系统表空间由于所有的表公用一个.ibdatat1数据文件，所以针对每个表只有一个.frm表结构文件」</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「在独立表空间中，每个表分别都有一个.frm表结构文件，一个.ibd数据文件」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">innodb存储引擎物理组织形式可以理解为其在磁盘的存储形式，表现为各种文件，其分类大概为</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">文件</font></strong></th>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">功能</font></strong></th>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">描述</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(1, 1, 1);">ibdatat1</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">共享表空间文件</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">系统&#x2F;共享表空间，存储各种缓冲数据</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">.frm</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">表定义文件</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">记录表的定义，列名以及列的数据类型</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">.ibd</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">表数据存储文件</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">独立表空间，存储数据表的数据，按行存储</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">ib_logfile0&#x2F;1</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">redo日志文件</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">重做日志文件，一共两个循环使用，一个写完即写另一个</font></td>
</tr>
</tbody></table>
<p><strong><font style="color:rgb(145, 109, 213);">「表空间是innodb存储引擎逻辑结构的最高层，所有的数据都存储在表空间中，默认innodb有一个共享表空间，所有的数据都存储在共享表空间中，可以通参数innodb_per_table设置每张表单独存放在一个表空间中」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「独立表空间内存储的只是数据、索引、插入缓冲页」</font></strong><font style="color:black;">。</font></li>
<li><strong><font style="color:rgb(145, 109, 213);">「回滚日志、插入缓冲索引页、事务信息、二次写缓冲等其他数据还是存放在共享表空间」</font></strong><font style="color:black;">。</font></li>
</ul>
<h4 id="3-1-2-表空间的五种类型"><a href="#3-1-2-表空间的五种类型" class="headerlink" title="3.1.2 表空间的五种类型"></a><font style="color:black;">3.1.2 表空间的五种类型</font></h4><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「系统表空间」</font></strong><font style="color:black;">（The System Tablespace）</font></li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">innodb_data_file_path用来指定innodb tablespace文件，如果我们不在My.cnf文件中指定innodb_data_home_dir和innodb_data_file_path那么默认会在datadir目录下创建ibdata1 作为innodb tablespace。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#默认值:</span><br><span class="line">innodb_data_file_path = ibdata1:12M:autoextend</span><br><span class="line"># ibdata1 : 文件名为ibdata1</span><br><span class="line"># 12M : 大小为12M</span><br><span class="line"># autoextend : 自动扩展</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;包含InnoDB数据字典，Doublewrite Buffer，Change Buffer，Undo Logs的&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「存储区域」&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt;。&lt;/font&gt;
- &lt;font style=&quot;color:black;&quot;&gt;系统表空间也默认包含任何用户在&lt;/font&gt;**&lt;font style=&quot;color:rgb(145, 109, 213);&quot;&gt;「系统表空间创建」&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt;的表数据和索引数据。&lt;/font&gt;
- &lt;font style=&quot;color:black;&quot;&gt;系统表空间是一个共享的表空间因为它是被多个表共享的。&lt;/font&gt;
</code></pre>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「独立表空间」</font></strong><font style="color:black;">（File-Per-Table Tablespaces）</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「默认开启，独立表空间是一个单表表空间，该表创建于自己的数据文件中，而非创建于系统表空间中」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">开启独立表空间参数为：innodb_file_per_table</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">innodb_file_per_table = ON：独立表空间：tablename.ibd</span><br><span class="line">innodb_file_per_table = OFF：系统表空间：ibdataX</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;【innodb_file_per_table = ON】&lt;/font&gt;
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「新建表被创建于【表空间】中,每一个表建立ibd的扩展文件,文件名为：表名.ibd」</font></strong><font style="color:black;">，该文件默认被创建于数据库目录中,表空间的表文件支持动态和压缩行格式。</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;【innodb_file_per_table = OFF】&lt;/font&gt;
</code></pre>
<p><strong><font style="color:rgb(145, 109, 213);">「innodb将被创建于【系统表空间】中，即ibdataX中」</font></strong><font style="color:black;">。X代表从1开始的一个数字</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;【查看表的存储表空间的存储方式值】&lt;/font&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;innodb_file_per_table&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641572822-8b5a0843-fe88-4f83-a7e6-7d530aad04f4.webp"></p>
<ul>
<li><font style="color:black;">【修改存储表空间的存储方式值为OFF】</font></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global innodb_file_per_table=off;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「通用表空间」</font></strong><font style="color:black;">（General Tablespaces）</font></li>
</ul>
<p><font style="color:black;">通用表空间为通过create tablespace语法创建的共享表空间。通用表空间可以创建于 mysql数据目录外的其他表空间，其可以容纳多张表，且其支持所有的行格式。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建表空间tablespaces1</span><br><span class="line">CREATE TABLESPACE tablespaces1 ADD DATAFILE tablespaces1.ibd Engine=InnoDB; </span><br><span class="line">#将表添加到test1表空间</span><br><span class="line">CREATE TABLE test1 (c1 INT PRIMARY KEY) TABLESPACE tablespaces1;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「撤销表空间」</font></strong><font style="color:black;">（Undo Tablespaces）</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「撤销表空间由一个或多个包含Undo日志文件组成。」</font></strong></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">在MySQL 5.7版本之前Undo占用的是System Tablespace共享区，从5.7开始将Undo从System Tablespace分离了出来。</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;【innodb_undo_tablespaces】&lt;/font&gt;
</code></pre>
<p><font style="color:black;">innodb_undo_tablespaces &#x3D; 0 ：默认值，表示使用系统表空间ibdata1</font></p>
<p><font style="color:black;">innodb_undo_tablespaces &#x3D; 1：大于0表示使用undo表空间undo_001、 undo_002等</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「临时表空间」</font></strong><font style="color:black;">（Temporary Tablespaces）</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「mysql服务器正常关闭或异常终止时，临时表空间将被移除，每次启动时会被重新创建」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">临时表空间分为两种：</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;【session temporary tablespaces】&lt;/font&gt;
</code></pre>
<p><font style="color:black;">存储的是用户创建的临时表和磁盘内部的临时表</font></p>
<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;【global temporary tablespace】&lt;/font&gt;
</code></pre>
<p><font style="color:black;">储存用户临时表的回滚段（rollback segments ）</font></p>
<h4 id="3-1-3-系统表空间与独立表空间怎么选择"><a href="#3-1-3-系统表空间与独立表空间怎么选择" class="headerlink" title="3.1.3 系统表空间与独立表空间怎么选择"></a><font style="color:black;">3.1.3 系统表空间与独立表空间怎么选择</font></h4><p><font style="color:black;">系统表空间与独立表空间都是</font><strong><font style="color:rgb(145, 109, 213);">「存储表结构和数据」</font></strong><font style="color:black;">，只是存储位置和方法不同，那么应该怎么选择呢</font></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">系统表空间与独立表空间差异</font><ul>
<li><font style="color:rgb(1, 1, 1);">系统表空间由于所有的数据都放ibdataX文件中，</font><strong><font style="color:rgb(145, 109, 213);">「容易产生IO瓶颈」</font></strong></li>
<li><font style="color:rgb(1, 1, 1);">独立表空间单表存储，可以同时刷新多个文件数据</font></li>
</ul>
</li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「基于此，我们一般都是使用独立的表空间进行管理，独立表空间也是默认的配置」</font></strong></p>
<ul>
<li><font style="color:black;">如何把系统表空间中的表转移到独立表空间中</font><ul>
<li><font style="color:black;">使用mysqldump导出所有数据库表的数据(备份)。</font></li>
<li><font style="color:black;">停止MYSQL服务器，修改my.conf配置，删除原来innodb表空间的相关文件</font></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改my.conf配置</span><br><span class="line">innodb_file_per_table = ON</span><br></pre></td></tr></table></figure>

<pre><code>- &lt;font style=&quot;color:black;&quot;&gt;重启MYSQL服务,并重建Innodb系统表空间&lt;/font&gt;
- &lt;font style=&quot;color:black;&quot;&gt;重新导入备份的数据&lt;/font&gt;
</code></pre>
<h3 id="3-2数据字典（InnoDB-Data-Dictionary）"><a href="#3-2数据字典（InnoDB-Data-Dictionary）" class="headerlink" title="3.2数据字典（InnoDB Data Dictionary）"></a><font style="color:black;">3.2数据字典（InnoDB Data Dictionary）</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「InnoDB数据字典由内部系统表组成」</font></strong><font style="color:black;">。这些表包含用于查找表、索引和表字段等对象的元数据。</font></p>
<p><font style="color:black;">元数据物理上位于InnoDB系统表空间中。数据字典元数据在一定程度上 与InnoDB表元数据文件（.frm文件）中存储的信息重叠。</font></p>
<h3 id="3-3-双写缓冲区（Doublewrite-Buffer）"><a href="#3-3-双写缓冲区（Doublewrite-Buffer）" class="headerlink" title="3.3 双写缓冲区（Doublewrite Buffer）"></a><font style="color:black;">3.3 双写缓冲区（Doublewrite Buffer）</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「位于系统表空间，是一个存储区域」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;background-color:rgb(244, 238, 255);">在BufferPage的page页刷新到磁盘真正的位置前，会先将数据存在Doublewrite 缓冲区。如果在page页写入过程中出现操作系统、存储子系统或 mysqld进程崩溃，InnoDB可以在崩溃恢复期间从Doublewrite缓冲区中找到page页备份。在大多数情况下，默认情况下启用双写缓冲区。</font></p>
<ul>
<li><font style="color:black;">innodb_doublewrite &#x3D; 0 ：禁用Doublewrite 缓冲区</font></li>
<li><font style="color:black;">innodb_flush_method &#x3D; O_DIRECT  ：数据文件写入操作会通知操作系统不要缓存数据，也不要用预读</font></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「innodb_flush_method控制innodb数据文件及redo log的打开、 刷写模式」</font></strong><font style="color:black;">。</font></p>
<h3 id="3-4-重做日志（Redo-Log）"><a href="#3-4-重做日志（Redo-Log）" class="headerlink" title="3.4 重做日志（Redo Log）"></a><font style="color:black;">3.4 重做日志（Redo Log）</font></h3><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间修正不完整事务写入的数据」</font></strong><font style="color:black;">。</font></li>
<li><font style="color:black;">MySQL以循环方式写入重做日志文件，记录InnoDB中所有对Buffer Pool修改的日志。</font></li>
</ul>
<p><font style="color:black;background-color:rgb(244, 238, 255);">当出现实例故障，导致数据未能更新到数据文件，则数据库重启时须redo，重新把数据更新到数据文件。读写事务在执行的过程中，都会不断的产生redo log。默认情况下，重做日志在磁盘上由两个名为ib_logfile0和ib_logfile1的文件物理表示。</font></p>
<h3 id="3-5-撤销日志（Undo-Logs）"><a href="#3-5-撤销日志（Undo-Logs）" class="headerlink" title="3.5 撤销日志（Undo Logs）"></a><font style="color:black;">3.5 撤销日志（Undo Logs）</font></h3><p><strong><font style="color:rgb(145, 109, 213);">「撤消日志是在事务开始之前保存的被修改数据的备份，用于回滚事务」</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">撤消日志属于逻辑日志，根据每行记录进行记录。</font></p>
<p><font style="color:black;">撤消日志存在于系统表空间、撤消表空间和临时表空间中。</font></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>存储引擎</tag>
        <tag>InnoDb</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB数据文件</title>
    <url>/2024/07/15/InnoDB%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一、数据文件的组成"><a href="#一、数据文件的组成" class="headerlink" title="一、数据文件的组成"></a><font style="color:rgb(89, 89, 89);">一、数据文件的组成</font></h2><p><strong><font style="color:rgb(71, 193, 168);">innodb数据逻辑存储形式为表空间,而每一个独立表空间都会有一个.ibd数据文件</font></strong><font style="color:rgb(89, 89, 89);">,ibd文件从大到小组成：</font></p>
<p><font style="color:rgb(89, 89, 89);">一个ibd数据文件–&gt;Segment（段）–&gt;Extent（区）–&gt;Page（页）–&gt;Row（行）</font><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641653671-10c7d3b2-4693-4b4f-91a1-aa161d781eec.webp"></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">表空间(Tablesapce)</font></strong></li>
</ul>
<p><strong><font style="color:rgb(71, 193, 168);">表空间，用于存储多个ibd数据文件，用于存储表的记录和索引，一个文件包含多个段。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">段(Segment)</font></strong></li>
</ul>
<p><strong><font style="color:rgb(71, 193, 168);">段由数据段、索引段、回滚段组成，innodb存储引擎索引与数据共同存储，数据段即是B+树叶节点，索引段则存储非叶节点</font>****<font style="color:rgb(89, 89, 89);">。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">区(Extent)</font></strong></li>
</ul>
<p><strong><font style="color:rgb(71, 193, 168);">区则是由连续页组成，每个区的大小为1M，一个区中一共有64个连续的页</font>****<font style="color:rgb(89, 89, 89);">。</font></strong></p>
<p><strong><font style="color:rgb(71, 193, 168);">页(Page)</font></strong></p>
<p><strong><font style="color:rgb(71, 193, 168);">页是innodb存储引擎磁盘管理的最小单位，页的大小为16KB，即每次数据的读取与写入都是以页为单位</font>****<font style="color:rgb(89, 89, 89);">。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(85, 85, 85);">“</font></strong></li>
</ul>
<p><strong><font style="color:black;">包含很多种页类型，比如数据页，undo页，系统页，事务数据页，大的BLOB对象页</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">行(Row)</font></strong></li>
</ul>
<p><strong><font style="color:rgb(71, 193, 168);">行包含记录的字段值，事务ID（Trx id）、滚动指针（Roll pointer）、字段指针（Field pointers）等信息。</font></strong><img src="https://cdn.fbbizyy.com/yuque/0/2024/gif/25873401/1717641653706-70fed344-a55d-44b8-8325-2540b65a9103.gif"></p>
<span id="more"></span>
<h2 id="二-InnoDB数据页结构"><a href="#二-InnoDB数据页结构" class="headerlink" title="二 InnoDB数据页结构"></a><font style="color:rgb(89, 89, 89);">二 InnoDB数据页结构</font></h2><p><strong><font style="color:rgb(71, 193, 168);">InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16KB</font></strong><font style="color:rgb(89, 89, 89);">。</font></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">页的组成</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641653690-33c78b35-b97b-45fe-9231-bb68d4cbec12.webp"></p>
<p><font style="color:rgb(89, 89, 89);">如图所示，InnoDB数据页由以下七个部分组成，</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641653719-f5f224e7-2838-45b4-999f-fc9d8352cf98.webp"></p>
<h3 id="2-1-File-Header（文件头）"><a href="#2-1-File-Header（文件头）" class="headerlink" title="2.1 File Header（文件头）"></a><font style="color:rgb(89, 89, 89);">2.1 File Header（文件头）</font></h3><p><font style="color:rgb(89, 89, 89);">File Header用来记录页的一些头信息，由如下8个部分组成，共占用38个字节，如表4-3所示：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641653670-ea5a6413-9ae4-4945-9802-2e4c5171acd5.webp"></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">FIL_PAGE_SPACE_OR_CHKSUM</font></strong><ul>
<li><strong><font style="color:rgb(89, 89, 89);">在MySQL4.0.14版本之前</font></strong></li>
</ul>
</li>
</ul>
<p><strong><font style="color:rgb(71, 193, 168);">该值代表该页属于哪个表空间</font>****<font style="color:rgb(89, 89, 89);">，当innodb_file_per_table没有开启事，共享表空间中可能存放了许多页，并且这些页属于不同的表空间。</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:rgb(89, 89, 89);&quot;&gt;MySQL4.0.14之后版本&lt;/font&gt;**
</code></pre>
<p><strong><font style="color:rgb(89, 89, 89);">该值代表页的checksum值（一种新的checksum值）。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">FIL_PAGE_OFFSET</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">表空间中页的偏移值。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">FIL_PAGE_PREV，FIL_PAGE_NEXT</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">当前页的上一个页以及下一个页。</font>****<font style="color:rgb(71, 193, 168);">B+Tree特性决定了叶子节点必须是双向列表。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">FIL_PAGE_LSN</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">该值代表该页最后被修改的日志序列位置LSN（Log Sequence Number）。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">FIL_PAGE_TYPE</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">页的类型。十六进制表示，0x45BF代表B+tree叶结点（存放数据的数据页）。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">FIL_PAGE_FILE_FLUSH_LSN</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">该值仅在数据文件中的一个页中定义，代表文件至少被更新到了该LSN值。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">从MySQL 4.1开始，该值代表页属于哪个表空间。</font></strong></p>
<h3 id="2-2-Page-Header（页头）"><a href="#2-2-Page-Header（页头）" class="headerlink" title="2.2 Page Header（页头）"></a><font style="color:rgb(89, 89, 89);">2.2 Page Header（页头）</font></h3><p><font style="color:rgb(89, 89, 89);">用来记录数据页的状态信息，由以下14个部分组成，共占用56个字节。</font></p>
<p><strong><font style="color:rgb(85, 85, 85);">“</font></strong></p>
<p><font style="color:black;">比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641654352-0488670e-07f8-4757-b3b0-d3e5f80fe0d0.webp"></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_N_DIR_SLOTS</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">在Page Directory（页目录）中的Slot（槽）数。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_HEAP_TOP</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">堆中第一个记录的指针。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_N_HEAP</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">堆中的记录数。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_FREE</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">指向空闲列表的首指针。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_GARBAGE</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">已删除记录的字节数，即行记录结构中，delete flag为1的记录大小的总数。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_LAST_INSERT</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">最后插入记录的位置。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_DIRECTION</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">最后插入的方向。取值为：</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;PAGE_LEFT（0x01）&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;PAGE_RIGHT（0x02）&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;PAGE_SAME_REC（0x03）&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;PAGE_SAME_PAGE（0x04）&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;PAGE_NO_DIRECTION（0x05）&lt;/font&gt;**
</code></pre>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_N_DIRECTION</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">一个方向连续插入记录的数量。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_N_RECS</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">该页中记录的数量。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_MAX_TRX_ID</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">修改当前页的最大事务ID，该值仅在Secondary Index定义。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_LEVEL</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">当前页在索引树中的位置，0x00代表叶节点。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_INDEX_ID</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">当前页属于哪个索引ID。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_BTR_SEG_LEAF</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">B+树的叶节点中，文件段的首指针位置。注意该值仅在B+树的Root页中定义。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">PAGE_BTR_SEG_TOP</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">B+树的非叶节点中，文件段的首指针位置。注意该值仅在B+树的Root页中定义。</font></strong><img src="https://cdn.fbbizyy.com/yuque/0/2024/gif/25873401/1717641654059-566c1ff8-0419-4238-b7f7-f685a10a5ec1.gif"></p>
<h3 id="2-3-Infimun-Supremum-Records"><a href="#2-3-Infimun-Supremum-Records" class="headerlink" title="2.3 Infimun+Supremum Records"></a><font style="color:rgb(89, 89, 89);">2.3 Infimun+Supremum Records</font></h3><p><strong><font style="color:rgb(71, 193, 168);">在InnoDB存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">Infimum记录是比该页中任何主键值都要小的值。</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">Supremum指比任何可能大的值还要大的值。</font></strong></li>
</ul>
<p><font style="color:rgb(89, 89, 89);">这两个值在页创建时被建立，并且在任何情况下不会被删除，如下图 ：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641654110-ed419523-1f8d-4e2b-a786-940cf92ba723.webp"></p>
<h3 id="2-4-User-Records（用户记录，即行记录）"><a href="#2-4-User-Records（用户记录，即行记录）" class="headerlink" title="2.4 User Records（用户记录，即行记录）"></a><font style="color:rgb(89, 89, 89);">2.4 User Records（用户记录，即行记录）</font></h3><p><strong><font style="color:rgb(71, 193, 168);">User Records即实际存储行记录的内容，InnoDB存储引擎表总是B+树索引组织的</font></strong><font style="color:rgb(89, 89, 89);">。</font></p>
<p><strong><font style="color:rgb(85, 85, 85);">“</font></strong></p>
<p><strong><font style="color:rgb(71, 193, 168);">每当我们插入一条记录，都会从Free Space部分申请一个记录大小的空间划分到User Records部分</font></strong><font style="color:black;">，当Free Space部分的空间全部被User Records部分替代掉之后，当前页就被用完了，此时如果还有新的记录插入就需要申请新的页了。</font></p>
<h3 id="2-5-Free-Space（空闲空间）"><a href="#2-5-Free-Space（空闲空间）" class="headerlink" title="2.5 Free Space（空闲空间）"></a><font style="color:rgb(89, 89, 89);">2.5 Free Space（空闲空间）</font></h3><p><strong><font style="color:rgb(71, 193, 168);">Free Space指的就是空闲空间，同样也是个链表数据结构</font></strong><font style="color:rgb(89, 89, 89);">。当一条记录被删除后，该空间会被加入空闲链表中。</font></p>
<h3 id="2-6-Page-Directory（页目录）"><a href="#2-6-Page-Directory（页目录）" class="headerlink" title="2.6 Page Directory（页目录）"></a><font style="color:rgb(89, 89, 89);">2.6 Page Directory（页目录）</font></h3><p><font style="color:rgb(89, 89, 89);">Page Directory（页目录）中存放了记录的</font><strong><font style="color:rgb(71, 193, 168);">相对位置</font></strong></p>
<ul>
<li><strong><font style="color:rgb(89, 89, 89);">所有正常的记录（包括最大和最小记录，不包括为已删除的记录）会被划分为几个组。</font></strong></li>
<li><strong><font style="color:rgb(89, 89, 89);">每个组的最后一条记录的头信息中的n_owned属性表示该组内共有几条记录。</font></strong></li>
<li><strong><font style="color:rgb(89, 89, 89);">将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽。这些地址偏移量都会被存储到靠近页的尾部的地方。</font></strong></li>
</ul>
<p><strong><font style="color:rgb(71, 193, 168);">InnoDB并不是每个记录拥有一个槽，InnoDB存储引擎的槽是一个稀疏目录（sparse directory），即一个槽中可能属于（belong to）多个记录，最少属于4条记录，最多属于8条记录。</font></strong></p>
<p><strong><font style="color:rgb(85, 85, 85);">“</font></strong></p>
<p><font style="color:black;">Slots中记录按照键顺序存放，这样可以利用二叉查找迅速找到记录的指针。假设有（’i’，’d’，’c’，’b’，’e’，’g’，’l’，’h’，’f’，’j’，’k’，’a’），同时假设一个槽中包含4条记录，则Slots中的记录可能是（’a’，’e’，’i’），然后通过recorder header中的next_record来继续查找相关记录。</font></p>
<p><strong><font style="color:rgb(71, 193, 168);">【B+树索引本身并不能找到具体的一条记录，B+树索引能找到只是该记录所在的页】。数据库把页载入内存，然后通过Page Directory再进行二叉查找。由于二叉查找的时间复杂度很低，同时内存中的查找很快，因此通常我们忽略了这部分查找所用的时间。</font></strong></p>
<p><font style="color:rgb(89, 89, 89);">所以在一个数据页中查找指定主键值的记录的过程分为两步：</font></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">通过二分法确定该记录所在的槽。</font></strong></li>
<li><strong><font style="color:rgb(1, 1, 1);">通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。</font></strong></li>
</ul>
<h3 id="2-7-File-Trailer（文件结尾信息）"><a href="#2-7-File-Trailer（文件结尾信息）" class="headerlink" title="2.7 File Trailer（文件结尾信息）"></a><font style="color:rgb(89, 89, 89);">2.7 File Trailer（文件结尾信息）</font></h3><p><font style="color:rgb(89, 89, 89);">File Trailer只有一个FIL_PAGE_END_LSN部分，占用8个字节。</font></p>
<p><strong><font style="color:rgb(71, 193, 168);">主要作用</font></strong></p>
<p><strong><font style="color:rgb(89, 89, 89);">保证页能够完整地写入磁盘，校验数据完整性。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(85, 85, 85);">“</font></strong></li>
</ul>
<p><strong><font style="color:black;">写入过程中磁盘损坏、机器宕机时</font></strong></p>
<ul>
<li><strong><font style="color:rgb(71, 193, 168);">具体方法</font></strong></li>
</ul>
<p><strong><font style="color:rgb(89, 89, 89);">前4个字节代表该页的checksum值，最后4个字节和File Header中的FIL_PAGE_LSN相同。</font></strong></p>
<p><strong><font style="color:rgb(89, 89, 89);">通过这两个值来和File Header中的FIL_PAGE_SPACE_OR_CHKSUM和FIL_PAGE_LSN值进行比较，看是否一致，以此来保证页的完整性（not corrupted）</font></strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>存储引擎</tag>
        <tag>InnoDb</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构下</title>
    <url>/2024/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%20%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="12-通过Zookeeper配置Mycat高可用"><a href="#12-通过Zookeeper配置Mycat高可用" class="headerlink" title="12.通过Zookeeper配置Mycat高可用"></a>12.通过Zookeeper配置Mycat高可用</h1><h2 id="12-1-ZooKeeper是什么？"><a href="#12-1-ZooKeeper是什么？" class="headerlink" title="12.1 ZooKeeper是什么？"></a>12.1 ZooKeeper是什么？</h2><blockquote>
<p> ZooKeeper是一个集中的服务，用于<code>配置管理</code>、<code>命名服务</code>、提供<code>分布式同步</code>和提供<code>组服务 </code>等。 本文将通过<code>ZK</code>的<code>配置集中管理</code>去管理Mycat配置(<code>schema.xml</code>，<code>server.xml</code>， <code>rule.xml</code> …)，即：将mycat的配置全部放到ZK上进行监听，一旦配置信息改变，就从ZK获取最新的 配置信息应用到mycat服务中  </p>
</blockquote>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662478972616-0027873c-1489-4f26-b1fb-f402f9ce3bd4.png"></p>
<span id="more"></span>
<h2 id="12-2-通过ZooKeeper集群管理Mycat配置"><a href="#12-2-通过ZooKeeper集群管理Mycat配置" class="headerlink" title="12.2 通过ZooKeeper集群管理Mycat配置"></a>12.2 通过ZooKeeper集群管理Mycat配置</h2><h3 id="12-2-0-清理测试环境"><a href="#12-2-0-清理测试环境" class="headerlink" title="12.2.0 清理测试环境"></a>12.2.0 清理测试环境</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[root@db01 ~]# pkill java</span><br><span class="line">[root@db01 ~]# rm -rf /data/app/mycat/</span><br><span class="line">[root@db01 ~]# rm -rf /data/app/zookeeper/</span><br></pre></td></tr></table></figure>



<h3 id="12-2-1-安装配置ZK"><a href="#12-2-1-安装配置ZK" class="headerlink" title="12.2.1 安装配置ZK"></a>12.2.1 安装配置ZK</h3><table>
<thead>
<tr>
<th>节点</th>
<th>部署的软件</th>
<th>数据库实例</th>
</tr>
</thead>
<tbody><tr>
<td>db01</td>
<td>jdk1.8、mycat1.6.7.4、zookeeper3.5.8、MySQL   8.0.20</td>
<td>3307，3308，3309，   3310</td>
</tr>
<tr>
<td>db02</td>
<td>jdk1.8、mycat1.6.7.4、zookeeper3.5.8、MySQL   8.0.20</td>
<td>3307，3308，3309，   3310</td>
</tr>
<tr>
<td>db03</td>
<td>jdk1.8、mycat1.6.7.4、zookeeper3.5.8、MySQL   8.0.20</td>
<td>3306</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.配置JDK环境</span><br><span class="line">linux:</span><br><span class="line">export JAVA<span class="emphasis">_HOME=/usr/local/jdk1.8</span></span><br><span class="line"><span class="emphasis">export PATH=$PATH:$JAVA_</span>HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA<span class="emphasis">_HOME/lib/dt.jar:$JAVA_</span>HOME/lib/tools.jar</span><br><span class="line">windows:</span><br><span class="line">略。</span><br><span class="line"><span class="section">#2.安装zk</span></span><br><span class="line">cd /data/app/</span><br><span class="line">wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.5.8/apachezookeeper-3.5.8.tar.gz</span><br><span class="line">cd /data/app</span><br><span class="line">tar xf apache-zookeeper-3.5.8.tar.gz</span><br><span class="line">ln -s apache-zookeeper-3.5.8 zookeeper</span><br><span class="line"><span class="bullet">3.</span> 安装maven</span><br><span class="line"><span class="section"># 安装</span></span><br><span class="line">wget http://mirrors.hust.edu.cn/apache/maven/maven-3/3.6.3/binaries/apachemaven-3.6.3-bin.tar.gz</span><br><span class="line"><span class="section"># 解压</span></span><br><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz</span><br><span class="line"><span class="section"># 添加环境变量</span></span><br><span class="line">vim /etc/profile</span><br><span class="line">export MAVEN<span class="emphasis">_HOME=/usr/local/maven-3.6.3</span></span><br><span class="line"><span class="emphasis">export PATH=$MAVEN_</span>HOME/bin:$PATH</span><br><span class="line"><span class="section"># 重新加载环境变量</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="section"># 查看是否安装成功</span></span><br><span class="line">mvn -v</span><br><span class="line"><span class="section"># mvn编译zookeeper</span></span><br><span class="line">cd /data/app/zookeeper</span><br><span class="line">cd zookeeper-server</span><br><span class="line">mvn package -Dmaven.test.skip=true</span><br><span class="line"><span class="bullet">4.</span> 拷贝ZK到各个节点</span><br><span class="line">scp -r zookeeper/ 10.0.0.53:/data/app/</span><br><span class="line">scp -r zookeeper/ 10.0.0.52:/data/app/</span><br><span class="line"><span class="bullet">5.</span> 配置启动zk</span><br><span class="line">cd zookeeper</span><br><span class="line">rm -rf data log</span><br><span class="line">mkdir data log</span><br><span class="line">cd conf/</span><br><span class="line">\cp zoo<span class="emphasis">_sample.cfg zoo.cfg</span></span><br><span class="line"><span class="emphasis"># 修改三个节点以下配置：</span></span><br><span class="line"><span class="emphasis">vim zoo.cfg</span></span><br><span class="line"><span class="emphasis">dataDir=/data/app/zookeeper/data</span></span><br><span class="line"><span class="emphasis">dataLogDir=/data/app/zookeeper/log</span></span><br><span class="line"><span class="emphasis">clientPort=2181</span></span><br><span class="line"><span class="emphasis">server.1=10.0.0.51:2888:3888</span></span><br><span class="line"><span class="emphasis">server.2=10.0.0.52:2888:3888</span></span><br><span class="line"><span class="emphasis">server.3=10.0.0.53:2888:3888</span></span><br><span class="line"><span class="emphasis">#拷贝到各个节点</span></span><br><span class="line"><span class="emphasis">scp zoo.cfg 10.0.0.52:/data/app/zookeeper/conf/</span></span><br><span class="line"><span class="emphasis">zoo.cfg</span></span><br><span class="line"><span class="emphasis">scp zoo.cfg 10.0.0.53:/data/app/zookeeper/conf/</span></span><br><span class="line"><span class="emphasis">zoo.cfg</span></span><br><span class="line"><span class="emphasis"># 添加myid文件</span></span><br><span class="line"><span class="emphasis">vim /data/app/zookeeper/data/myid ---&gt;1、2、3三个节点需要不同id</span></span><br><span class="line"><span class="emphasis"># 三个节点分表启动zk</span></span><br><span class="line"><span class="emphasis">/data/app/zookeeper/bin/zkServer.sh start</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#查看各个节点zk状态</span></span><br><span class="line"><span class="emphasis">[root@db02 bin]# /data/app/zookeeper/bin/zkServer.sh status</span></span><br><span class="line"><span class="emphasis">/usr/bin/java</span></span><br><span class="line"><span class="emphasis">ZooKeeper JMX enabled by default</span></span><br><span class="line"><span class="emphasis">Using config: /data/app/zookeeper/bin/../conf/zoo.cfg</span></span><br><span class="line"><span class="emphasis">Client port found: 2181. Client address: localhost.</span></span><br><span class="line"><span class="emphasis">Mode: leader</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">[root@db01 app]# /data/app/zookeeper/bin/zkServer.sh start</span></span><br><span class="line"><span class="emphasis">ZooKeeper JMX enabled by default</span></span><br><span class="line"><span class="emphasis">Using config: /data/app/zookeeper/bin/../conf/zoo.cfg</span></span><br><span class="line"><span class="emphasis">Starting zookeeper ... STARTED</span></span><br><span class="line"><span class="emphasis">[root@db01 app]# /data/app/zookeeper/bin/zkServer.sh status</span></span><br><span class="line"><span class="emphasis">ZooKeeper JMX enabled by default</span></span><br><span class="line"><span class="emphasis">Using config: /data/app/zookeeper/bin/../conf/zoo.cfg</span></span><br><span class="line"><span class="emphasis">Client port found: 2181. Client address: localhost.</span></span><br><span class="line"><span class="emphasis">Mode: follower</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">[root@db03 bin]# /data/app/zookeeper/bin/zkServer.sh status</span></span><br><span class="line"><span class="emphasis">ZooKeeper JMX enabled by default</span></span><br><span class="line"><span class="emphasis">Using config: /data/app/zookeeper/bin/../conf/zoo.cfg</span></span><br><span class="line"><span class="emphasis">Client port found: 2181. Client address: localhost.</span></span><br><span class="line"><span class="emphasis">Mode: follower</span></span><br></pre></td></tr></table></figure>

<h2 id="12-3-配置Mycat基础环境"><a href="#12-3-配置Mycat基础环境" class="headerlink" title="12.3 配置Mycat基础环境"></a>12.3 配置Mycat基础环境</h2><p> 拓扑图 </p>
<h3 id="12-3-1-安装3台Mycat节点"><a href="#12-3-1-安装3台Mycat节点" class="headerlink" title="12.3.1 安装3台Mycat节点"></a>12.3.1 安装3台Mycat节点</h3><p>略</p>
<h3 id="12-3-2-配置成取模分片-本地SEQ"><a href="#12-3-2-配置成取模分片-本地SEQ" class="headerlink" title="12.3.2 配置成取模分片+本地SEQ"></a>12.3.2 配置成取模分片+本地SEQ</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># schema.xml</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">dataNode</span>=<span class="string">&quot;sh1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;oldguo&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;sh1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;oldguo1&quot;</span> <span class="attr">database</span>= <span class="string">&quot;taobao&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;sh2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;oldguo2&quot;</span> <span class="attr">database</span>= <span class="string">&quot;taobao&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;oldguo1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db4&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;oldguo2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3308&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3310&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3308&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db4&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3310&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br><span class="line"># rule.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>sharding_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line">server.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">create table oldguo(</span><br><span class="line">id bigint(20) not null primary key auto_increment,</span><br><span class="line">name varchar(20),</span><br><span class="line">sharding_id bigint(20),</span><br><span class="line">company_id bigint(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--最后： 同步所有配置到各个节点mycat。--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-3-3-启动mycat测试"><a href="#12-3-3-启动mycat测试" class="headerlink" title="12.3.3 启动mycat测试"></a>12.3.3 启动mycat测试</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 3.数据录入</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy001&#x27;, 10011, 1);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy002&#x27;, 10012, 2);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy003&#x27;, 10013, 3);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy004&#x27;, 10014, 4);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy005&#x27;, 10015, 5);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy006&#x27;, 10016, 1);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy007&#x27;, 10017, 1);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy008&#x27;, 10018, 2);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy009&#x27;, 10019, 2);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy010&#x27;, 10020, 1);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy011&#x27;, 10021, 3);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy012&#x27;, 10022, 4);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy013&#x27;, 10023, 5);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy014&#x27;, 10024, 5);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy015&#x27;, 10025, 2);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy016&#x27;, 10026, 2);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy017&#x27;, 10027, 3);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy018&#x27;, 10028, 3);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy019&#x27;, 10029, 1);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy021&#x27;, 10030, 1);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy022&#x27;, 10031, 2);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy023&#x27;, 10032, 5);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy024&#x27;, 10033, 4);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy025&#x27;, 10034, 5);</span><br><span class="line">insert into oldguo(id, name, sharding_id, company_id) values(next value for</span><br><span class="line">MYCATSEQ_GLOBAL, &#x27;oldboy026&#x27;, 10035, 3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12-4-配置Mycat支持ZK管理"><a href="#12-4-配置Mycat支持ZK管理" class="headerlink" title="12.4 配置Mycat支持ZK管理"></a>12.4 配置Mycat支持ZK管理</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#修改mycat配置文件，支持zk管理</span><br><span class="line">[root@db01 conf]# vim myid.properties</span><br><span class="line"></span><br><span class="line">loadZk=true</span><br><span class="line">zkURL=10.0.0.51:2181,10.0.0.52:2821,10.0.0.53:2821</span><br><span class="line">clusterId=mycat-cluster-1</span><br><span class="line">myid=mycat_fz_01</span><br><span class="line">clusterSize=3</span><br><span class="line">clusterNodes=mycat_fz_01,mycat_fz_02,mycat_fz_03</span><br><span class="line">#server booster ; booster install on db same server,will reset all</span><br><span class="line">minCon to 2</span><br><span class="line">type=server</span><br><span class="line">boosterDataHosts=oldguo1,oldguo2</span><br><span class="line"></span><br><span class="line"># 拷贝mycat初始配置，将配置好的conf目录下的配置文件复制到同级目录zkconf下</span><br><span class="line">\cp /data/app/mycat/conf/*.xml /data/app/mycat/conf/zkconf/</span><br><span class="line">\cp /data/app/mycat/conf/*.properties /data/app/mycat/conf/zkconf/</span><br><span class="line">\cp /data/app/mycat/conf/*.txt /data/app/mycat/conf/zkconf/</span><br><span class="line">\cp /data/app/mycat/conf/*.conf /data/app/mycat/conf/zkconf/</span><br><span class="line"></span><br><span class="line"># 初始化ZK数据</span><br><span class="line">cd /data/app/mycat/bin</span><br><span class="line">./init_zk_data.sh</span><br><span class="line"></span><br><span class="line">解决报错：</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">shutdownHook</span>=<span class="string">&quot;disable&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12-5使用ZooInspector工具管理ZK"><a href="#12-5使用ZooInspector工具管理ZK" class="headerlink" title="12.5使用ZooInspector工具管理ZK"></a>12.5使用ZooInspector工具管理ZK</h2><ol>
<li>下载地址：<br><a href="https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip">https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</a></li>
<li>解压，进入build目录，运行 java -jar zookeeper-dev-ZooInspector.jar</li>
</ol>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662479456584-b44c06a7-bd03-4161-a89a-de6dadcf2de0.png"></p>
<ol start="3">
<li><a href="https://www.bejson.com/">https://www.bejson.com/</a> 在线美化代码工具。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;maxCon&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;minCon&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oldguo1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;writeType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;switchType&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dbType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dbDriver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;native&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;heartbeat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;select user()&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;writeHost&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;db1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.51:3307&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;readHost&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;db2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.51:3309&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;db3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.52:3307&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;readHost&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;db4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.52:3309&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;maxCon&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;minCon&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oldguo2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;writeType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;switchType&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dbType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dbDriver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;native&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;heartbeat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;select user()&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;writeHost&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;db1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.51:3308&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;readHost&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;db2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.51:3310&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;db3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.52:3308&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;readHost&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;db4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.52:3310&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h2 id="12-6-mycat-web应用"><a href="#12-6-mycat-web应用" class="headerlink" title="12.6 mycat-web应用"></a>12.6 mycat-web应用</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 注意：mycat-web默认不支持MySQL8<span class="number">.0</span>，需要做以下操作</span><br><span class="line">cd /data/app/mycat/lib/</span><br><span class="line">上传<span class="number">8.0</span>的连接驱动</span><br><span class="line">chmod <span class="number">777</span> mysql-connector-java<span class="number">-8.0</span><span class="number">.21</span>.jar</span><br><span class="line"></span><br><span class="line">#上传解压软件</span><br><span class="line">tar -xvf Mycat-web<span class="number">-1.0</span>-SNAPSHOT<span class="number">-20160331220346</span>-linux.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line"># 修改zookeeper配置信息：</span><br><span class="line">cd /usr/local/mycat-web/mycat-web/WEB-INF/classes</span><br><span class="line">vim mycat.properties</span><br><span class="line">zookeeper=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="punctuation">:</span><span class="number">2181</span></span><br><span class="line">sqlonline.server=localhost</span><br><span class="line">sqlonline.user=dev</span><br><span class="line">sqlonline.passwd=<span class="number">123456</span></span><br><span class="line"></span><br><span class="line"># 创建用户</span><br><span class="line">create user dev@&#x27;localhost&#x27; identified with mysql_native_password by</span><br><span class="line">&#x27;<span class="number">123456</span>&#x27;;</span><br><span class="line">grant all on *.* to dev@&#x27;localhost&#x27; ;</span><br><span class="line"></span><br><span class="line"># 导入模板数据</span><br><span class="line">cd /usr/local/mycat-web/mycat-web/WEB-INF/db</span><br><span class="line">create database mycat_eye charset utf8;</span><br><span class="line">use mycat_eye;</span><br><span class="line">source mycat-web.sql</span><br><span class="line"></span><br><span class="line"># 启动：</span><br><span class="line">cd /usr/local/mycat-web/</span><br><span class="line">nohup ./start.sh &amp;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662479591993-44adceba-1b83-4657-9a26-ea28317fc80a.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662479619538-7b828a72-4f48-429b-b938-8885ef970f64.png"></p>
<h1 id="13-Mycat的节点扩容"><a href="#13-Mycat的节点扩容" class="headerlink" title="13.Mycat的节点扩容"></a>13.Mycat的节点扩容</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 确认数据分布</span><br><span class="line"><span class="number">2.</span> 修改schema.xml</span><br><span class="line">	cp schema.xml newSchema.xml</span><br><span class="line">	vim newSchema.xml</span><br><span class="line">	修改dataNode=<span class="string">&quot;sh1,sh2,sh3&quot;</span>（新的分片定义）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 修改rule.xml</span><br><span class="line">	cp rule.xml newRule.xml</span><br><span class="line">	vim newRule.xml</span><br><span class="line">	修改节点个数</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 修改migrateTables.properties文件。</span><br><span class="line">	写明要迁移的schema和表，多张表用逗号隔开</span><br><span class="line">	TESTDB=oldguo</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>停止mycat和zk</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 执行dataMigrate.sh开始迁移(扩容)。</span><br></pre></td></tr></table></figure>

<h1 id="13-Mycat-Mycat-web-PXC-ZK-Sequnce分布式集群实-现"><a href="#13-Mycat-Mycat-web-PXC-ZK-Sequnce分布式集群实-现" class="headerlink" title="13.Mycat+Mycat-web+PXC+ZK+Sequnce分布式集群实 现"></a>13.Mycat+Mycat-web+PXC+ZK+Sequnce分布式集群实 现</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662481093148-4bea8739-a4af-4f96-8abe-266b5e775cdc.png"></p>
<h2 id="13-1-节点规划"><a href="#13-1-节点规划" class="headerlink" title="13.1 节点规划"></a>13.1 节点规划</h2><table>
<thead>
<tr>
<th>节点</th>
<th>软件</th>
</tr>
</thead>
<tbody><tr>
<td>10.0.0.11-pxc1-   node01</td>
<td>pxb2.4.14、pxc-5.7.25</td>
</tr>
<tr>
<td>10.0.0.12-pxc1-   node02</td>
<td>pxb2.4.14、pxc-5.7.25</td>
</tr>
<tr>
<td>10.0.0.13-pxc1-   node03</td>
<td>pxb2.4.14、pxc-5.7.25</td>
</tr>
<tr>
<td>10.0.0.14-pxc2-   node04</td>
<td>pxb2.4.14、pxc-5.7.25、mycat1.6.7.4、zookeeper3.5.8</td>
</tr>
<tr>
<td>10.0.0.15-pxc2-   node05</td>
<td>pxb2.4.14、pxc-5.7.25、mycat1.6.7.4、zookeeper3.5.8</td>
</tr>
<tr>
<td>10.0.0.16-pxc2-   node06</td>
<td>pxb2.4.14、pxc-5.7.25、mycat1.6.7.4、zookeeper3.5.8、haproxy、mycatweb</td>
</tr>
</tbody></table>
<h2 id="13-2-环境请理"><a href="#13-2-环境请理" class="headerlink" title="13.2 环境请理"></a>13.2 环境请理</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span>root@db01 bin<span class="punctuation">]</span># pkill mysqld</span><br><span class="line"><span class="punctuation">[</span>root@db01 bin<span class="punctuation">]</span># pkill java</span><br><span class="line"><span class="punctuation">[</span>root@db01 bin<span class="punctuation">]</span># \rm -rf /data/<span class="number">33</span>*</span><br><span class="line"><span class="punctuation">[</span>root@db01 bin<span class="punctuation">]</span># rm -rf /etc/my.*</span><br><span class="line"><span class="punctuation">[</span>root@node01 ~<span class="punctuation">]</span># rm -rf /etc/percona*</span><br><span class="line"><span class="punctuation">[</span>root@node01 ~<span class="punctuation">]</span># yum remove percona* -y</span><br></pre></td></tr></table></figure>

<h2 id="13-3-2组PXC集群实施"><a href="#13-3-2组PXC集群实施" class="headerlink" title="13.3 2组PXC集群实施"></a>13.3 2组PXC集群实施</h2><h3 id="13-3-1-软件上传及解压（6个节点都做）"><a href="#13-3-1-软件上传及解压（6个节点都做）" class="headerlink" title="13.3.1 软件上传及解压（6个节点都做）"></a>13.3.1 软件上传及解压（6个节点都做）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 创建目录，分别上传pxc和pxb的软件</span><br><span class="line">mkdir -p /usr/local/pxc</span><br><span class="line">mkdir -p /usr/local/pxb</span><br><span class="line">mv Percona-XtraBackup<span class="number">-2.4</span><span class="number">.14</span>-ref675d4-el7-x86_64-bundle.tar pxb/</span><br><span class="line">mv Percona-XtraDB-Cluster<span class="number">-5.7</span><span class="number">.25</span><span class="number">-31.35</span>-r463-el7-x86_64-bundle.tar pxc/</span><br><span class="line">tar xf Percona-XtraBackup<span class="number">-2.4</span><span class="number">.14</span>-ref675d4-el7-x86_64-bundle.tar</span><br><span class="line">tar xf Percona-XtraDB-Cluster<span class="number">-5.7</span><span class="number">.25</span><span class="number">-31.35</span>-r463-el7-x86_64-bundle.tar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-3-2-软件安装（6个节点都做）"><a href="#13-3-2-软件安装（6个节点都做）" class="headerlink" title="13.3.2 软件安装（6个节点都做）"></a>13.3.2 软件安装（6个节点都做）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 安装pxb软件</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">http<span class="punctuation">:</span><span class="comment">//mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line">cd /usr/local/pxb</span><br><span class="line">yum install -y percona-xtrabackup<span class="number">-24</span><span class="number">-2.4</span><span class="number">.14</span><span class="number">-1.</span>el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#安装pxc软件</span><br><span class="line">cd /usr/local/pxc/</span><br><span class="line">rpm -qa | grep Percona-Server | grep -v compat |xargs rpm -e --nodeps</span><br><span class="line">yum install -y *.rpm</span><br></pre></td></tr></table></figure>

<h3 id="13-3-3-配置PXC集群"><a href="#13-3-3-配置PXC集群" class="headerlink" title="13.3.3 配置PXC集群"></a>13.3.3 配置PXC集群</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#启动数据库</span></span><br><span class="line">systemctl start mysql</span><br><span class="line"></span><br><span class="line"><span class="section"># 修改密码和创建用户</span></span><br><span class="line">grep &quot;temporary password&quot; /var/log/mysqld.log</span><br><span class="line">&gt;Pgg0k&gt;B<span class="emphasis">_Gr7</span></span><br><span class="line"><span class="emphasis">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123&#x27;;</span></span><br><span class="line"><span class="emphasis">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123&#x27; WITH GRANT</span></span><br><span class="line"><span class="emphasis">OPTION;</span></span><br><span class="line"><span class="emphasis">flush privileges;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## 创建pxc的sst账户用户同步</span></span><br><span class="line"><span class="emphasis">CREATE USER &#x27;sstuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123&#x27;;</span></span><br><span class="line"><span class="emphasis">GRANT RELOAD, LOCK TABLES, REPLICATION CLIENT ON *.* TO</span></span><br><span class="line"><span class="emphasis">&#x27;sstuser&#x27;@&#x27;localhost&#x27;;</span></span><br><span class="line"><span class="emphasis">FLUSH PRIVILEGES;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">[root@node01 percona-xtradb-cluster.conf.d]# cat wsrep.cnf</span></span><br><span class="line"><span class="emphasis">[mysqld]</span></span><br><span class="line"><span class="emphasis"># Path to Galera library</span></span><br><span class="line"><span class="emphasis">wsrep_</span>provider=/usr/lib64/galera3/libgalera<span class="emphasis">_smm.so</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># Cluster connection URL contains IPs of nodes</span></span><br><span class="line"><span class="emphasis">#If no IP is found, this implies that a new cluster needs to be created,</span></span><br><span class="line"><span class="emphasis">#in order to do that you need to bootstrap this node</span></span><br><span class="line"><span class="emphasis">wsrep_</span>cluster<span class="emphasis">_address=gcomm://10.0.0.11,10,10.0.0.12,10.0.0.13</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># In order for Galera to work correctly binlog format should be ROW</span></span><br><span class="line"><span class="emphasis">binlog_</span>format=ROW</span><br><span class="line"></span><br><span class="line"><span class="section"># MyISAM storage engine has only experimental support</span></span><br><span class="line">default<span class="emphasis">_storage_</span>engine=InnoDB</span><br><span class="line"></span><br><span class="line"><span class="section"># Slave thread to use</span></span><br><span class="line">wsrep<span class="emphasis">_slave_</span>threads= 8</span><br><span class="line">wsrep<span class="emphasis">_log_</span>conflicts</span><br><span class="line"></span><br><span class="line"><span class="section"># This changes how InnoDB autoincrement locks are managed and is a</span></span><br><span class="line">requirement for Galera</span><br><span class="line">innodb<span class="emphasis">_autoinc_</span>lock<span class="emphasis">_mode=2</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># Node IP address</span></span><br><span class="line"><span class="emphasis">wsrep_</span>node<span class="emphasis">_address=10.0.0.11</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># Cluster name</span></span><br><span class="line"><span class="emphasis">wsrep_</span>cluster<span class="emphasis">_name=pxc-cluster</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#If wsrep_</span>node<span class="emphasis">_name is not specified, then system hostname will be used</span></span><br><span class="line"><span class="emphasis">wsrep_</span>node<span class="emphasis">_name=node01</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#pxc_</span>strict<span class="emphasis">_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER</span></span><br><span class="line"><span class="emphasis">pxc_</span>strict<span class="emphasis">_mode=ENFORCING</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># SST method</span></span><br><span class="line"><span class="emphasis">#wsrep_</span>sst<span class="emphasis">_method=xtrabackup-v2</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#Authentication for SST method</span></span><br><span class="line"><span class="emphasis">wsrep_</span>sst<span class="emphasis">_auth=&quot;sstuser:123&quot;</span></span><br><span class="line"><span class="emphasis">wsrep_</span>sst<span class="emphasis">_method = rsync</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 在第一节点引导启动集群</span></span><br><span class="line"><span class="emphasis">service mysql@bootstrap.service start</span></span><br><span class="line"><span class="emphasis">show global status like &#x27;wsrep%&#x27;;</span></span><br><span class="line"><span class="emphasis"># 其他节点</span></span><br><span class="line"><span class="emphasis">service mysql start</span></span><br></pre></td></tr></table></figure>

<h2 id="13-4-部署Mycat集群"><a href="#13-4-部署Mycat集群" class="headerlink" title="13.4 部署Mycat集群"></a>13.4 部署Mycat集群</h2><h3 id="13-4-1-安装jdk"><a href="#13-4-1-安装jdk" class="headerlink" title="13.4.1 安装jdk"></a>13.4.1 安装jdk</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 上传软件至/usr/local 解压</span></span><br><span class="line">略</span><br><span class="line"></span><br><span class="line"><span class="section"># 设置环境变量</span></span><br><span class="line">export JAVA<span class="emphasis">_HOME=/usr/local/jdk1.8</span></span><br><span class="line"><span class="emphasis">export PATH=$PATH:$JAVA_</span>HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA<span class="emphasis">_HOME/lib/dt.jar:$JAVA_</span>HOME/lib/tools.jar</span><br><span class="line">export PATH=/usr/local/mycat/bin:$PATH</span><br></pre></td></tr></table></figure>

<h3 id="13-4-2-上传至-x2F-usr-x2F-local解压Mycat"><a href="#13-4-2-上传至-x2F-usr-x2F-local解压Mycat" class="headerlink" title="13.4.2 上传至&#x2F;usr&#x2F;local解压Mycat"></a>13.4.2 上传至&#x2F;usr&#x2F;local解压Mycat</h3><p>略</p>
<h2 id="13-5上传zookeeper进行配置启动"><a href="#13-5上传zookeeper进行配置启动" class="headerlink" title="13.5上传zookeeper进行配置启动"></a>13.5上传zookeeper进行配置启动</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 上传软件至/usr/local/并解压</span></span><br><span class="line">tar xf apache-zookeeper-3.5.8-mvn.tar</span><br><span class="line">mv apache-zookeeper-3.5.8 zk</span><br><span class="line"></span><br><span class="line"><span class="section"># 创建相关目录并修改配置文件</span></span><br><span class="line">cd zk</span><br><span class="line">rm -rf data log</span><br><span class="line">mkdir data log</span><br><span class="line">cd conf/</span><br><span class="line">\cp zoo<span class="emphasis">_sample.cfg zoo.cfg</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 修改三个节点以下配置：</span></span><br><span class="line"><span class="emphasis">vim zoo.cfg</span></span><br><span class="line"><span class="emphasis">dataDir=/data/app/zookeeper/data</span></span><br><span class="line"><span class="emphasis">dataLogDir=/data/app/zookeeper/log</span></span><br><span class="line"><span class="emphasis">clientPort=2181</span></span><br><span class="line"><span class="emphasis">server.1=10.0.0.51:2888:3888</span></span><br><span class="line"><span class="emphasis">server.2=10.0.0.52:2888:3888</span></span><br><span class="line"><span class="emphasis">server.3=10.0.0.53:2888:3888</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 拷贝到各个节点</span></span><br><span class="line"><span class="emphasis">scp zoo.cfg 10.0.0.52:/usr/local/zk/conf/</span></span><br><span class="line"><span class="emphasis">scp zoo.cfg 10.0.0.53:/usr/local/zk/conf/</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 添加myid文件</span></span><br><span class="line"><span class="emphasis">vim /usr/local/zk/data/myid ---&gt;1、2、3三个节点需要不同id</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 三个节点分表启动zk</span></span><br><span class="line"><span class="emphasis">/usr/local/zk/bin/zkServer.sh start</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 查看各个节点zk状态</span></span><br><span class="line"><span class="emphasis">[root@db02 bin]# /usr/local/zk/bin/zkServer.sh status</span></span><br><span class="line"><span class="emphasis">/usr/bin/java</span></span><br><span class="line"><span class="emphasis">ZooKeeper JMX enabled by default</span></span><br><span class="line"><span class="emphasis">Using config: /data/app/zookeeper/bin/../conf/zoo.cfg</span></span><br><span class="line"><span class="emphasis">Client port found: 2181. Client address: localhost.</span></span><br><span class="line"><span class="emphasis">Mode: leader</span></span><br></pre></td></tr></table></figure>

<h2 id="13-6-将PXC集群加入Mycat管理"><a href="#13-6-将PXC集群加入Mycat管理" class="headerlink" title="13.6 将PXC集群加入Mycat管理"></a>13.6 将PXC集群加入Mycat管理</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># vim schema.xml</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">dataNode</span>=<span class="string">&quot;sh1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;oldguo&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;sh1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;oldguo1&quot;</span> <span class="attr">database</span>= <span class="string">&quot;taobao&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;sh2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;oldguo2&quot;</span> <span class="attr">database</span>= <span class="string">&quot;taobao&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;oldguo1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>show status like &#x27;wsrep%&#x27;<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.11:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.12:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.13:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;oldguo2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>show status like &#x27;wsrep%&#x27;<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.14:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.15:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.16:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br><span class="line"># rule.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">columns</span>&gt;</span>sharding_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="13-7-Mycat和zookeeper结合"><a href="#13-7-Mycat和zookeeper结合" class="headerlink" title="13.7 Mycat和zookeeper结合"></a>13.7 Mycat和zookeeper结合</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 修改mycat配置文件，支持zk管理</span></span><br><span class="line">[root@db01 conf]# vim myid.properties</span><br><span class="line">loadZk=true</span><br><span class="line">zkURL=10.0.0.14:2181,10.0.0.15:2821,10.0.0.16:2821</span><br><span class="line">clusterId=mycat-cluster-1</span><br><span class="line">myid=mycat<span class="emphasis">_fz_</span>01</span><br><span class="line">clusterSize=3</span><br><span class="line">clusterNodes=mycat<span class="emphasis">_fz_</span>01,mycat<span class="emphasis">_fz_</span>02,mycat<span class="emphasis">_fz_</span>03</span><br><span class="line"><span class="section">#server booster ; booster install on db same server,will reset all</span></span><br><span class="line">minCon to 2</span><br><span class="line">type=server</span><br><span class="line">boosterDataHosts=oldguo1,oldguo2</span><br><span class="line"></span><br><span class="line"><span class="section"># 拷贝mycat初始配置，将配置好的conf目录下的配置文件复制到同级目录zkconf下</span></span><br><span class="line">\cp /usr/local/mycat/conf/<span class="emphasis">*.xml /usr/local/mycat/conf/zkconf/</span></span><br><span class="line"><span class="emphasis">\cp /usr/local/mycat/conf/*</span>.properties /usr/local/mycat/conf/zkconf/</span><br><span class="line">\cp /usr/local/mycat/conf/<span class="emphasis">*.txt /usr/local/mycat/conf/zkconf/</span></span><br><span class="line"><span class="emphasis">\cp /usr/local/mycat/conf/*</span>.conf /usr/local/mycat/conf/zkconf/</span><br><span class="line"></span><br><span class="line"><span class="section"># 初始化ZK数据</span></span><br><span class="line">cd /usr/local/mycat/bin</span><br><span class="line">./init<span class="emphasis">_zk_</span>data.sh</span><br><span class="line">解决报错：</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">shutdownHook</span>=<span class="string">&quot;disable&quot;</span>&gt;</span></span></span><br><span class="line">  ...</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<h1 id="使用ZooInspector工具管理ZK"><a href="#使用ZooInspector工具管理ZK" class="headerlink" title="使用ZooInspector工具管理ZK"></a>使用ZooInspector工具管理ZK</h1><h1 id="haproxy"><a href="#haproxy" class="headerlink" title="haproxy"></a>haproxy</h1><h1 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h1>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>全面优化</title>
    <url>/2024/07/15/%E5%85%A8%E9%9D%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="0-优化思路"><a href="#0-优化思路" class="headerlink" title="0. 优化思路"></a>0. 优化思路</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">硬件       : DELL R730 40C 128G 10台 SAS(8块:4块raid10 2块热备)+SSD 512G日志  网卡 4块网卡 bonding 1</span><br><span class="line">操作系统   : C7.6,numa  THP 关闭 , XFS  ,Swap ,sysctl.conf ,limits.conf nofile , 防火墙 selinux 关闭,deadline,No LVM</span><br><span class="line">数据库实例 ：</span><br><span class="line">SQL规范    ：</span><br><span class="line">索引       ：</span><br><span class="line">事务和锁   ：</span><br><span class="line">架构      ：</span><br><span class="line">安全      ： </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1609894264877-dd346846-597a-4930-82b4-bd3df8bc2515.png"></p>
<span id="more"></span>

<hr>
<h2 id="1-硬件层面优化"><a href="#1-硬件层面优化" class="headerlink" title="1.硬件层面优化"></a>1.硬件层面优化</h2><p>1.0 硬件选配 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.0</span> 硬件选配</span><br><span class="line">DELL、HP、IBM、华为、浪潮。</span><br><span class="line">CPU：I、E</span><br><span class="line"></span><br><span class="line">内存：ECC </span><br><span class="line">IO : SAS 、 pci<span class="operator">-</span>e SSD 、 Nvme flash</span><br><span class="line">raid卡：Raid10</span><br><span class="line"></span><br><span class="line">网卡： 单卡单口  bonding  <span class="operator">+</span> 交换机堆叠</span><br><span class="line">云服务器： ECS 、RDS 、TDSQL、PolarxDB</span><br></pre></td></tr></table></figure>



<p>1.1 关闭NUMA </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1</span> 关闭NUMA</span><br><span class="line">SMP   NUMA</span><br><span class="line"></span><br><span class="line">a. bios级别:</span><br><span class="line">在bios层面numa关闭时，无论os层面的numa是否打开，都不会影响性能。 </span><br><span class="line"></span><br><span class="line"># numactl <span class="comment">--hardware</span></span><br><span class="line">available: <span class="number">1</span> nodes (<span class="number">0</span>)       #如果是<span class="number">2</span>或多个nodes就说明numa没关掉</span><br><span class="line"></span><br><span class="line">b. OS grub级别:</span><br><span class="line">vi <span class="operator">/</span>boot<span class="operator">/</span>grub2<span class="operator">/</span>grub.cfg</span><br><span class="line">#<span class="comment">/* Copyright 2010, Oracle. All rights reserved. */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">default</span><span class="operator">=</span><span class="number">0</span></span><br><span class="line">timeout<span class="operator">=</span><span class="number">5</span></span><br><span class="line">hiddenmenu</span><br><span class="line">foreground<span class="operator">=</span><span class="number">000000</span></span><br><span class="line">background<span class="operator">=</span>ffffff</span><br><span class="line">splashimage<span class="operator">=</span>(hd0,<span class="number">0</span>)<span class="operator">/</span>boot<span class="operator">/</span>grub<span class="operator">/</span>oracle.xpm.gz</span><br><span class="line"> </span><br><span class="line">title Trying_C0D0_as_HD0</span><br><span class="line">root (hd0,<span class="number">0</span>)</span><br><span class="line">kernel <span class="operator">/</span>boot<span class="operator">/</span>vmlinuz<span class="number">-2.6</span><span class="number">.18</span><span class="number">-128.1</span><span class="number">.16</span><span class="number">.0</span><span class="number">.1</span>.el5 root<span class="operator">=</span>LABEL<span class="operator">=</span>DBSYS ro bootarea<span class="operator">=</span>dbsys rhgb quiet console<span class="operator">=</span>ttyS0,<span class="number">115200</span>n8 console<span class="operator">=</span>tty1 crashkernel<span class="operator">=</span><span class="number">128</span>M<span class="variable">@16M</span> numa<span class="operator">=</span>off</span><br><span class="line">initrd <span class="operator">/</span>boot<span class="operator">/</span>initrd<span class="number">-2.6</span><span class="number">.18</span><span class="number">-128.1</span><span class="number">.16</span><span class="number">.0</span><span class="number">.1</span>.el5.img</span><br><span class="line"></span><br><span class="line">在os层numa关闭时,打开bios层的numa会影响性能，QPS会下降<span class="number">15</span><span class="number">-30</span><span class="operator">%</span>;</span><br><span class="line"></span><br><span class="line">c. 数据库级别:</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%numa%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_numa_interleave <span class="operator">|</span> OFF   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"></span><br><span class="line">或者： </span><br><span class="line">vi <span class="operator">/</span>etc<span class="operator">/</span>init.d<span class="operator">/</span>mysqld</span><br><span class="line">找到如下行</span><br><span class="line"># Give extra arguments <span class="keyword">to</span> mysqld <span class="keyword">with</span> the my.cnf file. This script</span><br><span class="line"># may be overwritten <span class="keyword">at</span> next upgrade.</span><br><span class="line">$bindir<span class="operator">/</span>mysqld_safe <span class="comment">--datadir=&quot;$datadir&quot; --pid-file=&quot;$mysqld_pid_file_path&quot; $other_args &gt;/dev/null &amp;</span></span><br><span class="line"></span><br><span class="line">wait_for_pid created &quot;$!&quot; &quot;$mysqld_pid_file_path&quot;; return_value<span class="operator">=</span>$?</span><br><span class="line">将$bindir<span class="operator">/</span>mysqld_safe <span class="comment">--datadir=&quot;$datadir&quot;这一行修改为：</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>numactl <span class="comment">--interleave all $bindir/mysqld_safe --datadir=&quot;$datadir&quot; --pid-file=&quot;$mysqld_pid_file_path&quot; $other_args &gt;/dev/null &amp;</span></span><br><span class="line">wait_for_pid created &quot;$!&quot; &quot;$mysqld_pid_file_path&quot;; return_value<span class="operator">=</span>$?</span><br></pre></td></tr></table></figure>



<p>1.2 阵列卡配置建议 </p>
<p>1.3 关闭THP </p>
<p>1.4 网卡绑定 </p>
<p>1.5 多路径储存 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.2</span> 阵列卡配置建议</span><br><span class="line">raid10(推荐)</span><br><span class="line">SSD或者PCI<span class="operator">-</span>E或者Flash</span><br><span class="line">强制回写（Force WriteBack）</span><br><span class="line">BBU 电池 ： 如果没电会有较大性能影响、定期充放电，如果UPS、多路电源、发电机。可以关闭。</span><br><span class="line">关闭预读</span><br><span class="line">有可能的话开启Cache(如果UPS、多路电源、发电机。)</span><br><span class="line"></span><br><span class="line"> <span class="number">1.3</span> 关闭THP</span><br><span class="line">vi <span class="operator">/</span>etc<span class="operator">/</span>rc.local</span><br><span class="line">在文件末尾添加如下指令：</span><br><span class="line">if test <span class="operator">-</span>f <span class="operator">/</span>sys<span class="operator">/</span>kernel<span class="operator">/</span>mm<span class="operator">/</span>transparent_hugepage<span class="operator">/</span>enabled; <span class="keyword">then</span></span><br><span class="line">echo never <span class="operator">&gt;</span> <span class="operator">/</span>sys<span class="operator">/</span>kernel<span class="operator">/</span>mm<span class="operator">/</span>transparent_hugepage<span class="operator">/</span>enabled</span><br><span class="line">fi</span><br><span class="line">if test <span class="operator">-</span>f <span class="operator">/</span>sys<span class="operator">/</span>kernel<span class="operator">/</span>mm<span class="operator">/</span>transparent_hugepage<span class="operator">/</span>defrag; <span class="keyword">then</span></span><br><span class="line">echo never <span class="operator">&gt;</span> <span class="operator">/</span>sys<span class="operator">/</span>kernel<span class="operator">/</span>mm<span class="operator">/</span>transparent_hugepage<span class="operator">/</span>defrag</span><br><span class="line">fi</span><br><span class="line">[root<span class="variable">@master</span>  <span class="operator">~</span>]# cat <span class="operator">/</span>sys<span class="operator">/</span>kernel<span class="operator">/</span>mm<span class="operator">/</span>transparent_hugepage<span class="operator">/</span>enabled </span><br><span class="line">always madvise [never]</span><br><span class="line">[root<span class="variable">@master</span>  <span class="operator">~</span>]# cat  <span class="operator">/</span>sys<span class="operator">/</span>kernel<span class="operator">/</span>mm<span class="operator">/</span>transparent_hugepage<span class="operator">/</span>defrag </span><br><span class="line">always madvise [never]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.4</span> 网卡绑定</span><br><span class="line">bonding技术，业务数据库服务器都要配置bonding继续。建议是主备模式。</span><br><span class="line">交换机一定要堆叠。</span><br><span class="line"></span><br><span class="line"><span class="number">1.5</span> 存储多路径</span><br><span class="line">使用独立存储设备的话，需要配置多路径。</span><br><span class="line">linux 自带 : multipath</span><br><span class="line">厂商提供    :</span><br></pre></td></tr></table></figure>



<h2 id="2-系统层面优化"><a href="#2-系统层面优化" class="headerlink" title="2.系统层面优化"></a>2.系统层面优化</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a. 更改文件句柄和进程数</span><br><span class="line">内核优化 <span class="operator">/</span>etc<span class="operator">/</span>sysctl.conf</span><br><span class="line">vm.swappiness <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">vm.dirty_ratio <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">vm.dirty_background_ratio <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog <span class="operator">=</span> <span class="number">819200</span></span><br><span class="line">net.core.netdev_max_backlog <span class="operator">=</span> <span class="number">400000</span></span><br><span class="line">net.core.somaxconn <span class="operator">=</span> <span class="number">4096</span></span><br><span class="line">net.ipv4.tcp_tw_reuse<span class="operator">=</span><span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_recycle<span class="operator">=</span><span class="number">0</span></span><br><span class="line"></span><br><span class="line">limits.conf </span><br><span class="line">nofile <span class="number">63000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b. 防火墙</span><br><span class="line">禁用selinux ： <span class="operator">/</span>etc<span class="operator">/</span>sysconfig<span class="operator">/</span>selinux 更改SELINUX<span class="operator">=</span>disabled.</span><br><span class="line">iptables如果不使用可以关闭。可是需要打开MySQL需要的端口号</span><br><span class="line"></span><br><span class="line">c. 文件系统优化</span><br><span class="line">推荐使用XFS文件系统</span><br><span class="line">MySQL数据分区独立 ，例如挂载点为: <span class="operator">/</span>data</span><br><span class="line">mount参数 defaults, noatime, nodiratime, nobarrier 如<span class="operator">/</span>etc<span class="operator">/</span>fstab：</span><br><span class="line"><span class="operator">/</span>dev<span class="operator">/</span>sdb <span class="operator">/</span>data                   xfs     defaults,noatime,nodiratime,nobarrier        <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">d. 不使用LVM </span><br><span class="line"></span><br><span class="line">e. io调度</span><br><span class="line">SAS ：      deadline</span><br><span class="line">SSD<span class="operator">&amp;</span>PCI<span class="operator">-</span>E： noop</span><br><span class="line"></span><br><span class="line">centos <span class="number">7</span> 默认是deadline</span><br><span class="line">cat   <span class="operator">/</span>sys<span class="operator">/</span>block<span class="operator">/</span>sda<span class="operator">/</span>queue<span class="operator">/</span>scheduler</span><br><span class="line"></span><br><span class="line">#临时修改为deadline(centos6)</span><br><span class="line">echo deadline <span class="operator">&gt;</span><span class="operator">/</span>sys<span class="operator">/</span>block<span class="operator">/</span>sda<span class="operator">/</span>queue<span class="operator">/</span>scheduler </span><br><span class="line">vi <span class="operator">/</span>boot<span class="operator">/</span>grub<span class="operator">/</span>grub.conf</span><br><span class="line">更改到如下内容:</span><br><span class="line">kernel <span class="operator">/</span>boot<span class="operator">/</span>vmlinuz<span class="number">-2.6</span><span class="number">.18</span><span class="number">-8.</span>el5 ro root<span class="operator">=</span>LABEL<span class="operator">=</span><span class="operator">/</span> elevator<span class="operator">=</span>deadline rhgb quiet</span><br></pre></td></tr></table></figure>



<h2 id="3-数据库版本选择"><a href="#3-数据库版本选择" class="headerlink" title="3. 数据库版本选择"></a>3. 数据库版本选择</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、稳定版：选择开源的社区版的稳定版<span class="variable constant_">GA</span>版本。</span><br><span class="line"><span class="number">2</span>、选择mysql数据库<span class="variable constant_">GA</span>版本发布后<span class="number">6</span>个月-<span class="number">12</span>个月的<span class="variable constant_">GA</span>双数版本，大约在<span class="number">15</span>-<span class="number">20</span>个小版本左右。</span><br><span class="line"><span class="number">3</span>、要选择前后几个月没有大的<span class="variable constant_">BUG</span>修复的版本，而不是大量修复<span class="variable constant_">BUG</span>的集中版本。</span><br><span class="line"><span class="number">4</span>、要考虑开发人员开发程序使用的版本是否兼容你选的版本。</span><br><span class="line"><span class="number">5</span>、作为内部开发测试数据库环境，跑大概<span class="number">3</span>-<span class="number">6</span>个月的时间。</span><br><span class="line"><span class="number">6</span>、优先企业非核心业务采用新版本的数据库<span class="variable constant_">GA</span>版本软件。</span><br><span class="line"><span class="number">7</span>、向<span class="variable constant_">DBA</span>高手请教，或者在技术氛围好的群里和大家一起交流，使用真正的高手们用过的好用的<span class="variable constant_">GA</span>版本产品。</span><br><span class="line"></span><br><span class="line">最终建议： <span class="number">8.0</span><span class="number">.20</span>是一个不错的版本选择。向后可以选择双数版。  </span><br></pre></td></tr></table></figure>



<h2 id="4-💖数据库三层结构及核心参数优化"><a href="#4-💖数据库三层结构及核心参数优化" class="headerlink" title="4.💖数据库三层结构及核心参数优化"></a>4.💖数据库三层结构及核心参数优化</h2><h3 id="4-1-连接层"><a href="#4-1-连接层" class="headerlink" title="4.1 连接层"></a>4.1 连接层</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">max_connections=<span class="number">1000</span>         #*****       最大连接数</span><br><span class="line">max_connect_errors=<span class="number">999999</span>                 数据库开启以来失败连接次数</span><br><span class="line">wait_timeout=<span class="number">600</span>             #*****       连接超时时间</span><br><span class="line">interactive_wait_timeout=<span class="number">3600</span>             交互式连接超时时间</span><br><span class="line">net_read_timeout  = <span class="number">120</span>                   网络读超时时间</span><br><span class="line">net_write_timeout = <span class="number">120</span>                   网络写超时时间</span><br><span class="line">max_allowed_packet= 32M      #*****       允许的数据包大小</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Server层"><a href="#4-2-Server层" class="headerlink" title="4.2 Server层"></a>4.2 Server层</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sql_safe_updates                =<span class="number">1</span>                 # *****             update <span class="keyword">delete</span>语句必须有where条件 有索引</span><br><span class="line">slow_query_log                  =<span class="variable constant_">ON</span>                                    是否开启慢日志</span><br><span class="line">slow_query_log_file             =<span class="regexp">/data/</span><span class="number">3307</span>/slow.<span class="property">log</span>   # *****         慢日志存放位置</span><br><span class="line">long_query_time                 =<span class="number">1</span>                  # *****            多久才算慢日志</span><br><span class="line">log_queries_not_using_indexes   =<span class="variable constant_">ON</span>                 # *****            没走索引的</span><br><span class="line">log_throttle_queries_not_using_indexes = <span class="number">10</span>         # *****            没走索引的  相同语句最多记录次数</span><br><span class="line">sort_buffer 					= 1M</span><br><span class="line">join_buffer 					= 1M</span><br><span class="line">read_buffer						= 1M</span><br><span class="line">read_rnd_buffer                 = 1M</span><br><span class="line">tmp_table  						= 16M</span><br><span class="line">heap_table 						= 16M</span><br><span class="line">max_execution_time              = <span class="number">28800</span>                                <span class="variable constant_">SQL</span>最大执行时间</span><br><span class="line">lock_wait_timeout               = <span class="number">60</span>                 # *****           <span class="variable constant_">MDL</span>锁等待时间</span><br><span class="line">lower_case_table_names          =<span class="number">1</span>                   # *****           建库建表时强制转换小写</span><br><span class="line">thread_cache_size               =<span class="number">64</span>                  </span><br><span class="line">log_timestamps                  =<span class="variable constant_">SYSTEM</span>              # *****           日志时间与系统时间一致</span><br><span class="line">init_connect                    =<span class="string">&quot;set names utf8&quot;</span>    # *****           客户端字符集设置成<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">event_scheduler                 =<span class="variable constant_">OFF</span>                                   计划任务</span><br><span class="line">secure-file-priv                =/tmp                # *****           导数据传到指定目录</span><br><span class="line">binlog_expire_logs_seconds      =<span class="number">2592000</span>             # *****           二进制日志过期时间</span><br><span class="line">sync_binlog                     =<span class="number">1</span>                   # *****           二进制日志文件每次写的时候同步到磁盘</span><br><span class="line">log-bin                         =<span class="regexp">/data/</span><span class="number">3307</span>/mysql-bin</span><br><span class="line">log-bin-index                   =<span class="regexp">/data/</span><span class="number">3307</span>/mysql-bin.<span class="property">index</span></span><br><span class="line">max_binlog_size                 =500M</span><br><span class="line">binlog_format                   =<span class="variable constant_">ROW</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-存储引擎层"><a href="#4-3-存储引擎层" class="headerlink" title="4.3 存储引擎层"></a>4.3 存储引擎层</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">transaction-isolation               =<span class="string">&quot;READ-COMMITTED&quot;</span>    # *****       隔离级别</span><br><span class="line">innodb_data_home_dir                =/xxx                              ibdata位置点</span><br><span class="line">innodb_log_group_home_dir           =/xxx                              redolog位置点</span><br><span class="line">innodb_log_file_size                =2048M                             redolog大小 （512M-4G)</span><br><span class="line">innodb_log_files_in_group           =<span class="number">3</span>                                 redolog组</span><br><span class="line">innodb_flush_log_at_trx_commit      =<span class="number">2</span>                   # *****       事务提交redolog立即刷新到磁盘</span><br><span class="line">innodb_flush_method                 =<span class="variable constant_">O_DIRECT</span>            # *****       刷新策略</span><br><span class="line">innodb_io_capacity                  =<span class="number">1000</span>                # *****       iops刷新多少数据页</span><br><span class="line">innodb_io_capacity_max              =<span class="number">4000</span>         </span><br><span class="line">innodb_buffer_pool_size             =64G                 # *****       <span class="number">50</span>%-<span class="number">75</span>%物理内存</span><br><span class="line">innodb_buffer_pool_instances        =<span class="number">4</span>                   # *****</span><br><span class="line">innodb_log_buffer_size              =64M                 # *****       redo buffer大小 (512M-4G)</span><br><span class="line">innodb_max_dirty_pages_pct          =<span class="number">85</span>                  # *****       脏页占比  超过出发ckpt刷新到磁盘</span><br><span class="line">innodb_lock_wait_timeout            =<span class="number">10</span>                  # *****       行锁超时时间</span><br><span class="line">innodb_open_files                   =<span class="number">63000</span>               # *****       文件句柄</span><br><span class="line">innodb_page_cleaners                =<span class="number">4</span>                                 刷写数据页线程数量</span><br><span class="line">innodb_sort_buffer_size             =64M                               排序缓冲区</span><br><span class="line">innodb_print_all_deadlocks          =<span class="number">1</span>                   #             监控死锁信息 自动打印到日志</span><br><span class="line">innodb_rollback_on_timeout          =<span class="variable constant_">ON</span>                                事务超时是否自动回滚</span><br><span class="line">innodb_deadlock_detect              =<span class="variable constant_">ON</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-复制"><a href="#4-4-复制" class="headerlink" title="4.4 复制"></a>4.4 复制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">relay_log                       =<span class="regexp">/opt/</span>log/mysql/blog/relay</span><br><span class="line">relay_log_index                 =<span class="regexp">/opt/</span>log/mysql/blog/relay.<span class="property">index</span></span><br><span class="line">max_relay_log_size              =500M</span><br><span class="line">relay_log_recovery              =<span class="variable constant_">ON</span></span><br><span class="line"></span><br><span class="line">rpl_semi_sync_master_enabled                =<span class="variable constant_">ON</span></span><br><span class="line">rpl_semi_sync_master_timeout                =<span class="number">1000</span></span><br><span class="line">rpl_semi_sync_master_trace_level            =<span class="number">32</span></span><br><span class="line">rpl_semi_sync_master_wait_for_slave_count   =<span class="number">1</span></span><br><span class="line">rpl_semi_sync_master_wait_no_slave          =<span class="variable constant_">ON</span></span><br><span class="line">rpl_semi_sync_master_wait_point             =<span class="variable constant_">AFTER_SYNC</span></span><br><span class="line">rpl_semi_sync_slave_enabled                 =<span class="variable constant_">ON</span></span><br><span class="line">rpl_semi_sync_slave_trace_level             =<span class="number">32</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binlog_group_commit_sync_delay              =<span class="number">1</span></span><br><span class="line">binlog_group_commit_sync_no_delay_count     =<span class="number">1000</span></span><br><span class="line"></span><br><span class="line">gtid_mode                       =<span class="variable constant_">ON</span></span><br><span class="line">enforce_gtid_consistency        =<span class="variable constant_">ON</span></span><br><span class="line"></span><br><span class="line">skip-slave-start                =<span class="number">1</span></span><br><span class="line">#read_only                      =<span class="variable constant_">ON</span></span><br><span class="line">#super_read_only                =<span class="variable constant_">ON</span></span><br><span class="line">log_slave_updates               =<span class="variable constant_">ON</span></span><br><span class="line">server_id                       =<span class="number">2330602</span></span><br><span class="line">report_host                     =xxxx</span><br><span class="line">report_port                     =<span class="number">3306</span></span><br><span class="line">slave_parallel_type                         =<span class="variable constant_">LOGICAL_CLOCK</span></span><br><span class="line">slave_parallel_workers                      =<span class="number">4</span></span><br><span class="line">master_info_repository                      =<span class="variable constant_">TABLE</span></span><br><span class="line">relay_log_info_repository                   =<span class="variable constant_">TABLE</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-其它"><a href="#4-5-其它" class="headerlink" title="4.5 其它"></a>4.5 其它</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端配置： </span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br></pre></td></tr></table></figure>



<h2 id="5-开发规范"><a href="#5-开发规范" class="headerlink" title="5.开发规范"></a>5.开发规范</h2><h3 id="5-1-字段规范"><a href="#5-1-字段规范" class="headerlink" title="5.1 字段规范"></a>5.1 字段规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 每个表建议在30个字段以内(了解三大范式)。</span><br><span class="line">2. 需要存储emoji字符的，则选择utf8mb4字符集。</span><br><span class="line">3. 机密数据，加密后存储。</span><br><span class="line">4. 整型数据，默认加上UNSIGNED。</span><br><span class="line">5. 存储IPV4地址建议用bigINT UNSIGNE，查询时再利用INET_ATON()、INET_NTOA()函数转换。</span><br><span class="line">6. 如果遇到BLOB、TEXT大字段单独存储表或者附件形式存储。</span><br><span class="line">7. 选择尽可能小的数据类型，用于节省磁盘和内存空间。</span><br><span class="line">8. 存储浮点数，可以放大倍数存储。</span><br><span class="line">9. 每个表必须有主键，INT/BIGINT并且自增做为主键，分布式架构使用sequence序列生成器保存。</span><br><span class="line">10. 每个列使用not null，或增加默认值。</span><br></pre></td></tr></table></figure>



<h3 id="5-2-SQL语句规范"><a href="#5-2-SQL语句规范" class="headerlink" title="5.2 SQL语句规范"></a>5.2 SQL语句规范</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">### <span class="number">1.</span> 去掉不必要的括号</span><br><span class="line">如：      ((a <span class="variable constant_">AND</span> b) <span class="variable constant_">AND</span> c <span class="variable constant_">OR</span> (((a <span class="variable constant_">AND</span> b) <span class="variable constant_">AND</span> (c <span class="variable constant_">AND</span> d)))) </span><br><span class="line">修改成    (a <span class="variable constant_">AND</span> b <span class="variable constant_">AND</span> c) <span class="variable constant_">OR</span> (a <span class="variable constant_">AND</span> b <span class="variable constant_">AND</span> c <span class="variable constant_">AND</span> d)</span><br><span class="line">### <span class="number">2.</span>  去掉重叠条件</span><br><span class="line">如：      (a&lt;b <span class="variable constant_">AND</span> b=c) <span class="variable constant_">AND</span> a=<span class="number">5</span></span><br><span class="line">修改成    b&gt;<span class="number">5</span> <span class="variable constant_">AND</span> b=c <span class="variable constant_">AND</span> a=<span class="number">5</span></span><br><span class="line">如：      (B&gt;=<span class="number">5</span> <span class="variable constant_">AND</span> B=<span class="number">5</span>) <span class="variable constant_">OR</span> (B=<span class="number">6</span> <span class="variable constant_">AND</span> <span class="number">5</span>=<span class="number">5</span>) <span class="variable constant_">OR</span> (B=<span class="number">7</span> <span class="variable constant_">AND</span> <span class="number">5</span>=<span class="number">6</span>)</span><br><span class="line">修改成    B=<span class="number">5</span> <span class="variable constant_">OR</span> B=<span class="number">6</span></span><br><span class="line"></span><br><span class="line">### <span class="number">3.</span> 避免使用not <span class="keyword">in</span>、not exists 、&lt;&gt;、like %%</span><br><span class="line">### <span class="number">4.</span> 多表连接，小表驱动大表</span><br><span class="line">### <span class="number">5.</span> 减少临时表应用，优化order by 、group by、union、distinct、join等</span><br><span class="line">### <span class="number">6.</span> 减少语句查询范围，精确查询条件</span><br><span class="line">### <span class="number">7.</span> 多条件，符合联合索引最左原则</span><br><span class="line">### <span class="number">8.</span> 查询条件减少使用函数、拼接字符等条件、条件隐式转换</span><br><span class="line">### <span class="number">9.</span> union all 替代 union</span><br><span class="line">### <span class="number">10.</span>减少having子句使用</span><br><span class="line">### <span class="number">11.</span>如非必须不使用 <span class="keyword">for</span> update语句 </span><br><span class="line">### <span class="number">12.</span>update和<span class="keyword">delete</span>，开启安全更新参数</span><br><span class="line">### <span class="number">13.</span>减少inset  ... select语句应用</span><br><span class="line">### <span class="number">14.</span>使用load 替代insert录入大数据</span><br><span class="line">### <span class="number">15.</span>导入大量数据时，可以禁用索引、增大缓冲区、增大redo文件和buffer、关闭autocommit、<span class="variable constant_">RC</span>级别可以提高效率 </span><br><span class="line">### <span class="number">16.</span>优化limit，最好业务逻辑中先获取主键<span class="variable constant_">ID</span>，再基于<span class="variable constant_">ID</span>进行查询 </span><br><span class="line">	limit <span class="number">5000000</span>,<span class="number">10</span>     limit <span class="number">10</span> , <span class="number">200</span></span><br><span class="line">### <span class="number">17.</span> <span class="variable constant_">DDL</span>执行前要审核</span><br><span class="line">### <span class="number">18.</span> 多表连接语句执行前要看执行计划</span><br></pre></td></tr></table></figure>



<h2 id="6-索引优化"><a href="#6-索引优化" class="headerlink" title="6. 索引优化"></a>6. 索引优化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 非唯一索引按照“i_字段名称_字段名称[_字段名]”进行命名。</span><br><span class="line">2. 唯一索引按照“u_字段名称_字段名称[_字段名]”进行命名。</span><br><span class="line">3. 索引名称使用小写。</span><br><span class="line">4. 索引中的字段数不超过5个。</span><br><span class="line">5. 唯一键由3个以下字段组成，并且字段都是整形时，使用唯一键作为主键。</span><br><span class="line">6. 没有唯一键或者唯一键不符合5中的条件时，使用自增<span class="built_in">id</span>作为主键。</span><br><span class="line">7. 唯一键不和主键重复。</span><br><span class="line">8. 索引选择度高的列作为联合索引最左条件</span><br><span class="line">9. ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面。</span><br><span class="line">10. 单张表的索引数量控制在5个以内，若单张表多个字段在查询需求上都要单独用到索引，需要经过DBA评估。</span><br><span class="line">    查询性能问题无法解决的，应从产品设计上进行重构。</span><br><span class="line">	</span><br><span class="line">11. 使用EXPLAIN判断SQL语句是否合理使用索引，尽量避免extra列出现：Using File Sort，Using Temporary。</span><br><span class="line"></span><br><span class="line">12. UPDATE、DELETE语句需要根据WHERE条件添加索引。</span><br><span class="line"></span><br><span class="line">13. 对长度大于50的VARCHAR字段建立索引时，按需求恰当的使用前缀索引，或使用其他方法。</span><br><span class="line"></span><br><span class="line">14. 下面的表增加一列url_crc32，然后对url_crc32建立索引，减少索引字段的长度，提高效率。</span><br><span class="line"></span><br><span class="line">CREATE TABLE all_url(ID INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">url VARCHAR(255) NOT NULL DEFAULT 0,      </span><br><span class="line">url_crc32 INT UNSIGNED NOT NULL DEFAULT 0,</span><br><span class="line">index idx_url(url_crc32));</span><br><span class="line"></span><br><span class="line">15. 合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)。</span><br><span class="line"></span><br><span class="line">16. 合理利用覆盖索引，减少回表。</span><br><span class="line"></span><br><span class="line">17. 减少冗余索引和使用率较低的索引</span><br><span class="line">mysql&gt; select * from sys.schema_unused_indexes;</span><br><span class="line">mysql&gt; select * from sys.schema_redundant_indexes\G</span><br></pre></td></tr></table></figure>



<h2 id="7-锁优化✨✨✨"><a href="#7-锁优化✨✨✨" class="headerlink" title="7.锁优化✨✨✨"></a>7.锁优化✨✨✨</h2><h3 id="7-1-全局锁-Global-Read-lock"><a href="#7-1-全局锁-Global-Read-lock" class="headerlink" title="7.1 全局锁 Global Read lock"></a>7.1 全局锁 Global Read lock</h3><h4 id="a-介绍"><a href="#a-介绍" class="headerlink" title="a. 介绍"></a>a. 介绍</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">全局读锁。</span><br><span class="line">加锁方法： <span class="variable constant_">FTWRL</span>，flush tables <span class="keyword">with</span> read lock.</span><br><span class="line">解锁方法： unlock tables;</span><br><span class="line"></span><br><span class="line">出现场景： </span><br><span class="line">	mysqldump  --master-data  </span><br><span class="line">	xtrabackup（<span class="number">8.0</span>之前早期版本）等备份时。</span><br><span class="line">属于类型： <span class="variable constant_">MDL</span>（matedatalock）层面锁</span><br><span class="line">影响情况： 加锁期间，阻塞所有事务写入，阻塞所有已有事务commit。</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">MDL</span>，等待时间受 lock_wait_timeout=<span class="number">31536000</span></span><br></pre></td></tr></table></figure>



<h4 id="b-检测方法🕵️‍♂️"><a href="#b-检测方法🕵️‍♂️" class="headerlink" title="b. 检测方法🕵️‍♂️"></a>b. 检测方法🕵️‍♂️</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## <span class="number">8.0</span>之前需要手工配置开启.</span><br><span class="line"><span class="keyword">UPDATE</span> performance_schema.setup_instruments</span><br><span class="line"><span class="keyword">SET</span> ENABLED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span>, TIMED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;wait/lock/metadata/sql/mdl&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.metadata_locks\G</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> OBJECT_SCHEMA ,OBJECT_NAME ,LOCK_TYPE,LOCK_DURATION,LOCK_STATUS ,OWNER_THREAD_ID,OWNER_EVENT_ID <span class="keyword">from</span> performance_schema.metadata_locks;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_table_lock_waits;</span><br><span class="line"></span><br><span class="line">场景:  业务反馈所有写入做不了.</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.metadata_locks\G</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_table_lock_waits;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">沟通后决定怎么处理?</span><br><span class="line">kill ?</span><br></pre></td></tr></table></figure>



<h4 id="经典故障案例1：5-7-xtrabackup-x2F-mysqldump备份时数据库出现hang状态，所有修改查询都不能进行"><a href="#经典故障案例1：5-7-xtrabackup-x2F-mysqldump备份时数据库出现hang状态，所有修改查询都不能进行" class="headerlink" title="经典故障案例1：5.7 xtrabackup&#x2F;mysqldump备份时数据库出现hang状态，所有修改查询都不能进行"></a>经典故障案例1：5.7 xtrabackup&#x2F;mysqldump备份时数据库出现hang状态，所有修改查询都不能进行</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">session1: 模拟一个大的查询或事务</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id,sleep(<span class="number">100</span>)  <span class="keyword">from</span> city <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">100</span>  <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"></span><br><span class="line">session2: 模拟备份时的FTWRL </span><br><span class="line">mysql<span class="operator">&gt;</span> flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 此时发现命令被阻塞</span></span><br><span class="line"></span><br><span class="line">session3: 发起查询，发现被阻塞</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> world.city <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">结论： 备份时，一定要选择业务不繁忙期间，否则有可能会阻塞正常业务。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p> </p>
<h4 id="故障案例2：-5-7版本-innobackupex备份全库，进程死了，mysql里就是全库读锁，后边insert-全阻塞了"><a href="#故障案例2：-5-7版本-innobackupex备份全库，进程死了，mysql里就是全库读锁，后边insert-全阻塞了" class="headerlink" title="故障案例2： 5.7版本  innobackupex备份全库，进程死了，mysql里就是全库读锁，后边insert 全阻塞了"></a>故障案例2： 5.7版本  innobackupex备份全库，进程死了，mysql里就是全库读锁，后边insert 全阻塞了</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#分析思路： </span><br><span class="line">show processlist  ----&gt;  select * <span class="keyword">from</span> performance_schema.<span class="property">metadata_locks</span>;  ---&gt; pending ----&gt;granted ----&gt; <span class="attr">OWNER_THREAD_ID</span>: <span class="number">66</span></span><br><span class="line">----&gt;  select * <span class="keyword">from</span> threads  \G -----&gt;processlist_Id----&gt;  show processlist -----&gt;  kill processlist_Id</span><br><span class="line">分析过程:</span><br><span class="line">pending 	 <span class="number">56</span>   <span class="number">54</span>  <span class="number">57</span></span><br><span class="line">events_statements_history</span><br><span class="line"><span class="number">56</span>: 	</span><br><span class="line"><span class="attr">SQL_TEXT</span>: select * <span class="keyword">from</span> city where id=<span class="number">500</span> <span class="keyword">for</span> update</span><br><span class="line"><span class="number">54</span>:</span><br><span class="line"><span class="attr">SQL_TEXT</span>: flush tables <span class="keyword">with</span> read lock</span><br><span class="line"><span class="number">57</span>:</span><br><span class="line"><span class="attr">SQL_TEXT</span>: select * <span class="keyword">from</span> user where id=<span class="number">1</span> <span class="keyword">for</span> update</span><br><span class="line">granted      <span class="number">55</span> 	</span><br><span class="line"><span class="attr">SQL_TEXT</span>: select id,<span class="title function_">sleep</span>(<span class="number">100</span>)  <span class="keyword">from</span> city where id&lt;<span class="number">100</span>  <span class="keyword">for</span> update</span><br><span class="line"><span class="number">55</span>  ---&gt; <span class="number">54</span> ----&gt; <span class="number">56</span> ,<span class="number">57</span></span><br><span class="line"><span class="number">55</span>?  ----&gt;</span><br><span class="line"></span><br><span class="line">#故障模拟： </span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="7-2-row-lock-wait-锁等待"><a href="#7-2-row-lock-wait-锁等待" class="headerlink" title="7.2 row lock wait 锁等待"></a>7.2 row lock wait 锁等待</h3><h4 id="a-介绍-1"><a href="#a-介绍-1" class="headerlink" title="a.介绍"></a>a.介绍</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">record lock 、gap、next lock</span><br><span class="line">都是基于索引加锁,与事务隔离级别有关。</span><br></pre></td></tr></table></figure>



<h4 id="b-行锁监控及分析🕵️‍♂️"><a href="#b-行锁监控及分析🕵️‍♂️" class="headerlink" title="b. 行锁监控及分析🕵️‍♂️"></a>b. 行锁监控及分析🕵️‍♂️</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 查询锁等待详细信息</span><br><span class="line">select * <span class="keyword">from</span> sys.<span class="property">innodb_lock_waits</span>;   ----&gt; <span class="title function_">blocking_pid</span>(锁源的连接线程)</span><br><span class="line"></span><br><span class="line"># 通过连接线程找<span class="variable constant_">SQL</span>线程</span><br><span class="line">select * <span class="keyword">from</span> performance_schema.<span class="property">threads</span>;</span><br><span class="line"></span><br><span class="line"># 通过<span class="variable constant_">SQL</span>线程找到 <span class="variable constant_">SQL</span>语句</span><br><span class="line">select * <span class="keyword">from</span> performance_schema.<span class="property">events_statements_history</span>;</span><br></pre></td></tr></table></figure>



<h4 id="c-优化方向"><a href="#c-优化方向" class="headerlink" title="c. 优化方向"></a>c. 优化方向</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 优化索引</span><br><span class="line"><span class="number">2.</span> 减少事务的更新范围</span><br><span class="line"><span class="number">3.</span> <span class="variable constant_">RC</span></span><br><span class="line"><span class="number">4.</span> 拆分语句： </span><br><span class="line">例如：  update t1 set num=num+<span class="number">10</span> where k1 &lt;<span class="number">100</span>;  k1 是辅助索引,record lock gap next</span><br><span class="line">	   改为:</span><br><span class="line">	   select id <span class="keyword">from</span> t1 where  k1 &lt;<span class="number">100</span>; ---&gt; <span class="attr">id</span>: <span class="number">20</span>,<span class="number">30</span>,<span class="number">50</span></span><br><span class="line">	   update t1 set num=num+<span class="number">10</span>   where id <span class="keyword">in</span> (<span class="number">20</span>,<span class="number">30</span>,<span class="number">50</span>);</span><br></pre></td></tr></table></figure>



<h4 id="故障案例3-16C-top-CPU使用总量-1200-1300-平均-80-MySQL数据库服务器"><a href="#故障案例3-16C-top-CPU使用总量-1200-1300-平均-80-MySQL数据库服务器" class="headerlink" title="故障案例3 :  16C    top  CPU使用总量 1200%-1300, 平均 80%+   MySQL数据库服务器"></a>故障案例3 :  16C    top  CPU使用总量 1200%-1300, 平均 80%+   MySQL数据库服务器</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#分析思路： </span><br><span class="line">top -<span class="title class_">Hp</span>  <span class="variable constant_">MYSQLID</span>   ---&gt; os_id   ----&gt; <span class="variable constant_">P_S</span>.<span class="property">threads</span> ---&gt; processlist_id ,  thread_id</span><br><span class="line"><span class="variable constant_">IO</span>  ---&gt; top  wait</span><br><span class="line">可能是什么原因?</span><br><span class="line"><span class="variable constant_">IOPS</span>? 回表太多?---&gt; 索引</span><br><span class="line">吞吐? 索引?</span><br><span class="line">硬件? raid <span class="variable constant_">IO</span>调度  .....</span><br><span class="line">大事务.</span><br><span class="line">参数.</span><br><span class="line"><span class="variable constant_">SQL</span> :</span><br><span class="line">events_statements_history/current</span><br><span class="line">类型:</span><br><span class="line">select  ----&gt; explain  ---&gt;索引     <span class="variable constant_">SQL</span>本身 --&gt; kill</span><br><span class="line"><span class="variable constant_">DML</span>     ----&gt; 锁  大事务 ---&gt; 索引  <span class="variable constant_">SQL</span>本身 ---&gt; 评估</span><br><span class="line"><span class="variable constant_">DDL</span>     ----&gt;  <span class="variable constant_">MDL</span>     ----&gt; kill</span><br><span class="line"></span><br><span class="line">#故障模拟：</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-架构优化"><a href="#8-架构优化" class="headerlink" title="8.架构优化"></a>8.架构优化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#高可用架构：</span><br><span class="line">	<span class="variable constant_">MHA</span>+<span class="title class_">ProxySQL</span>+<span class="variable constant_">GTID</span>+增强半同步   <span class="number">99.99</span>%   高可用+ 读写分离--&gt; 中小型企业</span><br><span class="line">	<span class="variable constant_">MGR</span>\<span class="title class_">InnoDB</span> <span class="title class_">Cluster</span>            </span><br><span class="line">	<span class="variable constant_">PXC</span> </span><br><span class="line">#读写分离： </span><br><span class="line">	<span class="title class_">ProxySQL</span>、<span class="title class_">MySQL</span>-router</span><br><span class="line">#分布式架构： </span><br><span class="line">	<span class="title class_">MYcat</span>  <span class="title class_">Polardb</span> <span class="variable constant_">TDSQL</span>   </span><br><span class="line"></span><br><span class="line">#<span class="title class_">NoSQL</span>: </span><br><span class="line">	<span class="title class_">Redis</span>+<span class="title function_">sentinel</span>(哨兵),<span class="title class_">Redis</span> <span class="title class_">Cluster</span></span><br><span class="line">	<span class="title class_">MongoDB</span> <span class="variable constant_">RS</span>/<span class="title class_">MongoDB</span> <span class="variable constant_">SHARDING</span> <span class="title class_">Cluster</span> </span><br><span class="line">	<span class="variable constant_">ES</span>  solr</span><br></pre></td></tr></table></figure>



<h2 id="9-安全优化"><a href="#9-安全优化" class="headerlink" title="9.安全优化"></a>9.安全优化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、 使用普通nologin用户管理<span class="title class_">MySQL</span></span><br><span class="line"><span class="number">2</span>、 合理授权用户、密码复杂度及最小权限、系统表保证只有管理员用户可访问。</span><br><span class="line"><span class="number">3</span>、 删除数据库匿名用户</span><br><span class="line"><span class="number">4</span>、 锁定非活动用户</span><br><span class="line"><span class="number">5</span>、 <span class="title class_">MySQL</span>尽量不暴露互联网,需要暴露互联网用户需要设置明确白名单、替换<span class="title class_">MySQL</span>默认端口号、使用ssl连接</span><br><span class="line"><span class="number">6</span>、 优化业务代码，防止<span class="variable constant_">SQL</span>注入。</span><br></pre></td></tr></table></figure>



<h2 id="10-常用工具介绍"><a href="#10-常用工具介绍" class="headerlink" title="10.常用工具介绍"></a>10.常用工具介绍</h2><h3 id="一、-PT（percona-toolkits）工具的应用"><a href="#一、-PT（percona-toolkits）工具的应用" class="headerlink" title="一、 PT（percona-toolkits）工具的应用"></a>一、 PT（percona-toolkits）工具的应用</h3><p><em>1. pt工具安装</em></p>
<p>[root@master ~]# <code>&lt;font style=&quot;color:#F5222D;&quot;&gt;yum install -y  percona-toolkit-3.1.0-2.el7.x86_64.rpm&lt;/font&gt;</code><font style="color:#F5222D;"> </font></p>
<p><em>2. 常用工具使用介绍</em></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1609981686723-1be82e57-b85f-4699-bb26-532048d8c476.png"></p>
<h4 id="2-1-pt-archiver-归档表"><a href="#2-1-pt-archiver-归档表" class="headerlink" title="2.1 pt-archiver 归档表"></a><font style="color:#F5222D;">2.1 pt-archiver 归档表</font></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">场景： </span><br><span class="line">	面试题： 亿级的大表，<span class="keyword">delete</span>批量删除100w左右数据。 #批量删除功能</span><br><span class="line">	面试题： 定期按照时间范围，进行归档表。           #归档功能---并发归档</span><br><span class="line"></span><br><span class="line">#重要参数</span><br><span class="line">--limit <span class="number">100</span>         每次取<span class="number">100</span>行数据用pt-archive处理    </span><br><span class="line">--txn-size  <span class="number">100</span>     设置<span class="number">100</span>行为一个事务提交一次，    </span><br><span class="line">--where <span class="string">&#x27;id&lt;3000&#x27;</span>   设置操作条件    </span><br><span class="line">--progress <span class="number">5000</span>     每处理<span class="number">5000</span>行输出一次处理信息    </span><br><span class="line">--statistics        输出执行过程及最后的操作统计。（只要不加上--quiet，默认情况下pt- archive都会输出执行过程的）    </span><br><span class="line">--charset=<span class="title class_">UTF8</span>      指定字符集为<span class="title class_">UTF8</span>—这个最后加上不然可能出现乱码。    </span><br><span class="line">--bulk-<span class="keyword">delete</span>       批量删除source上的旧数据(例如每次<span class="number">1000</span>行的批量删除操作)</span><br><span class="line"></span><br><span class="line">注意:  需要归档表中至少有一个索引,做好是where条件列有索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用案例：</span><br><span class="line"><span class="number">1.</span>归档到数据库      ---远程归档居多</span><br><span class="line">#<span class="number">1.1</span> 获得建表语句</span><br><span class="line"></span><br><span class="line">#<span class="number">1.2</span> 备份</span><br><span class="line">db01 [test]&gt; create table test1 like t100w;</span><br><span class="line">pt-archiver --source h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,D=test,t=t100w,u=oldguo,p=<span class="number">123</span> --dest h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,D=test,t=test1,u=oldguo,p=<span class="number">123</span> --where <span class="string">&#x27;id&lt;10000&#x27;</span> --no-check-charset --no-<span class="keyword">delete</span> --limit=<span class="number">1000</span> --commit-each --progress <span class="number">1000</span> --statistics</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>只清理数据</span><br><span class="line">pt-archiver --source h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,D=test,t=t100w,u=oldguo,p=<span class="number">123</span> --where <span class="string">&#x27;id&lt;10000&#x27;</span> --purge --limit=<span class="number">1</span> --no-check-charset</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>只把数据导出到外部文件，但是不删除源表里的数据</span><br><span class="line">pt-archiver --source h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,D=world,t=city,u=root,p=<span class="number">123</span> --where <span class="string">&#x27;1=1&#x27;</span> --no-check-charset --no-<span class="keyword">delete</span> --file=<span class="string">&quot;/tmp/archiver.dat&quot;</span> </span><br></pre></td></tr></table></figure>

<p><strong><font style="color:#F5222D;"></font></strong></p>
<h4 id="2-2-pt-osc-修改表结构"><a href="#2-2-pt-osc-修改表结构" class="headerlink" title="2.2 pt-osc 修改表结构"></a><font style="color:#F5222D;">2.2 pt-osc 修改表结构</font></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#场景：  </span><br><span class="line">	  修改表结构、索引创建删除</span><br><span class="line">	  不能加快速度，但能减少业务影响（锁）。</span><br><span class="line">	  </span><br><span class="line">#面试题 ： 	  	  </span><br><span class="line">pt-osc工作流程：</span><br><span class="line"><span class="number">1</span>、检查更改表是否有主键或唯一索引，是否有触发器</span><br><span class="line"><span class="number">2</span>、检查修改表的表结构，创建一个临时表，在新表上执行<span class="variable constant_">ALTER</span> <span class="variable constant_">TABLE</span>语句</span><br><span class="line">create table  bak like t1; </span><br><span class="line">alter table bak add telnum <span class="title function_">char</span>(<span class="number">11</span>) not <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、在源表上创建三个触发器分别对于<span class="variable constant_">INSERT</span> <span class="variable constant_">UPDATE</span> <span class="variable constant_">DELETE</span>操作</span><br><span class="line">create trigger </span><br><span class="line">a </span><br><span class="line">b </span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、从源表拷贝数据到临时表，在拷贝过程中，对源表的更新操作会写入到新建表中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、将临时表和源表rename（需要元数据修改锁，需要短时间锁表）</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、删除源表和触发器，完成表结构的修改。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pt-osc工具限制</span><br><span class="line"><span class="number">1</span>、源表必须有主键或唯一索引，如果没有工具将停止工作</span><br><span class="line"><span class="number">2</span>、如果线上的复制环境过滤器操作过于复杂，工具将无法工作</span><br><span class="line"><span class="number">3</span>、如果开启复制延迟检查，但主从延迟时，工具将暂停数据拷贝工作</span><br><span class="line"><span class="number">4</span>、如果开启主服务器负载检查，但主服务器负载较高时，工具将暂停操作</span><br><span class="line"><span class="number">5</span>、当表使用外键时，如果未使用--alter-foreign-keys-method参数，工具将无法执行</span><br><span class="line"><span class="number">6</span>、只支持<span class="title class_">Innodb</span>存储引擎表，且要求服务器上有该表<span class="number">1</span>倍以上的空闲空间。</span><br><span class="line"></span><br><span class="line">#pt-osc之alter语句限制</span><br><span class="line"><span class="number">1</span>、不需要包含alter table关键字，可以包含多个修改操作，使用逗号分开，如<span class="string">&quot;drop clolumn c1, add column c2 int&quot;</span></span><br><span class="line"><span class="number">2</span>、不支持rename语句来对表进行重命名操作</span><br><span class="line"><span class="number">3</span>、不支持对索引进行重命名操作</span><br><span class="line"><span class="number">4</span>、如果删除外键，需要对外键名加下划线，如删除外键fk_uid, 修改语句为<span class="string">&quot;DROP FOREIGN KEY _fk_uid&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pt-osc之命令模板</span><br><span class="line">## --execute表示执行</span><br><span class="line">## --dry-run表示只进行模拟测试</span><br><span class="line">## 表名只能使用参数t来设置，没有长参数</span><br><span class="line"></span><br><span class="line">pt-online-schema-change \</span><br><span class="line">--host=<span class="string">&quot;127.0.0.1&quot;</span> \</span><br><span class="line">--port=<span class="number">3358</span> \</span><br><span class="line">--user=<span class="string">&quot;root&quot;</span> \</span><br><span class="line">--password=<span class="string">&quot;root@root&quot;</span> \</span><br><span class="line">--charset=<span class="string">&quot;utf8&quot;</span> \</span><br><span class="line">--max-lag=<span class="number">10</span> \</span><br><span class="line">--check-salve-lag=<span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span> \</span><br><span class="line">--recursion-method=<span class="string">&quot;hosts&quot;</span> \</span><br><span class="line">--check-interval=<span class="number">2</span> \</span><br><span class="line">--database=<span class="string">&quot;testdb1&quot;</span> \</span><br><span class="line">  t=<span class="string">&quot;tb001&quot;</span> \</span><br><span class="line">--alter=<span class="string">&quot;add column c4 int&quot;</span> \</span><br><span class="line">--execute</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">pt-online-schema-change --user=oldguo --password=<span class="number">123</span> --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --alter <span class="string">&quot;add column state int not null default 1&quot;</span> D=test,t=t100w --print --execute</span><br><span class="line"></span><br><span class="line">pt-online-schema-change --user=oldguo --password=<span class="number">123</span> --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --alter <span class="string">&quot;add index idx(num)&quot;</span> D=test,t=t100w --print --execute</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:#F5222D;"></font></strong></p>
<h4 id="2-3-pt-table-checksum-校验主从数据"><a href="#2-3-pt-table-checksum-校验主从数据" class="headerlink" title="2.3 pt-table-checksum 校验主从数据"></a><font style="color:#F5222D;">2.3 pt-table-checksum 校验主从数据</font></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#场景：   校验主从数据一致性，生产中可用于定时任务。</span><br><span class="line"> 环境准备:</span><br><span class="line">	- 主从环境</span><br><span class="line">  - 从库开启配置</span><br><span class="line">    [mysqld]</span><br><span class="line">    report_host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.52</span></span><br><span class="line">		report_port=<span class="number">3307</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.3</span><span class="number">.1</span> 创建数据库</span><br><span class="line"><span class="title class_">Create</span> database pt <span class="variable constant_">CHARACTER</span> <span class="variable constant_">SET</span> utf8;</span><br><span class="line"></span><br><span class="line">创建用户checksum并授权</span><br><span class="line">create user  <span class="string">&#x27;checksum&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password by <span class="string">&#x27;checksum&#x27;</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">ALL</span> <span class="variable constant_">ON</span> *.* <span class="variable constant_">TO</span> <span class="string">&#x27;checksum&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span> ;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="number">2.3</span><span class="number">.2</span> 参数: </span><br><span class="line">--[no]check-replication-filters：是否检查复制的过滤器，默认是yes，建议启用不检查模式。</span><br><span class="line">--databases | -d：指定需要被检查的数据库，多个库之间可以用逗号分隔。</span><br><span class="line">--[no]check-binlog-format：是否检查binlog文件的格式，默认值yes。建议开启不检查。因为在默认的row格式下会出错。</span><br><span class="line">--replicate：把checksum的信息写入到指定表中。</span><br><span class="line">--replicate-check-only：只显示不同步信息</span><br><span class="line"></span><br><span class="line">pt-table-checksum --nocheck-replication-filters --no-check-binlog-format --replicate=pt.<span class="property">checksums</span> --create-replicate-table --databases=test --tables=t1 h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,u=checksum,p=checksum,P=<span class="number">3307</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----&gt;  可将命令加入到定时任务脚本。检查异步复制，是否出现问题。</span><br><span class="line">cat checksum.<span class="property">sh</span></span><br><span class="line">#!<span class="regexp">/bin/</span>bash </span><br><span class="line">date &gt;&gt; <span class="regexp">/root/</span>db/checksum.<span class="property">log</span></span><br><span class="line">pt-table-checksum --nocheck-binlog-format --nocheck-plan --nocheck-replication-filters --replicate=pt.<span class="property">checksums</span> --set-vars innodb_lock_wait_timeout=<span class="number">120</span> --databases test --tables t1 -u<span class="string">&#x27;checksum&#x27;</span> -p<span class="string">&#x27;checksum&#x27;</span> -h<span class="string">&#x27;10.0.0.51&#x27;</span> &gt;&gt; <span class="regexp">/tmp/</span>checksum.<span class="property">log</span></span><br><span class="line">date &gt;&gt; <span class="regexp">/root/</span>db/checksum.<span class="property">log</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-pt-table-sync-修复主从数据"><a href="#2-4-pt-table-sync-修复主从数据" class="headerlink" title="2.4 pt-table-sync 修复主从数据"></a>2.4 pt-table-sync 修复主从数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2.4</span> pt-table-sync</span><br><span class="line">主要参数介绍</span><br><span class="line">--replicate ：指定通过pt-table-checksum得到的表.</span><br><span class="line">--databases : 指定执行同步的数据库。</span><br><span class="line">--tables ：指定执行同步的表，多个用逗号隔开。</span><br><span class="line">--sync-to-master ：指定一个<span class="variable constant_">DSN</span>，即从的<span class="variable constant_">IP</span>，他会通过show processlist或show slave status 去自动的找主。</span><br><span class="line">h= ：服务器地址，命令里有<span class="number">2</span>个ip，第一次出现的是<span class="title class_">Master</span>的地址，第<span class="number">2</span>次是<span class="title class_">Slave</span>的地址。</span><br><span class="line">u= ：帐号。</span><br><span class="line">p= ：密码。</span><br><span class="line">--print ：打印，但不执行命令。</span><br><span class="line">--execute ：执行命令。</span><br><span class="line"></span><br><span class="line">pt-table-sync --replicate=pt.<span class="property">checksums</span> --databases test  --tables t1 h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,u=checksum,p=checksum,P=<span class="number">3307</span> h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,u=checksum,p=checksum,P=<span class="number">3306</span> --print</span><br><span class="line"></span><br><span class="line">pt-table-sync --replicate=pt.<span class="property">checksums</span> --databases test  --tables t1 h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,u=checksum,p=checksum,P=<span class="number">3307</span> h=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>,u=checksum,p=checksum,P=<span class="number">3307</span> --execute</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:#F5222D;"></font></strong></p>
<h4 id="2-5-pt-show-grants-备份数据库用户的方法-✨"><a href="#2-5-pt-show-grants-备份数据库用户的方法-✨" class="headerlink" title="2.5. # pt-show-grants (备份数据库用户的方法)✨ "></a><font style="color:#F5222D;">2.5. # pt-show-grants (备份数据库用户的方法)</font><font style="color:#F5222D;">✨</font><font style="color:#F5222D;"> </font></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#作用:  用户和权限信息迁移。</span><br><span class="line">pt-show-grants -h10<span class="number">.0</span><span class="number">.0</span><span class="number">.51</span>  -<span class="variable constant_">P3307</span>  -uchecksum -pchecksum </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------&gt;  导出结果： </span><br><span class="line">-- <span class="title class_">Grants</span> dumped by pt-show-grants</span><br><span class="line">-- <span class="title class_">Dumped</span> <span class="keyword">from</span> server <span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> via <span class="variable constant_">TCP</span>/<span class="variable constant_">IP</span>, <span class="title class_">MySQL</span> <span class="number">5.7</span><span class="number">.28</span>-log at <span class="number">2020</span>-<span class="number">05</span>-<span class="number">15</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">06</span></span><br><span class="line">-- <span class="title class_">Grants</span> <span class="keyword">for</span> <span class="string">&#x27;checksum&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span></span><br><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">USER</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">&#x27;checksum&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span>;</span><br><span class="line"><span class="variable constant_">ALTER</span> <span class="variable constant_">USER</span> <span class="string">&#x27;checksum&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span> <span class="variable constant_">IDENTIFIED</span> <span class="variable constant_">WITH</span> <span class="string">&#x27;mysql_native_password&#x27;</span> <span class="variable constant_">AS</span> <span class="string">&#x27;*E5E390AF1BDF241B51D9C0DBBEA262CC9407A2DF&#x27;</span> <span class="variable constant_">REQUIRE</span> <span class="variable constant_">NONE</span> <span class="variable constant_">PASSWORD</span> <span class="variable constant_">EXPIRE</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">ACCOUNT</span> <span class="variable constant_">UNLOCK</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">ALL</span> <span class="variable constant_">PRIVILEGES</span> <span class="variable constant_">ON</span> *.* <span class="variable constant_">TO</span> <span class="string">&#x27;checksum&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span>;</span><br><span class="line">-- <span class="title class_">Grants</span> <span class="keyword">for</span> <span class="string">&#x27;mysql.session&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">USER</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">&#x27;mysql.session&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable constant_">ALTER</span> <span class="variable constant_">USER</span> <span class="string">&#x27;mysql.session&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="variable constant_">IDENTIFIED</span> <span class="variable constant_">WITH</span> <span class="string">&#x27;mysql_native_password&#x27;</span> <span class="variable constant_">AS</span> <span class="string">&#x27;*THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE&#x27;</span> <span class="variable constant_">REQUIRE</span> <span class="variable constant_">NONE</span> <span class="variable constant_">PASSWORD</span> <span class="variable constant_">EXPIRE</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">ACCOUNT</span> <span class="variable constant_">LOCK</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">SELECT</span> <span class="variable constant_">ON</span> <span class="string">`mysql`</span>.<span class="string">`user`</span> <span class="variable constant_">TO</span> <span class="string">&#x27;mysql.session&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">SELECT</span> <span class="variable constant_">ON</span> <span class="string">`performance_schema`</span>.* <span class="variable constant_">TO</span> <span class="string">&#x27;mysql.session&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">SUPER</span> <span class="variable constant_">ON</span> *.* <span class="variable constant_">TO</span> <span class="string">&#x27;mysql.session&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">-- <span class="title class_">Grants</span> <span class="keyword">for</span> <span class="string">&#x27;mysql.sys&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">USER</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">&#x27;mysql.sys&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable constant_">ALTER</span> <span class="variable constant_">USER</span> <span class="string">&#x27;mysql.sys&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="variable constant_">IDENTIFIED</span> <span class="variable constant_">WITH</span> <span class="string">&#x27;mysql_native_password&#x27;</span> <span class="variable constant_">AS</span> <span class="string">&#x27;*THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE&#x27;</span> <span class="variable constant_">REQUIRE</span> <span class="variable constant_">NONE</span> <span class="variable constant_">PASSWORD</span> <span class="variable constant_">EXPIRE</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">ACCOUNT</span> <span class="variable constant_">LOCK</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">SELECT</span> <span class="variable constant_">ON</span> <span class="string">`sys`</span>.<span class="string">`sys_config`</span> <span class="variable constant_">TO</span> <span class="string">&#x27;mysql.sys&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">TRIGGER</span> <span class="variable constant_">ON</span> <span class="string">`sys`</span>.* <span class="variable constant_">TO</span> <span class="string">&#x27;mysql.sys&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">USAGE</span> <span class="variable constant_">ON</span> *.* <span class="variable constant_">TO</span> <span class="string">&#x27;mysql.sys&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">-- <span class="title class_">Grants</span> <span class="keyword">for</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span></span><br><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">USER</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span>;</span><br><span class="line"><span class="variable constant_">ALTER</span> <span class="variable constant_">USER</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span> <span class="variable constant_">IDENTIFIED</span> <span class="variable constant_">WITH</span> <span class="string">&#x27;mysql_native_password&#x27;</span> <span class="variable constant_">AS</span> <span class="string">&#x27;*23AE809DDACAF96AF0FD78ED04B6A265E05AA257&#x27;</span> <span class="variable constant_">REQUIRE</span> <span class="variable constant_">NONE</span> <span class="variable constant_">PASSWORD</span> <span class="variable constant_">EXPIRE</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">ACCOUNT</span> <span class="variable constant_">UNLOCK</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">REPLICATION</span> <span class="variable constant_">SLAVE</span> <span class="variable constant_">ON</span> *.* <span class="variable constant_">TO</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span>;</span><br><span class="line">-- <span class="title class_">Grants</span> <span class="keyword">for</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span></span><br><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">USER</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span>;</span><br><span class="line"><span class="variable constant_">ALTER</span> <span class="variable constant_">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span> <span class="variable constant_">IDENTIFIED</span> <span class="variable constant_">WITH</span> <span class="string">&#x27;mysql_native_password&#x27;</span> <span class="variable constant_">AS</span> <span class="string">&#x27;*23AE809DDACAF96AF0FD78ED04B6A265E05AA257&#x27;</span> <span class="variable constant_">REQUIRE</span> <span class="variable constant_">NONE</span> <span class="variable constant_">PASSWORD</span> <span class="variable constant_">EXPIRE</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">ACCOUNT</span> <span class="variable constant_">UNLOCK</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">ALL</span> <span class="variable constant_">PRIVILEGES</span> <span class="variable constant_">ON</span> *.* <span class="variable constant_">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span>;</span><br><span class="line">-- <span class="title class_">Grants</span> <span class="keyword">for</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">USER</span> <span class="variable constant_">IF</span> <span class="variable constant_">NOT</span> <span class="variable constant_">EXISTS</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable constant_">ALTER</span> <span class="variable constant_">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="variable constant_">IDENTIFIED</span> <span class="variable constant_">WITH</span> <span class="string">&#x27;mysql_native_password&#x27;</span> <span class="variable constant_">AS</span> <span class="string">&#x27;*23AE809DDACAF96AF0FD78ED04B6A265E05AA257&#x27;</span> <span class="variable constant_">REQUIRE</span> <span class="variable constant_">NONE</span> <span class="variable constant_">PASSWORD</span> <span class="variable constant_">EXPIRE</span> <span class="variable constant_">DEFAULT</span> <span class="variable constant_">ACCOUNT</span> <span class="variable constant_">UNLOCK</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">ALL</span> <span class="variable constant_">PRIVILEGES</span> <span class="variable constant_">ON</span> *.* <span class="variable constant_">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="variable constant_">WITH</span> <span class="variable constant_">GRANT</span> <span class="variable constant_">OPTION</span>;</span><br><span class="line"><span class="variable constant_">GRANT</span> <span class="variable constant_">PROXY</span> <span class="variable constant_">ON</span> <span class="string">&#x27;&#x27;</span>@<span class="string">&#x27;&#x27;</span> <span class="variable constant_">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="variable constant_">WITH</span> <span class="variable constant_">GRANT</span> <span class="variable constant_">OPTION</span>;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-pt-slave-find-显示主从结构-可了解下ORCH"><a href="#2-5-pt-slave-find-显示主从结构-可了解下ORCH" class="headerlink" title="2.5  pt-slave-find  显示主从结构 (可了解下ORCH)"></a>2.5  pt-slave-find  显示主从结构 (可了解下ORCH)</h4><p>[root@db01 tmp]#   <code>pt-slave-find -h10.0.0.51  -P3307 -uchecksum -pchecksum</code> </p>
<h4 id="2-6-监控主从延时"><a href="#2-6-监控主从延时" class="headerlink" title="2.6  监控主从延时"></a>2.6  监控主从延时</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#<span class="number">2.6</span>监控主从延时自带判定方法:</span><br><span class="line">show slave status \G</span><br><span class="line">second _behind_master===&gt; 从库sQr回放的<span class="title class_">Ts</span>-主从执行是的<span class="title class_">Ts</span>-主从的时间差异(主从系统时间延时会自动补偿)</span><br><span class="line">exec_master_log_pos ---&gt; 异步复制较准确/ 但<span class="variable constant_">SQL</span>多线程回放 如: loigcal_colck</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>存储引擎</title>
    <url>/2024/07/15/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="一、MySQL存储引擎概述"><a href="#一、MySQL存储引擎概述" class="headerlink" title="一、MySQL存储引擎概述"></a><strong><font style="color:black;">一、MySQL存储引擎概述</font></strong></h2><p><strong><font style="color:rgb(145, 109, 213);">「数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据」</font></strong><font style="color:black;">。不同的存储引擎提供不同的存储机制、索引、锁等功能。许多数据库管理系统都支持多种不同的数据引擎。</font></p>
<p><font style="color:black;">在关系数据库中数据的存储是以表的形式存储的，所以</font><strong><font style="color:rgb(145, 109, 213);">「存储引擎也可以称为表类型(Table Type，即存储和操作此表的类型)」</font></strong><font style="color:black;">。</font></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「MySQL的存储引擎」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「MySQL的存储引擎在体系架构中位于第三层，负责MySQL中的数据的存储和提取，是与文件打交道的子系统，它是根据MySQL提供的文件访问层抽象接口定制的一种文件访问机制。」</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641531036-9a90d1f7-c66d-4618-a142-afab1708fca9.webp"></p>
<span id="more"></span>
<p><font style="color:black;">从架构图中可以看出</font><strong><font style="color:rgb(145, 109, 213);">「mysql支持多种存储引擎， 不同版本的mysql支持的引擎会有细微差别」</font></strong></p>
<ul>
<li><font style="color:rgb(1, 1, 1);">InnoDB：支持事务，具有提交，回滚和崩溃恢复能力，事务安全</font></li>
<li><font style="color:rgb(1, 1, 1);">MyISAM：不支持事务和外键，访问速度快</font></li>
<li><font style="color:rgb(1, 1, 1);">Memory：利用内存创建表，访问速度非常快，因为数据在内存，而且默认使用Hash索引，但是 一旦关闭，数据就会丢失</font></li>
<li><font style="color:rgb(1, 1, 1);">Archive：归档类型引擎，仅能支持insert和select语句</font></li>
<li><font style="color:rgb(1, 1, 1);">Csv：以CSV文件进行数据存储，由于文件限制，所有列必须强制指定not null，另外CSV引擎也不 支持索引和分区，适合做数据交换的中间表</font></li>
<li><font style="color:rgb(1, 1, 1);">BlackHole: 黑洞，只进不出，进来消失，所有插入数据都不会保存</font></li>
<li><font style="color:rgb(1, 1, 1);">Federated：可以访问远端MySQL数据库中的表。一个本地表，不保存数据，访问远程表内容。</font></li>
<li><font style="color:rgb(1, 1, 1);">MRG_MyISAM：一组MyISAM表的组合，这些MyISAM表必须结构相同，</font></li>
<li><font style="color:rgb(1, 1, 1);">Merge表本身没有数据， 对Merge操作可以对一组MyISAM表进行操作。</font></li>
</ul>
<p><font style="color:black;">我本地使用的5.7.24版本，使用以下命令可以查看当前数据库支持的引擎信息：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641531020-b7843f6a-9a67-40f6-9d41-3e613a6ed968.webp"></p>
<h2 id="二-MySQL常用存储引擎"><a href="#二-MySQL常用存储引擎" class="headerlink" title="二 MySQL常用存储引擎"></a><strong><font style="color:black;">二 MySQL常用存储引擎</font></strong></h2><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「MySQL5.7支持的存储引擎包含」</font></strong></li>
</ul>
<p><font style="color:black;">InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等。</font></p>
<p><strong><font style="color:rgb(145, 109, 213);">「其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「MySQL默认存储引擎」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(145, 109, 213);">「Mysql5.5之前的默认存储引擎是MyISAM，5.5之后改为InnoDB」</font></strong><font style="color:black;">。通过以下命令可以查看默认的存储引擎</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%default_storage_engine%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641531098-50b0cf39-b6db-4fe2-a2b8-b0b91cc35c0b.webp"></p>
<p><strong><font style="color:rgb(145, 109, 213);">「可以在配置文件中设置default_storage_engine修改默认的存储引擎」</font></strong></p>
<ul>
<li><strong><font style="color:rgb(145, 109, 213);">「常用存储引擎的特性」</font></strong></li>
</ul>
<p><font style="color:black;">在MySQL中常用的存储引擎：【InnoDB】【MyISAM】【MEMORY】【 MERGE】【NDB】，它们之间的一些特细如下表：</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">特点</font></strong></th>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">InnoDB</font></strong></th>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">MyISAM</font></strong></th>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">MEMORY</font></strong></th>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">MERGE</font></strong></th>
<th align="left"><strong><font style="color:rgb(1, 1, 1);">NDB</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(1, 1, 1);">存储限制</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">64TB</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">265TB</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">RAM</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">没有</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">384 EB</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">事务安全</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">锁机制</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">行锁(适合高并发)</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">表锁</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">表锁</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">表锁</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">行锁</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">B树索引</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">哈希索引</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">全文索引</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持(5.6版本之后)</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">集群索引</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">数据索引</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">索引缓存</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">数据可压缩</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">空间使用</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">高</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">低</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">N&#x2F;A</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">低</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">低</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">内存使用</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">高</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">低</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">中等</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">低</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">高</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">批量插入速度</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">低</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">高</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">高</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">高</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">高</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(1, 1, 1);">支持外键</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">支持</font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
<td align="left"><font style="color:rgb(1, 1, 1);">   </font></td>
</tr>
</tbody></table>
<p><font style="color:black;">虽然mysql支持的存储引擎多种多样，但是</font><strong><font style="color:rgb(145, 109, 213);">「基本上在一般的企业和应用中大多是使用的【InnoDB】【MyISAM】两种」</font></strong><font style="color:black;">。因此我们在提到存储引擎的时候也都是默认描述的这两种，那么到底什么时候使用InnoDB？什么时候使用MyISAM呢？</font></p>
<h2 id="三、InnoDB和MyISAM对比"><a href="#三、InnoDB和MyISAM对比" class="headerlink" title="三、InnoDB和MyISAM对比"></a><strong><font style="color:black;">三、InnoDB和MyISAM对比</font></strong></h2><p><font style="color:black;">InnoDB和MyISAM是使用MySQL时最常用的两种引擎类型，我们重点来看下两者区别。</font></p>
<h3 id="3-1-事务和外键"><a href="#3-1-事务和外键" class="headerlink" title="3.1 事务和外键"></a><font style="color:black;">3.1 事务和外键</font></h3><ul>
<li><font style="color:rgb(1, 1, 1);">InnoDB支持事务和外键，具有安全性和完整性，适合大量insert或update操作</font></li>
<li><font style="color:rgb(1, 1, 1);">MyISAM不支持事务和外键，它提供高速存储和检索，适合大量的select查询操作</font></li>
</ul>
<h3 id="3-2-锁机制"><a href="#3-2-锁机制" class="headerlink" title="3.2 锁机制"></a><font style="color:black;">3.2 锁机制</font></h3><ul>
<li><font style="color:rgb(1, 1, 1);">InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现。</font></li>
<li><font style="color:rgb(1, 1, 1);">MyISAM支持表级锁，锁定整张表。</font></li>
</ul>
<h3 id="3-3-索引结构"><a href="#3-3-索引结构" class="headerlink" title="3.3 索引结构"></a><font style="color:black;">3.3 索引结构</font></h3><ul>
<li><font style="color:black;">InnoDB使用聚集索引（聚簇索引），索引和记录在一起存储，既缓存索引，也缓存记录。</font></li>
</ul>
<p><font style="color:black;">InnoDB中叶子结点中直接存储的是索引对应的数据，如下图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641531088-1d65d569-18f6-4a7e-b6bf-f4f78981ac37.webp"></p>
<ul>
<li><font style="color:black;">MyISAM使用非聚集索引（非聚簇索引），索引和记录分开。</font></li>
</ul>
<p><font style="color:black;">MyISAM中叶节点的data域存放的是数据记录的地址，如下图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717641531188-1fb960a3-7c38-424d-b653-88096826e3ce.webp"></p>
<h3 id="3-4-并发处理能力"><a href="#3-4-并发处理能力" class="headerlink" title="3.4 并发处理能力"></a><font style="color:black;">3.4 并发处理能力</font></h3><ul>
<li><font style="color:rgb(1, 1, 1);">MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞。</font></li>
<li><font style="color:rgb(1, 1, 1);">InnoDB读写阻塞可以与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发</font></li>
</ul>
<h3 id="3-5-存储文件"><a href="#3-5-存储文件" class="headerlink" title="3.5 存储文件"></a><font style="color:black;">3.5 存储文件</font></h3><ul>
<li><font style="color:rgb(1, 1, 1);">InnoDB表对应两个文件，一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；</font></li>
<li><font style="color:rgb(1, 1, 1);">MyISAM表对应三个文件，一个.frm表结构文件，一个MYD表数据文件，一个.MYI索引文件。从MySQL5.0开始默认限制是256TB。</font></li>
</ul>
<h3 id="3-6-适用场景"><a href="#3-6-适用场景" class="headerlink" title="3.6 适用场景"></a><font style="color:black;">3.6 适用场景</font></h3><ul>
<li><strong><font style="color:rgb(145, 109, 213);">「MyISAM」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">不需要事务支持（不支持）</font></li>
<li><font style="color:rgb(1, 1, 1);">并发相对较低（锁定机制问题）</font></li>
<li><font style="color:rgb(1, 1, 1);">数据修改相对较少，以读为主</font></li>
<li><font style="color:rgb(1, 1, 1);">数据一致性要求不高</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(145, 109, 213);">「InnoDB」</font></strong><ul>
<li><font style="color:rgb(1, 1, 1);">需要事务支持（具有较好的事务特性）</font></li>
<li><font style="color:rgb(1, 1, 1);">行级锁定对高并发有很好的适应能力</font></li>
<li><font style="color:rgb(1, 1, 1);">数据更新较为频繁的场景</font></li>
<li><font style="color:rgb(1, 1, 1);">数据一致性要求较高</font></li>
<li><font style="color:rgb(1, 1, 1);">硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO</font></li>
</ul>
</li>
</ul>
<h2 id="四、InnoDB与MyISAM如何选择"><a href="#四、InnoDB与MyISAM如何选择" class="headerlink" title="四、InnoDB与MyISAM如何选择"></a><strong><font style="color:black;">四、InnoDB与MyISAM如何选择</font></strong></h2><ul>
<li><font style="color:rgb(1, 1, 1);">需要事务选择InnoDB</font></li>
<li><font style="color:rgb(1, 1, 1);">存在并发修改选择InnoDB</font></li>
<li><font style="color:rgb(1, 1, 1);">追求快速查询，且数据修改少，选择MyISAM</font></li>
<li><font style="color:rgb(1, 1, 1);">在绝大多数情况下，推荐使用InnoDB</font></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>慢查询优化</title>
    <url>/2024/07/15/%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="索引和慢查询"><a href="#索引和慢查询" class="headerlink" title="索引和慢查询"></a><font style="color:rgb(34, 34, 34);">索引和慢查询</font></h3><p>慢查询的定义：</p>
<p><font style="color:rgb(34, 34, 34);">主要依据SQL语句的执行时间，它把当前语句的执行时间跟long_query_time 参数做比较，如果语句的执行时间 &gt; long_query_time，就会把这条执行语句记录到慢查询日志里面。long_query_time 参数的默认值是 10s，该参数值可以根据自己的业务需要进行调整。</font></p>
<p><font style="color:rgb(34, 34, 34);">判断是否应用了索引：</font></p>
<p><font style="color:rgb(34, 34, 34);">通过 explain命令分析查看，检查结果中的 key 值，是否为NULL。</font></p>
<span id="more"></span>
<h3 id="提高索引过滤性"><a href="#提高索引过滤性" class="headerlink" title="提高索引过滤性"></a><font style="color:rgb(34, 34, 34);">提高索引过滤性</font></h3><p><font style="color:rgb(34, 34, 34);">假如有一个5000万记录的用户表，通过sex&#x3D;’男’索引过滤后，还需要定位3000万，SQL执行速度也不会很快。其实这个问题涉及到索引的过滤性，比如1万条记录利用索引过滤后定位10条、100条、1000条，那他们过滤性是不同的。索引过滤性与索引字段、表的数据量、表设计结构都有关系。</font></p>
<h3 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a><font style="color:rgb(34, 34, 34);">分页查询优化</font></h3><p><font style="color:rgb(34, 34, 34);">在查询记录时，如果查询记录量相同，偏移量超过100后就开始随着偏移量增大，查询时间急剧的增加。（这种分页查询机制，每次都会从数据库第一条记录开始扫描，越往后查询越慢，而且查询的数据越多，也会拖慢总查询速度。）这时候有几个优化方法</font></p>
<h4 id="利用覆盖索引优化"><a href="#利用覆盖索引优化" class="headerlink" title="利用覆盖索引优化"></a><font style="color:rgb(34, 34, 34);">利用覆盖索引优化</font></h4><p>在书写sql语句的时候不要写</p>
<p>select * from table</p>
<p>使用索引内部的字段</p>
<p><strong><font style="color:rgb(34, 34, 34);">利用子查询优化</font></strong></p>
<p><font style="color:rgb(0, 0, 0);">select</font> <font style="color:rgb(152, 26, 26);">*</font> <font style="color:rgb(0, 0, 0);">from</font> <font style="color:rgb(0, 0, 0);">user</font> <font style="color:rgb(0, 0, 0);">where</font> <font style="color:rgb(0, 0, 0);">id</font><font style="color:rgb(152, 26, 26);">&gt;&#x3D;</font> (<font style="color:rgb(0, 0, 0);">select</font> <font style="color:rgb(0, 0, 0);">id</font> <font style="color:rgb(0, 0, 0);">from</font> <font style="color:rgb(0, 0, 0);">user</font> <font style="color:rgb(0, 0, 0);">limit</font> <font style="color:rgb(17, 102, 68);">10000</font>,<font style="color:rgb(17, 102, 68);">1</font>) <font style="color:rgb(0, 0, 0);">limit</font> <font style="color:rgb(17, 102, 68);">100</font>;</p>
<p><strong><font style="color:rgb(34, 34, 34);"></font></strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>主备复制</title>
    <url>/2024/07/15/%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-复制简介"><a href="#1-复制简介" class="headerlink" title="1 复制简介"></a>1 复制简介</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制是指：将主库的DDL、DML等操作通过binlog日志，传输到复制服务器（副本），副本进行回放这些日志，从而使得从库和主库数据保持&lt;近似&gt;同步的工作模式。</span><br><span class="line">复制架构: </span><br><span class="line">（1）传统异步：1主1从、1主多从、级联主从、双主</span><br><span class="line">（2）演变：(增强)半同步、过滤、延时、GTID、MTS(多SQL线程并发回放relaylog)</span><br><span class="line">（3）新型：多源复制（5.7+支持）</span><br><span class="line">（4）MGR：5.7.17+支持、8.0增强（WS:WriteSets）</span><br><span class="line">复制主要应用场景：</span><br><span class="line">	1. 备份</span><br><span class="line">	2. 高可用</span><br><span class="line">	3. 读写分离</span><br><span class="line">	4. 分布式架构</span><br><span class="line">	5. 迁移</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="2-主从复制前提"><a href="#2-主从复制前提" class="headerlink" title="2 主从复制前提"></a>2 主从复制前提</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. 2台以上的MySQL实例(同版本、同平台),具备不同的server_id,server_uuid</span><br><span class="line">b. 主库&quot;开启binlog, 创建复制用户。</span><br><span class="line">c. “补课”： 备份主库数据，恢复到从库.</span><br><span class="line">	mysqldump</span><br><span class="line">	pxb</span><br><span class="line">	Clone Plugin</span><br><span class="line">d. 告知从库复制的信息：change master to user,password, ip ,port, filename、pos (gtid)</span><br><span class="line">e. 让他干活 ： 启动线程 </span><br><span class="line">f. 查看复制状态</span><br></pre></td></tr></table></figure>

<h1 id="3-主从复制花式构建方法"><a href="#3-主从复制花式构建方法" class="headerlink" title="3 主从复制花式构建方法"></a>3 主从复制花式构建方法</h1><h2 id="3-0-准备初始环境"><a href="#3-0-准备初始环境" class="headerlink" title="3.0 准备初始环境"></a>3.0 准备初始环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 三台虚拟机</span><br><span class="line">10.0.0.51  db01</span><br><span class="line">10.0.0.52  db02</span><br><span class="line">10.0.0.53  db03</span><br><span class="line">防火墙关闭</span><br><span class="line"></span><br><span class="line">#清理环境： </span><br><span class="line">pkill mysqld</span><br><span class="line">rm -rf /data/3306/*</span><br><span class="line">mkdir -p /data/3306/data /data/3306/binlog</span><br><span class="line">chown -R mysql.mysql /data/*</span><br><span class="line"></span><br><span class="line"># 准备配置文件</span><br><span class="line">主库db01：</span><br><span class="line">mv /etc/my.cnf /tmp</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/data/3306/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=51</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">log_bin=/data/3306/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db01 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">slave1(db02)：</span><br><span class="line">mv /etc/my.cnf /tmp</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/data/3306/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=52</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">log_bin=/data/3306/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db02 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">slave2(db03)：</span><br><span class="line">mv /etc/my.cnf /tmp</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/usr/local/mysql </span><br><span class="line">datadir=/data/3306/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=53</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">log_bin=/data/3306/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line"></span><br><span class="line">log-slave-updates=1</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db03 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">初始化数据</span><br><span class="line">mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/3306/data </span><br><span class="line"></span><br><span class="line">启动数据库</span><br><span class="line">/etc/init.d/mysqld start</span><br></pre></td></tr></table></figure>



<h2 id="3-1-通过mysqldump（XBK）备份构建传统主从"><a href="#3-1-通过mysqldump（XBK）备份构建传统主从" class="headerlink" title="3.1 通过mysqldump（XBK）备份构建传统主从"></a>3.1 通过mysqldump（XBK）备份构建传统主从</h2><h3 id="a-各节点检查server-id、server-uuid、binlog"><a href="#a-各节点检查server-id、server-uuid、binlog" class="headerlink" title="a.各节点检查server_id、server_uuid、binlog"></a>a.各节点检查server_id、server_uuid、binlog</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e &quot;select @@server_id; select @@server_uuid;show variables like &#x27;log_bin%&#x27;;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="b-主库（51）创建复制用户和远程管理用户"><a href="#b-主库（51）创建复制用户和远程管理用户" class="headerlink" title="b.主库（51）创建复制用户和远程管理用户"></a>b.主库（51）创建复制用户和远程管理用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e &quot;create user repl@&#x27;10.0.0.%&#x27; identified with mysql_native_password by &#x27;123&#x27;;grant replication slave on *.* to repl@&#x27;10.0.0.%&#x27;;&quot;</span><br><span class="line">mysql -e &quot;create user root@&#x27;10.0.0.%&#x27; identified with mysql_native_password by &#x27;123&#x27;;grant all on *.* to root@&#x27;10.0.0.%&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">[root@db01 app]# mysql -e &quot;select user,host,plugin from mysql.user;&quot;</span><br><span class="line">+------------------+-----------+-----------------------+</span><br><span class="line">| user             | host      | plugin                |</span><br><span class="line">+------------------+-----------+-----------------------+</span><br><span class="line">| repl             | 10.0.0.%  | mysql_native_password |</span><br><span class="line">| root             | 10.0.0.%  | mysql_native_password |</span><br><span class="line">| mysql.infoschema | localhost | caching_sha2_password |</span><br><span class="line">| mysql.session    | localhost | caching_sha2_password |</span><br><span class="line">| mysql.sys        | localhost | caching_sha2_password |</span><br><span class="line">| root             | localhost | caching_sha2_password |</span><br></pre></td></tr></table></figure>

<h3 id="c-从库备份主库数据，并恢复。"><a href="#c-从库备份主库数据，并恢复。" class="headerlink" title="c.从库备份主库数据，并恢复。"></a>c.从库备份主库数据，并恢复。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@db02 data]# mysqldump -uroot -p123 -h 10.0.0.51 -P 3306 -A --master-data=2 --single-transaction -R -E --triggers &gt;/tmp/full.sql</span><br><span class="line">db02 [mysql]&gt;source /tmp/full.sql</span><br><span class="line"></span><br><span class="line">课后练习：</span><br><span class="line">通过pxb方式构建主从。</span><br></pre></td></tr></table></figure>

<h3 id="d-启动主从复制"><a href="#d-启动主从复制" class="headerlink" title="d. 启动主从复制"></a>d. 启动主从复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取复制起点</span><br><span class="line">[root@db02 data]# grep  &quot;\--\ CHANGE MASTER&quot; /tmp/full.sql </span><br><span class="line">-- CHANGE MASTER TO MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;, MASTER_LOG_POS=1187;</span><br><span class="line"></span><br><span class="line">[root@db02 data]# mysql -e \</span><br><span class="line">&quot;CHANGE MASTER TO \</span><br><span class="line">  MASTER_HOST=&#x27;10.0.0.51&#x27;,\</span><br><span class="line">  MASTER_USER=&#x27;repl&#x27;, \</span><br><span class="line">  MASTER_PASSWORD=&#x27;123&#x27;, \</span><br><span class="line">  MASTER_PORT=3306, \</span><br><span class="line">  MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;, \</span><br><span class="line">  MASTER_LOG_POS=1187, \</span><br><span class="line">  MASTER_CONNECT_RETRY=10;&quot;</span><br><span class="line">[root@db02 data]# mysql -e &quot;start slave;&quot;</span><br><span class="line">[root@db02 data]# mysql -e &quot;show slave status \G&quot;|grep &quot;Running:&quot;</span><br><span class="line">            Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>

<h2 id="3-2-新姿势-通过Clone-plugin搭建传统和GTID主从"><a href="#3-2-新姿势-通过Clone-plugin搭建传统和GTID主从" class="headerlink" title="3.2 新姿势-通过Clone-plugin搭建传统和GTID主从"></a>3.2 新姿势-通过Clone-plugin搭建传统和GTID主从</h2><h3 id="a-主库操作"><a href="#a-主库操作" class="headerlink" title="a. 主库操作"></a>a. 主库操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e &quot;INSTALL PLUGIN clone SONAME &#x27;mysql_clone.so&#x27;;create user test1@&#x27;%&#x27; identified by &#x27;123&#x27;;grant backup_admin on *.* to test1@&#x27;%&#x27;;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="b-从库操作"><a href="#b-从库操作" class="headerlink" title="b. 从库操作"></a>b. 从库操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@db03 data]# mysql -e &quot;INSTALL PLUGIN clone SONAME &#x27;mysql_clone.so&#x27;;create user test2@&#x27;%&#x27; identified by &#x27;123&#x27;;grant clone_admin on *.* to test2@&#x27;%&#x27;;SET GLOBAL clone_valid_donor_list=&#x27;10.0.0.51:3306&#x27;;&quot;</span><br><span class="line">[root@db03 data]# mysql -utest2 -p123 -h10.0.0.53  -P3306 -e &quot;CLONE INSTANCE FROM test1@&#x27;10.0.0.51&#x27;:3306 IDENTIFIED BY &#x27;123&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">[root@db03 data]# mysql -e &quot;SELECT BINLOG_FILE, BINLOG_POSITION FROM performance_schema.clone_status;&quot;</span><br><span class="line"></span><br><span class="line">[root@db03 data]# mysql -e &quot;SELECT BINLOG_FILE, BINLOG_POSITION FROM performance_schema.clone_status;&quot;</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| BINLOG_FILE      | BINLOG_POSITION |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| mysql-bin.000002 |            1714 |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line"></span><br><span class="line">注： 如果GTID复制查看: </span><br><span class="line">[root@db03 data]# mysql -e &quot;SELECT @@GLOBAL.GTID_EXECUTED;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="c-启动主从复制"><a href="#c-启动主从复制" class="headerlink" title="c. 启动主从复制"></a>c. 启动主从复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@db03 data]# mysql -e \</span><br><span class="line">&quot;CHANGE MASTER TO \</span><br><span class="line">  MASTER_HOST=&#x27;10.0.0.51&#x27;,\</span><br><span class="line">  MASTER_USER=&#x27;repl&#x27;, \</span><br><span class="line">  MASTER_PASSWORD=&#x27;123&#x27;, \</span><br><span class="line">  MASTER_PORT=3306, \</span><br><span class="line">  MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;, \</span><br><span class="line">  MASTER_LOG_POS=1717, \</span><br><span class="line">  MASTER_CONNECT_RETRY=10;&quot;</span><br><span class="line">[root@db03 data]# mysql -e &quot;start slave;&quot;</span><br><span class="line">[root@db03 data]# mysql -e &quot;show slave status \G&quot;|grep &quot;Running:&quot;</span><br><span class="line">            Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes            </span><br><span class="line">注： GTID方式</span><br><span class="line">[root@db03 data]# mysql -e \</span><br><span class="line">&quot;CHANGE MASTER TO \</span><br><span class="line">  MASTER_HOST=&#x27;10.0.0.51&#x27;,\</span><br><span class="line">  MASTER_USER=&#x27;repl&#x27;, \</span><br><span class="line">  MASTER_PASSWORD=&#x27;123&#x27;, \</span><br><span class="line">  MASTER_PORT=3306, \</span><br><span class="line">  MASTER_AUTO_POSITION=1;&quot;</span><br><span class="line">[root@db03 data]# mysql -e &quot;start slave;&quot;</span><br><span class="line">[root@db03 data]# mysql -e &quot;show slave status \G&quot;|grep &quot;Running:&quot;</span><br><span class="line">            Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>

<h3 id="3-3-传统复制和GTID转换"><a href="#3-3-传统复制和GTID转换" class="headerlink" title="3.3 传统复制和GTID转换"></a>3.3 传统复制和GTID转换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局唯一的ID号。 49a40a92-83d7-11eb-b567-000c2956311f:1-7</span><br></pre></td></tr></table></figure>

<h3 id="a-查看当前状态"><a href="#a-查看当前状态" class="headerlink" title="a. 查看当前状态"></a>a. 查看当前状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@db01 app]# mysql -e &quot;select @@enforce_gtid_consistency;&quot;</span><br><span class="line">+----------------------------+</span><br><span class="line">| @@enforce_gtid_consistency |</span><br><span class="line">+----------------------------+</span><br><span class="line">| OFF                        |</span><br><span class="line">+----------------------------+</span><br><span class="line">[root@db01 app]# mysql -e &quot;select @@gtid_mode;&quot;</span><br><span class="line">+-------------+</span><br><span class="line">| @@gtid_mode |</span><br><span class="line">+-------------+</span><br><span class="line">| OFF         |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<h3 id="b-修改enforce-gtid-consistency"><a href="#b-修改enforce-gtid-consistency" class="headerlink" title="b. 修改enforce_gtid_consistency"></a>b. 修改enforce_gtid_consistency</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@db01 data]# mysql -e &quot;set global enforce_gtid_consistency =warn;&quot;</span><br><span class="line">[root@db02 data]# mysql -e &quot;set global enforce_gtid_consistency =warn;&quot;</span><br><span class="line">[root@db03 data]# mysql -e &quot;set global enforce_gtid_consistency =warn;&quot;</span><br><span class="line">注意： </span><br><span class="line">	所有节点均先将其修改为 WARN,同时注意查看日志是否出现警告信息，生产环境想调整为GTID模式时，需提前一段时间调整此参数，观察一段时间，确定无警告后再调整。</span><br><span class="line">	开启后观察数据库日志，只有在无警告的情况下才可以进行下一步的操作。</span><br></pre></td></tr></table></figure>

<h3 id="c-修改enforce-gtid-consistency-x3D-on"><a href="#c-修改enforce-gtid-consistency-x3D-on" class="headerlink" title="c. 修改enforce_gtid_consistency &#x3D; on"></a>c. 修改enforce_gtid_consistency &#x3D; on</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e &quot;set global enforce_gtid_consistency = on;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="d-修改gtid-mode-x3D-off-permissive"><a href="#d-修改gtid-mode-x3D-off-permissive" class="headerlink" title="d. 修改gtid_mode &#x3D; off_permissive"></a>d. 修改gtid_mode &#x3D; off_permissive</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e &quot;set global gtid_mode = off_permissive;&quot;</span><br><span class="line">生成新的事务为匿名事务，同时允许复制的事务为匿名和GTID的。</span><br></pre></td></tr></table></figure>

<h3 id="e-修改gtid-mode-x3D-on-permissive"><a href="#e-修改gtid-mode-x3D-on-permissive" class="headerlink" title="e.修改gtid_mode&#x3D;on_permissive"></a>e.修改gtid_mode&#x3D;on_permissive</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e &quot;set global gtid_mode=on_permissive;&quot;</span><br><span class="line">生成新的事务使用GTID，同时允许复制的事务为匿名和GTID的。</span><br></pre></td></tr></table></figure>

<h3 id="f-各从节点检查剩余事务数"><a href="#f-各从节点检查剩余事务数" class="headerlink" title="f. 各从节点检查剩余事务数"></a>f. 各从节点检查剩余事务数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e  &quot;show status like &#x27;ongoing_anonymous_transaction_count&#x27;;&quot;</span><br><span class="line">表示标记为匿名正在运行的事务数量。置0后执行下一步。</span><br><span class="line">mysql -e  &quot;flush logs;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="g-启用gtid-mode"><a href="#g-启用gtid-mode" class="headerlink" title="g. 启用gtid_mode"></a>g. 启用gtid_mode</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e  &quot;set global gtid_mode=on;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="h-从库切换复制模式"><a href="#h-从库切换复制模式" class="headerlink" title="h. 从库切换复制模式"></a>h. 从库切换复制模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -e &quot;stop slave; change master to master_auto_position=1;start slave;&quot;</span><br><span class="line">mysql -e &quot;show slave status \G&quot;</span><br></pre></td></tr></table></figure>

<h3 id="i-修改配置文件永久生效"><a href="#i-修改配置文件永久生效" class="headerlink" title="i. 修改配置文件永久生效"></a>i. 修改配置文件永久生效</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br></pre></td></tr></table></figure>

<h1 id="4-异步（传统、GTID）复制工作原理"><a href="#4-异步（传统、GTID）复制工作原理" class="headerlink" title="4 异步（传统、GTID）复制工作原理"></a>4 异步（传统、GTID）复制工作原理</h1><h2 id="4-1-传统"><a href="#4-1-传统" class="headerlink" title="4.1 传统"></a>4.1 传统</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661873940324-7f7cd184-4c8c-4bc0-aae5-25605a867043.png"></p>
<h2 id="4-2-GTID在复制中改变"><a href="#4-2-GTID在复制中改变" class="headerlink" title="4.2 GTID在复制中改变"></a>4.2 GTID在复制中改变</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gtid格式 ：</span><br><span class="line">server_uuid:seq</span><br><span class="line">a. MASTER 发生事务,生成GTID,记录binlog。</span><br><span class="line">b. slave 根据gtid_next请求下一个GTID的事件。</span><br><span class="line">c. Master 发送 binlog到SLAVE.</span><br><span class="line">d. slave 接收二进制日志，存储至relaylog，读取gtid信息并设置gtid_next值。</span><br><span class="line">e. slave SQL 回放GTID事务。</span><br><span class="line">	1. 检测本地binlog是否有该GTID</span><br><span class="line">	2. 应用事务，并更新本地binlog(log_slave_updates)</span><br><span class="line">注： </span><br><span class="line">已执行的gtid信息更新至mysql.gtid_executed表中，并定期进行压缩。（reset master 会清空此表）</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661960590057-924046bf-663f-48cc-a567-7d53dbf51130.png"></p>
<h1 id="5-半同步、增强半同步复制工作原理"><a href="#5-半同步、增强半同步复制工作原理" class="headerlink" title="5 半同步、增强半同步复制工作原理"></a>5 半同步、增强半同步复制工作原理</h1><h2 id="5-0-预备知识–2PC-及-group-commit"><a href="#5-0-预备知识–2PC-及-group-commit" class="headerlink" title="5.0 预备知识–2PC 及 group commit"></a>5.0 预备知识–2PC 及 group commit</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#a. 2PC机制</span><br><span class="line">	客户端下发commit命令，此时进入真正的两阶段提交，两阶段提交分为prepare和commit两个阶段</span><br><span class="line">## prepare阶段： </span><br><span class="line">	prepare分为binlog prepare和innobase redo prepare,其中binlog prepare几乎不做操作，innobase prepare会更新事务状态。</span><br><span class="line"></span><br><span class="line"># commit阶段：</span><br><span class="line">	commit阶段被分为了三个阶段，分别是flush，sync，commit。其中 flush操作会进行线程binlog cache的文件写入，再将用户binlog cache刷新到文件；sync操作负责binlog的落盘；commit操作负责更新server层的最大事务提交数量(和并行复制相关),然后innobase 再次更新事务状态。提交结束。</span><br><span class="line"></span><br><span class="line">#b. group commit流程： </span><br><span class="line">## FLUSH 阶段：</span><br><span class="line">1)      持有Lock_log mutex [leader持有，follower等待]</span><br><span class="line">2)      获取队列中的一组binlog(队列中的所有事务)</span><br><span class="line">3)      将binlog buffer到OS cache</span><br><span class="line">4)      通知dump线程dump binlog</span><br><span class="line"></span><br><span class="line">## SYNC阶段</span><br><span class="line">1)      释放Lock_log mutex，持有Lock_sync mutex[leader持有，follower等待]</span><br><span class="line">2)      将一组binlog 落盘(sync动作，最耗时，假设sync_binlog为1)</span><br><span class="line"></span><br><span class="line">## COMMIT阶段</span><br><span class="line">1)      释放Lock_sync mutex，持有Lock_commit mutex[leader持有，follower等待]</span><br><span class="line">2)      遍历队列中的事务，逐一进行innodb commit</span><br><span class="line">3)      释放Lock_commit mutex</span><br><span class="line">4)      唤醒队列中等待的线程</span><br><span class="line"></span><br><span class="line">配套参数：</span><br><span class="line">binlog_group_commit_sync_no_delay_count=N</span><br><span class="line">binlog_group_commit_sync_delay=M</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661960761551-19811b64-a47a-40d8-8884-a09162eb68a4.png"></p>
<h2 id="5-1-半同步复制-after-commit"><a href="#5-1-半同步复制-after-commit" class="headerlink" title="5.1 半同步复制(after_commit)"></a>5.1 半同步复制(after_commit)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AFTER_COMMIT: The master writes each transaction to its binary log and the slave, syncs the binary log, and commits the transaction to the storage engine. The master waits for slave acknowledgment of transaction receipt after the commit. Upon receiving acknowledgment, the master returns a result to the client, which then can proceed.</span><br></pre></td></tr></table></figure>

<h2 id="5-2-增强半同步-after-sync"><a href="#5-2-增强半同步-after-sync" class="headerlink" title="5.2 增强半同步(after_sync)"></a>5.2 增强半同步(after_sync)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AFTER_SYNC (the default): The master writes each transaction to its binary log and the slave, and syncs the binary log to disk. The master waits for slave acknowledgment of transaction receipt after the sync. Upon receiving acknowledgment, the master commits the transaction to the storage engine and returns a result to the client, which then can proceed.</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661960812807-04c737c8-e978-4f1d-ad4a-6437f6b342c5.png"></p>
<h1 id="5-主从复制故障监控、原因分析、处理方案"><a href="#5-主从复制故障监控、原因分析、处理方案" class="headerlink" title="5 主从复制故障监控、原因分析、处理方案"></a>5 主从复制故障监控、原因分析、处理方案</h1><h2 id="5-1-主从复制监控方式"><a href="#5-1-主从复制监控方式" class="headerlink" title="5.1 主从复制监控方式"></a>5.1 主从复制监控方式</h2><h3 id="5-1-1-主库监控"><a href="#5-1-1-主库监控" class="headerlink" title="5.1.1 主库监控"></a>5.1.1 主库监控</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@db01 data]# mysql  -e &quot;show processlist&quot; |grep &quot;Dump&quot;</span><br><span class="line">7	repl	db01:34640	NULL	Binlog Dump	5355	Master has sent all binlog to slave; waiting for more updates	NULL</span><br><span class="line">9	repl	db01:34642	NULL	Binlog Dump	687	Master has sent all binlog to slave; waiting for more updates	NULL</span><br><span class="line"></span><br><span class="line">[root@db01 data]# mysql  -e &quot;show slave hosts;&quot;</span><br><span class="line">+-----------+----------------+------+-----------+--------------------------------------+</span><br><span class="line">| Server_id | Host           | Port | Master_id | Slave_UUID                           |</span><br><span class="line">+-----------+----------------+------+-----------+--------------------------------------+</span><br><span class="line">|        53 | 10.0.0.53:3306 | 3306 |        51 | af1c4368-c31a-11ea-9078-000c29a5e781 |</span><br><span class="line">|        52 | 10.0.0.52:3306 | 3306 |        51 | ac703788-c31a-11ea-a322-000c29f2d9fe |</span><br><span class="line">+-----------+----------------+------+-----------+--------------------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-从库监控"><a href="#5-1-2-从库监控" class="headerlink" title="5.1.2 从库监控"></a>5.1.2 从库监控</h3><h4 id="a-主库连接信息、binlog位置信息"><a href="#a-主库连接信息、binlog位置信息" class="headerlink" title="a. 主库连接信息、binlog位置信息"></a>a. 主库连接信息、binlog位置信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@db01 data]# mysql -e &quot;show slave status \G&quot;</span><br><span class="line">Master_Host: 10.0.0.51</span><br><span class="line">Master_User: repl</span><br><span class="line">Master_Port: 3306</span><br><span class="line">Connect_Retry: 10</span><br><span class="line">Master_Log_File: mysql-bin.000006</span><br><span class="line">Read_Master_Log_Pos: 341</span><br></pre></td></tr></table></figure>

<h4 id="b-从库中relay-log的回放信息"><a href="#b-从库中relay-log的回放信息" class="headerlink" title="b. 从库中relay-log的回放信息"></a>b. 从库中relay-log的回放信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Relay_Log_File: db02-relay-bin.000004</span><br><span class="line">Relay_Log_Pos: 458</span><br><span class="line">Relay_Master_Log_File: mysql-bin.000006</span><br><span class="line">Exec_Master_Log_Pos: 341</span><br></pre></td></tr></table></figure>

<h4 id="c-线程监控信息：主要用来排查主从故障"><a href="#c-线程监控信息：主要用来排查主从故障" class="headerlink" title="c. 线程监控信息：主要用来排查主从故障"></a>c. 线程监控信息：主要用来排查主从故障</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br><span class="line">Last_IO_Errno: 0</span><br><span class="line">Last_IO_Error: </span><br><span class="line">Last_SQL_Errno: 0</span><br><span class="line">Last_SQL_Error:</span><br></pre></td></tr></table></figure>

<h4 id="d-过滤复制相关信息"><a href="#d-过滤复制相关信息" class="headerlink" title="d. 过滤复制相关信息"></a>d. 过滤复制相关信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Replicate_Do_DB: </span><br><span class="line">Replicate_Ignore_DB: </span><br><span class="line">Replicate_Do_Table: </span><br><span class="line">Replicate_Ignore_Table: </span><br><span class="line">Replicate_Wild_Do_Table: </span><br><span class="line">Replicate_Wild_Ignore_Table:</span><br></pre></td></tr></table></figure>

<h4 id="e-落后于主库的秒数"><a href="#e-落后于主库的秒数" class="headerlink" title="e. 落后于主库的秒数"></a>e. 落后于主库的秒数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Seconds_Behind_Master: 0</span><br></pre></td></tr></table></figure>

<h4 id="f-延时从库状态信息"><a href="#f-延时从库状态信息" class="headerlink" title="f. 延时从库状态信息"></a>f. 延时从库状态信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL_Delay: 0</span><br><span class="line">SQL_Remaining_Delay: NULL</span><br></pre></td></tr></table></figure>

<h4 id="g-GTID复制信息"><a href="#g-GTID复制信息" class="headerlink" title="g. GTID复制信息"></a>g. GTID复制信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Retrieved_Gtid_Set: </span><br><span class="line">Executed_Gtid_Set: </span><br><span class="line">Auto_Position: 0</span><br></pre></td></tr></table></figure>

<h4 id="h-一堆pos-功能"><a href="#h-一堆pos-功能" class="headerlink" title="h. 一堆pos 功能"></a>h. 一堆pos 功能</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） IO 已经获取到的主库Binlog的位置点（master.info）</span><br><span class="line">Master_Log_File: mysql-bin.000001</span><br><span class="line">Read_Master_Log_Pos: 444</span><br><span class="line">作用： IO下次请求日志时，起点位置。</span><br><span class="line"></span><br><span class="line">（2） SQL 回放到的relaylog位置点。(relay-log.info)</span><br><span class="line">Relay_Log_File: db01-relay-bin.000006</span><br><span class="line">Relay_Log_Pos: 320</span><br><span class="line"></span><br><span class="line">（3）SQL回放的realylog位置点，对应的主库binlog的位置点(relay-log.info)</span><br><span class="line">Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">Exec_Master_Log_Pos: 600</span><br><span class="line">作用： 计算主从复制延时日志量。</span><br></pre></td></tr></table></figure>

<h2 id="5-2-主从故障分析及处理"><a href="#5-2-主从故障分析及处理" class="headerlink" title="5.2 主从故障分析及处理"></a>5.2 主从故障分析及处理</h2><h3 id="5-2-1-如何监控"><a href="#5-2-1-如何监控" class="headerlink" title="5.2.1 如何监控"></a>5.2.1 如何监控</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何监控 </span><br><span class="line">[root@db01 data]# mysql -S /tmp/mysql3308.sock -e &quot;show slave status \G&quot;</span><br><span class="line">Slave_IO_Running: Yes                # IO线程工作状态： YES、NO、Connecting  </span><br><span class="line">Slave_SQL_Running: Yes               # SQL线程工作状态：YES、NO</span><br><span class="line">Last_IO_Errno: 0                     # IO故障代码：2003,1045,1040,1593,1236...</span><br><span class="line">Last_IO_Error:                       # IO线程报错详细信息  </span><br><span class="line">Last_SQL_Errno: 0                    # SQL故障代码：1008，1007，1032，1062..</span><br><span class="line">Last_SQL_Error:                      # IO线程报错详细信息</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-IO线程故障"><a href="#5-2-2-IO线程故障" class="headerlink" title="5.2.2 IO线程故障"></a>5.2.2 IO线程故障</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. 连接主库失败 </span><br><span class="line">user,password,IP,Port,plugin</span><br><span class="line">主库无法连接：网络、宕机、防护墙、最大连接数上限</span><br><span class="line">故障模拟： </span><br><span class="line">(1)主库宕机 </span><br><span class="line"> systemctl stop mysqld3307 </span><br><span class="line"> show slave status\G </span><br><span class="line"> 还原: </span><br><span class="line"> systemctl start mysqld3307 </span><br><span class="line"> mysql -S /tmp/mysql3308.sock  -e &quot;start slave;&quot; </span><br><span class="line">(2) 模拟用户密码错误</span><br><span class="line">  mysql  -e &quot;alter user repl@&#x27;10.0.0.%&#x27; identified by &#x27;11212&#x27;&quot;</span><br><span class="line">  mysql   -e &quot;start slave;  show slave status\G &quot; </span><br><span class="line"> 还原： </span><br><span class="line">   mysql  -e &quot;alter user repl@&#x27;10.0.0.%&#x27; identified by &#x27;123&#x27;&quot; </span><br><span class="line">   mysql  -e &quot;start slave;  show slave status\G &quot; </span><br><span class="line"> </span><br><span class="line">(3) 连接数上限</span><br><span class="line"> mysql -e &quot; set global max_connections=2;&quot; </span><br><span class="line"> mysql </span><br><span class="line"> mysql </span><br><span class="line"> mysql  -e &quot;stop slave; start slave;  show slave status\G &quot; </span><br><span class="line"> 还原：  </span><br><span class="line"> mysql   -e &quot; set global max_connections=200;&quot; </span><br><span class="line"> mysql -e &quot;stop slave; start slave;  show slave status\G &quot; </span><br><span class="line"></span><br><span class="line">通用排查方法： </span><br><span class="line">[root@db01 ~]# mysql -urepl -p123 -h 10.0.0.51 -P 3300</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;10.0.0.51&#x27; (111)</span><br><span class="line">[root@db01 ~]# mysql -urepl -p123 -h 10.0.0.52 -P 3307</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;10.0.0.52&#x27; (113)</span><br><span class="line">[root@db01 ~]# mysql -urepla -p123 -h 10.0.0.51 -P 3307</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1045 (28000): Access denied for user &#x27;repla&#x27;@&#x27;db01&#x27; (using password: YES)</span><br><span class="line">[root@db01 ~]# mysql -urepl -p1123 -h 10.0.0.51 -P 3307</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1045 (28000): Access denied for user &#x27;repl&#x27;@&#x27;db01&#x27; (using password: YES)</span><br><span class="line">[root@db01 ~]# </span><br><span class="line"></span><br><span class="line">b. 主从信息交换</span><br><span class="line">主从的server_id、Server_uuid、相同。</span><br><span class="line">版本不兼容（低到高可以、高到低不行、跨太多版本也不行）。</span><br><span class="line"># server_id 故障重现： </span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3307.sock</span><br><span class="line">mysql&gt; set global server_id=8;</span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3307.sock</span><br><span class="line">mysql&gt; select @@server_id;</span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3308.sock</span><br><span class="line">mysql&gt; stop slave;start slave;show slave status;</span><br><span class="line"></span><br><span class="line">回退： </span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3307.sock</span><br><span class="line">mysql&gt; set global server_id=7;</span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3307.sock</span><br><span class="line">mysql&gt; select @@server_id;</span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3308.sock</span><br><span class="line">mysql&gt; start slave;show slave status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c. 请求日志失败</span><br><span class="line">主库日志损坏、缺失。</span><br><span class="line"></span><br><span class="line"># 主库日志损坏故障重现：</span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3307.sock</span><br><span class="line">mysql&gt; reset master;</span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3308.sock</span><br><span class="line">mysql&gt; start slave;show slave status;</span><br><span class="line"></span><br><span class="line">测试环境处理方法（主从的数据当前是一致的）： </span><br><span class="line">[root@db01 ~]# mysql -S /tmp/mysql3308.sock</span><br><span class="line"># 将所有线程停止。</span><br><span class="line">mysql&gt; stop slave;                </span><br><span class="line"># 将从库复制信息清空（master.info,relay-log.info清空，show slave status看不到信息了）</span><br><span class="line">mysql&gt; reset slave all;  </span><br><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">  MASTER_HOST=&#x27;10.0.0.51&#x27;,</span><br><span class="line">  MASTER_USER=&#x27;repl&#x27;,</span><br><span class="line">  MASTER_PASSWORD=&#x27;123&#x27;,</span><br><span class="line">  MASTER_PORT=3307,</span><br><span class="line">  MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,</span><br><span class="line">  MASTER_LOG_POS=154,</span><br><span class="line">  MASTER_CONNECT_RETRY=10;</span><br><span class="line">mysql&gt; start slave;</span><br><span class="line"></span><br><span class="line">生产中需要额外考虑什么情景？</span><br><span class="line">需要重构主从：</span><br><span class="line">	  1. 备份恢复.</span><br><span class="line">	  2. change master to  ;    start slave</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-SQL线程故障"><a href="#5-2-3-SQL线程故障" class="headerlink" title="5.2.3 SQL线程故障"></a>5.2.3 SQL线程故障</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL线程主要工作： 回放relaylog中的日志事件，可以理解为后台执行SQL语句。</span><br><span class="line">a. realy-log 损坏。 </span><br><span class="line">处理方法： 重构。</span><br><span class="line">方法1： 备份主库+change master to + start slave;  </span><br><span class="line"></span><br><span class="line">方法2： 找到问题点+ change master + start slave;</span><br><span class="line">	思路： 如何找到问题位置点。</span><br><span class="line">		1. 找到SQL已经回放到什么位置了。</span><br><span class="line">		SQL回放的realylog位置点，对应的主库binlog的位置点(relay-log.info)</span><br><span class="line">		Relay_Log_File: db01-relay-bin.000006</span><br><span class="line">		Relay_Log_Pos: 320</span><br><span class="line">		----》 </span><br><span class="line">		2. 找到主库相应位置点：</span><br><span class="line">		Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">		Exec_Master_Log_Pos: 600</span><br><span class="line">        3.  change master to  mysql-bin.000001 600</span><br><span class="line"></span><br><span class="line">b. 执行SQL出问题？</span><br><span class="line">（1）主从节点配置不一样： 平台、版本、参数、SQL_MODE</span><br><span class="line">  调整成一致。</span><br><span class="line">（2）修改的对象不存在（库、表、用户）</span><br><span class="line"> 从库被写入了。 双主架构。异步方式主从，导致数据不一致。</span><br><span class="line">（3）创建的对象已存在（库、表、用户、约束冲突）</span><br><span class="line"> 从库被写入了。 双主架构。</span><br><span class="line"></span><br><span class="line">方法一：部分场景可以使用，只要保证数据以主库为准即可使用。</span><br><span class="line">stop slave; </span><br><span class="line">set global sql_slave_skip_counter = 1;</span><br><span class="line">#将同步指针向下移动一个，如果多次不同步，可以重复操作。</span><br><span class="line">start slave;</span><br><span class="line"></span><br><span class="line">方法二：不推荐</span><br><span class="line">/etc/my.cnf</span><br><span class="line">slave-skip-errors = 1032,1062,1007</span><br><span class="line"></span><br><span class="line">常见错误代码:</span><br><span class="line">1007:对象已存在</span><br><span class="line">1032:无法执行DML</span><br><span class="line">1062:主键冲突,或约束冲突</span><br><span class="line">pt-table-checksum  pt-table-sync</span><br><span class="line"></span><br><span class="line">c. GTID 处理错误方式： </span><br><span class="line">查看监控信息:</span><br><span class="line">Last_SQL_Error: Error &#x27;Can&#x27;t create database &#x27;oldboy&#x27;; database exists&#x27; on query. Default database: &#x27;oldboy&#x27;. Query: &#x27;create database oldboy&#x27;</span><br><span class="line"></span><br><span class="line">Retrieved_Gtid_Set: 71bfa52e-4aae-11e9-ab8c-000c293b577e:1-3</span><br><span class="line">Executed_Gtid_Set:  71bfa52e-4aae-11e9-ab8c-000c293b577e:1-2,</span><br><span class="line">7ca4a2b7-4aae-11e9-859d-000c298720f6:1</span><br><span class="line">注入空事物的方法：</span><br><span class="line">stop slave;</span><br><span class="line">set gtid_next=&#x27;99279e1e-61b7-11e9-a9fc-000c2928f5dd:3&#x27;;</span><br><span class="line">begin;commit;</span><br><span class="line">set gtid_next=&#x27;AUTOMATIC&#x27;;</span><br><span class="line">    </span><br><span class="line">这里的xxxxx:N 也就是你的slave sql thread报错的GTID，或者说是你想要跳过的GTID。</span><br><span class="line">最好的解决方案：重新构建主从环境</span><br><span class="line"></span><br><span class="line">d. 总结： SQL线程故障规避方法</span><br><span class="line">1. 从库只读 ，读写分离中间件。</span><br><span class="line">2. 不使用双主结构。PXC、MGR替代。</span><br><span class="line">3. 半同步、增强半同步复制等，或者PXC、MGR替代。</span><br><span class="line">4. 使用pt相关工具校验主从数据，并同步。</span><br></pre></td></tr></table></figure>

<h2 id="5-3-主从延时分析及处理"><a href="#5-3-主从延时分析及处理" class="headerlink" title="5.3 主从延时分析及处理"></a>5.3 主从延时分析及处理</h2><h3 id="5-3-1-监控方法"><a href="#5-3-1-监控方法" class="headerlink" title="5.3.1 监控方法"></a>5.3.1 监控方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法一： 有没有延时</span><br><span class="line">Seconds_Behind_Master: 0</span><br><span class="line"></span><br><span class="line">方法二： </span><br><span class="line">主库： </span><br><span class="line">mysql&gt; show master status ;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000004 |   151847 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">从库： </span><br><span class="line">[root@db01 data]# mysql   -e &quot;show slave status \G&quot;|grep &quot;Master_Log&quot;</span><br><span class="line">已经拿到的主库日志量(master.info)：判断传输有没有延时</span><br><span class="line">Master_Log_File: mysql-bin.000004</span><br><span class="line">Read_Master_Log_Pos: 151847</span><br><span class="line"></span><br><span class="line">已经执行的主库日志(relay-log.info): 判断回放有没有延时</span><br><span class="line">Relay_Master_Log_File: mysql-bin.000004</span><br><span class="line">Exec_Master_Log_Pos: 141847</span><br><span class="line"></span><br><span class="line">计算主从复制延时日志量。</span><br><span class="line"></span><br><span class="line">方法三： </span><br><span class="line">	pt-heartbeat</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2-导致延时的主要原因"><a href="#5-3-2-导致延时的主要原因" class="headerlink" title="5.3.2 导致延时的主要原因"></a>5.3.2 导致延时的主要原因</h3><h4 id="a-主库方面"><a href="#a-主库方面" class="headerlink" title="a. 主库方面"></a>a. 主库方面</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） binlog记录不及时。</span><br><span class="line">mysql&gt; select @@sync_binlog;</span><br><span class="line">+---------------+</span><br><span class="line">| @@sync_binlog |</span><br><span class="line">+---------------+</span><br><span class="line">|             1 |</span><br><span class="line">+---------------+</span><br><span class="line">参数说明： </span><br><span class="line">	   1 ： 每次事务提交都立即刷新binlog到磁盘。 </span><br><span class="line">	   0 ： 由操作系统决定，什么刷新磁盘。</span><br><span class="line"></span><br><span class="line">（2） DUMP线程串行工作。</span><br><span class="line">大事务、并发事务高、DDL</span><br><span class="line">解决办法： </span><br><span class="line">	5.6版本加入GTID复制模式，但手工配置。DUMP在传输日志时可以并发。</span><br><span class="line">    5.7版本GTID做了增强，不手工开启也自动维护匿名的GTID信息。    </span><br><span class="line">（3）怎么判断是主库导致的延时？ </span><br><span class="line">主库： </span><br><span class="line">mysql&gt; show master status ;</span><br><span class="line">从库： </span><br><span class="line">mysql -S /tmp/mysql3308.sock -uroot -p123  -e &quot;show slave status \G&quot;|grep &quot;Master_Log&quot;</span><br></pre></td></tr></table></figure>

<h4 id="b-从库方面"><a href="#b-从库方面" class="headerlink" title="b. 从库方面"></a>b. 从库方面</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># IO线程： </span><br><span class="line">从库IO比较慢。relay 落地慢。可以将realy放到 SSD</span><br><span class="line"></span><br><span class="line"># SQL 线程： 串行回放。</span><br><span class="line">主库可以并行事务，从库SQL线程串行回放。</span><br><span class="line">所以：并发事务高、大事务、DDL</span><br><span class="line"></span><br><span class="line">解决方法： </span><br><span class="line">	   5.6 版本： 开启GTID后，可以多SQL线程，只能针对不同的库的事务进行并行SQL恢复。</span><br><span class="line">	   5.7 版本： 做了增强，基于逻辑时钟的并行回放。MTS。LAST_COMMIT(BINLOG_GROUP_COMMIT) </span><br><span class="line">       SEQ_NUM.</span><br><span class="line">5.7 的从库并发配置方法。</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency=ON</span><br><span class="line">log_slave_updates=ON</span><br><span class="line">slave-parallel-type=LOGICAL_CLOCK</span><br><span class="line">slave-parallel-workers=4</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br></pre></td></tr></table></figure>

<h1 id="7-多SQL线程复制MTS和-MGR-Writesets"><a href="#7-多SQL线程复制MTS和-MGR-Writesets" class="headerlink" title="7. 多SQL线程复制MTS和 MGR Writesets"></a>7. 多SQL线程复制MTS和 MGR Writesets</h1><h2 id="7-1-5-7-版本MTS"><a href="#7-1-5-7-版本MTS" class="headerlink" title="7.1 5.7+ 版本MTS"></a>7.1 5.7+ 版本MTS</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661960993317-4d120d62-0024-4dcf-920c-3b692931957b.png"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">a. 为什么会有 MTS和 WS ？ </span><br><span class="line">主库执行1000个事务，1000有GC机制，一次性投递到从库。</span><br><span class="line">从库SQL线程默认就1个。只能串行回放relay-log。</span><br><span class="line"></span><br><span class="line">5.6 版本&quot;</span><br><span class="line">加入多SQL线程回放机制。由一个管理线程，自动分配workers.</span><br><span class="line">按照database为基准，进行分配workers.</span><br><span class="line">MySQL 5.7 : </span><br><span class="line">利用Group Commit(LOGICAL<span class="emphasis">_CLOCK),检测事务之间是否冲突。</span></span><br><span class="line"><span class="emphasis">引入了新的并行回放类型， 由参数 slave_</span>parallel<span class="emphasis">_type决定，默认值DATABASE将会采用5.6版本中的SCHEMA级别的并行回放，设置为LOGICAL_</span>CLOCK 则会采用基于Group Commit的并行回放，同一个Group内的事务将会在Slave上并行回放。last<span class="emphasis">_commit=0 1 2 3 4 6</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">为了标记事务所属的组，MySQL 5.7 版本在产生 Binlog日志时会有两个特殊的值记录在Binlog Event中， last_</span>committed 和 sequence<span class="emphasis">_number , 其中 last_</span>committed 指的是该事务提交时，上一个事务提交的编号，sequence<span class="emphasis">_number 是事务提交的序列号，在一个Binlog文件内单调递增。如果两个事务的 last_</span>committed 值一致，这两个事务就是在一个组内提交的。</span><br><span class="line"></span><br><span class="line">mysqlbinlog mysql-bin.0000006 | grep last<span class="emphasis">_committed</span></span><br><span class="line"><span class="emphasis">server_</span>id 51 XXX GTID last<span class="emphasis">_committed=0 sequence_</span>numer=1</span><br><span class="line">server<span class="emphasis">_id 51 XXX GTID last_</span>committed=0 sequence<span class="emphasis">_numer=2</span></span><br><span class="line"><span class="emphasis">server_</span>id 51 XXX GTID last<span class="emphasis">_committed=0 sequence_</span>numer=3</span><br><span class="line">server<span class="emphasis">_id 51 XXX GTID last_</span>committed=0 sequence<span class="emphasis">_numer=4</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">注意： 同一个Session中的事件不能并发回放</span></span><br><span class="line"><span class="emphasis">session1: </span></span><br><span class="line"><span class="emphasis">TX1</span></span><br><span class="line"><span class="emphasis">create table t1;</span></span><br><span class="line"><span class="emphasis">TX2</span></span><br><span class="line"><span class="emphasis">begin;</span></span><br><span class="line"><span class="emphasis">insert into t1 values</span></span><br><span class="line"><span class="emphasis">commit;</span></span><br><span class="line"><span class="emphasis">TX3</span></span><br><span class="line"><span class="emphasis"> create table t2 ;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-2-8-0-版本-MGR-WS"><a href="#7-2-8-0-版本-MGR-WS" class="headerlink" title="7.2 8.0 版本 MGR WS"></a>7.2 8.0 版本 MGR WS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. 核心参数</span><br><span class="line">binlog_transaction_dependency_tracking  = WRITESET                 #    COMMIT_ORDER   </span><br><span class="line">transaction_write_set_extraction        = XXHASH64</span><br><span class="line"></span><br><span class="line"> b. 参数介绍</span><br><span class="line">	MySQL 8.0 中引入参数 binlog_transaction_depandency_tracking 用于控制如何决定事务的依赖关系。该值有三个选项：默认的 COMMIT_ORDERE 表示继续使用5.7中的基于组提交的方式决定事务的依赖关系；WRITESET 表示使用写集合来决定事务的依赖关系；还有一个选项 WRITESET_SESSION 表示使用 WriteSet 来决定事务的依赖关系，但是同一个Session内的事务不会有相同的 last_committed 值。</span><br><span class="line">	</span><br><span class="line">C.WS实现原理</span><br><span class="line">	在代码实现上，MySQL采用一个 vector&lt;uint64&gt; 的变量存储已经提交的事务的HASH值，所有已经提交的事务的所修改的主键和非空的 UniqueKey 的值经过HASH后与该vector中的值对比，以判断当前提交的事务是否与已经提交的事务更新了同一行，并以此确定依赖关系。该向量的大小由参数 binlog_transaction_dependency_history_size 控制，取值范围为 1-1000000 ，初始默认值为 25000。 同时有参数 transaction_write_set_extraction 控制检测事务依赖关系时采用的HASH算法，有三个取值 OFF| XXHASH64 | MURMUR32， 如果 binlog_transaction_depandency_tracking 取值为 WRITESET 或 WRITESET_SESSION, 那么该值取值不能为OFF，且不能变更。</span><br><span class="line"></span><br><span class="line">D. WriteSet 依赖检测条件</span><br><span class="line">	WriteSet 是通过检测两个事务是否更新了相同的记录来判断事务能否并行回放的，因此需要在运行时保存已经提交的事务信息以记录历史事务更新了哪些行。记录历史事务的参数为 binlog_transaction_dependency_history_size. 该值越大可以记录更多的已经提交的事务信息，不过需要注意的是，这个值并非指事务大小，而是指追踪的事务更新信息的数量。在开启了 WRITESET 或 WRITESET_SESSION 后，MySQL 按以下的方式标识并记录事务的更新。</span><br><span class="line">insert INTO TEST.T1 VALUES(1,&#x27;zhangsan&#x27;);</span><br><span class="line">insert INTO TEST.T1 VALUES(1,&#x27;ls&#x27;);</span><br><span class="line"></span><br><span class="line">	如果事务当前更新的行有主键（Primary Key），则将 HASH(DB名，TABLE名，KEY名称，KEY_VALUE1, KEY_VALUE2,.....) 加入到当前事务的 vector write_set 中。</span><br><span class="line">	如果事务当前更新的行有非空的唯一键 （Unique Key Not NULL）， 同样将 HASH(DB名, TABLE名，KEY名, KEY_VALUE1, ....)加入到当前事务的 write_set 中。</span><br><span class="line">	如果事务更新的行有外键约束( FOREIGN KEY )且不为空，则将该外键信息与VALUE的HASH加到当前事务的 write_set中.</span><br><span class="line">	如果事务当前更新的表的主键是其他某个表的外键，并设置当前事务 has_related_foreign_key = true</span><br><span class="line">	如果事务更新了某一行且没有任何数据被加入到 write_set 中，则标记当前事务 has_missing_key = true</span><br><span class="line">	在执行冲突检测的时候，先会检查 has_related_foreign_key 和 has_missing_key ， 如果为true， 则退到 COMMIT_ORDER 模式。否则，会依照事务的 write_set 中的HASH值与已提交的事务的 write_set 进行比对，如果没有冲突，则当前事务与最后一个已提交的事务共享相同的 last_commited, 否则将从全局已提交的 write_set 中删除那个冲突的事务之前提交的所有write_set，并退化到 COMMIT_ORDER 计算last_committed 。 每次计算完事务的 last_committed 值以后，检测当前全局已提交事务的 write_set 是否已经超过了 binlog_transaction_dependency_history_size 设置的值，如果超过，则清空已提交事务的全局write_set。</span><br><span class="line">	从检测条件上看，该特性依赖于主键和唯一索引，如果事务涉及的表中没有主键且没有唯一非空索引，那么将无法从此特性中获得性能的提升。除此之外，还需要将 Binlog 格式设置为 Row 格式。</span><br></pre></td></tr></table></figure>

<h1 id="8-延时从库应用"><a href="#8-延时从库应用" class="headerlink" title="8. 延时从库应用"></a>8. 延时从库应用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. 传统复制的痛点 </span><br><span class="line">	只能帮我们解决物理损坏，很难解决逻辑损坏。</span><br><span class="line">	可以用备份解决，但是数据量很大，通过备份方式花费很长时间。</span><br><span class="line">b. 配置方法：</span><br><span class="line">mysql&gt;stop slave;</span><br><span class="line">mysql&gt;CHANGE MASTER TO MASTER_DELAY = 300;</span><br><span class="line">mysql&gt;start slave;</span><br><span class="line">mysql&gt; show slave status \G</span><br><span class="line">SQL_Delay: 300</span><br><span class="line">SQL_Remaining_Delay: NULL</span><br><span class="line"></span><br><span class="line">#恢复思路 ： </span><br><span class="line">主库发生了逻辑损坏（DROP，truncate）时，可以使用延时从库快速恢复数据。</span><br><span class="line">    2小时延时  </span><br><span class="line">	10：00  做的drop database A;</span><br><span class="line">1. 及时监控故障： 主库 10:05发现故障，从库此时8:05数据状态</span><br><span class="line">2. 立即将从库的SQL线程关闭。 需要对A业务挂维护页。</span><br><span class="line">3. 停止所有线程。</span><br><span class="line">4. 在延时从。恢复A库数据</span><br><span class="line"></span><br><span class="line">方案一：针对无GTID  手工模拟SQL线程工作，直到drop之前位置点。</span><br><span class="line">   SQL线程上次执行到的位置------》drop之前</span><br><span class="line">   relay.info   ----&gt; 分析drop位置点   ---》 截取relaylog日志----》 source</span><br><span class="line">   </span><br><span class="line"># 故障模拟及恢复</span><br><span class="line">故障模拟：  </span><br><span class="line">create database delaydb charset utf8mb4;</span><br><span class="line">use delaydb;</span><br><span class="line">create table t1(id int);</span><br><span class="line">insert into t1 values(1),(2),(3);</span><br><span class="line">commit;</span><br><span class="line">drop database delaydb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">截取日志： </span><br><span class="line">起点: SQL上次执行到的位置点，</span><br><span class="line">               Relay_Log_File: db02-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 371</span><br><span class="line">终点： drop 之前 </span><br><span class="line">| db02-relay-bin.000002 | 1064 | Gtid           |        51 |        1006 | SET @@SESSION.GTID_NEXT= &#x27;188be1ed-c84c-11ea-98e7-000c29ea9d83:1469&#x27; |</span><br><span class="line">| db02-relay-bin.000002 | 1141 | Query          |        51 |        1119 | drop database delaydb /* xid=5339 */  </span><br><span class="line"></span><br><span class="line">[root@db01 tmp]# mysqlbinlog --start-position=371 --stop-position=1064 /data/3306/data/db02-relay-bin.000002 &gt;/tmp/bin.sql</span><br><span class="line">mysql&gt; reset slave all;</span><br><span class="line">mysql&gt; set sql_log_bin=0;</span><br><span class="line">mysql&gt; source /tmp/bin.sql;</span><br><span class="line">mysql&gt; set sql_log_bin=1;</span><br><span class="line"></span><br><span class="line">方案二： GTID</span><br><span class="line">db02 [(none)]&gt;stop slave;</span><br><span class="line"></span><br><span class="line">db02 [(none)]&gt;show relaylog events in &#x27;db02-relay-bin.000002&#x27;;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;188be1ed-c84c-11ea-98e7-000c29ea9d83:4&#x27; </span><br><span class="line">CHANGE MASTER TO MASTER_DELAY = 0;</span><br><span class="line"></span><br><span class="line">db02 [delaydb]&gt;START SLAVE UNTIL SQL_BEFORE_GTIDS = &quot;188be1ed-c84c-11ea-98e7-000c29ea9d83:4&quot;;</span><br></pre></td></tr></table></figure>

<h1 id="9-过滤复制"><a href="#9-过滤复制" class="headerlink" title="9. 过滤复制"></a>9. 过滤复制</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主库实现</span><br><span class="line">binlog_do_db      白名单</span><br><span class="line">binlog_ignore_db  黑名单</span><br><span class="line"></span><br><span class="line">说明： 是否记录binlog日志来控制过滤。</span><br><span class="line"></span><br><span class="line"># 从库实现 ******</span><br><span class="line">实现方法： </span><br><span class="line">IO线程不做限制。</span><br><span class="line">SQL线程回放时，选择性回放。</span><br><span class="line"></span><br><span class="line">参数： </span><br><span class="line">replicate_do_db=world</span><br><span class="line">replicate_do_db=oldboy</span><br><span class="line">replicate_ignore_db= </span><br><span class="line"></span><br><span class="line">replicate_do_table=world.city </span><br><span class="line">replicate_ignore_table= </span><br><span class="line"></span><br><span class="line">replicate_wild_do_table=world.t*</span><br><span class="line">replicate_wild_ignore_table=</span><br><span class="line"></span><br><span class="line">配置方法： </span><br><span class="line">方法一：  </span><br><span class="line">修改配置文件并重启</span><br><span class="line">vim /etc/my.cnf </span><br><span class="line">replicate_do_db=oldguo</span><br><span class="line">replicate_do_db=oldboy</span><br><span class="line"></span><br><span class="line">方法二： </span><br><span class="line">STOP SLAVE SQL_THREAD;</span><br><span class="line">CHANGE REPLICATION FILTER REPLICATE_DO_DB = (oldguo, oldboy);</span><br><span class="line">START  SLAVE SQL_THREAD;</span><br></pre></td></tr></table></figure>

<h1 id="10-多源复制-MSR"><a href="#10-多源复制-MSR" class="headerlink" title="10. 多源复制(MSR)"></a>10. 多源复制(MSR)</h1><h2 id="10-1-架构"><a href="#10-1-架构" class="headerlink" title="10.1 架构"></a>10.1 架构</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661961256653-6bbfc44a-dca0-4dfc-a27c-c6c927b8abd2.png"></p>
<h2 id="10-2-主机角色"><a href="#10-2-主机角色" class="headerlink" title="10.2 主机角色"></a>10.2 主机角色</h2><table>
<thead>
<tr>
<th>主机角色</th>
<th>地址</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>Master1</td>
<td>10.0.0.51</td>
<td>3306</td>
</tr>
<tr>
<td>Master2</td>
<td>10.0.0.52</td>
<td>3306</td>
</tr>
<tr>
<td>Slave</td>
<td>10.0.0.53</td>
<td>3306</td>
</tr>
</tbody></table>
<h2 id="10-3-配置过程"><a href="#10-3-配置过程" class="headerlink" title="10.3 配置过程"></a>10.3 配置过程</h2><h3 id="a-GTID环境准备"><a href="#a-GTID环境准备" class="headerlink" title="a. GTID环境准备"></a>a. GTID环境准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 清理环境</span><br><span class="line">pkill mysqld </span><br><span class="line">rm -rf /data/3306/*</span><br><span class="line">\mv /etc/my.cnf /tmp </span><br><span class="line"></span><br><span class="line">(2) 创建需要的目录 </span><br><span class="line">mkdir -p /data/3306/data /data/3306/binlog</span><br><span class="line">chown -R mysql.mysql /data</span><br><span class="line"></span><br><span class="line">(3) 准备配置文件 </span><br><span class="line"># db01 </span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/data/app/mysql8</span><br><span class="line">datadir=/data/3306/data</span><br><span class="line">server_id=6</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">log_bin=/data/3306/binlog/mysql-bin</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency</span><br><span class="line">log-slave-updates=1</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">innodb_flush_method=O_DIRECT</span><br><span class="line">slow_query_log=ON</span><br><span class="line">slow_query_log_file=/data/3306/data/db01-slow.log</span><br><span class="line">long_query_time=0.1</span><br><span class="line">log_queries_not_using_indexes</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">[client]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db01 [\\d]&gt;</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># db02 </span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/data/app/mysql8</span><br><span class="line">datadir=/data/3306/data</span><br><span class="line">server_id=7</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">log_bin=/data/3306/binlog/mysql-bin</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency</span><br><span class="line">log-slave-updates=1</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">innodb_flush_method=O_DIRECT</span><br><span class="line">slow_query_log=ON</span><br><span class="line">slow_query_log_file=/data/3306/data/db01-slow.log</span><br><span class="line">long_query_time=0.1</span><br><span class="line">log_queries_not_using_indexes</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">[client]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db02 [\\d]&gt;</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># db03 </span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/data/app/mysql8</span><br><span class="line">datadir=/data/3306/data</span><br><span class="line">server_id=8</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">log_bin=/data/3306/binlog/mysql-bin</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency</span><br><span class="line">log-slave-updates=1</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">innodb_flush_method=O_DIRECT</span><br><span class="line">slow_query_log=ON</span><br><span class="line">slow_query_log_file=/data/3306/data/db01-slow.log</span><br><span class="line">long_query_time=0.1</span><br><span class="line">log_queries_not_using_indexes</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">[client]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db03 [\\d]&gt;</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">(4) 初始化数据 </span><br><span class="line">mysqld --initialize-insecure --user=mysql --basedir=/data/app/mysql8  --datadir=/data/3306/data </span><br><span class="line"></span><br><span class="line">(5) 启动数据库</span><br><span class="line">/etc/init.d/mysqld start </span><br><span class="line"></span><br><span class="line">(6) 构建主从  </span><br><span class="line"># 1. 创建复制用户(主节点)</span><br><span class="line">set sql_log_bin=0;</span><br><span class="line">create user repl@&#x27;10.0.0.%&#x27; identified with mysql_native_password by &#x27;123&#x27;;</span><br><span class="line">grant replication slave on *.*  to repl@&#x27;10.0.0.%&#x27; ;</span><br><span class="line">set sql_log_bin=1;</span><br></pre></td></tr></table></figure>

<h3 id="b-配置多源复制"><a href="#b-配置多源复制" class="headerlink" title="b. 配置多源复制"></a>b. 配置多源复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;10.0.0.51&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123&#x27;, MASTER_AUTO_POSITION=1 FOR CHANNEL &#x27;Master_1&#x27;;                </span><br><span class="line"></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;10.0.0.52&#x27;,MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123&#x27;, MASTER_AUTO_POSITION=1 FOR CHANNEL &#x27;Master_2&#x27;;           </span><br><span class="line"></span><br><span class="line">start slave for CHANNEL  &#x27;Master_1&#x27;;</span><br><span class="line">start slave for CHANNEL  &#x27;Master_2&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="c-多源复制监控"><a href="#c-多源复制监控" class="headerlink" title="c. 多源复制监控"></a>c. 多源复制监控</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db03 [(none)]&gt;SHOW SLAVE STATUS FOR CHANNEL &#x27;Master_1&#x27;\G</span><br><span class="line">db03 [(none)]&gt;SHOW SLAVE STATUS FOR CHANNEL &#x27;Master_2&#x27;\G</span><br><span class="line">db03 [performance_schema]&gt;select * from replication_connection_configuration\G</span><br><span class="line">SELECT * FROM replication_connection_status WHERE CHANNEL_NAME=&#x27;master_1&#x27;\G</span><br><span class="line">db03 [performance_schema]&gt;select * from performance_schema.replication_applier_status_by_worker;</span><br></pre></td></tr></table></figure>

<h3 id="d-多源复制配置过滤"><a href="#d-多源复制配置过滤" class="headerlink" title="d.多源复制配置过滤"></a>d.多源复制配置过滤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = (&#x27;db1.%&#x27;) FOR CHANNEL &quot;master_1&quot;;</span><br><span class="line">mysql&gt; CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = (&#x27;db2.%&#x27;) FOR CHANNEL &quot;master_2&quot;;</span><br></pre></td></tr></table></figure>

<h1 id="11-MGR组复制引入"><a href="#11-MGR组复制引入" class="headerlink" title="11.  MGR组复制引入"></a>11.  MGR组复制引入</h1><h2 id="11-0-历史"><a href="#11-0-历史" class="headerlink" title="11.0 历史"></a>11.0 历史</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.7.17+以后，出现的组复制技术。MySQL Group Replication。</span><br><span class="line">为了复制环境中，数据一致性考虑、多写的场景研发的技术。</span><br></pre></td></tr></table></figure>

<h2 id="11-1-架构原理"><a href="#11-1-架构原理" class="headerlink" title="11.1 架构原理"></a>11.1 架构原理</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661961313863-c981821e-b5d8-4f4a-9ff2-988c81ff785d.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在2N+1个节点组成的单主模式组复制集群中，主库上一个事务提交时，会将事务修改记录相关的信息和事务产生的BINLOG事件打包生成一个写集(WRITE SET)，将写集发送给所有节点，并通过至少N个节点投票通过才能事务提交成功。</span><br><span class="line"></span><br><span class="line">在事务执行期间，会将：</span><br><span class="line">1、事务操作生成的map event/query event/dml event等写入BINLOG CACHE中(内存)</span><br><span class="line">2、将Write Set写入到Rpl_transaction_write_set_ctx中(内存)</span><br><span class="line"></span><br><span class="line">在事务提交时，具体在MYSQL_BIN_LOG::prepare之后，但是在MYSQL_BIN_LOG::ordered_commit之前，即事务相关的BINLOG Event还在BINLOG CACHE没有写入到BINLOG FILE前，将BINLOG CACHE中和Rpl_transaction_write_set_ctx中的数据进行处理并写入到transaction_msg中，由gcs_module负责发送transaction_msg到各个节点，等待各节点进行事务认证。</span><br><span class="line"></span><br><span class="line">由于transaction_msg中包含BINLOG信息，并在事务认证期间发送给MGR各节点，因此无需等待主节点的BINLOG落盘后再发送给备用节点。</span><br><span class="line"></span><br><span class="line">每个MGR群集中的节点上，都存在IO线程和SQL线程，IO线程会解析transaction_msg获取到BINLOG EVENT并保存到RELAY LOG中，再由SQL线程执行重放到辅助节点上。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结： </span><br><span class="line">	single-primary:</span><br><span class="line">	begin;</span><br><span class="line">	update t1 set name=‘zs’ where id=10;</span><br><span class="line">	commit;</span><br><span class="line">	</span><br><span class="line">	1. 主库发生新的事务，事务执行期间，会将事务binlog 刷到binlog cache。</span><br><span class="line">	2. 生成write_set ,包含binlog日志+表、库hash值。写入Rpl_transaction_write_set_ctx。</span><br><span class="line">	3. MYSQL_BIN_LOG::prepare之后，在MYSQL_BIN_LOG::ordered_commit之前</span><br><span class="line">	通过gcs_module将所有的Rpl_transaction_write_set_ctx，以transaction_msg传输给各个节点。</span><br><span class="line">	4. 通过certify验证（Paxos）,通过投票机制，判断此次事务是否满足半数以上节点通过（不冲突）。	</span><br><span class="line">	5. 主库binlog flush &amp;&amp; sync disk</span><br><span class="line">	6. 此时，各个从库开始回放relaylog。</span><br></pre></td></tr></table></figure>

<h2 id="11-2-MGR构建过程"><a href="#11-2-MGR构建过程" class="headerlink" title="11.2 MGR构建过程"></a>11.2 MGR构建过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. 清理环境 </span><br><span class="line">pkill mysqld </span><br><span class="line">rm -rf /data/83306/*</span><br><span class="line">\mv /etc/my.cnf /etc/my.cnf.sin</span><br><span class="line"></span><br><span class="line">b. 创建目录</span><br><span class="line">mkdir -p /data/83306/data</span><br><span class="line">mkdir -p /data/83306/binlog</span><br><span class="line">chown -R mysql.mysql /data/*</span><br><span class="line"></span><br><span class="line">c. 配置文件</span><br><span class="line">[root@db01 data]# cat /proc/sys/kernel/random/uuid</span><br><span class="line">ca842376-1c50-42ac-bb57-a5adc7da7a12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># db01：</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/data/app/mysql8/</span><br><span class="line">datadir=/data/83306/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=51</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">log_bin=/data/83306/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">port=3306</span><br><span class="line">skip_name_resolve</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">report_host=10.0.0.51</span><br><span class="line">report_port=3306</span><br><span class="line">socket=/tmp/mysql83306.sock</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">binlog_checksum=NONE</span><br><span class="line"></span><br><span class="line">binlog_transaction_dependency_tracking = WRITESET</span><br><span class="line">transaction_write_set_extraction=XXHASH64</span><br><span class="line">loose-group_replication_group_name=&quot;ca842376-1c50-42ac-bb57-a5adc7da7a12&quot;</span><br><span class="line">loose-group_replication_start_on_boot=OFF</span><br><span class="line">loose-group_replication_local_address= &quot;10.0.0.51:33061&quot;</span><br><span class="line">loose-group_replication_group_seeds= &quot;10.0.0.51:33061,10.0.0.52:33062,10.0.0.53:33063&quot;</span><br><span class="line">loose-group_replication_bootstrap_group=OFF</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">prompt=db01 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#db02：</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/data/app/mysql8/</span><br><span class="line">datadir=/data/83306/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=52</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">log_bin=/data/83306/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">port=3306</span><br><span class="line">skip_name_resolve</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">report_host=10.0.0.52</span><br><span class="line">report_port=3306</span><br><span class="line">socket=/tmp/mysql83306.sock</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">binlog_checksum=NONE</span><br><span class="line"></span><br><span class="line">binlog_transaction_dependency_tracking = WRITESET</span><br><span class="line">transaction_write_set_extraction=XXHASH64</span><br><span class="line">loose-group_replication_group_name=&quot;ca842376-1c50-42ac-bb57-a5adc7da7a12&quot;</span><br><span class="line">loose-group_replication_start_on_boot=OFF</span><br><span class="line">loose-group_replication_local_address= &quot;10.0.0.52:33062&quot;</span><br><span class="line">loose-group_replication_group_seeds= &quot;10.0.0.51:33061,10.0.0.52:33062,10.0.0.53:33063&quot;</span><br><span class="line">loose-group_replication_bootstrap_group=OFF</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db02 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># db03 ：</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/data/app/mysql8/</span><br><span class="line">datadir=/data/83306/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=53</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">log_bin=/data/83306/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">port=3306</span><br><span class="line">skip_name_resolve</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">report_host=10.0.0.53</span><br><span class="line">report_port=3306</span><br><span class="line">socket=/tmp/mysql83306.sock</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">binlog_checksum=NONE</span><br><span class="line"></span><br><span class="line">binlog_transaction_dependency_tracking = WRITESET</span><br><span class="line">transaction_write_set_extraction=XXHASH64</span><br><span class="line">loose-group_replication_group_name=&quot;ca842376-1c50-42ac-bb57-a5adc7da7a12&quot;</span><br><span class="line">loose-group_replication_start_on_boot=OFF</span><br><span class="line">loose-group_replication_local_address= &quot;10.0.0.53:33063&quot;</span><br><span class="line">loose-group_replication_group_seeds= &quot;10.0.0.51:33061,10.0.0.52:33062,10.0.0.53:33063&quot;</span><br><span class="line">loose-group_replication_bootstrap_group=OFF</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db03 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d. 初始化数据</span><br><span class="line">mysqld --initialize-insecure --user=mysql --basedir=/data/app/mysql8  --datadir=/data/83306/data </span><br><span class="line">e. 启动数据库</span><br><span class="line">/etc/init.d/mysqld start</span><br><span class="line"></span><br><span class="line">f. 组复制部分，配置文件介绍：</span><br><span class="line">// group_replication变量使用的loose-前缀是指示Server启用时尚未加载复制插件也将继续启动</span><br><span class="line">##指示Server必须为每个事务收集写集合，并使用XXHASH64哈希算法将其编码为散列</span><br><span class="line">transaction_write_set_extraction = XXHASH64</span><br><span class="line"></span><br><span class="line">##表示将加入或者创建的复制组命名为01e5fb97-be64-41f7-bafd-3afc7a6ab555</span><br><span class="line">##可自定义(通过cat /proc/sys/kernel/random/uuid)</span><br><span class="line">loose-group_replication_group_name=&quot;01e5fb97-be64-41f7-bafd-3afc7a6ab555&quot;</span><br><span class="line"></span><br><span class="line">##设置为Server启动时不自动启动组复制</span><br><span class="line">loose-group_replication_start_on_boot=off </span><br><span class="line"></span><br><span class="line">##绑定本地的192.168.29.128及33061端口接受其他组成员的连接，IP地址必须为其他组成员可正常访问</span><br><span class="line">loose-group_replication_local_address=&quot;192.168.29.128:33061&quot; </span><br><span class="line"></span><br><span class="line">##本行为告诉服务器当服务器加入组时，应当连接到</span><br><span class="line">##这些种子服务器进行配置。本设置可以不是全部的组成员服务地址。</span><br><span class="line">loose-group_replication_group_seeds=&quot;192.168.29.128:33061,192.168.29.128:33062,192.168.29.128:33063&quot;</span><br><span class="line"></span><br><span class="line">##配置是否自动引导组</span><br><span class="line">loose-group_replication_bootstrap_group = off </span><br><span class="line"></span><br><span class="line">##配置白名单，默认情况下只允许192.168.29.128连接到复制组，如果是其他IP则需要配置。</span><br><span class="line">loose-group_replication_ip_whitelist=”10.30.0.0/16,10.31.0..0/16,10.27.0.0/16″</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">g. 设置本地root用户密码和密码插件（所有节点）</span><br><span class="line">mysql -S /tmp/mysql83306.sock -e &quot;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">h. 安装MGR插件（所有节点）</span><br><span class="line">mysql -uroot -p123 -S /tmp/mysql83306.sock -e &quot;INSTALL PLUGIN group_replication SONAME &#x27;group_replication.so&#x27;;&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">i. 设置复制账号(所有节点)</span><br><span class="line">[root@db03 83306]# mysql -uroot -p123 -S /tmp/mysql83306.sock </span><br><span class="line">SET SQL_LOG_BIN=0;</span><br><span class="line">CREATE USER repl@&#x27;%&#x27; IDENTIFIED BY &#x27;123&#x27;;</span><br><span class="line">CREATE USER repl@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123&#x27;;</span><br><span class="line">CREATE USER repl@&#x27;127.0.0.1&#x27; IDENTIFIED BY &#x27;123&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE,replication client ON *.* TO repl@&#x27;%&#x27;;</span><br><span class="line"> grant replication slave,replication client on *.* to repl@&#x27;localhost&#x27; ;</span><br><span class="line"> grant replication slave,replication client on *.* to repl@&#x27;127.0.0.1&#x27; ;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">SET SQL_LOG_BIN=1;</span><br><span class="line">  </span><br><span class="line">j. 启动MGR单主模式</span><br><span class="line">  </span><br><span class="line"># 启动MGR，在主库(10.0.0.51)上执行</span><br><span class="line">CHANGE MASTER TO MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123&#x27;  FOR CHANNEL &#x27;group_replication_recovery&#x27;;</span><br><span class="line">SET GLOBAL group_replication_bootstrap_group=ON;</span><br><span class="line">START GROUP_REPLICATION;</span><br><span class="line">SET GLOBAL group_replication_bootstrap_group=OFF;</span><br><span class="line">SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| group_replication_applier | 5e46b750-c834-11ea-ab1a-000c29ea9d83 | 10.0.0.51   |       65535 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line"></span><br><span class="line"># 其他节点加入MGR，在从库上执行</span><br><span class="line">reset master;</span><br><span class="line">CHANGE MASTER TO MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123&#x27;  FOR CHANNEL &#x27;group_replication_recovery&#x27;;</span><br><span class="line"> START GROUP_REPLICATION;</span><br><span class="line">  </span><br><span class="line"># 查看MGR组信息</span><br><span class="line">db03 [(none)]&gt;SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| group_replication_applier | 60aec22c-c83d-11ea-9560-000c29a5e781 | 10.0.0.53   |       65535 | ONLINE       | SECONDARY   | 8.0.20         |</span><br><span class="line">| group_replication_applier | 627fde7d-c83d-11ea-9a66-000c29f2d9fe | 10.0.0.52   |        3306 | ONLINE       | SECONDARY   | 8.0.20         |</span><br><span class="line">| group_replication_applier | 7c612d78-c83d-11ea-b17b-000c29ea9d83 | 10.0.0.51   |        3306 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">// 可以看到，3个节点状态为online，并且主节点为192.168.56.101，只有主节点可以写入，其他节点只读，MGR单主模式搭建成功。</span><br><span class="line">  </span><br><span class="line">如果需要重置，那么需要执行如下命令：</span><br><span class="line">STOP GROUP_REPLICATION;</span><br><span class="line">reset master;</span><br><span class="line">SET SQL_LOG_BIN=1;</span><br><span class="line">CHANGE MASTER TO MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123&#x27; FOR CHANNEL &#x27;group_replication_recovery&#x27;;</span><br><span class="line">start GROUP_REPLICATION;</span><br><span class="line">  </span><br><span class="line">k. 切换到多主模式</span><br><span class="line">MGR切换模式需要重新启动组复制，因些需要在所有节点上先关闭组复制，设置 group_replication_single_primary_mode=OFF 等参数，再启动组复制。</span><br><span class="line">1、该模式启用需设置两个参数</span><br><span class="line">group_replication_single_primary_mode=0 #这个参数很好理解，就是关闭单master模式</span><br><span class="line">group_replication_enforce_update_everywhere_checks=1 #这个参数设置多主模式下各个节点严格一致性检查</span><br><span class="line">================</span><br><span class="line">db02 [(none)]&gt;stop  GROUP_REPLICATION;</span><br><span class="line">db02 [(none)]&gt;set global group_replication_single_primary_mode=OFF;</span><br><span class="line">db02 [(none)]&gt;set global group_replication_enforce_update_everywhere_checks=1;</span><br><span class="line">db03 [(none)]&gt;stop  GROUP_REPLICATION;</span><br><span class="line">db03 [(none)]&gt;set global group_replication_single_primary_mode=OFF;</span><br><span class="line">db03 [(none)]&gt;set global group_replication_enforce_update_everywhere_checks=1;</span><br><span class="line">select @@group_replication_single_primary_mode,@@group_replication_enforce_update_everywhere_checks;</span><br><span class="line">===============</span><br><span class="line"></span><br><span class="line">2、 默认启动的都是单master模式，其他节点都设置了read_only、super_read_only这两个参数，需要修改这两个配置</span><br><span class="line">===========</span><br><span class="line">db03 [(none)]&gt;set global read_only=0;</span><br><span class="line">db03 [(none)]&gt;set global super_read_only=0;</span><br><span class="line">===========</span><br><span class="line">3、 完成上面的配置后就可以执行多点写入了，多点写入会存在冲突检查，这耗损性能挺大的，官方建议采用网络分区功能，在程序端把相同的业务定位到同一节点，尽量减少冲突发生几率。</span><br><span class="line">  </span><br><span class="line"># 停止组复制(所有节点执行)：</span><br><span class="line">stop group_replication;</span><br><span class="line">set global group_replication_single_primary_mode=OFF;</span><br><span class="line">set global group_replication_enforce_update_everywhere_checks=ON;</span><br><span class="line">  </span><br><span class="line"># 随便选择某个节点执行</span><br><span class="line">SET GLOBAL group_replication_bootstrap_group=ON;</span><br><span class="line">START GROUP_REPLICATION; </span><br><span class="line">SET GLOBAL group_replication_bootstrap_group=OFF;</span><br><span class="line">  </span><br><span class="line"># 其他节点执行</span><br><span class="line">START GROUP_REPLICATION; </span><br><span class="line">  </span><br><span class="line"># 查看组信息，所有节点的 MEMBER_ROLE 都为 PRIMARY，</span><br><span class="line">SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">切回单主模式</span><br><span class="line"># 所有节点执行</span><br><span class="line">stop group_replication;</span><br><span class="line">set global group_replication_enforce_update_everywhere_checks=OFF;</span><br><span class="line">set global group_replication_single_primary_mode=ON;</span><br><span class="line">  </span><br><span class="line"># 主节点执行</span><br><span class="line">SET GLOBAL group_replication_bootstrap_group=ON; </span><br><span class="line">START GROUP_REPLICATION; </span><br><span class="line">SET GLOBAL group_replication_bootstrap_group=OFF;</span><br><span class="line"></span><br><span class="line"># 从节点执行</span><br><span class="line">START GROUP_REPLICATION; </span><br><span class="line">  </span><br><span class="line"># 查看MGR组信息，SELECT * FROM performance_schema.replication_group_members;</span><br></pre></td></tr></table></figure>

<h2 id="11-3-MGR的运维"><a href="#11-3-MGR的运维" class="headerlink" title="11.3 MGR的运维"></a>11.3 MGR的运维</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. MGR的监控</span><br><span class="line">SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">b. MGR故障处理</span><br><span class="line">## 宕掉主节点测试。</span><br><span class="line">db02 [(none)]&gt;SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| group_replication_applier | 60aec22c-c83d-11ea-9560-000c29a5e781 | 10.0.0.53   |       65535 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">| group_replication_applier | 627fde7d-c83d-11ea-9a66-000c29f2d9fe | 10.0.0.52   |        3306 | ONLINE       | SECONDARY   | 8.0.20         |</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">## 启动主节点</span><br><span class="line">db02 [(none)]&gt;SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| group_replication_applier | 60aec22c-c83d-11ea-9560-000c29a5e781 | 10.0.0.53   |       65535 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">| group_replication_applier | 627fde7d-c83d-11ea-9a66-000c29f2d9fe | 10.0.0.52   |        3306 | ONLINE       | SECONDARY   | 8.0.20         |</span><br><span class="line">| group_replication_applier | 7c612d78-c83d-11ea-b17b-000c29ea9d83 | 10.0.0.51   |        3306 | ONLINE       | SECONDARY   | 8.0.20         |</span><br><span class="line">+---------------------------+--------------------------------------+-------------+-------------+--------------+-------------+-----</span><br><span class="line"></span><br><span class="line">c. MGR添加删除节点</span><br><span class="line"># 通过clone plugin 添加新的节点</span><br><span class="line">1. 初始化新节点</span><br><span class="line">pkill mysqld </span><br><span class="line">rm -rf /data/83306/*</span><br><span class="line">\mv /etc/my.cnf /etc/my.cnf.sin</span><br><span class="line">mkdir -p /data/83306/data</span><br><span class="line">mkdir -p /data/83306/binlog</span><br><span class="line">chown -R mysql.mysql /data/*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/data/app/mysql8/</span><br><span class="line">datadir=/data/83306/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=51</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">log_bin=/data/83306/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">port=3306</span><br><span class="line">skip_name_resolve</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">report_host=10.0.0.51</span><br><span class="line">report_port=3306</span><br><span class="line">socket=/tmp/mysql83306.sock</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">binlog_checksum=NONE</span><br><span class="line"></span><br><span class="line">transaction_write_set_extraction=XXHASH64</span><br><span class="line">loose-group_replication_group_name=&quot;ca842376-1c50-42ac-bb57-a5adc7da7a12&quot;</span><br><span class="line">loose-group_replication_start_on_boot=OFF</span><br><span class="line">loose-group_replication_local_address= &quot;10.0.0.54:33061&quot;</span><br><span class="line">loose-group_replication_group_seeds= &quot;10.0.0.51:33061,10.0.0.52:33062,10.0.0.53:33063&quot;</span><br><span class="line">loose-group_replication_bootstrap_group=OFF</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db01 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">2. 初始化数据</span><br><span class="line">mysqld --initialize-insecure --user=mysql --basedir=/data/app/mysql8  --datadir=/data/83306/data </span><br><span class="line">3. 启动数据库</span><br><span class="line">/etc/init.d/mysqld start</span><br><span class="line"></span><br><span class="line">4. 设置本地root用户密码和密码插件（所有节点）</span><br><span class="line">mysql -S /tmp/mysql83306.sock -e &quot;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">5. 安装MGR插件（所有节点）</span><br><span class="line">mysql -uroot -p123 -S /tmp/mysql83306.sock -e &quot;INSTALL PLUGIN group_replication SONAME &#x27;group_replication.so&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">6. clone plugin 克隆主库数据</span><br><span class="line"># 主库： </span><br><span class="line">[root@db01 ~]# mysql -uroot -p123 -S /tmp/mysql83306.sock -e &quot;INSTALL PLUGIN clone SONAME &#x27;mysql_clone.so&#x27;;create user test@&#x27;%&#x27; identified by &#x27;123&#x27;;grant backup_admin on *.* to test@&#x27;%&#x27;;&quot;</span><br><span class="line"></span><br><span class="line"># 从库： </span><br><span class="line"> mysql -uroot -p123 -S /tmp/mysql83306.sock -e &quot;INSTALL PLUGIN clone SONAME &#x27;mysql_clone.so&#x27;;create user test1@&#x27;%&#x27; identified by &#x27;123&#x27;;grant clone_admin on *.* to test1@&#x27;%&#x27;;SET GLOBAL clone_valid_donor_list=&#x27;10.0.0.52:3306&#x27;;&quot;</span><br><span class="line"> mysql -utest1 -p123 -h10.0.0.51  -P3306 -e &quot;CLONE INSTANCE FROM test@&#x27;10.0.0.52&#x27;:3306 IDENTIFIED BY &#x27;123&#x27;;&quot;</span><br><span class="line"> </span><br><span class="line"># 加入集群</span><br><span class="line">CHANGE MASTER TO MASTER_USER=&#x27;repl&#x27;, MASTER_PASSWORD=&#x27;123&#x27;  FOR CHANNEL &#x27;group_replication_recovery&#x27;;</span><br><span class="line"> START GROUP_REPLICATION;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># 查看MGR组信息</span><br><span class="line">SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line"></span><br><span class="line">d. MGR的限制</span><br><span class="line">1. 仅支持innodb存储引擎</span><br><span class="line">MGR集群中，只支持innodb存储引擎，能够创建非innodb引擎的表，但是无法写入数据，向非innodb表写数据直接报错。</span><br><span class="line">2. 表必须有主键，或者非Null的唯一键</span><br><span class="line">MGR集群中，只支持innodb引擎的表，并且该表必须有显式的主键，或者非Null的唯一键，否则即使能够创建表，也无法向表中写入数据。</span><br><span class="line">3. 网络限制</span><br><span class="line">MGR 组通信引擎目前仅支持IPv4网络，并且对节点间的网络性能要求较高，低延迟、高带宽的网络是部署MGR集群的基础。</span><br><span class="line">4. MGR忽略表锁和命名锁，在MGR中lock tables、unlock tables、get_lock、release_lock等这些表锁和命名锁将被忽略。</span><br><span class="line">5. MGR多主模式中，默认不支持 SERIALIZABLE 隔离级别。建议使用RC。</span><br><span class="line">6. 多主模式下，对同一个对象进行并发的有冲突的ddl和dml操作导致这种冲突在部分成员节点中无法检测到，最终可能导致数据不一致。</span><br><span class="line">7. 多主模式下，不支持级联约束的外键，可能造成有冲突的操作无法检测。</span><br><span class="line">8. 不支持超大事务。</span><br><span class="line">9. 多主模式下可能导致死锁，比如select ...for update在不同节点执行，由于多节点锁无法共享，很容易导致死锁。</span><br><span class="line">10.不支持复制过滤，如果有节点设置了复制过滤，将影响节点间决议的达成。</span><br><span class="line">11. MGR最多支持9个节点，大于9个节点，将拒绝新节点的加入。</span><br></pre></td></tr></table></figure>

<h2 id="11-4-MGR在8-0版本读写一致性保证"><a href="#11-4-MGR在8-0版本读写一致性保证" class="headerlink" title="11.4 MGR在8.0版本读写一致性保证"></a>11.4 MGR在8.0版本读写一致性保证</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MGR相对于半同步复制，在relay log前增加了冲突检查协调，但是binlog回放仍然可能延时，也就是跟我们熟悉的半同步复制存在SQL线程的回放延迟情况类似。当然关于SQL线程回放慢的原因，跟半同步也类似，比如大事务！！</span><br><span class="line"></span><br><span class="line">所以MGR并不是全同步方案，关于如何处理一致性读写的问题，MySQL 在8.0.14版本中加入了“读写一致性”特性，并引入了参数：group_replication_consistency，下面将对读写一致性的相关参数及不同应用场景进行详细说明。</span><br></pre></td></tr></table></figure>

<h3 id="参数group-replication-consistency的说明"><a href="#参数group-replication-consistency的说明" class="headerlink" title="参数group_replication_consistency的说明"></a>参数group_replication_consistency的说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EVENTUAL 默认值(最终一致性)，开启事务（T2），事务执行前不会等待先序事务（T1）的回放完成，也不会影响后序事务等待该事务回放完成。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661961388742-07ddb480-84fb-48bd-92a8-677e790afb9b.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEFORE （本地强一致性）开启事务（T2），在开始前首先要等待先序事务（T1）的回放完成，确保此事务将在最新的数据上执行。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661961400032-5d8e18d6-ee39-41be-9288-76fa1b709aac.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AFTER（全局强一致性），开启事务（T1），只有等该事务回放完成。其他后序事务（T2）才开始执行，这样所有后序事务都会读取包含其更改的数据库状态，而不管它们在哪个成员上执行。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661961413541-486a9116-f41b-4961-8783-a1cda9d1693f.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEFORE_AND_AFTER 开启事务（T2），需要等待前序事务的回放完成（T1）；同时后序事务（T3）等待该事务的回放完成；</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661961617336-44c73a57-8ccf-403c-b2e2-e244d580aef6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEFORE_ON_PRIMARY_FAILOVER,在发生切换时，连到新主的事务会被阻塞，等待先序提交的事务回放完成；这样确保在故障切换时客户端都能读取到主服务器上的最新数据，保证了一致性</span><br><span class="line">group_replication_consistency 参数可以用法SESSION，GLOBAL去进行更改。</span><br><span class="line"></span><br><span class="line">官方说明请参考：</span><br><span class="line">https://dev.mysql.com/doc/refman/8.0/en/group-replication-options.html</span><br></pre></td></tr></table></figure>

<h3 id="MGR读写一致性的优缺点"><a href="#MGR读写一致性的优缺点" class="headerlink" title="MGR读写一致性的优缺点"></a>MGR读写一致性的优缺点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官方引入的MGR读写一致性既有它自身的天然优势，也不可避免的存在相应的不足，其优缺点如下：</span><br><span class="line">优点：MGR配合中间件，比如读写分离功能的中间件，在MGR单主模式下，可以根据业务场景进行读写分离，不用担心会产生延迟，充分利用了MGR主节点以外的节点。</span><br><span class="line">缺点：使用读写一致性会对性能有极大影响，尤其是网络环境不稳定的场景下。</span><br><span class="line">在实际应用中需要大家因地制宜，根据实际情况选择最适配的方案</span><br></pre></td></tr></table></figure>

<h3 id="MGR读写一致性的方案"><a href="#MGR读写一致性的方案" class="headerlink" title="MGR读写一致性的方案"></a>MGR读写一致性的方案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对不同应用场景应当如何选择MGR读写一致性的相关方式，官方提供了几个参数以及与其相对应的应用场景：</span><br><span class="line"></span><br><span class="line">AFTER</span><br><span class="line">适用场景1：写少读多的场景进行读写分离，担心读取到过期事务，可选择AFTER。</span><br><span class="line">适用场景2：只读为主的集群，有RW的事务需要保证提交的事务能被其他后序事务读到最新读数据，可选择AFTER。</span><br><span class="line"></span><br><span class="line">BEFORE</span><br><span class="line">适用场景1：应用大量写入数据，偶尔进行读取一致性数据，应当选择BEFORE。</span><br><span class="line">适用场景2：有特定事务需要读写一致性，以便对敏感数据操作时，始终读取最新的数据；应当选择BEFORE。</span><br><span class="line"></span><br><span class="line">BEFORE_AND_AFTER</span><br><span class="line">适用场景：有一个读为主的集群，有RW的事务既要保证读到最新的数据，又要保证这个事务提交后，被其他后序事务读到；在这种情况下可选择BEFORE_AND_AFTER。</span><br><span class="line"></span><br><span class="line">http://www.itdks.com/Course/detail?id=117532</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构上</title>
    <url>/2024/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="1、分布式架构-演变"><a href="#1、分布式架构-演变" class="headerlink" title="1、分布式架构-演变"></a>1、分布式架构-演变</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1648273278095-383d560f-e330-4d5a-974d-e1c742f323f6.png?x-oss-process=image/resize,w_1170,limit_0"></p>
<span id="more"></span>
<h1 id="2、基础架构介绍"><a href="#2、基础架构介绍" class="headerlink" title="2、基础架构介绍"></a>2、基础架构介绍</h1><h2 id="2-1-环境准备："><a href="#2-1-环境准备：" class="headerlink" title="2.1 环境准备："></a>2.1 环境准备：</h2><ul>
<li>两台虚拟机 db01 db02 </li>
<li>每台创建四个mysql实例：3307  3308   &#x2F; 3309 3310  </li>
<li><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1609853952424-0478e92a-57c0-4cd7-9454-67c0072384ab.png"></li>
</ul>
<h2 id="2-2-删除历史环境："><a href="#2-2-删除历史环境：" class="headerlink" title="2.2 删除历史环境："></a>2.2 删除历史环境：</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pkill mysqld</span><br><span class="line">rm -rf /data/330*</span><br><span class="line">mv /etc/my.cnf /etc/my.cnf.bak</span><br></pre></td></tr></table></figure>

<h2 id="2-3-创建相关目录初始化数据"><a href="#2-3-创建相关目录初始化数据" class="headerlink" title="2.3 创建相关目录初始化数据"></a>2.3 创建相关目录初始化数据</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mkdir /data/33&#123;07..10&#125;/data -p</span><br><span class="line">mysqld --initialize-insecure --user=mysql --datadir=/data/3307/data --</span><br><span class="line">basedir=/data/app/mysql</span><br><span class="line">mysqld --initialize-insecure --user=mysql --datadir=/data/3308/data --</span><br><span class="line">basedir=/data/app/mysql</span><br><span class="line">mysqld --initialize-insecure --user=mysql --datadir=/data/3309/data --</span><br><span class="line">basedir=/data/app/mysql</span><br><span class="line">mysqld --initialize-insecure --user=mysql --datadir=/data/3310/data --</span><br><span class="line">basedir=/data/app/mysql</span><br></pre></td></tr></table></figure>

<h2 id="2-4-准备配置文件和启动脚本"><a href="#2-4-准备配置文件和启动脚本" class="headerlink" title="2.4 准备配置文件和启动脚本"></a>2.4 准备配置文件和启动脚本</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># ========db01==============</span></span><br><span class="line">cat &gt;/data/3307/my.cnf&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">mysqld</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">datadir</span>=<span class="string">/data/3307/data</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">socket</span>=<span class="string">/data/3307/mysql.sock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">port</span>=<span class="string">3307</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-error</span>=<span class="string">/data/3307/mysql.log</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_bin</span>=<span class="string">/data/3307/mysql-bin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_format</span>=<span class="string">row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">skip-name-resolve</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">server-id</span>=<span class="string">7</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid-mode</span>=<span class="string">on</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce-gtid-consistency</span>=<span class="string">true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-slave-updates</span>=<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">rpl_semi_sync</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_timeout</span> =<span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_for_slave_count</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_no_slave</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_point</span> =<span class="string">AFTER_SYNC</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_slave_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">group</span> <span class="attr">commit</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_delay</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_no_delay_count</span> =<span class="string">1000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid_mode</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce_gtid_consistency</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_slave_update</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_type</span> =<span class="string">LOGICAL_CLOCK</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_workers</span> =<span class="string">4</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">master_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">relay_log_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/data/3308/my.cnf&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">mysqld</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">datadir</span>=<span class="string">/data/3308/data</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">port</span>=<span class="string">3308</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">socket</span>=<span class="string">/data/3308/mysql.sock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-error</span>=<span class="string">/data/3308/mysql.log</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_bin</span>=<span class="string">/data/3308/mysql-bin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_format</span>=<span class="string">row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">skip-name-resolve</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">server-id</span>=<span class="string">8</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid-mode</span>=<span class="string">on</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce-gtid-consistency</span>=<span class="string">true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-slave-updates</span>=<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">rpl_semi_sync</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_timeout</span> =<span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_for_slave_count</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_no_slave</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_point</span> =<span class="string">AFTER_SYNC</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_slave_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">group</span> <span class="attr">commit</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_delay</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_no_delay_count</span> =<span class="string">1000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid_mode</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce_gtid_consistency</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_slave_update</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_type</span> =<span class="string">LOGICAL_CLOCK</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_workers</span> =<span class="string">4</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">master_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">relay_log_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/data/3309/my.cnf&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">mysqld</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">datadir</span>=<span class="string">/data/3309/data</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">socket</span>=<span class="string">/data/3309/mysql.sock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">port</span>=<span class="string">3309</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-error</span>=<span class="string">/data/3309/mysql.log</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_bin</span>=<span class="string">/data/3309/mysql-bin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_format</span>=<span class="string">row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">skip-name-resolve</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">server-id</span>=<span class="string">9</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid-mode</span>=<span class="string">on</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce-gtid-consistency</span>=<span class="string">true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-slave-updates</span>=<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">rpl_semi_sync</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_timeout</span> =<span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_for_slave_count</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_no_slave</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_point</span> =<span class="string">AFTER_SYNC</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_slave_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">group</span> <span class="attr">commit</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_delay</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_no_delay_count</span> =<span class="string">1000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid_mode</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce_gtid_consistency</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_slave_update</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_type</span> =<span class="string">LOGICAL_CLOCK</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_workers</span> =<span class="string">4</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">master_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">relay_log_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/data/3310/my.cnf&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">mysqld</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">datadir</span>=<span class="string">/data/3310/data</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">socket</span>=<span class="string">/data/3310/mysql.sock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">port</span>=<span class="string">3310</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-error</span>=<span class="string">/data/3310/mysql.log</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_bin</span>=<span class="string">/data/3310/mysql-bin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_format</span>=<span class="string">row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">skip-name-resolve</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">server-id</span>=<span class="string">10</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid-mode</span>=<span class="string">on</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce-gtid-consistency</span>=<span class="string">true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-slave-updates</span>=<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">rpl_semi_sync</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_timeout</span> =<span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_for_slave_count</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_no_slave</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_point</span> =<span class="string">AFTER_SYNC</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_slave_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">group</span> <span class="attr">commit</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_delay</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_no_delay_count</span> =<span class="string">1000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid_mode</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce_gtid_consistency</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_slave_update</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_type</span> =<span class="string">LOGICAL_CLOCK</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_workers</span> =<span class="string">4</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">master_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">relay_log_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/etc/systemd/system/mysqld3307.service&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Unit</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Description</span>=<span class="string">MySQL</span> <span class="attr">Server</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">man:mysqld(8)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">network.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">syslog.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Install</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Service</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">User</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Group</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ExecStart</span>=<span class="string">/data/app/mysql/bin/mysqld</span> <span class="attr">--defaults-file</span>=<span class="string">/data/3307/my.cnf</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">LimitNOFILE</span> = <span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/etc/systemd/system/mysqld3308.service&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Unit</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Description</span>=<span class="string">MySQL</span> <span class="attr">Server</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">man:mysqld(8)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">network.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">syslog.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Install</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Service</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">User</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Group</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ExecStart</span>=<span class="string">/data/app/mysql/bin/mysqld</span> <span class="attr">--defaults-file</span>=<span class="string">/data/3308/my.cnf</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">LimitNOFILE</span> = <span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/etc/systemd/system/mysqld3309.service&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Unit</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Description</span>=<span class="string">MySQL</span> <span class="attr">Server</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">man:mysqld(8)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">network.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">syslog.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Install</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Service</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">User</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Group</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ExecStart</span>=<span class="string">/data/app/mysql/bin/mysqld</span> <span class="attr">--defaults-file</span>=<span class="string">/data/3309/my.cnf</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">LimitNOFILE</span> = <span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/etc/systemd/system/mysqld3310.service&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Unit</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Description</span>=<span class="string">MySQL</span> <span class="attr">Server</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">man:mysqld(8)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">network.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">syslog.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Install</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Service</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">User</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Group</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ExecStart</span>=<span class="string">/data/app/mysql/bin/mysqld</span> <span class="attr">--defaults-file</span>=<span class="string">/data/3310/my.cnf</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">LimitNOFILE</span> = <span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"># ========<span class="string">db02</span>===============</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="string">cat</span> &gt;</span></span>/data/3307/my.cnf&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">mysqld</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">datadir</span>=<span class="string">/data/3307/data</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">socket</span>=<span class="string">/data/3307/mysql.sock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">port</span>=<span class="string">3307</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-error</span>=<span class="string">/data/3307/mysql.log</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_bin</span>=<span class="string">/data/3307/mysql-bin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_format</span>=<span class="string">row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">skip-name-resolve</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">server-id</span>=<span class="string">17</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid-mode</span>=<span class="string">on</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce-gtid-consistency</span>=<span class="string">true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-slave-updates</span>=<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">rpl_semi_sync</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_timeout</span> =<span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_for_slave_count</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_no_slave</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_point</span> =<span class="string">AFTER_SYNC</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_slave_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">group</span> <span class="attr">commit</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_delay</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_no_delay_count</span> =<span class="string">1000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid_mode</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce_gtid_consistency</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_slave_update</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_type</span> =<span class="string">LOGICAL_CLOCK</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_workers</span> =<span class="string">4</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">master_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">relay_log_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/data/3308/my.cnf&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">mysqld</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">datadir</span>=<span class="string">/data/3308/data</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">port</span>=<span class="string">3308</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">socket</span>=<span class="string">/data/3308/mysql.sock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-error</span>=<span class="string">/data/3308/mysql.log</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_bin</span>=<span class="string">/data/3308/mysql-bin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_format</span>=<span class="string">row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">skip-name-resolve</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">server-id</span>=<span class="string">18</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid-mode</span>=<span class="string">on</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce-gtid-consistency</span>=<span class="string">true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-slave-updates</span>=<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">rpl_semi_sync</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_timeout</span> =<span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_for_slave_count</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_no_slave</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_point</span> =<span class="string">AFTER_SYNC</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_slave_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">group</span> <span class="attr">commit</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_delay</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_no_delay_count</span> =<span class="string">1000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid_mode</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce_gtid_consistency</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_slave_update</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_type</span> =<span class="string">LOGICAL_CLOCK</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_workers</span> =<span class="string">4</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">master_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">relay_log_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/data/3309/my.cnf&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">mysqld</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">datadir</span>=<span class="string">/data/3309/data</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">socket</span>=<span class="string">/data/3309/mysql.sock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">port</span>=<span class="string">3309</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-error</span>=<span class="string">/data/3309/mysql.log</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_bin</span>=<span class="string">/data/3309/mysql-bin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_format</span>=<span class="string">row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">skip-name-resolve</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">server-id</span>=<span class="string">19</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid-mode</span>=<span class="string">on</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce-gtid-consistency</span>=<span class="string">true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-slave-updates</span>=<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">rpl_semi_sync</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_timeout</span> =<span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_for_slave_count</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_no_slave</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_point</span> =<span class="string">AFTER_SYNC</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_slave_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">group</span> <span class="attr">commit</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_delay</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_no_delay_count</span> =<span class="string">1000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid_mode</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce_gtid_consistency</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_slave_update</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_type</span> =<span class="string">LOGICAL_CLOCK</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_workers</span> =<span class="string">4</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">master_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">relay_log_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/data/3310/my.cnf&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">mysqld</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">datadir</span>=<span class="string">/data/3310/data</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">socket</span>=<span class="string">/data/3310/mysql.sock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">port</span>=<span class="string">3310</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-error</span>=<span class="string">/data/3310/mysql.log</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_bin</span>=<span class="string">/data/3310/mysql-bin</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_format</span>=<span class="string">row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">skip-name-resolve</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">server-id</span>=<span class="string">20</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid-mode</span>=<span class="string">on</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce-gtid-consistency</span>=<span class="string">true</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log-slave-updates</span>=<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">rpl_semi_sync</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_timeout</span> =<span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_for_slave_count</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_no_slave</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_master_wait_point</span> =<span class="string">AFTER_SYNC</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rpl_semi_sync_slave_enabled</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">group</span> <span class="attr">commit</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_delay</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">binlog_group_commit_sync_no_delay_count</span> =<span class="string">1000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">gtid_mode</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">enforce_gtid_consistency</span> =<span class="string">ON</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">log_slave_update</span> =<span class="string">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">#*************** <span class="attr">gtid</span> ***************</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_type</span> =<span class="string">LOGICAL_CLOCK</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">slave_parallel_workers</span> =<span class="string">4</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">master_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">relay_log_info_repository</span> =<span class="string">TABLE</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/etc/systemd/system/mysqld3307.service&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Unit</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Description</span>=<span class="string">MySQL</span> <span class="attr">Server</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">man:mysqld(8)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">network.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">syslog.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Install</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Service</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">User</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Group</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ExecStart</span>=<span class="string">/data/app/mysql/bin/mysqld</span> <span class="attr">--defaults-file</span>=<span class="string">/data/3307/my.cnf</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">LimitNOFILE</span> = <span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/etc/systemd/system/mysqld3308.service&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Unit</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Description</span>=<span class="string">MySQL</span> <span class="attr">Server</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">man:mysqld(8)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">network.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">syslog.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Install</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Service</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">User</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Group</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ExecStart</span>=<span class="string">/data/app/mysql/bin/mysqld</span> <span class="attr">--defaults-file</span>=<span class="string">/data/3308/my.cnf</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">LimitNOFILE</span> = <span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/etc/systemd/system/mysqld3309.service&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Unit</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Description</span>=<span class="string">MySQL</span> <span class="attr">Server</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">man:mysqld(8)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">network.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">syslog.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Install</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Service</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">User</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Group</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ExecStart</span>=<span class="string">/data/app/mysql/bin/mysqld</span> <span class="attr">--defaults-file</span>=<span class="string">/data/3309/my.cnf</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">LimitNOFILE</span> = <span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">cat</span> &gt;</span></span>/etc/systemd/system/mysqld3310.service&lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Unit</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Description</span>=<span class="string">MySQL</span> <span class="attr">Server</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">man:mysqld(8)</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Documentation</span>=<span class="string">http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">network.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">After</span>=<span class="string">syslog.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Install</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">[<span class="attr">Service</span>]</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">User</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">Group</span>=<span class="string">mysql</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">ExecStart</span>=<span class="string">/data/app/mysql/bin/mysqld</span> <span class="attr">--defaults-file</span>=<span class="string">/data/3310/my.cnf</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">LimitNOFILE</span> = <span class="string">5000</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">EOF</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-修改权限，启动多实例"><a href="#2-5-修改权限，启动多实例" class="headerlink" title="2.5 修改权限，启动多实例"></a>2.5 修改权限，启动多实例</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">chown -R mysql.mysql /data/*</span><br><span class="line">systemctl start mysqld3307</span><br><span class="line">systemctl start mysqld3308</span><br><span class="line">systemctl start mysqld3309</span><br><span class="line">systemctl start mysqld3310</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;show variables like &#x27;server<span class="emphasis">_id&#x27;&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;show variables like &#x27;server_</span>id&#x27;&quot;</span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;show variables like &#x27;server<span class="emphasis">_id&#x27;&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3310/mysql.sock -e &quot;show variables like &#x27;server_</span>id&#x27;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-节点主从规划"><a href="#2-6-节点主从规划" class="headerlink" title="2.6 节点主从规划"></a>2.6 节点主从规划</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">10.0.0.52:3308 &lt;-----&gt; 10.0.0.51:3308</span><br><span class="line">10.0.0.52:3310 -----&gt; 10.0.0.52:3308</span><br><span class="line">10.0.0.51:3310 -----&gt; 10.0.0.51:3308</span><br></pre></td></tr></table></figure>

<h2 id="2-7-开始配置主从环境"><a href="#2-7-开始配置主从环境" class="headerlink" title="2.7 开始配置主从环境"></a>2.7 开始配置主从环境</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># shard1</span></span><br><span class="line"><span class="section">## 10.0.0.51:3307 &lt;-----&gt; 10.0.0.52:3307</span></span><br><span class="line"><span class="section"># db02</span></span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;create user repl@&#x27;10.0.0.%&#x27; identified</span><br><span class="line">with mysql<span class="emphasis">_native_</span>password by &#x27;123&#x27;; grant replication slave on <span class="emphasis">*.*</span> to</span><br><span class="line">repl@&#x27;10.0.0.%&#x27;;&quot;</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;create user root@&#x27;10.0.0.%&#x27; identified</span><br><span class="line">with mysql<span class="emphasis">_native_</span>password by &#x27;123&#x27;; grant all on <span class="emphasis">*.*</span> to root@&#x27;10.0.0.%&#x27;;</span><br><span class="line">&quot;</span><br><span class="line"><span class="section"># db01</span></span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;CHANGE MASTER TO</span><br><span class="line">MASTER<span class="emphasis">_HOST=&#x27;10.0.0.52&#x27;, MASTER_</span>PORT=3307, MASTER<span class="emphasis">_AUTO_</span>POSITION=1,</span><br><span class="line">MASTER<span class="emphasis">_USER=&#x27;repl&#x27;, MASTER_</span>PASSWORD=&#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;start slave;&quot;</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;show slave status\G&quot;|grep Running:</span><br><span class="line"><span class="section"># db02</span></span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;CHANGE MASTER TO</span><br><span class="line">MASTER<span class="emphasis">_HOST=&#x27;10.0.0.51&#x27;, MASTER_</span>PORT=3307, MASTER<span class="emphasis">_AUTO_</span>POSITION=1,</span><br><span class="line">MASTER<span class="emphasis">_USER=&#x27;repl&#x27;, MASTER_</span>PASSWORD=&#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;start slave;&quot;</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;show slave status\G&quot;|grep Running:</span><br><span class="line"><span class="section">## 10.0.0.51:3309 ------&gt; 10.0.0.51:3307</span></span><br><span class="line"></span><br><span class="line"><span class="section"># db01</span></span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;CHANGE MASTER TO</span><br><span class="line">MASTER<span class="emphasis">_HOST=&#x27;10.0.0.51&#x27;, MASTER_</span>PORT=3307, MASTER<span class="emphasis">_AUTO_</span>POSITION=1,</span><br><span class="line">MASTER<span class="emphasis">_USER=&#x27;repl&#x27;, MASTER_</span>PASSWORD=&#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;start slave;&quot;</span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;show slave status\G&quot;|grep Running:</span><br><span class="line"><span class="section">## 10.0.0.52:3309 ------&gt; 10.0.0.52:3307</span></span><br><span class="line"><span class="section"># db02</span></span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;CHANGE MASTER TO</span><br><span class="line">MASTER<span class="emphasis">_HOST=&#x27;10.0.0.52&#x27;, MASTER_</span>PORT=3307, MASTER<span class="emphasis">_AUTO_</span>POSITION=1,</span><br><span class="line">MASTER<span class="emphasis">_USER=&#x27;repl&#x27;, MASTER_</span>PASSWORD=&#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;start slave;&quot;</span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;show slave status\G&quot;|grep Running:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====================================================================</span><br><span class="line"><span class="section"># shard2</span></span><br><span class="line"><span class="section">## 10.0.0.52:3308 &lt;-----&gt; 10.0.0.51:3308</span></span><br><span class="line"><span class="section"># db01</span></span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;create user repl@&#x27;10.0.0.%&#x27; identified</span><br><span class="line">with mysql<span class="emphasis">_native_</span>password by &#x27;123&#x27;; grant replication slave on <span class="emphasis">*.*</span> to</span><br><span class="line">repl@&#x27;10.0.0.%&#x27;;&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;create user root@&#x27;10.0.0.%&#x27; identified</span><br><span class="line">with mysql<span class="emphasis">_native_</span>password by &#x27;123&#x27;; grant all on <span class="emphasis">*.*</span> to root@&#x27;10.0.0.%&#x27;;</span><br><span class="line">&quot;</span><br><span class="line"><span class="section"># db02</span></span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;CHANGE MASTER TO</span><br><span class="line">MASTER<span class="emphasis">_HOST=&#x27;10.0.0.51&#x27;, MASTER_</span>PORT=3308, MASTER<span class="emphasis">_AUTO_</span>POSITION=1,</span><br><span class="line">MASTER<span class="emphasis">_USER=&#x27;repl&#x27;, MASTER_</span>PASSWORD=&#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;start slave;&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;show slave status\G&quot;|grep Running:</span><br><span class="line"><span class="section"># db01</span></span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;CHANGE MASTER TO</span><br><span class="line">MASTER<span class="emphasis">_HOST=&#x27;10.0.0.52&#x27;, MASTER_</span>PORT=3308, MASTER<span class="emphasis">_AUTO_</span>POSITION=1,</span><br><span class="line">MASTER<span class="emphasis">_USER=&#x27;repl&#x27;, MASTER_</span>PASSWORD=&#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;start slave;&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;show slave status\G&quot;|grep Running:</span><br><span class="line"><span class="section">## 10.0.0.52:3310 -----&gt; 10.0.0.52:3308</span></span><br><span class="line"><span class="section"># db02</span></span><br><span class="line">mysql -S /data/3310/mysql.sock -e &quot;CHANGE MASTER TO</span><br><span class="line">MASTER<span class="emphasis">_HOST=&#x27;10.0.0.52&#x27;, MASTER_</span>PORT=3308, MASTER<span class="emphasis">_AUTO_</span>POSITION=1,</span><br><span class="line">MASTER<span class="emphasis">_USER=&#x27;repl&#x27;, MASTER_</span>PASSWORD=&#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3310/mysql.sock -e &quot;start slave;&quot;</span><br><span class="line">mysql -S /data/3310/mysql.sock -e &quot;show slave status\G&quot;|grep Running:</span><br><span class="line"><span class="section">##10.0.0.51:3310 -----&gt; 10.0.0.51:3308</span></span><br><span class="line"></span><br><span class="line"><span class="section"># db01</span></span><br><span class="line">mysql -S /data/3310/mysql.sock -e &quot;CHANGE MASTER TO</span><br><span class="line">MASTER<span class="emphasis">_HOST=&#x27;10.0.0.51&#x27;, MASTER_</span>PORT=3308, MASTER<span class="emphasis">_AUTO_</span>POSITION=1,</span><br><span class="line">MASTER<span class="emphasis">_USER=&#x27;repl&#x27;, MASTER_</span>PASSWORD=&#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3310/mysql.sock -e &quot;start slave;&quot;</span><br><span class="line">mysql -S /data/3310/mysql.sock -e &quot;show slave status\G&quot;|grep Running:</span><br><span class="line">2.9 检测主从状态</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;show slave status\G&quot;|grep Yes</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;show slave status\G&quot;|grep Yes</span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;show slave status\G&quot;|grep Yes</span><br><span class="line">mysql -S /data/3310/mysql.sock -e &quot;show slave status\G&quot;|grep Yes</span><br><span class="line">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">注：如果中间出现错误，在每个节点进行执行以下命令，从2.8从头执行</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;stop slave; reset slave all;&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;stop slave; reset slave all;&quot;</span><br><span class="line">mysql -S /data/3309/mysql.sock -e &quot;stop slave; reset slave all;&quot;</span><br><span class="line">mysql -S /data/3310/mysql.sock -e &quot;stop slave; reset slave all;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="3-MyCAT安装"><a href="#3-MyCAT安装" class="headerlink" title="3.MyCAT安装"></a>3.MyCAT安装</h1><h2 id="3-1-预先安装Java运行环境"><a href="#3-1-预先安装Java运行环境" class="headerlink" title="3.1 预先安装Java运行环境"></a>3.1 预先安装Java运行环境</h2><p><code>yum install -y java </code></p>
<h2 id="3-2下载"><a href="#3-2下载" class="headerlink" title="3.2下载"></a>3.2下载</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Mycat-server-xxxxx.linux.tar.gz</span><br><span class="line">http://dl.mycat.org.cn/</span><br></pre></td></tr></table></figure>

<h2 id="3-3-解压文件"><a href="#3-3-解压文件" class="headerlink" title="3.3 解压文件"></a>3.3 解压文件</h2><p> <code>tar xf Mycat-server-*  </code></p>
<h2 id="3-4-软件目录结构"><a href="#3-4-软件目录结构" class="headerlink" title="3.4 软件目录结构"></a>3.4 软件目录结构</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">bin catlet conf lib logs version.txt</span><br></pre></td></tr></table></figure>

<h2 id="3-5-启动和连接"><a href="#3-5-启动和连接" class="headerlink" title="3.5 启动和连接"></a>3.5 启动和连接</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">export PATH=/data/app/mycat/bin:$PATH</span><br><span class="line">source /etc/profile</span><br><span class="line">mycat start</span><br><span class="line">mysql -uroot -p123456 -h 127.0.0.1 -P8066</span><br><span class="line">注： Mycat中使用的是MySQL 5.1版本驱动，连接8.0时将会失败。</span><br><span class="line"></span><br><span class="line"><span class="section"># 解决方案：</span></span><br><span class="line"><span class="bullet">1.</span> 下载更新客户端程序</span><br><span class="line">https://downloads.mysql.com/archives/c-j/</span><br><span class="line"><span class="bullet">2.</span> 连接时添加auth=mysql<span class="emphasis">_native_</span>password参数</span><br><span class="line">mysql -uroot -p123456 -h10.0.0.51 -P8066 --defaultauth=mysql<span class="emphasis">_native_</span>password</span><br><span class="line"><span class="bullet">3.</span> 更新MySQL客户端命令为8.0之前版本</span><br></pre></td></tr></table></figure>

<h1 id="4-配置文件介绍"><a href="#4-配置文件介绍" class="headerlink" title="4.配置文件介绍"></a>4.配置文件介绍</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4.1 bin 目录</span><br><span class="line">程序目录</span><br><span class="line">4.2 conf</span><br><span class="line">配置文件目录</span><br><span class="line">4.2.1 schema.xml</span><br><span class="line">主配置文件：节点信息、读写分离、高可用设置、调用分片策略..</span><br><span class="line">4.2.2 rule.xml</span><br><span class="line">分片策略的定义、功能、使用用方法</span><br><span class="line">4.2.3 server.xml</span><br><span class="line">mycat服务有关配置： 用户、网络、权限、策略、资源...</span><br><span class="line">4.2.4 xx.txt文件</span><br><span class="line">分片参数定义文件</span><br><span class="line">4.2.5 log4j2.xml</span><br><span class="line">Mycat 相关日志记录配置</span><br><span class="line">4.3 logs</span><br><span class="line">wrapper.log : 启动日志</span><br><span class="line">mycat.log ：工作日志</span><br></pre></td></tr></table></figure>

<h1 id="5-schema-xml配置文件基本结构"><a href="#5-schema-xml配置文件基本结构" class="headerlink" title="5.schema.xml配置文件基本结构"></a>5.schema.xml配置文件基本结构</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[root@db01 conf]# cd /data/mycat/conf/</span><br><span class="line">mv schema.xml schema.xml.bak</span><br><span class="line">vim schema.xml</span><br><span class="line"><span class="section"># 逻辑库：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span></span><br><span class="line"><span class="section"># DN数据节点（逻辑分片）：数据节点（逻辑分片）：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>= <span class="string">&quot;world&quot;</span> /&gt;</span></span></span><br><span class="line">作用：</span><br><span class="line">垂直和水平查分。</span><br><span class="line"><span class="section"># DH 数据主机</span></span><br><span class="line">作用： 高可用和读写分离</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>select user()<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span><br><span class="line"><span class="section"><span class="language-xml"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span></span></span><br><span class="line"><span class="section">====================================</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-配置文件简单试水-读写分离"><a href="#5-2-配置文件简单试水-读写分离" class="headerlink" title="5.2 配置文件简单试水-读写分离"></a>5.2 配置文件简单试水-读写分离</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#配置文件模板-读写分离</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>= <span class="string">&quot;world&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>select user()<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span></span><br><span class="line"><span class="section"># 测试环境准备</span></span><br><span class="line">db01:</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;grant all on <span class="emphasis">*.*</span> to root@&#x27;10.0.0.%&#x27;</span><br><span class="line">identified by &#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;source /root/world.sql&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;grant all on <span class="emphasis">*.*</span> to root@&#x27;10.0.0.%&#x27;</span><br><span class="line">identified by &#x27;123&#x27;;&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;source /root/world.sql&quot;</span><br><span class="line"><span class="section"># 重启mycat</span></span><br><span class="line">mycat restart</span><br><span class="line">读写分离测试</span><br><span class="line"><span class="section"># 连接mycat 服务</span></span><br><span class="line">[root@db01 ~]# mysql -uroot -p123456 -h 10.0.0.51 -P8066</span><br><span class="line"><span class="section"># 测试读</span></span><br><span class="line">mysql&gt; select @@server<span class="emphasis">_id;</span></span><br><span class="line"><span class="emphasis"># 测试写</span></span><br><span class="line"><span class="emphasis">mysql&gt; begin ; select @@server_</span>id;commit;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-配置读写分离及高可用"><a href="#5-3-配置读写分离及高可用" class="headerlink" title="5.3 配置读写分离及高可用"></a>5.3 配置读写分离及高可用</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[root@db01 conf]# mv schema.xml schema.xml.rw</span><br><span class="line">[root@db01 conf]# vim schema.xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">dataNode</span>=<span class="string">&quot;sh1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;sh1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;oldguo1&quot;</span> <span class="attr">database</span>= <span class="string">&quot;world&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;oldguo1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>select user()<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db4&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span></span><br><span class="line">primary writehost ：负责写操作的writehost</span><br><span class="line">standby writeHost ：和readhost一样，只提供读服务</span><br><span class="line">当写节点宕机后，后面跟的readhost也不提供服务，这时候standby的writehost就提供写服务，</span><br><span class="line">后面跟的readhost提供读服务</span><br><span class="line">测试读写分离：</span><br><span class="line">mycat restart</span><br><span class="line">mysql -uroot -p123456 -h 10.0.0.51 -P 8066</span><br><span class="line">mysql&gt; select @@server<span class="emphasis">_id;</span></span><br><span class="line"><span class="emphasis">mysql&gt; begin;select @@server_</span>id;commit;</span><br><span class="line">测试高可用：</span><br><span class="line">[root@db01 conf]# systemctl stop mysqld3307</span><br><span class="line">mysql -uroot -p123456 -h 10.0.0.51 -P 8066</span><br><span class="line">mysql&gt; select @@server<span class="emphasis">_id;</span></span><br><span class="line"><span class="emphasis">mysql&gt; begin;select @@server_</span>id;commit;</span><br><span class="line">[root@db01 conf]# systemctl start mysqld3307</span><br><span class="line">mysql -uroot -p123456 -h 10.0.0.51 -P 8066</span><br><span class="line">mysql&gt; select @@server<span class="emphasis">_id;</span></span><br><span class="line"><span class="emphasis">mysql&gt; begin;select @@server_</span>id;commit;</span><br><span class="line"></span><br><span class="line"><span class="section"># 说明：</span></span><br><span class="line"><span class="bullet">1.</span> MHA + Mycat+ 3分片</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;mha1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>show slave status<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.55:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.53:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;mha2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>show slave status<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.56:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.53:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;mha3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>show slave status<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.57:3308&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3308&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3308&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> PXC+Mycat+3分片</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;pxc1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>show status like &#x27;wsrep%&#x27;<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.53:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span><br><span class="line">...此处省略...</span><br><span class="line">   </span><br><span class="line"><span class="bullet">4.</span> 调研： MGR+Mycat+3分片</span><br><span class="line">  </span><br><span class="line"><span class="bullet">6.</span> 调研： DBLE</span><br></pre></td></tr></table></figure>

<h2 id="5-4-Schema-xml核心参数介绍"><a href="#5-4-Schema-xml核心参数介绍" class="headerlink" title="5.4 Schema.xml核心参数介绍"></a>5.4 Schema.xml核心参数介绍</h2><h3 id="5-4-1-balance属性"><a href="#5-4-1-balance属性" class="headerlink" title="5.4.1 balance属性"></a>5.4.1 balance属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">读操作负载均衡类型，目前的取值有3种：</span><br><span class="line"><span class="bullet">1.</span> balance=&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的writeHost上。</span><br><span class="line"><span class="bullet">2.</span> balance=&quot;1&quot;，全部的readHost与standby writeHost参与select语句的负载均衡，简单的</span><br><span class="line">说，</span><br><span class="line">当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且M1与 M2互为主备)，正常情况下，M2,S1,S2都参与select</span><br><span class="line">语句的负载均衡。</span><br><span class="line"><span class="bullet">3.</span> balance=&quot;2&quot;，所有读操作都随机的在writeHost、readhost上分发。</span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-writeType属性"><a href="#5-4-2-writeType属性" class="headerlink" title="5.4.2 writeType属性"></a>5.4.2 writeType属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">写操作负载均衡，目前的取值有2种：</span><br><span class="line"><span class="bullet">1.</span> writeType=&quot;0&quot;, 所有写操作发送到配置的第一个writeHost，</span><br><span class="line">第一个挂了切到还生存的第二个writeHost，重新启动后已切换后的为主，切换记录在配置文件</span><br><span class="line">中:dnindex.properties .</span><br><span class="line"><span class="bullet">2.</span> writeType=“1”，所有写操作都随机的发送到配置的writeHost，但不推荐使用</span><br></pre></td></tr></table></figure>

<h3 id="5-4-3-switchType属性"><a href="#5-4-3-switchType属性" class="headerlink" title="5.4.3 switchType属性"></a>5.4.3 switchType属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-1: 表示不自动切换</span><br><span class="line">1 : 默认值，自动切换</span><br><span class="line">2 : 基于MySQL主从同步的状态决定是否切换 ，心跳语句为 show slave status (注意超时参数，</span><br><span class="line">参考orch)</span><br><span class="line">3 : 基于Galary Cluster（PXC,MGC） 切换机制，心跳语句为：show status like &#x27;wsrep%&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-4-连接有关"><a href="#5-4-4-连接有关" class="headerlink" title="5.4.4 连接有关"></a>5.4.4 连接有关</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">maxCon=&quot;1000&quot;：最大的并发连接数</span><br><span class="line">minCon=&quot;10&quot; ：mycat在启动之后，会在后端节点上自动开启的连接线程</span><br></pre></td></tr></table></figure>

<h3 id="5-4-5-tempReadHostAvailable-x3D-”1”"><a href="#5-4-5-tempReadHostAvailable-x3D-”1”" class="headerlink" title="5.4.5 tempReadHostAvailable&#x3D;”1”"></a>5.4.5 tempReadHostAvailable&#x3D;”1”</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这个一主一从时（1个writehost，1个readhost时），可以开启这个参数，如果2个writehost，2个</span><br><span class="line">readhost时</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>select user()<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span> 监测心跳</span><br></pre></td></tr></table></figure>

<h3 id="5-4-6-checkSQLschema-x3D-”false”"><a href="#5-4-6-checkSQLschema-x3D-”false”" class="headerlink" title="5.4.6 checkSQLschema&#x3D;”false”"></a>5.4.6 checkSQLschema&#x3D;”false”</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">是否检查，在select时的库名字。</span><br><span class="line">例如，执行 select * from TESTDB.t1;</span><br><span class="line">参数开启为true，会自动架构TESTDB去掉。否则会使得后端节点执行报错。</span><br><span class="line">当然如果，TESTDB写成了一个不存在的逻辑库名字，也会报错。</span><br><span class="line">结论： 一般我们可以先use，后select的方式进行查询数据即可避免此类问题。</span><br></pre></td></tr></table></figure>

<h1 id="6-Mycat-分布式架构–垂直分表"><a href="#6-Mycat-分布式架构–垂直分表" class="headerlink" title="6.Mycat 分布式架构–垂直分表"></a>6.Mycat 分布式架构–垂直分表</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">taobao user （sh1），order<span class="emphasis">_t(sh2) ,others(sh3)</span></span><br><span class="line"><span class="emphasis">cd /data/app/mycat/conf</span></span><br><span class="line"><span class="emphasis">mv schema.xml schema.xml.ha</span></span><br><span class="line"><span class="emphasis">vim schema.xml</span></span><br><span class="line"><span class="emphasis">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="emphasis">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">dataNode</span>=<span class="string">&quot;sh1&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1&quot;</span>/&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;order_t&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh2&quot;</span>/&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;sh1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;oldguo1&quot;</span> <span class="attr">database</span>= <span class="string">&quot;taobao&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;sh2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;oldguo2&quot;</span> <span class="attr">database</span>= <span class="string">&quot;taobao&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;oldguo1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>select user()<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3307&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db4&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3309&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;oldguo2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span></span>select user()<span class="language-xml"><span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3308&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.51:3310&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;db3&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3308&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;db4&quot;</span> <span class="attr">url</span>=<span class="string">&quot;10.0.0.52:3310&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">password</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">创建测试库和表:</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3307/mysql.sock -e &quot;create database taobao charset utf8;&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;create database taobao charset utf8;&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3307/mysql.sock -e &quot;use taobao;create table user(id int,name</span></span><br><span class="line"><span class="emphasis">varchar(20))&quot;;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;use taobao;create table order_</span>t(id</span><br><span class="line">int,name varchar(20))&quot;</span><br><span class="line"><span class="section"># 重启mycat</span></span><br><span class="line">mycat restart</span><br><span class="line"><span class="section"># mycat中对user 和 order 数据插入</span></span><br><span class="line">mysql -uroot -p123456 -h10.0.0.51 -P8066 --defaultauth=mysql<span class="emphasis">_native_</span>password</span><br><span class="line">insert into user values(1,&#x27;a&#x27;);</span><br><span class="line">insert into user values(2,&#x27;b&#x27;);</span><br><span class="line">insert into user values(3,&#x27;c&#x27;);</span><br><span class="line">commit;</span><br><span class="line">insert into order<span class="emphasis">_t values(1,&#x27;x&#x27;),(2,&#x27;y&#x27;);</span></span><br><span class="line"><span class="emphasis">commit;</span></span><br><span class="line"><span class="emphasis">[root@db01 conf]# mysql -S /data/3307/mysql.sock -e &quot;show tables from</span></span><br><span class="line"><span class="emphasis">taobao&quot;</span></span><br><span class="line"><span class="emphasis">+------------------+</span></span><br><span class="line"><span class="emphasis">| Tables_</span>in<span class="emphasis">_taobao |</span></span><br><span class="line"><span class="emphasis">+------------------+</span></span><br><span class="line"><span class="emphasis">| user 						 |</span></span><br><span class="line"><span class="emphasis">+------------------+</span></span><br><span class="line"><span class="emphasis">[root@db01 conf]# mysql -S /data/3308/mysql.sock -e &quot;show tables from</span></span><br><span class="line"><span class="emphasis">taobao&quot;</span></span><br><span class="line"><span class="emphasis">+------------------+</span></span><br><span class="line"><span class="emphasis">| Tables_</span>in<span class="emphasis">_taobao |</span></span><br><span class="line"><span class="emphasis">+------------------+</span></span><br><span class="line"><span class="emphasis">| order_</span>t          |</span><br><span class="line">+------------------+</span><br><span class="line">[root@db01 conf]# mysql -S /data/3307/mysql.sock -e &quot;select * from</span><br><span class="line">taobao.user&quot;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">| 1    | a    |</span><br><span class="line">| 2    | b    | </span><br><span class="line">| 3    | c    |</span><br><span class="line">+------+------+</span><br><span class="line">[root@db01 conf]# mysql -S /data/3308/mysql.sock -e &quot;select * from</span><br><span class="line">taobao.order<span class="emphasis">_t&quot;</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| id   | name |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">| 1    | x    |</span></span><br><span class="line"><span class="emphasis">| 2    | y    |</span></span><br><span class="line"><span class="emphasis">+------+------+</span></span><br><span class="line"><span class="emphasis">[root@db01 conf]#</span></span><br></pre></td></tr></table></figure>

<h1 id="7-Mycat-分布式架构–水平拆分"><a href="#7-Mycat-分布式架构–水平拆分" class="headerlink" title="7. Mycat 分布式架构–水平拆分"></a>7. Mycat 分布式架构–水平拆分</h1><h2 id="7-0-重要概念"><a href="#7-0-重要概念" class="headerlink" title="7.0 重要概念"></a>7.0 重要概念</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">分片策略 ：几乎融合经典业务中大部分的分片策略。Mycat已经开发了相应算法，非常方便调用。</span><br><span class="line">范围分片</span><br><span class="line">取模</span><br><span class="line">枚举</span><br><span class="line">日期</span><br><span class="line">HASH</span><br><span class="line">等。</span><br><span class="line">分片键： 作为分片条件的列。</span><br></pre></td></tr></table></figure>

<h2 id="7-1-范围分片"><a href="#7-1-范围分片" class="headerlink" title="7.1 范围分片"></a>7.1 范围分片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">比如说t3表</span><br><span class="line">(1)行数非常多，2000w（1-1000w:sh1 1000w01-2000w:sh2）</span><br><span class="line">(2)访问非常频繁，用户访问较离散</span><br><span class="line"><span class="section"># 1. 修改schema.xml文件，定制分片策略</span></span><br><span class="line">cp schema.xml schema.xml.1</span><br><span class="line">vim schema.xml</span><br><span class="line">添加：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;t3&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2. 定义和使用分片策略</span></span><br><span class="line">vim rule.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span></span><br><span class="line">   			<span class="language-xml"><span class="tag">&lt;<span class="name">columns</span>&gt;</span></span>id<span class="language-xml"><span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span></span><br><span class="line">   			<span class="language-xml"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span></span>rang-long<span class="language-xml"><span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span></span><br><span class="line">   </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">	<span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">	&lt;property name=&quot;mapFile&quot;&gt;autopartition-long.txt&lt;/property&gt;</span></span><br><span class="line"><span class="code">&lt;/function&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3. 定义范围</span></span><br><span class="line">vim autopartition-long.txt</span><br><span class="line">0-10=0</span><br><span class="line">10-20=1</span><br><span class="line"></span><br><span class="line"><span class="section"># 4. 创建测试表：</span></span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;use taobao;create table t3 (id int not</span><br><span class="line">null primary key auto<span class="emphasis">_increment,name varchar(20) not null);&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;use taobao;create table t3 (id int not</span></span><br><span class="line"><span class="emphasis">null primary key auto_</span>increment,name varchar(20) not null);&quot;</span><br><span class="line"></span><br><span class="line"><span class="section"># 5. 测试：</span></span><br><span class="line">重启mycat</span><br><span class="line">mycat restart</span><br><span class="line">mysql -uroot -p123456 -h 10.0.0.51 -P 8066</span><br><span class="line">insert into t3(id,name) values(1,&#x27;a&#x27;);</span><br><span class="line">insert into t3(id,name) values(2,&#x27;b&#x27;);</span><br><span class="line">insert into t3(id,name) values(3,&#x27;c&#x27;);</span><br><span class="line">insert into t3(id,name) values(4,&#x27;d&#x27;);</span><br><span class="line">insert into t3(id,name) values(11,&#x27;aa&#x27;);</span><br><span class="line">insert into t3(id,name) values(12,&#x27;bb&#x27;);</span><br><span class="line">insert into t3(id,name) values(13,&#x27;cc&#x27;);</span><br><span class="line">insert into t3(id,name) values(14,&#x27;dd&#x27;);</span><br><span class="line">[root@db01 conf]# mysql -S /data/3308/mysql.sock -e &quot;select * from</span><br><span class="line">taobao.t3&quot;</span><br><span class="line">[root@db01 conf]# mysql -S /data/3307/mysql.sock -e &quot;select * from</span><br><span class="line">taobao.t3&quot;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-取模分片"><a href="#7-2-取模分片" class="headerlink" title="7.2 取模分片"></a>7.2 取模分片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1%3 1</span><br><span class="line">2%3 2</span><br><span class="line">3%3 0</span><br><span class="line">4%3 1</span><br><span class="line">任何正整数数字和N（正整数）取模，得的值永远都是 0~N-1</span><br><span class="line">id % 分片数量取模</span><br><span class="line">N % 5 = 0-4 idx</span><br><span class="line">取余分片方式：分片键（一个列）与节点数量进行取余，得到余数，将数据写入对应节点</span><br><span class="line"><span class="section"># 1. 修改配置文件</span></span><br><span class="line">vim schema.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;t4&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2. 查看和定义分片使用</span></span><br><span class="line">vim rule.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span>2<span class="language-xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3. 准备测试环境</span></span><br><span class="line">创建测试表：</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;use taobao;create table t4 (id int not</span><br><span class="line">null primary key auto<span class="emphasis">_increment,name varchar(20) not null);&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;use taobao;create table t4 (id int not</span></span><br><span class="line"><span class="emphasis">null primary key auto_</span>increment,name varchar(20) not null);&quot;</span><br><span class="line">重启mycat</span><br><span class="line">mycat restart</span><br><span class="line"></span><br><span class="line"><span class="section"># 4. 测试：</span></span><br><span class="line">mysql -uroot -p123456 -h10.0.0.51 -P8066</span><br><span class="line">use TESTDB</span><br><span class="line">insert into t4(id,name) values(1,&#x27;a&#x27;);</span><br><span class="line">insert into t4(id,name) values(2,&#x27;b&#x27;);</span><br><span class="line">insert into t4(id,name) values(3,&#x27;c&#x27;);</span><br><span class="line">insert into t4(id,name) values(4,&#x27;d&#x27;);</span><br><span class="line">insert into t4(id,name) values(6,&#x27;x&#x27;),(8,&#x27;y&#x27;),(10,&#x27;z&#x27;);</span><br><span class="line">分别登录后端节点查询数据</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;select * from taobao.t4&quot;</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;select * from taobao.t4&quot;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-月份分片"><a href="#7-3-月份分片" class="headerlink" title="7.3 月份分片"></a>7.3 月份分片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">假设，tm (id int not null primary key,create<span class="emphasis">_time datetime)</span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-month&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">   <span class="language-xml"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">  	 	<span class="language-xml"><span class="tag">&lt;<span class="name">columns</span>&gt;</span></span>create_</span>time<span class="language-xml"><span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span></span><br><span class="line">  		 <span class="language-xml"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span></span>partbymonth<span class="language-xml"><span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;partbymonth&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMonth&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">		&lt;property name=&quot;dateFormat&quot;&gt;yyyy-MM-dd&lt;/property&gt;</span></span><br><span class="line"><span class="code">		&lt;property name=&quot;sBeginDate&quot;&gt;2020-01-01&lt;/property&gt;</span></span><br><span class="line"><span class="code">&lt;/function</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;use taobao;create table tm (id int not</span><br><span class="line">null primary key auto<span class="emphasis">_increment,create_</span>time datetime not null);&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;use taobao;create table tm (id int not</span><br><span class="line">null primary key auto<span class="emphasis">_increment,create_</span>time datetime not null);&quot;</span><br><span class="line">测试例子：</span><br></pre></td></tr></table></figure>

<h2 id="7-4-枚举分片"><a href="#7-4-枚举分片" class="headerlink" title="7.4 枚举分片"></a>7.4 枚举分片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">t5 表</span><br><span class="line">id name telnum</span><br><span class="line">1 bj 1212</span><br><span class="line">2 sh 22222</span><br><span class="line">3 bj 3333</span><br><span class="line">4 sh 44444</span><br><span class="line">5 bj 5555</span><br><span class="line"></span><br><span class="line">sharding-by-intfile</span><br><span class="line"></span><br><span class="line"><span class="section"># 1. 设计分片策略</span></span><br><span class="line">vim schema.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;t5&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-intfile&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2. 应用分片策略</span></span><br><span class="line">vim rule.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-intfile&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">	&lt;rule&gt;</span></span><br><span class="line"><span class="code">		&lt;columns&gt;name&lt;/columns&gt;</span></span><br><span class="line"><span class="code">		&lt;algorithm&gt;hash-int&lt;/algorithm&gt;</span></span><br><span class="line"><span class="code">	&lt;/rule&gt;</span></span><br><span class="line"><span class="code">&lt;/tableRule&gt;</span></span><br><span class="line"><span class="code">&lt;function name=&quot;hash-int&quot;</span></span><br><span class="line"><span class="code">class=&quot;org.opencloudb.route.function.PartitionByFileMap&quot;&gt;</span></span><br><span class="line"><span class="code">&lt;property name=&quot;mapFile&quot;&gt;partition-hash-int.txt&lt;/property&gt;</span></span><br><span class="line"><span class="code">	&lt;property name=&quot;type&quot;&gt;1&lt;/property&gt;</span></span><br><span class="line"><span class="code">&lt;/function&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">vim partition-hash-int.txt 配置：</span><br><span class="line">bj=0</span><br><span class="line">sh=1</span><br><span class="line">DEFAULT<span class="emphasis">_NODE=1</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 3. 准备测试环境</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3307/mysql.sock -e &quot;use taobao;create table t5 (id int not</span></span><br><span class="line"><span class="emphasis">null primary key auto_</span>increment,name varchar(20) not null);&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;use taobao;create table t5 (id int not</span><br><span class="line">null primary key auto<span class="emphasis">_increment,name varchar(20) not null);&quot;</span></span><br><span class="line"><span class="emphasis">重启mycat</span></span><br><span class="line"><span class="emphasis">mycat restart</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 4. 插入测试数据：</span></span><br><span class="line"><span class="emphasis">mysql -uroot -p123456 -h10.0.0.51 -P8066</span></span><br><span class="line"><span class="emphasis">use TESTDB</span></span><br><span class="line"><span class="emphasis">insert into t5(id,name) values(1,&#x27;bj&#x27;);</span></span><br><span class="line"><span class="emphasis">insert into t5(id,name) values(2,&#x27;sh&#x27;);</span></span><br><span class="line"><span class="emphasis">insert into t5(id,name) values(3,&#x27;bj&#x27;);</span></span><br><span class="line"><span class="emphasis">insert into t5(id,name) values(4,&#x27;sh&#x27;);</span></span><br><span class="line"><span class="emphasis">insert into t5(id,name) values(5,&#x27;tj&#x27;);</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;select * from taobao.t5&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3307/mysql.sock -e &quot;select * from taobao.t5&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-5-Mycat全局表"><a href="#7-5-Mycat全局表" class="headerlink" title="7.5 Mycat全局表"></a>7.5 Mycat全局表</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">a b c d .....</span><br><span class="line">join</span><br><span class="line">t</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">id name age</span><br><span class="line"></span><br><span class="line">1 zs 18 sh1</span><br><span class="line">id addr aid</span><br><span class="line">1001 bj 1</span><br><span class="line">1002 sh 2</span><br><span class="line"></span><br><span class="line">2 ls 19 sh2</span><br><span class="line">id addr aid</span><br><span class="line">1001 bj 1</span><br><span class="line">1002 sh 2</span><br><span class="line"></span><br><span class="line">t</span><br><span class="line">id addr aid</span><br><span class="line">1001 bj 1</span><br><span class="line">1002 sh 2</span><br><span class="line"></span><br><span class="line">使用场景：</span><br><span class="line">如果你的业务中有些数据类似于数据字典，比如配置文件的配置，</span><br><span class="line">常用业务的配置或者数据量不大很少变动的表，这些表往往不是特别大，</span><br><span class="line">而且大部分的业务场景都会用到，那么这种表适合于Mycat全局表，无须对数据进行切分，</span><br><span class="line">要在所有的分片上保存一份数据即可，Mycat 在Join操作中，业务表与全局表进行Join聚合会优先选</span><br><span class="line">择相同分片内的全局表join，</span><br><span class="line">避免跨库Join，在进行数据插入操作时，mycat将把数据分发到全局表对应的所有分片执行，在进行数</span><br><span class="line">据读取时候将会随机获取一个节点读取数据。</span><br><span class="line"></span><br><span class="line"><span class="section"># 1. 设置全局表策略</span></span><br><span class="line">vim schema.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;t_area&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2. 后端数据准备</span></span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;use taobao;create table t<span class="emphasis">_area (id int</span></span><br><span class="line"><span class="emphasis">not null primary key auto_</span>increment,name varchar(20) not null);&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;use taobao;create table t<span class="emphasis">_area (id int</span></span><br><span class="line"><span class="emphasis">not null primary key auto_</span>increment,name varchar(20) not null);&quot;</span><br><span class="line">重启mycat</span><br><span class="line">mycat restart</span><br><span class="line"></span><br><span class="line"><span class="section"># 3. 测试：</span></span><br><span class="line">mysql -uroot -p123456 -h10.0.0.51 -P8066</span><br><span class="line">  use TESTDB</span><br><span class="line"><span class="code">     insert into t_area(id,name) values(1,&#x27;a&#x27;);</span></span><br><span class="line"><span class="code">     insert into t_area(id,name) values(2,&#x27;b&#x27;);</span></span><br><span class="line"><span class="code">     insert into t_area(id,name) values(3,&#x27;c&#x27;);</span></span><br><span class="line"><span class="code">     insert into t_area(id,name) values(4,&#x27;d&#x27;);</span></span><br><span class="line"><span class="code">     </span></span><br><span class="line"><span class="code">mysql -S /data/3308/mysql.sock -e &quot;select * from taobao.t_area&quot;</span></span><br><span class="line"><span class="code">mysql -S /data/3307/mysql.sock -e &quot;select * from taobao.t_area&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-6-E-R-分片"><a href="#7-6-E-R-分片" class="headerlink" title="7.6 E-R  分片"></a>7.6 E-R  分片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">join</span><br><span class="line">b</span><br><span class="line">on a.xx =b.yy</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">id name</span><br><span class="line">1 a sh1</span><br><span class="line">3 c</span><br><span class="line"></span><br><span class="line">2 b sh2</span><br><span class="line">4 d</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">id addr aid</span><br><span class="line">1001 bj 1</span><br><span class="line">1002 sh 2</span><br><span class="line"></span><br><span class="line">1003 tj 3 sh2</span><br><span class="line">1004 wh 4</span><br><span class="line"></span><br><span class="line">为了防止跨分片join，可以使用E-R模式</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">		&lt;childTable name=&quot;b&quot; joinKey=&quot;aid&quot; parentKey=&quot;id&quot; /&gt;</span></span><br><span class="line"><span class="code">&lt;/table&gt;</span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">select * from a join b on a.id = b.aid where a.name=d</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">例子：</span><br><span class="line"><span class="bullet">1.</span> 修改配置文件</span><br><span class="line">vim schema.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long_oldguo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">			&lt;childTable name=&quot;b&quot; joinKey=&quot;aid&quot; parentKey=&quot;id&quot; /&gt;</span></span><br><span class="line"><span class="code">&lt;/table&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span> 修改rule.xml mod-log分片策略:</span><br><span class="line">vim rule.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod-long_oldguo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">columns</span>&gt;</span></span>id<span class="language-xml"><span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span></span>mod-long<span class="emphasis">_oldguo<span class="language-xml"><span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long_oldguo&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span>2<span class="language-xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3. 创建测试表</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3307/mysql.sock -e &quot;use taobao;create table a (id int not</span></span><br><span class="line"><span class="emphasis">null primary key auto_</span>increment,name varchar(20) not null);&quot;</span><br><span class="line">mysql -S /data/3307/mysql.sock -e &quot;use taobao;create table b (id int not</span><br><span class="line">null primary key auto<span class="emphasis">_increment,addr varchar(20) not null ,aid int );&quot;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;use taobao;create table a (id int not</span></span><br><span class="line"><span class="emphasis">null primary key auto_</span>increment,name varchar(20) not null);&quot;</span><br><span class="line">mysql -S /data/3308/mysql.sock -e &quot;use taobao;create table b (id int not</span><br><span class="line">null primary key auto<span class="emphasis">_increment,addr varchar(20) not null ,aid int );&quot;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4. 重启mycat 测试</span></span><br><span class="line"><span class="emphasis">mycat restart</span></span><br><span class="line"><span class="emphasis">mysql -uroot -p123456 -h10.0.0.51 -P8066</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">use TESTDB</span></span><br><span class="line"><span class="emphasis">insert into a(id,name) values(1,&#x27;a&#x27;); 1 3308</span></span><br><span class="line"><span class="emphasis">insert into a(id,name) values(2,&#x27;b&#x27;); 0 3307</span></span><br><span class="line"><span class="emphasis">insert into a(id,name) values(3,&#x27;c&#x27;); 1 3308</span></span><br><span class="line"><span class="emphasis">insert into a(id,name) values(4,&#x27;d&#x27;); 0 3307</span></span><br><span class="line"><span class="emphasis">insert into a(id,name) values(5,&#x27;e&#x27;); 1 3308</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">insert into b(id,addr,aid) values(1001,&#x27;bj&#x27;,1); 1 3308</span></span><br><span class="line"><span class="emphasis">insert into b(id,addr,aid) values(1002,&#x27;sj&#x27;,3); 1 3308</span></span><br><span class="line"><span class="emphasis">insert into b(id,addr,aid) values(1003,&#x27;sd&#x27;,4); 0 3307</span></span><br><span class="line"><span class="emphasis">insert into b(id,addr,aid) values(1004,&#x27;we&#x27;,2); 0 3307</span></span><br><span class="line"><span class="emphasis">insert into b(id,addr,aid) values(1005,&#x27;er&#x27;,5); 0 3307</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">========================================================</span></span><br><span class="line"><span class="emphasis">后端数据节点数据分布：</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3307/mysql.sock -e &quot;select * from taobao.a&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3307/mysql.sock -e &quot;select * from taobao.b&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;select * from taobao.a&quot;</span></span><br><span class="line"><span class="emphasis">mysql -S /data/3308/mysql.sock -e &quot;select * from taobao.b&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="8-管理类操作"><a href="#8-管理类操作" class="headerlink" title="8. 管理类操作"></a>8. 管理类操作</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[root@db01 conf]# mysql -uroot -p123456 -h10.0.0.51 -P9066</span><br><span class="line"><span class="section"># 查看帮助</span></span><br><span class="line">show @@help;</span><br><span class="line"><span class="section"># 重新加载配置信息</span></span><br><span class="line">reload @@config ： schema.xml</span><br><span class="line">reload @@config<span class="emphasis">_all : 所有配置重新加载</span></span><br><span class="line"><span class="emphasis">rollback @@config | Rollback all config from memory</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># sql监控分析功能，建议在做压测的时候关闭。</span></span><br><span class="line"><span class="emphasis">reload @@sqlstat=open | Open real-time sql stat analyzer</span></span><br><span class="line"><span class="emphasis">reload @@sqlstat=close | Close real-time sql stat analyzer</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 查看Mycat 服务情况</span></span><br><span class="line"><span class="emphasis">show @@server ;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 查看分片DN节点信息</span></span><br><span class="line"><span class="emphasis">mysql&gt; show @@datanode;</span></span><br><span class="line"><span class="emphasis">mysql&gt; show @@datanode where schema = ?;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 查看数据源</span></span><br><span class="line"><span class="emphasis">show @@datasource</span></span><br><span class="line"><span class="emphasis">show @@datasource where datanode=sh1;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 报告心跳信息</span></span><br><span class="line"><span class="emphasis">show @@heartbeat</span></span><br><span class="line"><span class="emphasis">show @@heartbeat.detail where name=?</span></span><br><span class="line"><span class="emphasis">RS_</span>CODE :</span><br><span class="line">-1：连接失败</span><br><span class="line">1 ：连接正常</span><br><span class="line">-2：连接超时</span><br><span class="line">0 ：初始化状态</span><br><span class="line">如果节点故障，会有5次检测，失败后则状态为-1。</span><br><span class="line"><span class="section"># 查看连接信息</span></span><br><span class="line">show @@connection</span><br><span class="line"><span class="section"># 关闭连接</span></span><br><span class="line">kill @@connection id1,id2,...</span><br><span class="line"><span class="section"># 查看后端连接</span></span><br><span class="line">show @@backend</span><br><span class="line"><span class="section"># 查看缓存应用情况</span></span><br><span class="line">show @@cache;</span><br><span class="line"><span class="section"># 查看sql统计</span></span><br><span class="line">mysql&gt; show @@sql;</span><br><span class="line">mysql&gt; show @@sql<span class="emphasis">_slow;</span></span><br><span class="line"><span class="emphasis">mysql&gt; show @@sql.sum;</span></span><br></pre></td></tr></table></figure>

<h1 id="9-其他管理"><a href="#9-其他管理" class="headerlink" title="9.其他管理"></a>9.其他管理</h1><h2 id="9-1-配置Mycat的日志管理"><a href="#9-1-配置Mycat的日志管理" class="headerlink" title="9.1 配置Mycat的日志管理"></a>9.1 配置Mycat的日志管理</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">asyncRoot</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span></span><br><span class="line">级别：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</span><br><span class="line"><span class="code">                                                       </span></span><br><span class="line"><span class="code">调试建议使用 Debug 级别，生产上一般使用 Info级别 </span></span><br></pre></td></tr></table></figure>

<h2 id="9-2-配置Mycat的服务器参数"><a href="#9-2-配置Mycat的服务器参数" class="headerlink" title="9.2 配置Mycat的服务器参数"></a>9.2 配置Mycat的服务器参数</h2><h3 id="charset-属性"><a href="#charset-属性" class="headerlink" title="charset 属性"></a>charset 属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">该属性用于字符集设置。</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;charset&quot;</span>&gt;</span></span>utf8<span class="language-xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="processors-属性"><a href="#processors-属性" class="headerlink" title="processors 属性"></a>processors 属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">   该属性主要用于指定系统可用的线程数，默认值为机器 CPU 核心线程数。主要影响</span><br><span class="line">processorBufferPool、 processorBufferLocalPercent、 processorExecutor 属性。</span><br><span class="line">NIOProcessor 的个数也是由这个属性定义的，所以调优的时候可以适当的调高这个属性。</span><br></pre></td></tr></table></figure>

<h3 id="processorBufferChunk-属性"><a href="#processorBufferChunk-属性" class="headerlink" title="processorBufferChunk 属性"></a>processorBufferChunk 属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">  该属性指定每次分配 Socket Direct Buffer 的大小，默认是 4096 个字节。这个属性也影响</span><br><span class="line">buffer pool 的长度。如果一次性获取的数过大 buffer 不够用会经常出现警告，此时可以适当调</span><br><span class="line">大。</span><br></pre></td></tr></table></figure>

<h3 id="processorBufferPool-属性"><a href="#processorBufferPool-属性" class="headerlink" title="processorBufferPool 属性"></a>processorBufferPool 属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">该属性指定 bufferPool 计算比例值。由于每次执行 NIO 读、写操作都需要使用到 buffer，</span><br><span class="line">系统初始化的时候会建立一定长度的 buffer 池来加快读、写的效率，减少建立 buffer 的时间。</span><br><span class="line">Mycat 中有两个主要的 buffer 池：</span><br><span class="line"></span><br><span class="line">BufferPool：BufferPool 由 ThreadLocalPool 组合而成，每次从 BufferPool 中获</span><br><span class="line">取 buffer 都会优先获取ThreadLocalPool 中的 buffer，未命中之后才会去获取 BufferPool</span><br><span class="line">中的 buffer。也就是说 ThreadLocalPool 是作为 BufferPool 的二级缓存，每个线程内部</span><br><span class="line">自己使用的。BufferPool 上的 buffer 则是每个 NIOProcessor 都共享的。这个属性的默认值</span><br><span class="line">为：</span><br><span class="line"><span class="code">	默认bufferChunkSize(4096) * processors属性 * 1000</span></span><br><span class="line"><span class="code">	BufferPool 的总长度 = bufferPool / bufferChunk。</span></span><br><span class="line"><span class="code">	若 bufferPool 不是 bufferChunk 的整数倍，则总长度为前面计算得出的商 + 1</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">假设系统线程数为 4，其他都为属性的默认值，则：</span><br><span class="line">bufferPool ＝ 4096 * 4 * 1000</span><br><span class="line">BufferPool 的总长度 : 4000 = 16384000 / 4096</span><br></pre></td></tr></table></figure>

<h3 id="processorBufferLocalPercent-属性"><a href="#processorBufferLocalPercent-属性" class="headerlink" title="processorBufferLocalPercent 属性:"></a>processorBufferLocalPercent 属性:</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">前面提到了 ThreadLocalPool。这个属性就是用来控制分配这个 pool 的大小用的，这个属性</span><br><span class="line">默认值为 100。</span><br><span class="line"></span><br><span class="line"><span class="code">	线程缓存百分比 = bufferLocalPercent / processors 属性。</span></span><br><span class="line"><span class="code">	例如，系统可以同时运行 4 个线程，使用默认值，则根据公式每个线程的百分比为 25。最后根据</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">这个百分比来计算出具体的 ThreadLocalPool 的长度公式如下：</span><br><span class="line"><span class="code">	ThreadLocalPool 的长度 = 线程缓存百分比 * BufferPool 长度 / 100</span></span><br><span class="line"><span class="code">	假设 BufferPool 的长度为 4000，其他保持默认值。</span></span><br><span class="line"><span class="code">	那么最后每个线程建立上的 ThreadLocalPool 的长度为： 1000 = 25 * 4000 / 100</span></span><br></pre></td></tr></table></figure>

<h3 id="心跳属性"><a href="#心跳属性" class="headerlink" title="心跳属性"></a>心跳属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mycat 中有几个周期性的任务来异步的处理一些我需要的工作。这些属性就在系统调优的过程中也是比</span><br><span class="line">不可少的。</span><br><span class="line"></span><br><span class="line">processorCheckPeriod :</span><br><span class="line">清理 NIOProcessor 上前后端空闲、超时和关闭连接的间隔时间。默认是 1 秒，单位毫秒。</span><br><span class="line"></span><br><span class="line">dataNodeIdleCheckPeriod :</span><br><span class="line">对后端连接进行空闲、超时检查的时间间隔，默认是 300 秒，单位毫秒。</span><br><span class="line"></span><br><span class="line">dataNodeHeartbeatPeriod :</span><br><span class="line">对后端所有读、写库发起心跳的间隔时间，默认是 10 秒，单位毫秒。</span><br></pre></td></tr></table></figure>

<h3 id="服务相关属性"><a href="#服务相关属性" class="headerlink" title="服务相关属性"></a>服务相关属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">bindIp :</span><br><span class="line">mycat 服务监听的 IP 地址，默认值为 0.0.0.0。</span><br><span class="line"></span><br><span class="line">serverPort :</span><br><span class="line">定义 mycat 的使用端口，默认值为 8066。</span><br><span class="line"></span><br><span class="line">managerPort :</span><br><span class="line">定义 mycat 的管理端口，默认值为 9066。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Mysql-连接相关属性"><a href="#Mysql-连接相关属性" class="headerlink" title="Mysql 连接相关属性"></a>Mysql 连接相关属性</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">packetHeaderSize :</span><br><span class="line"><span class="code">	指定 Mysql 协议中的报文头长度。默认 4。</span></span><br><span class="line"><span class="code">maxPacketSize :</span></span><br><span class="line"><span class="code">	指定 Mysql 协议可以携带的数据最大长度。默认 16M。</span></span><br><span class="line"><span class="code">idleTimeout :</span></span><br><span class="line"><span class="code">	指定连接的空闲超时时间。某连接在发起空闲检查下，发现距离上次使用超过了空闲时间，那么这</span></span><br><span class="line"><span class="code">个连接会被回收，就是被直接的关闭掉。默认 30 分钟，单位毫秒。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">charset :</span><br><span class="line"><span class="code">	连接的初始化字符集。默认为 utf8。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">txIsolation :</span><br><span class="line"><span class="code">	前端连接的初始化事务隔离级别，只在初始化的时候使用，后续会根据客户端传递过来的属性对后</span></span><br><span class="line"><span class="code">端数据库连接进行同步。默认为 REPEATED_READ，设置值为数字默认 3。</span></span><br><span class="line"><span class="code">READ_UNCOMMITTED = 1;</span></span><br><span class="line"><span class="code">READ_COMMITTED = 2;</span></span><br><span class="line"><span class="code">REPEATED_READ = 3;</span></span><br><span class="line"><span class="code">SERIALIZABLE = 4;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">sqlExecuteTimeout :</span><br><span class="line"><span class="code">	SQL 执行超时的时间，Mycat 会检查连接上最后一次执行 SQL 的时间，若超过这个时间则会直</span></span><br><span class="line"><span class="code">接关闭这连接。默认时间为 300 秒，单位秒。</span></span><br></pre></td></tr></table></figure>

<h1 id="10-逻辑库配置"><a href="#10-逻辑库配置" class="headerlink" title="10.逻辑库配置"></a>10.逻辑库配置</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总配置文件</span></span><br><span class="line">schema.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;oldboy&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">dataNode</span>=<span class="string">&quot;sh1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">	sh3</span></span><br><span class="line"><span class="code">	sh4</span></span><br><span class="line"><span class="code">&lt;/schema&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># mycat 服务配置</span></span><br><span class="line">server.xml</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">      &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;</span></span><br><span class="line"><span class="code">      &lt;property name=&quot;schemas&quot;&gt;oldboy&lt;/property&gt;</span></span><br><span class="line"><span class="code">      &lt;property name=&quot;defaultSchema&quot;&gt;oldboy&lt;/property&gt;</span></span><br><span class="line"><span class="code">			&lt;!--No MyCAT Database selected 错误前会尝试使用该schema作为</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">schema，不设置则为null,报错 --&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	&lt;!-- 表级 DML 权限设置 --&gt;</span></span><br><span class="line"><span class="code">	&lt;!--</span></span><br><span class="line"><span class="code">	&lt;privileges check=&quot;false&quot;&gt;</span></span><br><span class="line"><span class="code">			&lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;</span></span><br><span class="line"><span class="code">					&lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="code">					&lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="code">			&lt;/schema&gt;</span></span><br><span class="line"><span class="code">	&lt;/privileges&gt;</span></span><br><span class="line"><span class="code">  --&gt;</span></span><br><span class="line"><span class="code">&lt;/user&gt;</span></span><br><span class="line"><span class="code">		&lt;user name=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="code">				&lt;property name=&quot;password&quot;&gt;user&lt;/property&gt;</span></span><br><span class="line"><span class="code">				&lt;property name=&quot;schemas&quot;&gt;oldboy&lt;/property&gt;</span></span><br><span class="line"><span class="code">				&lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;</span></span><br><span class="line"><span class="code">				&lt;property name=&quot;defaultSchema&quot;&gt;oldboy&lt;/property&gt;</span></span><br><span class="line"><span class="code">		&lt;/user&gt;</span></span><br><span class="line"><span class="code">reload @@config_all : 所有配置重新加载</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span> 添加一个逻辑库</span><br><span class="line"><span class="code">	schema.xml</span></span><br><span class="line"><span class="code">		&lt;schema name=&quot;oldboy&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;</span></span><br><span class="line"><span class="code">dataNode=&quot;sh1&quot;&gt;</span></span><br><span class="line"><span class="code">		&lt;/schema&gt;</span></span><br><span class="line"><span class="code">  </span></span><br><span class="line"><span class="code">server.xml</span></span><br><span class="line"><span class="code">	&lt;property name=&quot;schemas&quot;&gt;oldboy,oldguo&lt;/property&gt;</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">reload @@config_all : 所有配置重新加载</span></span><br></pre></td></tr></table></figure>

<h1 id="11-sequence分布式全局序列"><a href="#11-sequence分布式全局序列" class="headerlink" title="11.sequence分布式全局序列"></a>11.sequence分布式全局序列</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">	在实现分库分表的情况下，数据库自增主键已经无法保证在集群中是全局唯一的主键了，因此</span></span><br><span class="line"><span class="code">mycat提供了全局的sequence.</span></span><br></pre></td></tr></table></figure>

<h2 id="11-1-本地方式"><a href="#11-1-本地方式" class="headerlink" title="11.1 本地方式"></a>11.1 本地方式</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">采用该方式，mycat将sequence配置到classpath目录的sequence<span class="emphasis">_conf.properties文件中，</span></span><br><span class="line"><span class="emphasis">在sequence_</span>conf.properties文件做如下配置</span><br><span class="line"></span><br><span class="line">GLOBAL<span class="emphasis">_SEQ.HISIDS=</span></span><br><span class="line"><span class="emphasis">GLOBAL_</span>SEQ.MINID=1001</span><br><span class="line">GLOBAL<span class="emphasis">_SEQ.MAXID=100000000</span></span><br><span class="line"><span class="emphasis">GLOBAL_</span>SEQ.CURID=1000</span><br><span class="line"></span><br><span class="line">其中HISIDS表示历史分段（一般无特殊需要则可以不配置），MINID表示最新的ID值，MAXID表示最</span><br><span class="line">大的ID值，CURID表示当前的ID值。</span><br><span class="line"></span><br><span class="line"><span class="bullet">0.</span> 打开本地seq功能。</span><br><span class="line">需要启用这种方式，则首先需要在server.xml中配置如下参数：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span></span>0<span class="language-xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">配置测试：</span><br><span class="line"><span class="bullet">1.</span> 修改sequence<span class="emphasis">_conf.properties</span></span><br><span class="line"><span class="emphasis">vim sequence_</span>conf.properties</span><br><span class="line"><span class="section">#全局seq</span></span><br><span class="line">GLOBAL<span class="emphasis">_SEQ.HISIDS=</span></span><br><span class="line"><span class="emphasis">GLOBAL_</span>SEQ.MINID=1001</span><br><span class="line">GLOBAL<span class="emphasis">_SEQ.MAXID=10000000</span></span><br><span class="line"><span class="emphasis">GLOBAL_</span>SEQ.CURID=1000</span><br><span class="line">或者：自己定制</span><br><span class="line"><span class="section"># self define sequence</span></span><br><span class="line">OLDGUO.HISIDS=</span><br><span class="line">OLDGUO.MINID=2001</span><br><span class="line">OLDGUO.MAXID=20000000</span><br><span class="line">OLDGUO.CURID=2000</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 设置server.xml</span><br><span class="line">&lt;!--lang:java--&gt;</span><br><span class="line">public static final int SEQUENCEHANDLER<span class="emphasis">_LOCALFILE = 0;</span></span><br><span class="line"><span class="emphasis">public static final int SEQUENCEHANDLER_</span>MYSQLDB = 1;</span><br><span class="line">public static final int SEQUENCEHANDLER<span class="emphasis">_LOCAL_</span>TIME = 2;</span><br><span class="line">private int sequnceHandlerType = SEQUENCEHANDLER<span class="emphasis">_LOCALFILE;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3.建表，插入数据测试</span></span><br><span class="line"><span class="emphasis">mysql&gt; create table test(id int not null primary key ,name varchar(20));</span></span><br><span class="line"><span class="emphasis">Query OK, 0 rows affected (0.04 sec)</span></span><br><span class="line"><span class="emphasis">mysql&gt; insert into test(id,name) values(next value for</span></span><br><span class="line"><span class="emphasis">MYCATSEQ_</span>OLDGUO,@@hostname);</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; select * from test;</span><br><span class="line">+-------+------+</span><br><span class="line">| id | name    |</span><br><span class="line">+-------+------+</span><br><span class="line">| 10001 | db02 |</span><br><span class="line">+-------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into test(id,name) values(next value for</span><br><span class="line">MYCATSEQ<span class="emphasis">_GLOBAL,@@hostname);</span></span><br><span class="line"><span class="emphasis">Query OK, 1 row affected (0.01 sec)</span></span><br><span class="line"><span class="emphasis">mysql&gt; select * from test;</span></span><br><span class="line"><span class="emphasis">+-------+------+</span></span><br><span class="line"><span class="emphasis">| id | name    |</span></span><br><span class="line"><span class="emphasis">+-------+------+</span></span><br><span class="line"><span class="emphasis">| 10001 | db02 |</span></span><br><span class="line"><span class="emphasis">| 10002 | db02 |</span></span><br><span class="line"><span class="emphasis">+-------+------+</span></span><br><span class="line"><span class="emphasis">2 rows in set (0.00 sec)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">mysql&gt; select * from test;</span></span><br><span class="line"><span class="emphasis">+-------+------+</span></span><br><span class="line"><span class="emphasis">| id | name    |</span></span><br><span class="line"><span class="emphasis">+-------+------+</span></span><br><span class="line"><span class="emphasis">| 10001 | db02 |</span></span><br><span class="line"><span class="emphasis">| 10002 | db02 |</span></span><br><span class="line"><span class="emphasis">+-------+------+</span></span><br><span class="line"><span class="emphasis">2 rows in set (0.01 sec)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">mysql&gt; insert into test(id,name) values(next value for</span></span><br><span class="line"><span class="emphasis">MYCATSEQ_</span>GLOBAL,@@hostname);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; select * from test;</span><br><span class="line">+-------+------+</span><br><span class="line">| id | name 	 |</span><br><span class="line">+-------+------+</span><br><span class="line">| 10001 | db02 |</span><br><span class="line">| 10002 | db02 |</span><br><span class="line">| 10003 | db02 |</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure>

<h2 id="11-2-数据库方式"><a href="#11-2-数据库方式" class="headerlink" title="11.2 数据库方式"></a>11.2 数据库方式</h2><h3 id="11-2-1-原理"><a href="#11-2-1-原理" class="headerlink" title="11.2.1 原理"></a>11.2.1 原理</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">	在数据库中建立一张表，存放 sequence 名称(name)，sequence 当前值(current_value)，步长</span></span><br><span class="line"><span class="code">(increment int 类型每次读取多少个 sequence，假设为 K)等信息；</span></span><br></pre></td></tr></table></figure>

<h3 id="11-2-2-获取步骤"><a href="#11-2-2-获取步骤" class="headerlink" title="11.2.2 获取步骤"></a>11.2.2 获取步骤</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">当初次使用该 sequence 时，根据传入的 sequence 名称，从数据库这张表中读取</span><br><span class="line">current<span class="emphasis">_value，和 increment 到 MyCat 中，并将数据库中的 current_</span>value 设置为原</span><br><span class="line">current<span class="emphasis">_value 值+increment 值；</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">MyCat 将读取到 current_</span>value+increment 作为本次要使用的 sequence 值，下次使用时，自</span><br><span class="line">动加 1，当 使用 increment 次后，执行步骤 1)相同的操作. MyCat 负责维护这张表，用到哪些</span><br><span class="line">sequence，只需要在这张表中插入一条记录即可。若某次读取的 sequence 没有用完，系统就停掉</span><br><span class="line">了，则这次读取的 sequence 剩余值不会再使用。</span><br></pre></td></tr></table></figure>

<h3 id="11-2-3-配置细节"><a href="#11-2-3-配置细节" class="headerlink" title="11.2.3 配置细节"></a>11.2.3 配置细节</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 修改Mycat配置文件server.xml</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span></span>1<span class="language-xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 修改Mycat配置文件schema.xml</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;t&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">autoIncrement</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh1,sh2&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;MYCAT_SEQUENCE&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;name&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;sh2&quot;</span>/&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="section"># 修改Mycat 配置文件 sequence<span class="emphasis">_db_</span>conf.properties，</span></span><br><span class="line">GLOBAL=sh2 ---&gt;修改</span><br><span class="line">COMPANY=dn1</span><br><span class="line">CUSTOMER=dn1</span><br><span class="line">ORDERS=dn1</span><br><span class="line"></span><br><span class="line"><span class="section"># 在sh2节点的 主 数据库中添加 MYCAT<span class="emphasis">_SEQUENCE表</span></span></span><br><span class="line"><span class="emphasis"><span class="section">DROP TABLE IF EXISTS MYCAT_</span>SEQUENCE;</span></span><br><span class="line">CREATE TABLE MYCAT<span class="emphasis">_SEQUENCE (name VARCHAR(50) NOT NULL,current_</span>value INT</span><br><span class="line">NOT NULL,increment INT NOT NULL DEFAULT 100, PRIMARY KEY(name))</span><br><span class="line">ENGINE=InnoDB;</span><br><span class="line"><span class="section"># 在dn2节点的 主库数据库中的 MYCAT<span class="emphasis">_SEQUENCE 表插入sequence初始记录</span></span></span><br><span class="line"><span class="emphasis"><span class="section">insert into MYCAT_</span>SEQUENCE(name,current<span class="emphasis">_value,increment)</span></span></span><br><span class="line"><span class="emphasis"><span class="section">VALUES(&#x27;GLOBAL&#x27;,10000,100);</span></span></span><br><span class="line"><span class="emphasis"><span class="section"># 在dn2节点的 主数据库中创建存储过程</span></span></span><br><span class="line"><span class="emphasis"><span class="section">## 获取当前sequence的值：</span></span></span><br><span class="line"><span class="emphasis"><span class="section">DROP FUNCTION IF EXISTS mycat_</span>seq<span class="emphasis">_currval;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">DELIMITER $</span></span></span><br><span class="line"><span class="emphasis"><span class="section">CREATE FUNCTION mycat_</span>seq<span class="emphasis">_currval(seq_</span>name VARCHAR(50)) RETURNS varchar(64)</span></span><br><span class="line">CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE retval VARCHAR(64);</span><br><span class="line">SET retval=&quot;-999999999,null&quot;;</span><br><span class="line">SELECT concat(CAST(current<span class="emphasis">_value AS CHAR),&quot;,&quot;,CAST(increment AS CHAR)) INTO</span></span><br><span class="line"><span class="emphasis">retval FROM MYCAT_</span>SEQUENCE WHERE name = seq<span class="emphasis">_name;</span></span><br><span class="line"><span class="emphasis">RETURN retval;</span></span><br><span class="line"><span class="emphasis">END $</span></span><br><span class="line"><span class="emphasis">DELIMITER ;</span></span><br><span class="line"><span class="emphasis">## 设置sequence值：</span></span><br><span class="line"><span class="emphasis">DROP FUNCTION IF EXISTS mycat_</span>seq<span class="emphasis">_setval;</span></span><br><span class="line"><span class="emphasis">DELIMITER $</span></span><br><span class="line"><span class="emphasis">CREATE FUNCTION mycat_</span>seq<span class="emphasis">_setval(seq_</span>name VARCHAR(50),value INTEGER)</span><br><span class="line">RETURNS varchar(64) CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">UPDATE MYCAT<span class="emphasis">_SEQUENCE</span></span><br><span class="line"><span class="emphasis">SET current_</span>value = value</span><br><span class="line">WHERE name = seq<span class="emphasis">_name;</span></span><br><span class="line"><span class="emphasis">RETURN mycat_</span>seq<span class="emphasis">_currval(seq_</span>name);</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="section">## 获取下一个sequence值：</span></span><br><span class="line">DROP FUNCTION IF EXISTS mycat<span class="emphasis">_seq_</span>nextval;</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION mycat<span class="emphasis">_seq_</span>nextval(seq<span class="emphasis">_name VARCHAR(50)) RETURNS varchar(64)</span></span><br><span class="line"><span class="emphasis">CHARSET utf8</span></span><br><span class="line"><span class="emphasis">DETERMINISTIC</span></span><br><span class="line"><span class="emphasis">BEGIN</span></span><br><span class="line"><span class="emphasis">UPDATE MYCAT_</span>SEQUENCE</span><br><span class="line">SET current<span class="emphasis">_value = current_</span>value + increment WHERE name = seq<span class="emphasis">_name;</span></span><br><span class="line"><span class="emphasis">RETURN mycat_</span>seq<span class="emphasis">_currval(seq_</span>name);</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="section"># 测试获取全局自增ID</span></span><br><span class="line">mysql&gt; insert into t4(id,name) values(NEXT VALUE FOR MYCATSEQ<span class="emphasis">_GLOBAL,&#x27;zy&#x27;)</span></span><br><span class="line"><span class="emphasis">;</span></span><br></pre></td></tr></table></figure>

<h2 id="11-3-时间戳方式"><a href="#11-3-时间戳方式" class="headerlink" title="11.3 时间戳方式"></a>11.3 时间戳方式</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">ID= 64 位二进制 (42(毫秒)+5(机器 ID)+5(业务编码)+12(重复累加)</span><br><span class="line">server.xml：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span></span>2<span class="language-xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span></span><br><span class="line">sequence<span class="emphasis">_time_</span>conf.properties：</span><br><span class="line">WORKID=0-31 任意整数</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用技术</title>
    <url>/2024/07/15/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="什么是高可用"><a href="#什么是高可用" class="headerlink" title="什么是高可用"></a>什么是高可用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">企业高可用标准：全年无故障率</span><br><span class="line"></span><br><span class="line">无故障时间     故障时间</span><br><span class="line">99.9%          0.1% = 525.6 min               KA+双主 ：人为干预</span><br><span class="line">99.99%         0.01% = 52.56 min              MHA 、ORCH ：半自动化</span><br><span class="line">99.999%        0.001% = 5.256 min             PXC 、 MGR 、MGC</span><br><span class="line">99.9999%       0.0001% = 0.5256 min           自动化、云化、平台化</span><br></pre></td></tr></table></figure>

<h1 id="数据库容灾级别"><a href="#数据库容灾级别" class="headerlink" title="数据库容灾级别"></a>数据库容灾级别</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661963247847-1a7d17cf-244b-49d0-aae2-0017e0dcc538.png"></p>
<span id="more"></span>
<h1 id="1-MHA高可用技术"><a href="#1-MHA高可用技术" class="headerlink" title="1. MHA高可用技术"></a>1. MHA高可用技术</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661963335260-c7d5699d-2e8a-4171-b1a2-235dfb6a2c90.png"></p>
<p>MHA脚本逻辑： </p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1661964362995-f6663795-e86a-45c7-a2ad-9573157d7e28.png"></p>
<p>1.0 MHA高可用架构介绍及搭建过程</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 规划:</span></span><br><span class="line">主库:               从库:                 </span><br><span class="line">51 node             52 node         53 node manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 准备环境</span></span><br><span class="line">略。1主2从GTID</span><br><span class="line"></span><br><span class="line"><span class="section"># 配置关键程序软连接</span></span><br><span class="line">ln -s /data/app/mysql/bin/mysqlbinlog /usr/bin/mysqlbinlog</span><br><span class="line">ln -s /data/app/mysql/bin/mysql /usr/bin/mysql</span><br><span class="line"></span><br><span class="line"><span class="section"># 配置各节点互信(各节点之间无密码SSH)</span></span><br><span class="line"><span class="section">## db01：</span></span><br><span class="line">rm -rf /root/.ssh</span><br><span class="line">ssh-keygen</span><br><span class="line">cd /root/.ssh</span><br><span class="line">mv id<span class="emphasis">_rsa.pub authorized_</span>keys</span><br><span class="line">scp -r /root/.ssh 10.0.0.52:/root</span><br><span class="line">scp -r /root/.ssh 10.0.0.53:/root</span><br><span class="line"><span class="section">## 各节点验证</span></span><br><span class="line"><span class="section">## db01:</span></span><br><span class="line">ssh 10.0.0.51 date</span><br><span class="line">ssh 10.0.0.52 date</span><br><span class="line">ssh 10.0.0.53 date</span><br><span class="line"><span class="section">## db02:</span></span><br><span class="line">ssh 10.0.0.51 date</span><br><span class="line">ssh 10.0.0.52 date</span><br><span class="line">ssh 10.0.0.53 date</span><br><span class="line"><span class="section">## db03:</span></span><br><span class="line">ssh 10.0.0.51 date</span><br><span class="line">ssh 10.0.0.52 date</span><br><span class="line">ssh 10.0.0.53 date</span><br><span class="line"></span><br><span class="line"><span class="section">#安装软件</span></span><br><span class="line"><span class="section">## 下载mha软件</span></span><br><span class="line">mha官网：https://code.google.com/archive/p/mysql-master-ha/</span><br><span class="line">github下载地址：https://github.com/yoshinorim/mha4mysqlmanager/wiki/Downloads</span><br><span class="line"><span class="section">## 所有节点安装Node软件依赖包</span></span><br><span class="line">yum install perl-DBD-MySQL -y</span><br><span class="line">rpm -ivh mha4mysql-node<span class="emphasis">*.rpm</span></span><br><span class="line"><span class="emphasis">## 在db01主库中创建mha需要的用户</span></span><br><span class="line"><span class="emphasis">create user mha@&#x27;10.0.0.%&#x27; identified with mysql_native_password by &#x27;mha&#x27;;</span></span><br><span class="line"><span class="emphasis">grant all privileges on *</span>.* to mha@&#x27;10.0.0.%&#x27;;</span><br><span class="line"><span class="section">## Manager软件安装（db03）</span></span><br><span class="line">yum install -y perl-Config-Tiny epel-release perl-Log-Dispatch perlParallel-ForkManager perl-Time-HiRes</span><br><span class="line">rpm -ivh mha4mysql-manager<span class="emphasis">*.rpm</span></span><br><span class="line"><span class="emphasis">## 配置文件准备(db03)</span></span><br><span class="line"><span class="emphasis">### 创建配置文件目录</span></span><br><span class="line"><span class="emphasis">mkdir -p /etc/mha</span></span><br><span class="line"><span class="emphasis">### 创建日志目录</span></span><br><span class="line"><span class="emphasis">mkdir -p /var/log/mha/app1</span></span><br><span class="line"><span class="emphasis">### 编辑mha配置文件</span></span><br><span class="line"><span class="emphasis">vim /etc/mha/app1.cnf</span></span><br><span class="line"><span class="emphasis">[server default]</span></span><br><span class="line"><span class="emphasis">manager_log=/var/log/mha/app1/manager</span></span><br><span class="line"><span class="emphasis">manager_workdir=/var/log/mha/app1</span></span><br><span class="line"><span class="emphasis">master_binlog_dir=/data/binlog/</span></span><br><span class="line"><span class="emphasis">user=mha</span></span><br><span class="line"><span class="emphasis">password=mha</span></span><br><span class="line"><span class="emphasis">ping_interval=2</span></span><br><span class="line"><span class="emphasis">repl_password=123</span></span><br><span class="line"><span class="emphasis">repl_user=repl</span></span><br><span class="line"><span class="emphasis">ssh_user=root</span></span><br><span class="line"><span class="emphasis">[server1]</span></span><br><span class="line"><span class="emphasis">hostname=10.0.0.51</span></span><br><span class="line"><span class="emphasis">port=3306</span></span><br><span class="line"><span class="emphasis">[server2]</span></span><br><span class="line"><span class="emphasis">hostname=10.0.0.52</span></span><br><span class="line"><span class="emphasis">candidate_master=1</span></span><br><span class="line"><span class="emphasis">port=3306</span></span><br><span class="line"><span class="emphasis">[server3]</span></span><br><span class="line"><span class="emphasis">hostname=10.0.0.53</span></span><br><span class="line"><span class="emphasis">port=3306</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 状态检查</span></span><br><span class="line"><span class="emphasis">## 互信检查</span></span><br><span class="line"><span class="emphasis">masterha_check_ssh --conf=/etc/mha/app1.cnf</span></span><br><span class="line"><span class="emphasis">## 主从状态检查</span></span><br><span class="line"><span class="emphasis">masterha_check_repl --conf=/etc/mha/app1.cnf</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 开启MHA(db03)：</span></span><br><span class="line"><span class="emphasis">nohup masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf -</span></span><br><span class="line"><span class="emphasis">-ignore_last_failover &lt; /dev/null&gt; /var/log/mha/app1/manager.log 2&gt;&amp;1 &amp;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 查看MHA状态</span></span><br><span class="line"><span class="emphasis">[root@db03 ~]# masterha_check_status --conf=/etc/mha/app1.cnf</span></span><br></pre></td></tr></table></figure>

<h2 id="1-1-MHA软件结构介绍"><a href="#1-1-MHA软件结构介绍" class="headerlink" title="1.1 MHA软件结构介绍"></a>1.1 MHA软件结构介绍</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">manager 组件</span><br><span class="line">masterha<span class="emphasis">_manger 启动MHA</span></span><br><span class="line"><span class="emphasis">masterha_</span>check<span class="emphasis">_ssh 检查MHA的SSH配置状况</span></span><br><span class="line"><span class="emphasis">masterha_</span>check<span class="emphasis">_repl 检查MySQL复制状况</span></span><br><span class="line"><span class="emphasis">masterha_</span>master<span class="emphasis">_monitor 检测master是否宕机</span></span><br><span class="line"><span class="emphasis">masterha_</span>check<span class="emphasis">_status 检测当前MHA运行状态</span></span><br><span class="line"><span class="emphasis">masterha_</span>master<span class="emphasis">_switch 控制故障转移（自动或者手动）</span></span><br><span class="line"><span class="emphasis">masterha_</span>conf<span class="emphasis">_host 添加或删除配置的server信息</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">node 组件</span></span><br><span class="line"><span class="emphasis">save_</span>binary<span class="emphasis">_logs 保存和复制master的二进制日志</span></span><br><span class="line"><span class="emphasis">apply_</span>diff<span class="emphasis">_relay_</span>logs 识别差异的中继日志事件并将其差异的事件应用于其他的</span><br><span class="line">purge<span class="emphasis">_relay_</span>logs 清除中继日志（不会阻塞SQL线程）</span><br></pre></td></tr></table></figure>

<h2 id="1-2-应用透明—VIP"><a href="#1-2-应用透明—VIP" class="headerlink" title="1.2 应用透明—VIP"></a>1.2 应用透明—VIP</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">vip : 10.0.0.55/24</span><br><span class="line">vip 故障转移脚本</span><br><span class="line">上传脚本文件到/usr/local/bin 解压</span><br><span class="line">[root@db03 mha<span class="emphasis">_script]# cp -a /data/mha_</span>script/* /usr/local/bin</span><br><span class="line"></span><br><span class="line">修改权限</span><br><span class="line">[root@db03 bin]# chmod +x /usr/local/bin/*</span><br><span class="line"></span><br><span class="line">修改内容</span><br><span class="line">[root@db03 bin]# cp master<span class="emphasis">_ip_</span>failover master<span class="emphasis">_ip_</span>failover.bak</span><br><span class="line">my $vip = &#x27;10.0.0.55/24&#x27;;</span><br><span class="line">my $key = &#x27;1&#x27;;</span><br><span class="line">my $if = &#x27;ens33&#x27;;</span><br><span class="line">my $ssh<span class="emphasis">_start_</span>vip = &quot;/sbin/ifconfig $if:$key $vip&quot;;</span><br><span class="line">my $ssh<span class="emphasis">_stop_</span>vip = &quot;/sbin/ifconfig $if:$key down&quot;;</span><br><span class="line">my $ssh<span class="emphasis">_Bcast_</span>arp= &quot;/sbin/arping -I $if -c 3 -A 10.0.0.55&quot;;</span><br><span class="line">修改Manager 配置文件</span><br><span class="line">vim /etc/mha/app1.cnf</span><br><span class="line">master<span class="emphasis">_ip_</span>failover<span class="emphasis">_script=/usr/local/bin/master_</span>ip<span class="emphasis">_failover</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">重启MHA</span></span><br><span class="line"><span class="emphasis">[root@db03 bin]# masterha_</span>stop --conf=/etc/mha/app1.cnf</span><br><span class="line">[root@db03 bin]# nohup masterha<span class="emphasis">_manager --conf=/etc/mha/app1.cnf --</span></span><br><span class="line"><span class="emphasis">remove_</span>dead<span class="emphasis">_master_</span>conf --ignore<span class="emphasis">_last_</span>failover &lt; /dev/null&gt;</span><br><span class="line">/var/log/mha/app1/manager.log 2&gt;&amp;1 &amp;</span><br><span class="line">手工在主库添加VIP</span><br><span class="line">[root@db03 bin]# masterha<span class="emphasis">_check_</span>status --conf=/etc/mha/app1.cnf</span><br><span class="line">[root@db02 ~]# ifconfig ens33:1 10.0.0.55/24</span><br><span class="line"></span><br><span class="line">效果测试</span><br><span class="line">使用navicat 连接测试MHA vip功能。</span><br></pre></td></tr></table></figure>

<h2 id="1-3-故障提醒功能"><a href="#1-3-故障提醒功能" class="headerlink" title="1.3 故障提醒功能"></a>1.3 故障提醒功能</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">准备脚本</span><br><span class="line">[root@db03 bin]# cp send<span class="emphasis">_report send_</span>report.bak1</span><br><span class="line">my $smtp=&#x27;smtp.qq.com&#x27;; # smtp服务器</span><br><span class="line">my $mail<span class="emphasis">_from=&#x27;22654481@qq.com&#x27;; # 发件箱</span></span><br><span class="line"><span class="emphasis">my $mail_</span>user=&#x27;22654481&#x27;; # 用户名 QQ号</span><br><span class="line">my $mail<span class="emphasis">_pass=&#x27;gemghsvgkeyzcagh&#x27;; # 授权码</span></span><br><span class="line"><span class="emphasis">my $mail_</span>to=[&#x27;22654481@qq.com&#x27;]; # 收件箱</span><br><span class="line"><span class="section">#my $mail<span class="emphasis">_to=[&#x27;to1@qq.com&#x27;,&#x27;to2@qq.com&#x27;];</span></span></span><br><span class="line"><span class="emphasis"><span class="section"></span></span></span><br><span class="line"><span class="emphasis"><span class="section">修改配置文件</span></span></span><br><span class="line"><span class="emphasis"><span class="section">vim /etc/mha/app1.cnf  # 添加一行：</span></span></span><br><span class="line"><span class="emphasis"><span class="section">report_</span>script=/usr/local/bin/send<span class="emphasis">_report</span></span></span><br><span class="line"><span class="emphasis"><span class="section"></span></span></span><br><span class="line"><span class="emphasis"><span class="section">重启MHA</span></span></span><br><span class="line"><span class="emphasis"><span class="section">[root@db03 bin]# masterha_</span>stop --conf=/etc/mha/app1.cnf</span></span><br><span class="line">[root@db03 bin]# nohup masterha<span class="emphasis">_manager --conf=/etc/mha/app1.cnf --</span></span><br><span class="line"><span class="emphasis">remove_</span>dead<span class="emphasis">_master_</span>conf --ignore<span class="emphasis">_last_</span>failover &lt; /dev/null&gt;</span><br><span class="line">/var/log/mha/app1/manager.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-1-故障如何半自愈？"><a href="#1-3-1-故障如何半自愈？" class="headerlink" title="1.3.1 故障如何半自愈？"></a>1.3.1 故障如何半自愈？</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 检查数据库是否启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db01</span> <span class="type">app</span>]<span class="comment"># mysqladmin -umha -pmha -h 10.0.0.51 ping</span></span><br><span class="line"><span class="comment"># 2. 恢复主从</span></span><br><span class="line"><span class="comment">## 2.1 缺失少部分日志</span></span><br><span class="line">如果没有缺失GTID事务。直接change master</span><br><span class="line"><span class="comment">## 2.2 缺失大部分日志</span></span><br><span class="line">备份主库数据，恢复至从库。change master</span><br><span class="line">clone plugin + change master to</span><br><span class="line"><span class="comment"># 3. 配置文件添加修复节点</span></span><br><span class="line">masterha_conf_host <span class="literal">--command</span>=add <span class="literal">--conf</span>=/etc/mha/app1.cnf <span class="literal">--</span></span><br><span class="line">hostname=<span class="number">10.0</span>.<span class="number">0.51</span> <span class="literal">--block</span>=server10 <span class="literal">--params</span>=<span class="string">&quot;port=3306&quot;</span></span><br><span class="line"><span class="comment"># 4. 检查</span></span><br><span class="line"><span class="comment">## 互信检查</span></span><br><span class="line">masterha_check_ssh <span class="literal">--conf</span>=/etc/mha/app1.cnf</span><br><span class="line"><span class="comment">## 主从状态检查</span></span><br><span class="line">masterha_check_repl <span class="literal">--conf</span>=/etc/mha/app1.cnf</span><br><span class="line"><span class="comment"># 启动MHA</span></span><br><span class="line">nohup masterha_manager <span class="literal">--conf</span>=/etc/mha/app1.cnf <span class="literal">--remove_dead_master_conf</span> -</span><br><span class="line"><span class="literal">-ignore_last_failover</span> &lt; /dev/null&gt; /var/log/mha/app1/manager.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"></span><br><span class="line">手工恢复具体步骤：</span><br><span class="line"><span class="number">1</span>. 修改Linux服务器</span><br><span class="line"><span class="number">2</span>. 安装MySQL软件</span><br><span class="line"><span class="number">3</span>. 初始化数据，并启动</span><br><span class="line"><span class="number">4</span>. clone 数据到新节点，并构建主从</span><br><span class="line">主库：</span><br><span class="line">mysql <span class="literal">-e</span> <span class="string">&quot;INSTALL PLUGIN clone SONAME &#x27;mysql_clone.so&#x27;;create user test@&#x27;%&#x27;</span></span><br><span class="line"><span class="string">identified by &#x27;123&#x27;;grant backup_admin on *.* to test@&#x27;%&#x27;;&quot;</span></span><br><span class="line">从库：</span><br><span class="line">mysql <span class="literal">-e</span> <span class="string">&quot;INSTALL PLUGIN clone SONAME &#x27;mysql_clone.so&#x27;;create user test@&#x27;%&#x27;</span></span><br><span class="line"><span class="string">identified by &#x27;123&#x27;;grant clone_admin on *.* to test@&#x27;%&#x27;;SET GLOBAL</span></span><br><span class="line"><span class="string">clone_valid_donor_list=&#x27;10.0.0.52:3306&#x27;;&quot;</span></span><br><span class="line">mysql <span class="literal">-utest</span> <span class="literal">-p123</span> <span class="literal">-h10</span>.<span class="number">0.0</span>.<span class="number">51</span> <span class="literal">-P3306</span> <span class="literal">-e</span> <span class="string">&quot;CLONE INSTANCE FROM</span></span><br><span class="line"><span class="string">test@&#x27;10.0.0.52&#x27;:3306 IDENTIFIED BY &#x27;123&#x27;;&quot;</span></span><br><span class="line">mysql <span class="literal">-e</span> <span class="string">&quot; SELECT STAGE, STATE, END_TIME FROM</span></span><br><span class="line"><span class="string">performance_schema.clone_progress;&quot;</span></span><br><span class="line">mysql <span class="literal">-e</span> \</span><br><span class="line"><span class="string">&quot;CHANGE MASTER TO \</span></span><br><span class="line"><span class="string">MASTER_HOST=&#x27;10.0.0.52&#x27;,\</span></span><br><span class="line"><span class="string">MASTER_USER=&#x27;repl&#x27;, \</span></span><br><span class="line"><span class="string">MASTER_PASSWORD=&#x27;123&#x27;, \</span></span><br><span class="line"><span class="string">MASTER_PORT=3306, \</span></span><br><span class="line"><span class="string">MASTER_AUTO_POSITION=1;&quot;</span></span><br><span class="line">mysql <span class="literal">-e</span> <span class="string">&quot;start slave;&quot;</span></span><br><span class="line">mysql <span class="literal">-e</span> <span class="string">&quot;show slave status \G&quot;</span>|grep <span class="string">&quot;Running:&quot;</span></span><br><span class="line"><span class="number">5</span>. 添加节点至配置文件</span><br><span class="line">masterha_conf_host <span class="literal">--command</span>=add <span class="literal">--conf</span>=/etc/mha/app1.cnf <span class="literal">--</span></span><br><span class="line">hostname=<span class="number">10.0</span>.<span class="number">0.51</span> <span class="literal">--block</span>=server10 <span class="literal">--params</span>=<span class="string">&quot;port=3306&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>. 修复binlogserver</span><br><span class="line">mysqlbinlog <span class="literal">-R</span> <span class="literal">--host</span>=<span class="number">10.0</span>.<span class="number">0.52</span> <span class="literal">--user</span>=mha <span class="literal">--password</span>=mha <span class="literal">--raw</span> <span class="literal">--stop-never</span> mysql<span class="literal">-bin</span>.<span class="number">000003</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>. 状态检查</span><br><span class="line"><span class="comment">## 互信检查</span></span><br><span class="line">masterha_check_ssh <span class="literal">--conf</span>=/etc/mha/app1.cnf</span><br><span class="line"><span class="comment">## 主从状态检查</span></span><br><span class="line">masterha_check_repl <span class="literal">--conf</span>=/etc/mha/app1.cnf</span><br><span class="line"><span class="number">8</span>. 启动MHA</span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">app1</span>]<span class="comment"># nohup masterha_manager --conf=/etc/mha/app1.cnf --</span></span><br><span class="line">remove_dead_master_conf <span class="literal">--ignore_last_failover</span> &lt; /dev/null&gt;</span><br><span class="line">/var/log/mha/app1/manager.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">app1</span>]<span class="comment"># masterha_check_status --conf=/etc/mha/app1.cnf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以写脚本实现半自愈功能。</span><br></pre></td></tr></table></figure>

<h2 id="1-4-日志补偿的冗余方案–binlog-server"><a href="#1-4-日志补偿的冗余方案–binlog-server" class="headerlink" title="1.4 日志补偿的冗余方案–binlog_server"></a>1.4 日志补偿的冗余方案–binlog_server</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建必要目录(db03)</span></span><br><span class="line">mkdir <span class="literal">-p</span> /<span class="keyword">data</span>/binlog_server/</span><br><span class="line">chown <span class="literal">-R</span> mysql.mysql /<span class="keyword">data</span>/*</span><br><span class="line"><span class="built_in">cd</span> /<span class="keyword">data</span>/binlog_server/</span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> ~]<span class="comment"># mysql -e &quot;show slave status \G&quot;|grep &quot;Master_Log&quot;</span></span><br><span class="line">Master_Log_File: mysql<span class="literal">-bin</span>.<span class="number">000008</span></span><br><span class="line">Read_Master_Log_Pos: <span class="number">194</span></span><br><span class="line">Relay_Master_Log_File: mysql<span class="literal">-bin</span>.<span class="number">000008</span></span><br><span class="line">Exec_Master_Log_Pos: <span class="number">194</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> ~]<span class="comment">#</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">binlog_server</span>]<span class="comment"># masterha_check_status --conf=/etc/mha/app1.cnf</span></span><br><span class="line">app1 (pid:<span class="number">7057</span>) is running(<span class="number">0</span>:PING_OK), master:<span class="number">10.0</span>.<span class="number">0.52</span></span><br><span class="line">mysqlbinlog <span class="literal">-R</span> <span class="literal">--host</span>=<span class="number">10.0</span>.<span class="number">0.52</span> <span class="literal">--user</span>=mha <span class="literal">--password</span>=mha <span class="literal">--raw</span> <span class="literal">--stop</span>never mysql<span class="literal">-bin</span>.<span class="number">000003</span> &amp;</span><br><span class="line">注意：</span><br><span class="line">拉取日志的起点,需要按照目前从库的已经获取到的二进制日志点为起点</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置文件设置</span></span><br><span class="line">vim /etc/mha/app1.cnf</span><br><span class="line">[<span class="type">binlog1</span>]</span><br><span class="line">no_master=<span class="number">1</span></span><br><span class="line">hostname=<span class="number">10.0</span>.<span class="number">0.53</span></span><br><span class="line">master_binlog_dir=/<span class="keyword">data</span>/binlog_server/</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启MHA</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">bin</span>]<span class="comment"># masterha_stop --conf=/etc/mha/app1.cnf</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">bin</span>]<span class="comment"># nohup masterha_manager --conf=/etc/mha/app1.cnf --</span></span><br><span class="line">remove_dead_master_conf <span class="literal">--ignore_last_failover</span> &lt; /dev/null&gt;</span><br><span class="line">/var/log/mha/app1/manager.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-MHA的维护操作-在线切换功能"><a href="#1-5-MHA的维护操作-在线切换功能" class="headerlink" title="1.5 MHA的维护操作 - 在线切换功能"></a>1.5 MHA的维护操作 - 在线切换功能</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">db03</span> ~]<span class="comment"># masterha_stop --conf=/etc/mha/app1.cnf</span></span><br><span class="line">只切换角色</span><br><span class="line">masterha_master_switch <span class="literal">--conf</span>=/etc/mha/app1.cnf <span class="literal">--master_state</span>=alive <span class="literal">--</span></span><br><span class="line">new_master_host=<span class="number">10.0</span>.<span class="number">0.51</span> <span class="literal">--orig_master_is_new_slave</span> <span class="literal">--</span></span><br><span class="line">running_updates_limit=<span class="number">10000</span></span><br><span class="line">注意：</span><br><span class="line">master_ip_online_change_script is not defined. <span class="keyword">If</span> you <span class="keyword">do</span> not disable writes</span><br><span class="line">on the current master manually, applications keep writing on the current</span><br><span class="line">master. Is it ok to proceed? (yes/NO): yes</span><br><span class="line"><span class="number">1</span>. 此种方法 切换，要注意将原主库，FTWRL，否则会造成主从不一致。</span><br><span class="line"><span class="number">2</span>. 手工切换vip</span><br><span class="line"><span class="number">3</span>. 重新拉去新主库的binlog</span><br><span class="line"><span class="number">4</span>. 发邮件功能</span><br><span class="line"></span><br><span class="line">master_ip_online_change_script功能实现</span><br><span class="line">功能: 在线切换时，自动锁原主库，VIP自动切换</span><br><span class="line"></span><br><span class="line"><span class="comment">#准备切换脚本</span></span><br><span class="line">vim /usr/local/bin/master_ip_online_change</span><br><span class="line">my <span class="variable">$vip</span> = <span class="string">&quot;10.0.0.55/24&quot;</span>;</span><br><span class="line">my <span class="variable">$key</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">my <span class="variable">$ssh_start_vip</span> = <span class="string">&quot;/sbin/ifconfig ens33:<span class="variable">$key</span> <span class="variable">$vip</span>&quot;</span>;</span><br><span class="line">my <span class="variable">$ssh_stop_vip</span> = <span class="string">&quot;/sbin/ifconfig ens33:<span class="variable">$key</span> <span class="variable">$vip</span> down&quot;</span>;</span><br><span class="line">my <span class="variable">$ssh_Bcast_arp</span>= <span class="string">&quot;/sbin/arping -I ens33 -c 3 -A 10.0.0.55&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改MHA配置文件</span></span><br><span class="line">vim /etc/mha/app1.cnf</span><br><span class="line">master_ip_online_change_script=/usr/local/bin/master_ip_online_change</span><br><span class="line"></span><br><span class="line"><span class="comment">#停 MHA</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">bin</span>]<span class="comment"># masterha_stop --conf=/etc/mha/app1.cnf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查repl</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">bin</span>]<span class="comment"># masterha_check_repl --conf=/etc/mha/app1.cnf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在线切换</span></span><br><span class="line">masterha_master_switch <span class="literal">--conf</span>=/etc/mha/app1.cnf <span class="literal">--master_state</span>=alive <span class="literal">--</span></span><br><span class="line">new_master_host=<span class="number">10.0</span>.<span class="number">0.51</span> <span class="literal">--orig_master_is_new_slave</span> <span class="literal">--</span></span><br><span class="line">running_updates_limit=<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重构binlogserver</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">bin</span>]<span class="comment"># ps -ef |grep mysqlbinlog</span></span><br><span class="line">root <span class="number">28144</span> <span class="number">16272</span> <span class="number">0</span> <span class="number">17</span>:<span class="number">50</span> pts/<span class="number">1</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> mysqlbinlog <span class="literal">-R</span> <span class="literal">--</span></span><br><span class="line">host=<span class="number">10.0</span>.<span class="number">0.52</span> <span class="literal">--user</span>=mha <span class="literal">--password</span>=x x <span class="literal">--raw</span> <span class="literal">--stop-never</span> mysqlbin.<span class="number">000005</span></span><br><span class="line">root <span class="number">28529</span> <span class="number">16272</span> <span class="number">0</span> <span class="number">18</span>:<span class="number">03</span> pts/<span class="number">1</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep <span class="literal">--color</span>=auto</span><br><span class="line">mysqlbinlog</span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">bin</span>]<span class="comment"># kill -9 28144</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">bin</span>]<span class="comment"># cd /data/binlog_server/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">binlog_server</span>]<span class="comment"># ll</span></span><br><span class="line">total <span class="number">4</span></span><br><span class="line"><span class="literal">-rw-r-----</span> <span class="number">1</span> root root <span class="number">194</span> Apr <span class="number">1</span> <span class="number">17</span>:<span class="number">50</span> mysql<span class="literal">-bin</span>.<span class="number">000005</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">binlog_server</span>]<span class="comment"># rm -rf *</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">binlog_server</span>]<span class="comment"># mysqlbinlog -R --host=10.0.0.51 --user=mha --</span></span><br><span class="line">password=mha <span class="literal">--raw</span> <span class="literal">--stop-never</span> mysql<span class="literal">-bin</span>.<span class="number">000009</span> &amp;</span><br><span class="line">[<span class="number">1</span>] <span class="number">28534</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动MHA</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">bin</span>]<span class="comment"># nohup masterha_manager --conf=/etc/mha/app1.cnf --</span></span><br><span class="line">remove_dead_master_conf <span class="literal">--ignore_last_failover</span> &lt; /dev/null&gt;</span><br><span class="line">/var/log/mha/app1/manager.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line">[<span class="type">root</span>@<span class="type">db03</span> <span class="type">binlog_server</span>]<span class="comment"># masterha_check_status --conf=/etc/mha/app1.cnf</span></span><br><span class="line">app1 (pid:<span class="number">28535</span>) is running(<span class="number">0</span>:PING_OK), master:<span class="number">10.0</span>.<span class="number">0.51</span></span><br></pre></td></tr></table></figure>



<h2 id="1-6-MHA如何防止脑裂"><a href="#1-6-MHA如何防止脑裂" class="headerlink" title="1.6 MHA如何防止脑裂"></a>1.6 MHA如何防止脑裂</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 什么是脑裂？</span></span><br><span class="line">1.7 MHA的数据一致性保证</span><br><span class="line">2、ProxySQL中间件</span><br><span class="line">2.1 介绍</span><br><span class="line">多个节点争抢主库角色。会导致多库写入的问题。</span><br><span class="line">manager程序与现有主库之间出现网络故障。默认manager是单一心跳检查的。</span><br><span class="line"></span><br><span class="line"><span class="section"># 解决方案：</span></span><br><span class="line"><span class="bullet">1.</span> 采用多心跳投票机制。例如：多条网络线路（以太网、磁盘网络）。</span><br><span class="line"><span class="bullet">2.</span> stonith是“shoot the other node in the head”的首字母简写</span><br><span class="line"><span class="section"># shutdown<span class="emphasis">_script 脚本</span></span></span><br><span class="line"><span class="emphasis"><span class="section">利用服务器的远程控制IDRAC等，使用ipmitool强制去关机，以避免fence设备重启主服务器，造成</span></span></span><br><span class="line"><span class="emphasis"><span class="section">脑列现象.</span></span></span><br><span class="line"><span class="emphasis"><span class="section">shutdown_</span>script= /usr/local/bin/power<span class="emphasis">_manager</span></span></span><br><span class="line"><span class="emphasis"><span class="section">fence: 网络fence(ilo、idrac)、电源fence</span></span></span><br><span class="line"><span class="emphasis"><span class="section"></span></span></span><br><span class="line"><span class="emphasis"><span class="section"># secondary_</span>check<span class="emphasis">_script脚本</span></span></span><br><span class="line"><span class="emphasis"><span class="section">secondary_</span>check<span class="emphasis">_script = &quot;masterha_</span>secondary<span class="emphasis">_check -s 10.0.0.52 -s</span></span></span><br><span class="line"><span class="emphasis"><span class="section">10.0.0.53&quot;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="1-7-MHA的数据一致性保证"><a href="#1-7-MHA的数据一致性保证" class="headerlink" title="1.7 MHA的数据一致性保证"></a>1.7 MHA的数据一致性保证</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** rpl<span class="emphasis">_semi_</span>sync **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span></span><br><span class="line">rpl<span class="emphasis">_semi_</span>sync<span class="emphasis">_master_</span>enabled =ON</span><br><span class="line">rpl<span class="emphasis">_semi_</span>sync<span class="emphasis">_master_</span>timeout =5000</span><br><span class="line">rpl<span class="emphasis">_semi_</span>sync<span class="emphasis">_master_</span>wait<span class="emphasis">_for_</span>slave<span class="emphasis">_count =1</span></span><br><span class="line"><span class="emphasis">rpl_</span>semi<span class="emphasis">_sync_</span>master<span class="emphasis">_wait_</span>no<span class="emphasis">_slave =ON</span></span><br><span class="line"><span class="emphasis">rpl_</span>semi<span class="emphasis">_sync_</span>master<span class="emphasis">_wait_</span>point =AFTER<span class="emphasis">_SYNC</span></span><br><span class="line"><span class="emphasis">rpl_</span>semi<span class="emphasis">_sync_</span>slave<span class="emphasis">_enabled =ON</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** group commit **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span></span><br><span class="line"><span class="emphasis">binlog_</span>group<span class="emphasis">_commit_</span>sync<span class="emphasis">_delay =1</span></span><br><span class="line"><span class="emphasis">binlog_</span>group<span class="emphasis">_commit_</span>sync<span class="emphasis">_no_</span>delay<span class="emphasis">_count =1000</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** gtid **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span></span><br><span class="line"><span class="emphasis">gtid_</span>mode =ON</span><br><span class="line">enforce<span class="emphasis">_gtid_</span>consistency =ON</span><br><span class="line">log<span class="emphasis">_slave_</span>update =1</span><br><span class="line"></span><br><span class="line"><span class="section">#<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** gtid **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span></span><br><span class="line">slave<span class="emphasis">_parallel_</span>type =LOGICAL<span class="emphasis">_CLOCK</span></span><br><span class="line"><span class="emphasis">slave_</span>parallel<span class="emphasis">_workers =4</span></span><br><span class="line"><span class="emphasis">master_</span>info<span class="emphasis">_repository =TABLE</span></span><br><span class="line"><span class="emphasis">relay_</span>log<span class="emphasis">_info_</span>repository =TABL</span><br></pre></td></tr></table></figure>

<h1 id="2-ProxySQL中间件"><a href="#2-ProxySQL中间件" class="headerlink" title="2. ProxySQL中间件"></a>2. ProxySQL中间件</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">ProxySQL是基于MySQL的一款开源的中间件的产品，是一个灵活的MySQL代理层，可以实现读写分离，</span><br><span class="line">支持 Query路由功能，支持动态指定某个SQL进行缓存，支持动态加载配置信息（无需重启 ProxySQL</span><br><span class="line">服务），支持故障切换和SQL的过滤功能。</span><br><span class="line"></span><br><span class="line">相关 ProxySQL 的网站：</span><br><span class="line">https://www.proxysql.com/</span><br><span class="line">https://github.com/sysown/proxysql/wiki</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662198239220-724a2039-161d-449e-8df7-b44a08b1bd27.png"></p>
<h2 id="2-2-安装ProxySQL"><a href="#2-2-安装ProxySQL" class="headerlink" title="2. 2 安装ProxySQL"></a>2. 2 安装ProxySQL</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 下载proxySQL</span></span><br><span class="line">https://proxysql.com/</span><br><span class="line">https://github.com/sysown/proxysql/releases</span><br><span class="line"></span><br><span class="line"><span class="section"># 安装proxySQL</span></span><br><span class="line">[root@db03 ~]# rpm -ivh proxysql-2.0.10-1-centos7.x86<span class="emphasis">_64.rpm</span></span><br><span class="line"><span class="emphasis">[root@db03 ~]# systemctl start proxysql</span></span><br><span class="line"><span class="emphasis">[root@db03 ~]# netstat -tulnp</span></span><br><span class="line"><span class="emphasis">tcp 0 0 0.0.0.0:6032 0.0.0.0:* LISTEN</span></span><br><span class="line"><span class="emphasis">	2115/proxysql</span></span><br><span class="line"><span class="emphasis">tcp 0 0 0.0.0.0:6033 0.0.0.0:* LISTEN</span></span><br><span class="line"><span class="emphasis">	2115/proxysql</span></span><br><span class="line"><span class="emphasis">[root@db03 ~]# mysql -uadmin -padmin -h127.0.0.1 -P6032</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-ProxySQL中管理结构"><a href="#2-3-ProxySQL中管理结构" class="headerlink" title="2.3 ProxySQL中管理结构"></a>2.3 ProxySQL中管理结构</h2><h4 id="ProxySQL-自带系统库信息"><a href="#ProxySQL-自带系统库信息" class="headerlink" title="ProxySQL  自带系统库信息"></a>ProxySQL  自带系统库信息</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在ProxySQL，6032端口共五个库： main、disk、stats 、monitor、stats<span class="emphasis">_history</span></span><br><span class="line"><span class="emphasis">   main:</span></span><br><span class="line"><span class="emphasis">     main 库中有如下信息：</span></span><br><span class="line"><span class="emphasis">     mysql_</span>servers: 后端可以连接 MySQL 服务器的列表</span><br><span class="line"><span class="code">     mysql_users: 配置后端数据库的账号和监控的账号。</span></span><br><span class="line"><span class="code">     mysql_query_rules: 指定 Query 路由到后端不同服务器的规则列表。</span></span><br><span class="line"><span class="code">     mysql_replication_hostgroups : 节点分组配置信息</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注： 表名以 runtime<span class="emphasis">_开头的表示ProxySQL 当前运行的配置内容，不能直接修改。不带runtime_</span></span><br><span class="line">是下文图中Mem相关的配置。</span><br><span class="line"><span class="section">#disk ：</span></span><br><span class="line"><span class="code">	持久化的磁盘的配置</span></span><br><span class="line"><span class="code">#stats：</span></span><br><span class="line"><span class="code">	统计信息的汇总</span></span><br><span class="line"><span class="code">#monitor：</span></span><br><span class="line"><span class="code">	监控的收集信息，比如数据库的健康状态等</span></span><br><span class="line"><span class="code">#stats_history:  ProxySQL 收集的有关其内部功能的历史指标</span></span><br></pre></td></tr></table></figure>

<h4 id="ProxySQL-管理接口的多层配置关系"><a href="#ProxySQL-管理接口的多层配置关系" class="headerlink" title="ProxySQL  管理接口的多层配置关系"></a>ProxySQL  管理接口的多层配置关系</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662198791773-585599b1-ca0c-4fac-9131-114d60e375d6.png"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">整套配置系统分为三层：</span><br><span class="line"><span class="section"># 顶层 RUNTIME</span></span><br><span class="line"><span class="section"># 中间层 MEMORY （主要修改的配置表）</span></span><br><span class="line"><span class="section"># 持久层 DISK 和 CFG FILE</span></span><br><span class="line"></span><br><span class="line">RUNTIME ：</span><br><span class="line"><span class="code">	代表 ProxySQL 当前正在使用的配置，无法直接修改此配置，必须要从下一层 （MEM层）</span></span><br><span class="line"><span class="code">“load” 进来。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">MEMORY：</span><br><span class="line">MEMORY 层上面连接 RUNTIME 层，下面disk持久层。这层可以在线操作 ProxySQL 配置，随</span><br><span class="line">便修改，不会影响生产环境。确认正常之后在加载达到RUNTIME和持久化的磁盘上。修改方法：</span><br><span class="line">insert、update、delete、select。</span><br><span class="line"></span><br><span class="line">DISK和CONFIG FILE：</span><br><span class="line">持久化配置信息。重启时，可以从磁盘快速加载回来。</span><br></pre></td></tr></table></figure>

<h4 id="ProxySQL-在不同层次间移动配置"><a href="#ProxySQL-在不同层次间移动配置" class="headerlink" title="ProxySQL  在不同层次间移动配置"></a>ProxySQL  在不同层次间移动配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">为了将配置持久化到磁盘或者应用到 runtime，在管理接口下有一系列管理命令来实现它们。</span><br><span class="line">1. user相关配置</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># MEM 加载到runtime</span></span></span><br><span class="line">LOAD MYSQL USERS TO RUNTIME;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># runtime 保存至 MEM</span></span></span><br><span class="line">SAVE MYSQL USERS TO MEMORY;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># disk 加载到 MEM</span></span></span><br><span class="line">LOAD MYSQL USERS FROM DISK;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># MEM 到 disk</span></span></span><br><span class="line">SAVE MYSQL USERS TO DISK;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># CFG 到 MEM</span></span></span><br><span class="line">LOAD MYSQL USERS FROM CONFIG</span><br><span class="line">=============================</span><br><span class="line">2. server 相关配置</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># MEM 加载到runtime</span></span></span><br><span class="line">LOAD MYSQL SERVERS TO RUNTIME;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># runtime 保存至 MEM</span></span></span><br><span class="line">SAVE MYSQL SERVERS TO MEMORY;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># disk 加载到 MEM</span></span></span><br><span class="line">LOAD MYSQL SERVERS FROM DISK;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># MEM 到 disk</span></span></span><br><span class="line">SAVE MYSQL SERVERS TO DISK;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># CFG 到 MEM</span></span></span><br><span class="line">LOAD MYSQL SERVERS FROM CONFIG</span><br><span class="line">===============================</span><br><span class="line">3. mysql query rules配置</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># MEM 加载到runtime</span></span></span><br><span class="line">LOAD MYSQL QUERY RULES TO RUNTIME;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># runtime 保存至 MEM</span></span></span><br><span class="line">SAVE MYSQL QUERY RULES TO MEMORY;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># disk 加载到 MEM</span></span></span><br><span class="line">LOAD MYSQL QUERY RULES FROM DISK;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># MEM 到 disk</span></span></span><br><span class="line">SAVE MYSQL QUERY RULES TO DISK;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># CFG 到 MEM</span></span></span><br><span class="line">LOAD MYSQL QUERY RULES FROM CONFIG</span><br><span class="line">=================================</span><br><span class="line">4. MySQL variables配置</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># MEM 加载到runtime</span></span></span><br><span class="line">LOAD MYSQL VARIABLES TO RUNTIME;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># runtime 保存至 MEM</span></span></span><br><span class="line">SAVE MYSQL VARIABLES TO MEMORY;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># disk 加载到 MEM</span></span></span><br><span class="line">LOAD MYSQL VARIABLES FROM DISK;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># MEM 到 disk</span></span></span><br><span class="line">SAVE MYSQL VARIABLES TO DISK;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># CFG 到 MEM</span></span></span><br><span class="line">LOAD MYSQL VARIABLES FROM CONFIG</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">日常配置其实大部分时间在MEM配置，然后load到RUNTIME，然后SAVE到DIsk。cfg很少使用。</span><br><span class="line">例如 ：</span><br><span class="line">load xxx to runtime;</span><br><span class="line">save xxx to disk;</span><br><span class="line">注意：</span><br><span class="line">只有load到 runtime 状态时才会验证配置。在保MEM或disk时，都不会发生任何警告或错误。</span><br><span class="line">当load到 runtime 时，如果出现错误，将恢复为之前保存得状态，这时可以去检查错误日志。</span><br></pre></td></tr></table></figure>

<h2 id="2-4-ProxySQL应用——基于SQL的读写分离"><a href="#2-4-ProxySQL应用——基于SQL的读写分离" class="headerlink" title="2.4  ProxySQL应用——基于SQL的读写分离"></a>2.4  ProxySQL应用——基于SQL的读写分离</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在mysql<span class="emphasis">_replication_</span>hostgroup表中，配置读写组编号</span><br><span class="line">db03 [main]&gt;insert into</span><br><span class="line">mysql<span class="emphasis">_replication_</span>hostgroups</span><br><span class="line">(writer<span class="emphasis">_hostgroup, reader_</span>hostgroup, comment)</span><br><span class="line">values (10,20,&#x27;proxy&#x27;);</span><br><span class="line">load mysql servers to runtime;</span><br><span class="line">save mysql servers to disk;</span><br><span class="line"></span><br><span class="line">db03 [main]&gt;select * from mysql<span class="emphasis">_replication_</span>hostgroups\G</span><br><span class="line"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** 1. row **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span><br><span class="line">writer<span class="emphasis">_hostgroup: 10</span></span><br><span class="line"><span class="emphasis">reader_</span>hostgroup: 20</span><br><span class="line">check<span class="emphasis">_type: read_</span>only</span><br><span class="line">comment: proxy</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">说明：</span><br><span class="line">ProxySQL 会根据server 的read<span class="emphasis">_only 的取值将服务器进行分组。 read_</span>only=0 的</span><br><span class="line">server，master被分到编号为10的写组，read<span class="emphasis">_only=1 的server，slave则被分到编号20的读</span></span><br><span class="line"><span class="emphasis">组。所以需要将从库设置：</span></span><br><span class="line"><span class="emphasis">set global read_</span>only=1;</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 添加主机到ProxySQL</span><br><span class="line">insert into mysql<span class="emphasis">_servers(hostgroup_</span>id,hostname,port) values</span><br><span class="line">(10,&#x27;10.0.0.51&#x27;,3306);</span><br><span class="line">insert into mysql<span class="emphasis">_servers(hostgroup_</span>id,hostname,port) values</span><br><span class="line">(20,&#x27;10.0.0.52&#x27;,3306);</span><br><span class="line">insert into mysql<span class="emphasis">_servers(hostgroup_</span>id,hostname,port) values</span><br><span class="line">(20,&#x27;10.0.0.53&#x27;,3306);</span><br><span class="line">load mysql servers to runtime;</span><br><span class="line">save mysql servers to disk;</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 创建监控用户，并开启监控</span><br><span class="line"><span class="section"># 主库创建监控用户</span></span><br><span class="line">create user monitor@&#x27;%&#x27; identified with mysql<span class="emphasis">_native_</span>password by &#x27;123&#x27;;</span><br><span class="line">grant replication client on <span class="emphasis">*.*</span> to monitor@&#x27;%&#x27;;</span><br><span class="line"><span class="section"># proxySQL修改variables表</span></span><br><span class="line">set mysql-monitor<span class="emphasis">_username=&#x27;monitor&#x27;;</span></span><br><span class="line"><span class="emphasis">set mysql-monitor_</span>password=&#x27;123&#x27;;</span><br><span class="line">或者 ：</span><br><span class="line">UPDATE global<span class="emphasis">_variables SET variable_</span>value=&#x27;monitor&#x27;</span><br><span class="line">WHERE variable<span class="emphasis">_name=&#x27;mysql-monitor_</span>username&#x27;;</span><br><span class="line">UPDATE global<span class="emphasis">_variables SET variable_</span>value=&#x27;123&#x27;</span><br><span class="line">WHERE variable<span class="emphasis">_name=&#x27;mysql-monitor_</span>password&#x27;;</span><br><span class="line">load mysql variables to runtime;</span><br><span class="line">save mysql variables to disk;</span><br><span class="line"><span class="section"># 查询监控日志</span></span><br><span class="line">db03 [(none)]&gt;select * from mysql<span class="emphasis">_server_</span>connect<span class="emphasis">_log;</span></span><br><span class="line"><span class="emphasis">db03 [(none)]&gt;select * from mysql_</span>server<span class="emphasis">_ping_</span>log;</span><br><span class="line">db03 [(none)]&gt;select * from mysql<span class="emphasis">_server_</span>read<span class="emphasis">_only_</span>log;</span><br><span class="line">db03 [(none)]&gt;select * from mysql<span class="emphasis">_server_</span>replication<span class="emphasis">_lag_</span>log;</span><br><span class="line"></span><br><span class="line">4.配置应用用户</span><br><span class="line">create user root@&#x27;%&#x27; identified with mysql<span class="emphasis">_native_</span>password by &#x27;123&#x27;;</span><br><span class="line">grant all on <span class="emphasis">*.*</span> to root@&#x27;%&#x27;;</span><br><span class="line">insert into mysql<span class="emphasis">_users(username,password,default_</span>hostgroup)</span><br><span class="line">values(&#x27;root&#x27;,&#x27;123&#x27;,10);</span><br><span class="line">load mysql users to runtime;</span><br><span class="line">save mysql users to disk;</span><br><span class="line">早期版本，需要开启事务持续化。</span><br><span class="line">update mysql<span class="emphasis">_users set transaction_</span>persistent=1 where username=&#x27;root&#x27;;</span><br><span class="line">load mysql users to runtime;</span><br><span class="line">save mysql users to disk;</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 实用的读写规则</span><br><span class="line">insert into</span><br><span class="line">mysql<span class="emphasis">_query_</span>rules(rule<span class="emphasis">_id,active,match_</span>pattern,destination<span class="emphasis">_hostgroup,apply)</span></span><br><span class="line"><span class="emphasis">values (1,1,&#x27;^select.*for update$&#x27;,10,1);</span></span><br><span class="line"><span class="emphasis">insert into</span></span><br><span class="line"><span class="emphasis">mysql_</span>query<span class="emphasis">_rules(rule_</span>id,active,match<span class="emphasis">_pattern,destination_</span>hostgroup,apply)</span><br><span class="line">values (2,1,&#x27;^select&#x27;,20,1);</span><br><span class="line">load mysql query rules to runtime;</span><br><span class="line">save mysql query rules to disk;</span><br><span class="line">注： select … for update规则的rule<span class="emphasis">_id必须要小于普通的select规则的rule_</span>id，</span><br><span class="line">ProxySQL是根据rule<span class="emphasis">_id的顺序进行规则匹配。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">6. 测试读写分离</span></span><br><span class="line"><span class="emphasis">[root@db03 ~]# mysql -uroot -p123 -P 6033 -h 127.0.0.1 -e &quot;begin;select</span></span><br><span class="line"><span class="emphasis">@@server_</span>id;commit&quot;</span><br><span class="line">[root@db03 ~]# mysql -uroot -p123 -P 6033 -h 127.0.0.1 -e &quot;select</span><br><span class="line">@@server<span class="emphasis">_id;&quot;</span></span><br><span class="line"><span class="emphasis">db03 [(none)]&gt;select * from stats_</span>mysql<span class="emphasis">_query_</span>digest\G</span><br></pre></td></tr></table></figure>

<h3 id="2-5-ProxySQL应用扩展——花式路由规则"><a href="#2-5-ProxySQL应用扩展——花式路由规则" class="headerlink" title="2.5 ProxySQL应用扩展——花式路由规则"></a>2.5 ProxySQL应用扩展——花式路由规则</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 基于端口的路由</span><br><span class="line"><span class="section">## 修改ProxySQL监听SQL流量的端口号，监听多端口上。</span></span><br><span class="line">set mysql-interfaces=&#x27;0.0.0.0:6033;0.0.0.0:6034&#x27;;</span><br><span class="line">save mysql variables to disk;</span><br><span class="line"></span><br><span class="line"><span class="section">## 重启生效</span></span><br><span class="line">systemctl restart proxysql</span><br><span class="line"></span><br><span class="line"><span class="section">## 设定路由规则</span></span><br><span class="line">delete from mysql<span class="emphasis">_query_</span>rules; # 为了测试，先清空已有规则</span><br><span class="line">insert into</span><br><span class="line">mysql<span class="emphasis">_query_</span>rules(rule<span class="emphasis">_id,active,proxy_</span>port,destination<span class="emphasis">_hostgroup,apply)</span></span><br><span class="line"><span class="emphasis">values(1,1,6033,10,1), (2,1,6034,20,1);</span></span><br><span class="line"><span class="emphasis">load mysql query rules to runtime;</span></span><br><span class="line"><span class="emphasis">save mysql query rules to disk;</span></span><br><span class="line"><span class="emphasis">说明：</span></span><br><span class="line"><span class="emphasis">	除了基于端口进行分离，还可以基于监听地址(修改字段proxy_</span>addr即可)，也可以基于客户端地</span><br><span class="line">址(修改字段client<span class="emphasis">_addr字段即可)。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">2. 基于用户的路由</span></span><br><span class="line"><span class="emphasis">nsert into mysql_</span>users(username,password,default<span class="emphasis">_hostgroup)</span></span><br><span class="line"><span class="emphasis">values(&#x27;writer&#x27;,&#x27;123&#x27;,10),(&#x27;reader&#x27;,&#x27;123&#x27;,20);</span></span><br><span class="line"><span class="emphasis">load mysql users to runtime;</span></span><br><span class="line"><span class="emphasis">save mysql users to disk;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">delete from mysql_</span>query<span class="emphasis">_rules; # 为了测试，先清空已有规则</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">insert into</span></span><br><span class="line"><span class="emphasis">mysql_</span>query<span class="emphasis">_rules(rule_</span>id,active,username,destination<span class="emphasis">_hostgroup,apply)</span></span><br><span class="line"><span class="emphasis">values(1,1,&#x27;writer&#x27;,10,1),(2,1,&#x27;reader&#x27;,20,1);</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">load mysql query rules to runtime;</span></span><br><span class="line"><span class="emphasis">save mysql query rules to disk;</span></span><br></pre></td></tr></table></figure>

<h1 id="3-ORCH可视化高可用集群应用"><a href="#3-ORCH可视化高可用集群应用" class="headerlink" title="3. ORCH可视化高可用集群应用"></a>3. ORCH可视化高可用集群应用</h1><h2 id="3-1-ORCH介绍"><a href="#3-1-ORCH介绍" class="headerlink" title="3.1 ORCH介绍"></a>3.1 ORCH介绍</h2><p>Orchestrator（orch）：go编写的MySQL高可用性和复制拓扑管理工具，支持复制拓扑结构的调整，</p>
<p>自动故障转移和手动主从切换等。后端数据库用MySQL或SQLite存储元数据，并提供Web界面展示</p>
<p>MySQL复制的拓扑关系及状态，通过Web可更改MySQL实例的复制关系和部分配置信息，同时也提供</p>
<p>命令行和api接口，方便运维管理。 <em><strong>相对比MHA来看最重要的是解决了管理节点的单点问题，其通过</strong></em></p>
<p><em><strong>raft协议保证本身的高可用。GitHub的一部分管理也在用该工具进行管理。</strong></em></p>
<p>① 自动发现MySQL的复制拓扑，并且在web上展示。</p>
<p>② 重构复制关系，可以在web进行拖图来进行复制关系变更。</p>
<p>③ 检测主异常，并可以自动或手动恢复，通过Hooks进行自定义脚本。</p>
<p>④ 支持命令行和web界面管理复制。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662430632001-ffbe7606-f029-4a5d-9386-05bca89c7cd3.png"></p>
<blockquote>
<p>参考文档： <a href="https://blog.csdn.net/u010648194/article/details/126039337?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~ESLANDING~default-4-126039337-blog-122556988.relrec_prioritylanding&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~ESLANDING~default-4-126039337-blog-122556988.relrec_prioritylanding&utm_relevant_index=5">Mysql orchestrator高可用_天道酬勤-明天会更好的博客-CSDN博客_mysql orchestrator</a></p>
</blockquote>
<h2 id="3-2-部署"><a href="#3-2-部署" class="headerlink" title="3.2 部署"></a>3.2 部署</h2><h4 id="a-集群规划"><a href="#a-集群规划" class="headerlink" title="a. 集群规划"></a>a. 集群规划</h4><table>
<thead>
<tr>
<th>IP地址</th>
<th>主机名</th>
<th>安装软件</th>
<th>数据库端口</th>
</tr>
</thead>
<tbody><tr>
<td>10.0.0.51</td>
<td>db01</td>
<td>mysql、orchestrator</td>
<td>3306、3307</td>
</tr>
<tr>
<td>10.0.0.52</td>
<td>db02</td>
<td>mysql、orchestrator</td>
<td>3306、3307</td>
</tr>
<tr>
<td>10.0.0.53</td>
<td>db03</td>
<td>mysql、orchestrator</td>
<td>3306、3307</td>
</tr>
</tbody></table>
<pre><code> 根据以上表格安装软件、配置地址和主机名、初始化6个MySQL实例。 orch默认是用主机名来进行管理的，需要在mysql的配置文件里添加：report_host和report_port参 数。  
</code></pre>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[root@db01 ~]# mysql -V</span><br><span class="line">mysql Ver 8.0.20 for Linux on x86<span class="emphasis">_64 (MySQL Community Server - GPL)</span></span><br><span class="line"><span class="emphasis">[root@db02 ~]# mysql -V</span></span><br><span class="line"><span class="emphasis">mysql Ver 8.0.20 for Linux on x86_</span>64 (MySQL Community Server - GPL)</span><br><span class="line">[root@db03 ~]# mysql -V</span><br><span class="line">mysql Ver 8.0.20 for Linux on x86<span class="emphasis">_64 (MySQL Community Server - GPL)</span></span><br><span class="line"><span class="emphasis">[root@db01 ~]# hostname</span></span><br><span class="line"><span class="emphasis">db01</span></span><br><span class="line"><span class="emphasis">[root@db01 ~]# cat /etc/hosts</span></span><br><span class="line"><span class="emphasis">127.0.0.1 localhost localhost.localdomain localhost4</span></span><br><span class="line"><span class="emphasis">localhost4.localdomain4</span></span><br><span class="line"><span class="emphasis">::1 localhost localhost.localdomain localhost6</span></span><br><span class="line"><span class="emphasis">localhost6.localdomain6</span></span><br><span class="line"><span class="emphasis">10.0.0.53 db03</span></span><br><span class="line"><span class="emphasis">10.0.0.52 db02</span></span><br><span class="line"><span class="emphasis">10.0.0.51 db01</span></span><br><span class="line"><span class="emphasis">[root@db02 ~]# cat /etc/hosts</span></span><br><span class="line"><span class="emphasis">127.0.0.1 localhost localhost.localdomain localhost4</span></span><br><span class="line"><span class="emphasis">localhost4.localdomain4</span></span><br><span class="line"><span class="emphasis">::1 localhost localhost.localdomain localhost6</span></span><br><span class="line"><span class="emphasis">localhost6.localdomain6</span></span><br><span class="line"><span class="emphasis">10.0.0.53 db03</span></span><br><span class="line"><span class="emphasis">10.0.0.52 db02</span></span><br><span class="line"><span class="emphasis">10.0.0.51 db01</span></span><br><span class="line"><span class="emphasis">[root@db03 ~]# cat /etc/hosts</span></span><br><span class="line"><span class="emphasis">127.0.0.1 localhost localhost.localdomain localhost4</span></span><br><span class="line"><span class="emphasis">localhost4.localdomain4</span></span><br><span class="line"><span class="emphasis">::1 localhost localhost.localdomain localhost6</span></span><br><span class="line"><span class="emphasis">localhost6.localdomain6</span></span><br><span class="line"><span class="emphasis">10.0.0.53 db03</span></span><br><span class="line"><span class="emphasis">10.0.0.52 db02</span></span><br><span class="line"><span class="emphasis">10.0.0.51 db01</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 部署6个 MySQL实例</span></span><br><span class="line"><span class="emphasis">pkill mysqld</span></span><br><span class="line"><span class="emphasis">rm -rf /etc/my3306.cnf</span></span><br><span class="line"><span class="emphasis">rm -rf /data/3306/data /data/3306/binlog*</span></span><br><span class="line"><span class="emphasis">mkdir -p /data/3306/data /data/3306/binlog</span></span><br><span class="line"><span class="emphasis">mysqld --initialize-insecure --user=mysql --basedir=/data/app/mysql --</span></span><br><span class="line"><span class="emphasis">datadir=/data/3306/data</span></span><br><span class="line"><span class="emphasis">pkill mysqld</span></span><br><span class="line"><span class="emphasis">rm -rf /etc/my3307.cnf</span></span><br><span class="line"><span class="emphasis">rm -rf /data/3307/data /data/3307/binlog*</span></span><br><span class="line"><span class="emphasis">mkdir -p /data/3307/data /data/3307/binlog</span></span><br><span class="line"><span class="emphasis">mysqld --initialize-insecure --user=mysql --basedir=/data/app/mysql --</span></span><br><span class="line"><span class="emphasis">datadir=/data/3307/data</span></span><br><span class="line"><span class="emphasis">cat &gt; /etc/my3306.cnf &lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis">[<span class="attr">client</span>]</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">socket</span>=<span class="string">/tmp/mysql3306.sock</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis">[<span class="attr">mysqld</span>]</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">user</span>=<span class="string">mysql</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">datadir</span>=<span class="string">/data/3306/data</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">log_bin</span>=<span class="string">/data/3306/binlog/mysql-bin</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">server_id</span>=<span class="string">6</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">socket</span>=<span class="string">/tmp/mysql.sock</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">gtid_mode</span>=<span class="string">ON</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">enforce_gtid_consistency</span>=<span class="string">ON</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">master_info_repository</span>=<span class="string">TABLE</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">relay_log_info_repository</span>=<span class="string">TABLE</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">log_slave_updates</span>=<span class="string">ON</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">tmpdir</span> = <span class="string">/tmp</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">default-storage-engine</span>=<span class="string">INNODB</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">disabled_storage_engines</span> = <span class="string">MyISAM,BLACKHOLE,FEDERATED,CSV,ARCHIVE</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">max_connections</span>=<span class="string">500</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">max_allowed_packet</span>=<span class="string">32M</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">default_authentication_plugin</span>=<span class="string">mysql_native_password</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">report_host</span>=<span class="string">10.0.0.51</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">report_port</span>=<span class="string">3306</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">mysqlx</span>=<span class="string">0</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">EOF</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">cat</span> &gt;</span></span> /etc/my3307.cnf &lt;<span class="language-xml"><span class="tag">&lt;<span class="name">EOF</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis">[<span class="attr">client</span>]</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">socket</span>=<span class="string">/tmp/mysql3307.sock</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis">[<span class="attr">mysqld</span>]</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">user</span>=<span class="string">mysql</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">basedir</span>=<span class="string">/data/app/mysql</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">datadir</span>=<span class="string">/data/3307/data</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">log_bin</span>=<span class="string">/data/3307/binlog/mysql-bin</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">server_id</span>=<span class="string">16</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">socket</span>=<span class="string">/tmp/mysql3307.sock</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">gtid_mode</span>=<span class="string">ON</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">enforce_gtid_consistency</span>=<span class="string">ON</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">master_info_repository</span>=<span class="string">TABLE</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">relay_log_info_repository</span>=<span class="string">TABLE</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">log_slave_updates</span>=<span class="string">ON</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">tmpdir</span> = <span class="string">/tmp</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">default-storage-engine</span>=<span class="string">INNODB</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">disabled_storage_engines</span> = <span class="string">MyISAM,BLACKHOLE,FEDERATED,CSV,ARCHIVE</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">max_connections</span>=<span class="string">500</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">max_allowed_packet</span>=<span class="string">32M</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">default_authentication_plugin</span>=<span class="string">mysql_native_password</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">report_host</span>=<span class="string">10.0.0.51</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">report_port</span>=<span class="string">3307</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">port</span>=<span class="string">3307</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">mysqlx</span>=<span class="string">0</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="emphasis"><span class="attr">EOF</span></span></span></span></span><br></pre></td></tr></table></figure>

<h4 id="b-获取软件和相关脚本"><a href="#b-获取软件和相关脚本" class="headerlink" title="b. 获取软件和相关脚本"></a>b. 获取软件和相关脚本</h4><p><code>https://github.com/openark/orchestrator/releases </code></p>
<p><code>https://github.com/theTibi/orchestrator_vip  </code></p>
<h4 id="c-安装软件"><a href="#c-安装软件" class="headerlink" title="c. 安装软件"></a>c. 安装软件</h4><p><code>yum install -y orchestrator-* </code></p>
<h4 id="d-配置orch-后端数据库及用户-所有3306节点"><a href="#d-配置orch-后端数据库及用户-所有3306节点" class="headerlink" title="d. 配置orch 后端数据库及用户(所有3306节点)"></a>d. 配置orch 后端数据库及用户(所有3306节点)</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS oldguo;</span><br><span class="line">CREATE USER &#x27;oldguo&#x27;@&#x27;127.0.0.1&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT ALL ON oldguo.* TO &#x27;oldguo&#x27;@&#x27;127.0.0.1&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="e-配置被管理节点主从关系-3307"><a href="#e-配置被管理节点主从关系-3307" class="headerlink" title="e.配置被管理节点主从关系(3307)"></a>e.配置被管理节点主从关系(3307)</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 主库</span></span><br><span class="line">CREATE USER &#x27;repl&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT replication slave on <span class="emphasis">*.*</span> TO &#x27;repl&#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="section"># 从库</span></span><br><span class="line">change master to</span><br><span class="line">master<span class="emphasis">_host=&#x27;10.0.0.51&#x27;,master_</span>port=3307,master<span class="emphasis">_user=&#x27;repl&#x27;,master_</span>password</span><br><span class="line">=&#x27;123456&#x27;,master<span class="emphasis">_auto_</span>position=1,MASTER<span class="emphasis">_HEARTBEAT_</span>PERIOD=2,MASTER<span class="emphasis">_CONNECT_</span>R</span><br><span class="line">ETRY=1, MASTER<span class="emphasis">_RETRY_</span>COUNT=86400;</span><br><span class="line">start slave;</span><br><span class="line">set global slave<span class="emphasis">_net_</span>timeout=8;</span><br><span class="line">set global read<span class="emphasis">_only=1;</span></span><br><span class="line"><span class="emphasis">set global super_</span>read<span class="emphasis">_only=1;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#说明：</span></span><br><span class="line"><span class="emphasis">1、orch检测主库宕机依赖从库的IO线程。默认change master to时，</span></span><br><span class="line"><span class="emphasis">MASTER_</span>HEARTBEAT<span class="emphasis">_PERIOD过长，会导致切换判断过久。所以，需要修改</span></span><br><span class="line"><span class="emphasis">MASTER_</span>HEARTBEAT<span class="emphasis">_PERIOD 优化故障感知速度。</span></span><br><span class="line"><span class="emphasis">2、另外slave_</span>net<span class="emphasis">_timeout,参数定义了从库从主库获取数据等待的秒数，超过这个时间从库会主动</span></span><br><span class="line"><span class="emphasis">退出读取，中断连接，并尝试重连。</span></span><br></pre></td></tr></table></figure>

<h4 id="f-配置被管理节点用户"><a href="#f-配置被管理节点用户" class="headerlink" title="f. 配置被管理节点用户"></a>f. 配置被管理节点用户</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;oldboy&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;Aa123456&#x27;;</span><br><span class="line">GRANT SUPER, PROCESS, REPLICATION SLAVE, RELOAD ON <span class="emphasis">*.*</span> TO &#x27;oldboy&#x27;@&#x27;%&#x27;;</span><br><span class="line">GRANT SELECT ON mysql.slave<span class="emphasis">_master_</span>info TO &#x27;oldboy&#x27;@&#x27;%&#x27;;</span><br><span class="line">GRANT SELECT ON meta.* TO &#x27;oldboy&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="g-orch配置文件定制"><a href="#g-orch配置文件定制" class="headerlink" title="g.orch配置文件定制"></a>g.orch配置文件定制</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> orchestrator<span class="literal">-sample</span>.conf.json /etc/orchestrator.conf.json</span><br><span class="line">vim /etc/orchestrator.conf.json</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Debug&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;EnableSyslog&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;ListenAddress&quot;</span>: <span class="string">&quot;:3000&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLTopologyUser&quot;</span>: <span class="string">&quot;orchestrator&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLTopologyPassword&quot;</span>: <span class="string">&quot;Aa123456&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLTopologyCredentialsConfigFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLTopologySSLPrivateKeyFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLTopologySSLCertFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLTopologySSLCAFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLTopologySSLSkipVerify&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;MySQLTopologyUseMutualTLS&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorHost&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorPort&quot;</span>: <span class="number">3306</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorDatabase&quot;</span>: <span class="string">&quot;orchestrator&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorUser&quot;</span>: <span class="string">&quot;orchestrator&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorPassword&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorCredentialsConfigFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorSSLPrivateKeyFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorSSLCertFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorSSLCAFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorSSLSkipVerify&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;MySQLOrchestratorUseMutualTLS&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;MySQLConnectTimeoutSeconds&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;MySQLTopologyReadTimeoutSeconds&quot;</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">&quot;MySQLDiscoveryReadTimeoutSeconds&quot;</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">&quot;DefaultInstancePort&quot;</span>: <span class="number">3306</span>,</span><br><span class="line"><span class="string">&quot;DiscoverByShowSlaveHosts&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;InstancePollSeconds&quot;</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">&quot;UnseenInstanceForgetHours&quot;</span>: <span class="number">240</span>,</span><br><span class="line"><span class="string">&quot;SnapshotTopologiesIntervalHours&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;InstanceBulkOperationsWaitTimeoutSeconds&quot;</span>: <span class="number">10</span>,</span><br><span class="line"><span class="string">&quot;HostnameResolveMethod&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line"><span class="string">&quot;MySQLHostnameResolveMethod&quot;</span>: <span class="string">&quot;@@hostname&quot;</span>,</span><br><span class="line"><span class="string">&quot;SkipBinlogServerUnresolveCheck&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;SkipMaxScaleCheck&quot;</span>:true,</span><br><span class="line"><span class="string">&quot;ExpiryHostnameResolvesMinutes&quot;</span>: <span class="number">60</span>,</span><br><span class="line"><span class="string">&quot;RejectHostnameResolvePattern&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;ReasonableReplicationLagSeconds&quot;</span>: <span class="number">10</span>,</span><br><span class="line"><span class="string">&quot;ProblemIgnoreHostnameFilters&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;VerifyReplicationFilters&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;ReasonableMaintenanceReplicationLagSeconds&quot;</span>: <span class="number">20</span>,</span><br><span class="line"><span class="string">&quot;CandidateInstanceExpireMinutes&quot;</span>: <span class="number">1440</span>,</span><br><span class="line"><span class="string">&quot;AuditLogFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;AuditToSyslog&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;RemoveTextFromHostnameDisplay&quot;</span>: <span class="string">&quot;:3306&quot;</span>,</span><br><span class="line"><span class="string">&quot;ReadOnly&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;AuthenticationMethod&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;HTTPAuthUser&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;HTTPAuthPassword&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;AuthUserHeader&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;PowerAuthUsers&quot;</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line"><span class="string">&quot;ClusterNameToAlias&quot;</span>: &#123;<span class="string">&quot;127.0.0.1&quot;</span>: <span class="string">&quot;test suite&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;SlaveLagQuery&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;DetectClusterAliasQuery&quot;</span>: <span class="string">&quot;SELECT cluster_name FROM meta.cluster WHERE</span></span><br><span class="line"><span class="string">cluster_name = left(@@hostname,4) &quot;</span>,</span><br><span class="line"><span class="string">&quot;DetectClusterDomainQuery&quot;</span>: <span class="string">&quot;SELECT cluster_domain FROM meta.cluster WHERE</span></span><br><span class="line"><span class="string">cluster_name = left(@@hostname,4) &quot;</span>,</span><br><span class="line"><span class="string">&quot;DetectInstanceAliasQuery&quot;</span>: <span class="string">&quot;SELECT @@hostname as instance_alias&quot;</span>,</span><br><span class="line"><span class="string">&quot;DetectPromotionRuleQuery&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;DetectDataCenterQuery&quot;</span>: <span class="string">&quot;SELECT data_center FROM meta.cluster WHERE</span></span><br><span class="line"><span class="string">cluster_name = left(@@hostname,4) &quot;</span>,</span><br><span class="line"><span class="string">&quot;PhysicalEnvironmentPattern&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;PromotionIgnoreHostnameFilters&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;DetachLostReplicasAfterMasterFailover&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;DetectSemiSyncEnforcedQuery&quot;</span>: <span class="string">&quot;SELECT 0 AS semisync FROM DUAL WHERE NOT</span></span><br><span class="line"><span class="string">EXISTS (SELECT 1 FROM performance_schema.global_variables WHERE</span></span><br><span class="line"><span class="string">VARIABLE_NAME = &#x27;rpl_semi_sync_master_wait_no_slave&#x27; AND VARIABLE_VALUE =</span></span><br><span class="line"><span class="string">&#x27;ON&#x27;) UNION SELECT 1 FROM DUAL WHERE EXISTS (SELECT 1 FROM</span></span><br><span class="line"><span class="string">performance_schema.global_variables WHERE VARIABLE_NAME =</span></span><br><span class="line"><span class="string">&#x27;rpl_semi_sync_master_wait_no_slave&#x27; AND VARIABLE_VALUE = &#x27;ON&#x27;)&quot;</span>,</span><br><span class="line"><span class="string">&quot;ServeAgentsHttp&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;AgentsServerPort&quot;</span>: <span class="string">&quot;:3001&quot;</span>,</span><br><span class="line"><span class="string">&quot;AgentsUseSSL&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;AgentsUseMutualTLS&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;AgentSSLSkipVerify&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;AgentSSLPrivateKeyFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;AgentSSLCertFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;AgentSSLCAFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;AgentSSLValidOUs&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;UseSSL&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;UseMutualTLS&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;SSLSkipVerify&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;SSLPrivateKeyFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;SSLCertFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;SSLCAFile&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;SSLValidOUs&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;URLPrefix&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;StatusEndpoint&quot;</span>: <span class="string">&quot;/api/status&quot;</span>,</span><br><span class="line"><span class="string">&quot;StatusSimpleHealth&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;StatusOUVerify&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;AgentPollMinutes&quot;</span>: <span class="number">60</span>,</span><br><span class="line"><span class="string">&quot;UnseenAgentForgetHours&quot;</span>: <span class="number">6</span>,</span><br><span class="line"><span class="string">&quot;StaleSeedFailMinutes&quot;</span>: <span class="number">60</span>,</span><br><span class="line"><span class="string">&quot;SeedAcceptableBytesDiff&quot;</span>: <span class="number">8192</span>,</span><br><span class="line"><span class="string">&quot;AutoPseudoGTID&quot;</span>:true,</span><br><span class="line"><span class="string">&quot;PseudoGTIDPattern&quot;</span>: <span class="string">&quot;drop view if exists</span></span><br><span class="line"><span class="string">`meta`.`_pseudo_gtid_hint__asc:&quot;</span>,</span><br><span class="line"><span class="string">&quot;PseudoGTIDPatternIsFixedSubstring&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;PseudoGTIDMonotonicHint&quot;</span>: <span class="string">&quot;asc:&quot;</span>,</span><br><span class="line"><span class="string">&quot;DetectPseudoGTIDQuery&quot;</span>: <span class="string">&quot;select count(*) as pseudo_gtid_exists from</span></span><br><span class="line"><span class="string">meta.pseudo_gtid_status where anchor = 1 and time_generated &gt; now() -</span></span><br><span class="line"><span class="string">interval 2 hour&quot;</span>,</span><br><span class="line"><span class="string">&quot;BinlogEventsChunkSize&quot;</span>: <span class="number">10000</span>,</span><br><span class="line"><span class="string">&quot;SkipBinlogEventsContaining&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;ReduceReplicationAnalysisCount&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;FailureDetectionPeriodBlockMinutes&quot;</span>: <span class="number">60</span>,</span><br><span class="line"><span class="string">&quot;RecoveryPeriodBlockSeconds&quot;</span>: <span class="number">31</span>,</span><br><span class="line"><span class="string">&quot;RecoveryIgnoreHostnameFilters&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;RecoverMasterClusterFilters&quot;</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line"><span class="string">&quot;RecoverIntermediateMasterClusterFilters&quot;</span>: [<span class="string">&quot;*&quot;</span>],</span><br><span class="line"><span class="string">&quot;OnFailureDetectionProcesses&quot;</span>: [<span class="string">&quot;echo &#x27; Detected &#123;failureType&#125; on</span></span><br><span class="line"><span class="string">&#123;failureCluster&#125;. Affected replicas: &#123;countSlaves&#125;&#x27; &gt;&gt;</span></span><br><span class="line"><span class="string">/tmp/recovery.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;PreGracefulTakeoverProcesses&quot;</span>: [<span class="string">&quot;echo &#x27; Planned takeover about to take</span></span><br><span class="line"><span class="string">place on &#123;failureCluster&#125;. Master will switch to read_only&#x27; &gt;&gt;</span></span><br><span class="line"><span class="string">/tmp/recovery.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;PreFailoverProcesses&quot;</span>: [<span class="string">&quot;echo &#x27; Will recover from &#123;failureType&#125; on</span></span><br><span class="line"><span class="string">&#123;failureCluster&#125;&#x27; &gt;&gt; /tmp/recovery.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;PostFailoverProcesses&quot;</span>: [<span class="string">&quot;echo &#x27; (for all types) Recovered from</span></span><br><span class="line"><span class="string">&#123;failureType&#125; on &#123;failureCluster&#125;. Failed: &#123;failedHost&#125;:&#123;failedPort&#125;;</span></span><br><span class="line"><span class="string">Successor: &#123;successorHost&#125;:&#123;successorPort&#125;; failureClusterAlias:</span></span><br><span class="line"><span class="string">&#123;failureClusterAlias&#125;&#x27; &gt;&gt;</span></span><br><span class="line"><span class="string">/tmp/recovery.log&quot;</span>,<span class="string">&quot;/usr/local/orchestrator/orch_hook.sh &#123;failureType&#125;</span></span><br><span class="line"><span class="string">&#123;failureClusterAlias&#125; &#123;failedHost&#125; &#123;successorHost&#125; &gt;&gt; /tmp/orch.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;PostUnsuccessfulFailoverProcesses&quot;</span>: [ <span class="string">&quot;echo &#x27; Unsuccessful Failover &#x27; &gt;&gt;</span></span><br><span class="line"><span class="string">/tmp/recovery.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;PostMasterFailoverProcesses&quot;</span>: [<span class="string">&quot;echo &#x27; Recovered from &#123;failureType&#125; on</span></span><br><span class="line"><span class="string">&#123;failureCluster&#125;. Failed: &#123;failedHost&#125;:&#123;failedPort&#125;; Promoted:</span></span><br><span class="line"><span class="string">&#123;successorHost&#125;:&#123;successorPort&#125;&#x27; &gt;&gt;/tmp/recovery.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;PostIntermediateMasterFailoverProcesses&quot;</span>: [<span class="string">&quot;echo &#x27; Recovered from</span></span><br><span class="line"><span class="string">&#123;failureType&#125; on &#123;failureCluster&#125;. Failed: &#123;failedHost&#125;:&#123;failedPort&#125;;</span></span><br><span class="line"><span class="string">Successor: &#123;successorHost&#125;:&#123;successorPort&#125;&#x27; &gt;&gt; /tmp/recovery.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;PostGracefulTakeoverProcesses&quot;</span>: [<span class="string">&quot;echo &#x27; Planned takeover complete&#x27; &gt;&gt;</span></span><br><span class="line"><span class="string">/tmp/recovery.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;CoMasterRecoveryMustPromoteOtherCoMaster&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;DetachLostSlavesAfterMasterFailover&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;ApplyMySQLPromotionAfterMasterFailover&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;PreventCrossDataCenterMasterFailover&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;MasterFailoverDetachSlaveMasterHost&quot;</span>: false,</span><br><span class="line"><span class="string">&quot;MasterFailoverLostInstancesDowntimeMinutes&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;PostponeSlaveRecoveryOnLagMinutes&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;OSCIgnoreHostnameFilters&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;GraphiteAddr&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;GraphitePath&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;GraphiteConvertHostnameDotsToUnderscores&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;RaftEnabled&quot;</span>: true,</span><br><span class="line"><span class="string">&quot;BackendDB&quot;</span>: <span class="string">&quot;mysql&quot;</span>,</span><br><span class="line"><span class="string">&quot;RaftBind&quot;</span>: <span class="string">&quot;10.0.0.51&quot;</span>,</span><br><span class="line"><span class="string">&quot;RaftDataDir&quot;</span>: <span class="string">&quot;/usr/local/orchestrator&quot;</span>,</span><br><span class="line"><span class="string">&quot;DefaultRaftPort&quot;</span>: <span class="number">10008</span>,</span><br><span class="line"><span class="string">&quot;RaftNodes&quot;</span>: [<span class="string">&quot;10.0.0.51&quot;</span>,<span class="string">&quot;10.0.0.52&quot;</span>,<span class="string">&quot;10.0.0.53&quot;</span>],</span><br><span class="line"><span class="string">&quot;ConsulAddress&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="string">&quot;ConsulAclToken&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="h-启动orch"><a href="#h-启动orch" class="headerlink" title="h.启动orch"></a>h.启动orch</h4><p><code> cd /usr/local/orchestrator &amp;&amp; nohup ./orchestrator -- config=/etc/orchestrator.conf.json http &amp;</code>  </p>
<h4 id="i-配置自动切换脚本"><a href="#i-配置自动切换脚本" class="headerlink" title="i.配置自动切换脚本"></a>i.配置自动切换脚本</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;PostFailoverProcesses&quot;</span>: [<span class="string">&quot;echo &#x27; (for all types) Recovered from</span></span><br><span class="line"><span class="string">&#123;failureType&#125; on &#123;failureCluster&#125;. Failed: &#123;failedHost&#125;:&#123;failedPort&#125;;</span></span><br><span class="line"><span class="string">Successor: &#123;successorHost&#125;:&#123;successorPort&#125;; failureClusterAlias:</span></span><br><span class="line"><span class="string">&#123;failureClusterAlias&#125;&#x27; &gt;&gt;</span></span><br><span class="line"><span class="string">/tmp/recovery.log&quot;</span>,<span class="string">&quot;/usr/local/orchestrator/orch_hook.sh &#123;failureType&#125;</span></span><br><span class="line"><span class="string">&#123;failureClusterAlias&#125; &#123;failedHost&#125; &#123;successorHost&#125; &gt;&gt; /tmp/orch.log&quot;</span>],</span><br><span class="line"><span class="string">&quot;PostUnsuccessfulFailoverProcesses&quot;</span>: [ <span class="string">&quot;echo &#x27; Unsuccessful Failover &#x27; &gt;&gt;</span></span><br><span class="line"><span class="string">/tmp/recovery.log&quot;</span>],</span><br></pre></td></tr></table></figure>

<h4 id="j-免交互管理orch"><a href="#j-免交互管理orch" class="headerlink" title="j. 免交互管理orch"></a>j. 免交互管理orch</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看集群信息</span></span><br><span class="line">orchestrator<span class="literal">-client</span> <span class="literal">-c</span> clusters</span><br><span class="line"><span class="comment"># 手工发现节点</span></span><br><span class="line">orchestrator<span class="literal">-client</span> <span class="literal">-c</span> discover <span class="literal">-i</span> db01:<span class="number">3307</span></span><br><span class="line"><span class="comment"># 忘记节点</span></span><br><span class="line">orchestrator<span class="literal">-client</span> <span class="literal">-c</span> forget <span class="literal">-i</span> db01:<span class="number">3307</span></span><br><span class="line"><span class="comment"># 查看集群拓扑</span></span><br><span class="line">orchestrator<span class="literal">-client</span> <span class="literal">-c</span> topology<span class="literal">-tabulated</span> <span class="literal">-i</span> db03:<span class="number">3307</span></span><br><span class="line"><span class="comment"># 手工切换主从关系</span></span><br><span class="line">orchestrator<span class="literal">-client</span> <span class="literal">-c</span> graceful<span class="literal">-master-takeover</span> <span class="literal">-a</span> db03:<span class="number">3307</span> <span class="literal">-d</span> db01:<span class="number">3307</span></span><br><span class="line"><span class="comment"># 调整主从拓扑</span></span><br><span class="line">orchestrator<span class="literal">-client</span> <span class="literal">-c</span> relocate <span class="literal">-i</span> db03:<span class="number">3307</span> <span class="literal">-d</span> db01:<span class="number">3307</span></span><br></pre></td></tr></table></figure>

<h1 id="4-InnoDB-Cluster-应用"><a href="#4-InnoDB-Cluster-应用" class="headerlink" title="4. InnoDB Cluster 应用"></a>4. InnoDB Cluster 应用</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">MySQL InnoDB集群提供了一个集成的，本地的，HA解决方案。Mysq Innodb Cluster是利用组复制</span><br><span class="line">的 pxos 协议，保障数据一致性，组复制支持单主模式和多主模式。</span><br><span class="line">MySQL InnoDB集群由以下几部分组成：</span><br><span class="line">- MySQL Servers with <span class="built_in">Group</span> Replication：向集群的所有成员复制数据，同时提供容错、自</span><br><span class="line">动故障转移和弹性。MySQL Server <span class="number">5.7</span>.<span class="number">17</span>或更高的版本。</span><br><span class="line">- MySQL Router：确保客户端请求是负载平衡的，并在任何数据库故障时路由到正确的服务器。</span><br><span class="line">MySQL Router <span class="number">2.1</span>.<span class="number">3</span>或更高的版本。</span><br><span class="line">- MySQL Shell：通过内置的管理API创建及管理Innodb集群。MySQL Shell <span class="number">1.0</span>.<span class="number">9</span>或更高的版</span><br><span class="line">本。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662218330238-24640bac-ff31-41eb-8fb4-f9d3c8a2fa5a.png"></p>
<h2 id="4-2-构建过程"><a href="#4-2-构建过程" class="headerlink" title="4.2 构建过程"></a>4.2 构建过程</h2><h3 id="4-2-1主机-规划列表"><a href="#4-2-1主机-规划列表" class="headerlink" title="4.2.1主机 规划列表"></a>4.2.1主机 规划列表</h3><table>
<thead>
<tr>
<th>IP</th>
<th>HOSTNAME</th>
<th>主机角色</th>
<th>安装软件</th>
</tr>
</thead>
<tbody><tr>
<td>10.0.0.151</td>
<td>master</td>
<td>mic-master</td>
<td>mysql、mysqlsh</td>
</tr>
<tr>
<td>10.0.0.152</td>
<td>slave1</td>
<td>mic-slave1</td>
<td>mysql、mysqlsh</td>
</tr>
<tr>
<td>10.0.0.153</td>
<td>slave2</td>
<td>mic-slave2</td>
<td>mysql、mysqlsh</td>
</tr>
<tr>
<td>10.0.0.154</td>
<td>manager</td>
<td>mic-manager</td>
<td>mysqlsh、mysql-router</td>
</tr>
</tbody></table>
<h3 id="4-2-2-准备MIC基础环境"><a href="#4-2-2-准备MIC基础环境" class="headerlink" title="4.2.2 准备MIC基础环境"></a>4.2.2 准备MIC基础环境</h3><blockquote>
<p><em><strong><font style="color:#E8323C;">准备三台虚拟机并上传软件  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照规划列表，将所有软件解压。</span></span><br><span class="line">tar xf mysql<span class="literal">-8</span>.<span class="number">0.20</span><span class="literal">-linux-glibc2</span>.<span class="number">12</span><span class="literal">-x86_64</span>.tar.xz</span><br><span class="line">tar xf mysql<span class="literal">-shell-8</span>.<span class="number">0.21</span><span class="literal">-linux-glibc2</span>.<span class="number">12</span><span class="literal">-x86-64bit</span>.tar.gz</span><br><span class="line">tar xf mysql<span class="literal">-router-8</span>.<span class="number">0.21</span><span class="literal">-linux-glibc2</span>.<span class="number">12</span><span class="literal">-x86_64</span>.tar.xz</span><br><span class="line">ln <span class="literal">-s</span> mysql<span class="literal">-8</span>.<span class="number">0.20</span><span class="literal">-linux-glibc2</span>.<span class="number">12</span><span class="literal">-x86_64</span> mysql</span><br><span class="line">ln <span class="literal">-s</span> mysql<span class="literal">-shell-8</span>.<span class="number">0.21</span><span class="literal">-linux-glibc2</span>.<span class="number">12</span><span class="literal">-x86-64bit</span>.tar.gz mysqlsh</span><br><span class="line">ln <span class="literal">-s</span> mysql<span class="literal">-shell-8</span>.<span class="number">0.21</span><span class="literal">-linux-glibc2</span>.<span class="number">12</span><span class="literal">-x86-64bit</span>.tar.gz mysql<span class="literal">-router</span></span><br><span class="line"><span class="comment"># 配置环境遍变量</span></span><br><span class="line">export PATH=/<span class="keyword">data</span>/app/mysql/bin:/<span class="keyword">data</span>/app/mysqlsh/bin:/<span class="keyword">data</span>/app/mysqlrouter/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 按照规划列表，将所有主机名和hosts文件全部解析。</span></span><br><span class="line"><span class="built_in">cat</span> /etc/hosts</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span> localhost localhost.localdomain localhost4</span><br><span class="line">localhost4.localdomain4</span><br><span class="line">::<span class="number">1</span> localhost localhost.localdomain localhost6</span><br><span class="line">localhost6.localdomain6</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.151</span> master</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.152</span> slave1</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.153</span> slave2</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.154</span> manage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有节点Firewalld和SELINUX关闭。</span></span><br><span class="line">略。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><font style="color:#E8323C;">准备三台数据库节点（151、152、153）</font></strong><font style="color:#E8323C;"> </font> </p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#清理环境，并重新初始化数据</span></span><br><span class="line">pkill mysqld</span><br><span class="line">pkill mysqlsh</span><br><span class="line"><span class="built_in">rm</span> <span class="literal">-rf</span> /<span class="keyword">data</span>/<span class="number">3306</span>/<span class="keyword">data</span> /<span class="keyword">data</span>/<span class="number">3306</span>/binlog*</span><br><span class="line">mkdir /<span class="keyword">data</span>/<span class="number">3306</span>/<span class="keyword">data</span> /<span class="keyword">data</span>/<span class="number">3306</span>/binlog</span><br><span class="line">mysqld <span class="literal">--initialize-insecure</span> <span class="literal">--user</span>=mysql <span class="literal">--basedir</span>=/<span class="keyword">data</span>/app/mysql <span class="literal">--</span></span><br><span class="line">datadir=/<span class="keyword">data</span>/<span class="number">3306</span>/<span class="keyword">data</span></span><br><span class="line"><span class="comment">#配置文件准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## master节点</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">app</span>]<span class="comment"># cat &gt; /etc/my.cnf &lt;&lt;EOF</span></span><br><span class="line">[<span class="type">client</span>]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">[<span class="type">mysqld</span>]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/<span class="keyword">data</span>/app/mysql</span><br><span class="line">datadir=/<span class="keyword">data</span>/<span class="number">3306</span>/<span class="keyword">data</span></span><br><span class="line">log_bin=/<span class="keyword">data</span>/<span class="number">3306</span>/binlog</span><br><span class="line">server_id=<span class="number">151</span></span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency=ON</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">log_slave_updates=ON</span><br><span class="line">tmpdir = /tmp</span><br><span class="line">default<span class="literal">-storage-engine</span>=INNODB</span><br><span class="line">disabled_storage_engines = MyISAM,BLACKHOLE,FEDERATED,CSV,ARCHIVE</span><br><span class="line">max_connections=<span class="number">500</span></span><br><span class="line">max_allowed_packet=<span class="number">32</span>M</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">binlog_checksum=NONE</span><br><span class="line">binlog_transaction_dependency_tracking = WRITESET</span><br><span class="line">transaction_write_set_extraction=XXHASH64</span><br><span class="line">loose<span class="literal">-group_replication_group_name</span>=<span class="string">&quot;ca842376-1c50-42ac-bb57-a5adc7da7a12&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_start_on_boot</span>=OFF</span><br><span class="line">loose<span class="literal">-group_replication_local_address</span>= <span class="string">&quot;master:33061&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_group_seeds</span>=</span><br><span class="line"><span class="string">&quot;master:33061,slave1:33062,slave2:33063&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_bootstrap_group</span>=OFF</span><br><span class="line">loose<span class="literal">-group_replication_ip_whitelist</span>=<span class="string">&quot;master,slave1,slave2,manager&quot;</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">## slave1 节点</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">slave1</span> <span class="type">data</span>]<span class="comment"># cat &gt;/etc/my.cnf &lt;&lt;EOF</span></span><br><span class="line">[<span class="type">client</span>]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">[<span class="type">mysqld</span>]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/<span class="keyword">data</span>/app/mysql</span><br><span class="line">datadir=/<span class="keyword">data</span>/<span class="number">3306</span>/<span class="keyword">data</span></span><br><span class="line">log_bin=/<span class="keyword">data</span>/<span class="number">3306</span>/binlog</span><br><span class="line">server_id=<span class="number">152</span></span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency=ON</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">log_slave_updates=ON</span><br><span class="line">tmpdir = /tmp</span><br><span class="line">default<span class="literal">-storage-engine</span>=INNODB</span><br><span class="line">disabled_storage_engines = MyISAM,BLACKHOLE,FEDERATED,CSV,ARCHIVE</span><br><span class="line">max_connections=<span class="number">500</span></span><br><span class="line">max_allowed_packet=<span class="number">16</span>M</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">binlog_checksum=NONE</span><br><span class="line">binlog_transaction_dependency_tracking = WRITESET</span><br><span class="line">transaction_write_set_extraction=XXHASH64</span><br><span class="line">loose<span class="literal">-group_replication_group_name</span>=<span class="string">&quot;ca842376-1c50-42ac-bb57-a5adc7da7a12&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_start_on_boot</span>=OFF</span><br><span class="line">loose<span class="literal">-group_replication_local_address</span>= <span class="string">&quot;slave1:33062&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_group_seeds</span>=</span><br><span class="line"><span class="string">&quot;master:33061,slave1:33062,slave2:33063&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_bootstrap_group</span>=OFF</span><br><span class="line">loose<span class="literal">-group_replication_ip_whitelist</span>=<span class="string">&quot;master,slave1,slave2,manager&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_allow_local_disjoint_gtids_join</span>=ON</span><br><span class="line">[<span class="type">root</span>@<span class="type">slave1</span> <span class="type">data</span>]<span class="comment">#</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">## slave2 节点</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">slave2</span> <span class="type">data</span>]<span class="comment"># cat &gt; /etc/my.cnf &lt;&lt;EOF</span></span><br><span class="line">[<span class="type">client</span>]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">[<span class="type">mysqld</span>]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/<span class="keyword">data</span>/app/mysql</span><br><span class="line">datadir=/<span class="keyword">data</span>/<span class="number">3306</span>/<span class="keyword">data</span></span><br><span class="line">log_bin=/<span class="keyword">data</span>/<span class="number">3306</span>/binlog</span><br><span class="line">server_id=<span class="number">153</span></span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency=ON</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">log_slave_updates=ON</span><br><span class="line">tmpdir = /tmp</span><br><span class="line">default<span class="literal">-storage-engine</span>=INNODB</span><br><span class="line">disabled_storage_engines = MyISAM,BLACKHOLE,FEDERATED,CSV,ARCHIVE</span><br><span class="line">max_connections=<span class="number">200</span></span><br><span class="line">max_allowed_packet=<span class="number">16</span>M</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">binlog_checksum=NONE</span><br><span class="line">binlog_transaction_dependency_tracking = WRITESET</span><br><span class="line">transaction_write_set_extraction=XXHASH64</span><br><span class="line">loose<span class="literal">-group_replication_group_name</span>=<span class="string">&quot;ca842376-1c50-42ac-bb57-a5adc7da7a12&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_start_on_boot</span>=OFF</span><br><span class="line">loose<span class="literal">-group_replication_local_address</span>= <span class="string">&quot;slave2:33063&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_group_seeds</span>=</span><br><span class="line"><span class="string">&quot;master:33061,slave1:33062,slave2:33063&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_bootstrap_group</span>=OFF</span><br><span class="line">loose<span class="literal">-group_replication_ip_whitelist</span>=<span class="string">&quot;master,slave1,slave2,manager&quot;</span></span><br><span class="line">loose<span class="literal">-group_replication_allow_local_disjoint_gtids_join</span>=ON</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-所有数据库节点初始化集群实例"><a href="#4-2-3-所有数据库节点初始化集群实例" class="headerlink" title="4.2.3 所有数据库节点初始化集群实例"></a>4.2.3 所有数据库节点初始化集群实例</h3><blockquote>
<p><em><strong><font style="color:#E8323C;"> 设置root@’localhost’密码  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user root<span class="string">@&#x27;localhost&#x27; identified with mysql_native_password by</span></span><br><span class="line"><span class="string">&#x27;123&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong><font style="color:#E8323C;"> 初始化配置集群实例  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysqlsh</span><br><span class="line">mysql<span class="literal">-js</span>&gt; shell.connect(<span class="string">&#x27;root@localhost:3306&#x27;</span>);</span><br><span class="line">mysql<span class="literal">-js</span>&gt; dba.configureLocalInstance(); <span class="comment">#见下图。</span></span><br><span class="line">mysql<span class="literal">-js</span>&gt; dba.checkInstanceConfiguration(<span class="string">&quot;root@localhost:3306&quot;</span>);<span class="comment"># 见下图。</span></span><br></pre></td></tr></table></figure>

<pre><code>           ![](https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662218754065-3fbd608d-870b-47c0-8110-74098c19ca69.png)

          ![](https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662218768038-615966d9-ecbc-47f5-84b6-6b8aef49fe19.png)
</code></pre>
<h3 id="4-2-4-创建集群并添加节点（154）"><a href="#4-2-4-创建集群并添加节点（154）" class="headerlink" title="4.2.4 创建集群并添加节点（154）"></a>4.2.4 创建集群并添加节点（154）</h3><blockquote>
<p><em><strong><font style="color:#E8323C;"> 创建集群并添加主节点  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysqlsh</span><br><span class="line">mysql<span class="literal">-js</span>&gt; shell.connect(<span class="string">&#x27;root@master:3306&#x27;</span>);</span><br><span class="line">mysql<span class="literal">-js</span>&gt; var cluster = dba.createCluster(<span class="string">&#x27;oldguo&#x27;</span>);</span><br><span class="line">mysql<span class="literal">-js</span>&gt; cluster.status();</span><br></pre></td></tr></table></figure>

<pre><code>       ![](https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662218825275-df2b5e2a-957d-4184-bd3b-92b05825d5ad.png)

       ![](https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662218843093-31c7ccce-07d7-4016-b7db-6db654769d73.png)
</code></pre>
<blockquote>
<p><em><strong><font style="color:#E8323C;">添加slave1\slave2节点  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysqlsh</span><br><span class="line">mysql<span class="literal">-js</span>&gt; shell.connect(<span class="string">&#x27;root@master:3306&#x27;</span>);</span><br><span class="line">mysql<span class="literal">-js</span>&gt; var cluster = dba.getCluster(<span class="string">&#x27;oldguo&#x27;</span>);</span><br><span class="line">mysql<span class="literal">-js</span>&gt; cluster.addInstance(<span class="string">&#x27;root@slave1:3306&#x27;</span>);</span><br><span class="line">mysql<span class="literal">-js</span>&gt; cluster.addInstance(<span class="string">&#x27;root@slave2:3306&#x27;</span>);</span><br><span class="line">mysql<span class="literal">-js</span>&gt; cluster.status();</span><br></pre></td></tr></table></figure>

<pre><code>     ![](https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662218888036-addddda1-df0e-4d16-9b87-686d431609f9.png)

    ![](https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662218899554-fc49b44c-1f76-427a-a5d7-11b7655972d9.png)
</code></pre>
<blockquote>
<p><em><strong><font style="color:#E8323C;">配置启动 mysql-router（154）  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注册router到集群，生成myrouter目录, 并生成启动程序和配置文件.</span></span><br><span class="line">mysqlrouter <span class="literal">--bootstrap</span> root@master:<span class="number">3306</span> <span class="literal">-d</span> myrouter <span class="literal">--user</span>=root</span><br><span class="line"><span class="comment"># 启动myrouter</span></span><br><span class="line">myrouter/start.sh</span><br></pre></td></tr></table></figure>

<pre><code>        ![](https://cdn.fbbizyy.com/yuque/0/2022/png/1581532/1662218928961-7a72ce01-05cb-4037-a85e-c5c547234d2e.png)
</code></pre>
<blockquote>
<p><em><strong><font style="color:#E8323C;"> 验证连接router  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">a) 管理节点本机mysql<span class="literal">-shell</span>连接:</span><br><span class="line">mysqlsh <span class="literal">--uri</span> root@localhost:<span class="number">6446</span></span><br><span class="line">b) 管理节点本机mysql连接:</span><br><span class="line">mysql <span class="literal">-u</span> root <span class="literal">-h</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="literal">-P</span> <span class="number">6446</span> <span class="literal">-p</span></span><br><span class="line">c) 远程客户机通过route连接mysql</span><br><span class="line">mysql <span class="literal">-u</span> root <span class="literal">-h</span> manager_ip <span class="literal">-P</span> <span class="number">6446</span> <span class="literal">-p</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong><font style="color:#E8323C;"> 验证cluster集群  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.登陆后，新建一个表，往里面写进数据，查看从节点数据会不会同步；</span><br><span class="line"><span class="number">2</span>.关闭master的mysql服务，route将主节点自动切换到slave1，slave1从只读变为可读写，重新启</span><br><span class="line">动master mysql后，master变为只读模式。</span><br><span class="line"><span class="number">3</span>. 验证读写分离功能</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong><font style="color:#E8323C;"> 可能遇到的问题  </font></strong></em></p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">主节点：</span><br><span class="line">mysqlshell 清空集群</span><br><span class="line">dba.dropMetadataSchema()</span><br><span class="line">mysql&gt; stop group_replication;</span><br><span class="line">mysql&gt; reset master; （清空日志，确保和从库的表没有冲突奥，）</span><br><span class="line">mysql&gt; reset slave</span><br><span class="line">其他节点(主要清理和主库的主从信息， 确保主库和从库的表没有冲突奥)</span><br><span class="line">mysql&gt; stop group_replication;</span><br><span class="line">mysql&gt; reset master;</span><br><span class="line">mysql&gt; reset slave</span><br></pre></td></tr></table></figure>

<h2 id="4-3-MIC集群常用管理命令汇总"><a href="#4-3-MIC集群常用管理命令汇总" class="headerlink" title="4.3 MIC集群常用管理命令汇总"></a>4.3 MIC集群常用管理命令汇总</h2><h3 id="4-3-1-信息查询"><a href="#4-3-1-信息查询" class="headerlink" title="4.3.1 信息查询"></a>4.3.1 信息查询</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查节点是否符合集群标准</span></span><br><span class="line">dba.checkInstanceConfiguration()</span><br><span class="line"><span class="comment"># 集群结构信息描述</span></span><br><span class="line">cluster.describe()</span><br><span class="line"><span class="comment"># 集群状态总览</span></span><br><span class="line">cluster.status()</span><br><span class="line"><span class="comment"># 查看集群名字</span></span><br><span class="line">dba.getCluster();</span><br><span class="line"><span class="comment">#查看router信息</span></span><br><span class="line">cluster.listRouters()</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-集群创建及节点管理"><a href="#4-3-2-集群创建及节点管理" class="headerlink" title="4.3.2 集群创建及节点管理"></a>4.3.2 集群创建及节点管理</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dba.createCluster()</span></span><br><span class="line">例：</span><br><span class="line">var cluster = dba.createCluster(<span class="string">&#x27;oldguo&#x27;</span>);</span><br><span class="line"><span class="comment"># Cluster.addInstance()</span></span><br><span class="line">例：</span><br><span class="line">cluster.addInstance(<span class="string">&#x27;root@slave1:3306&#x27;</span>);</span><br><span class="line"><span class="comment"># Cluster.removeInstance()</span></span><br><span class="line">例：</span><br><span class="line">cluster.removeInstance(<span class="string">&#x27;root@slave1:3306&#x27;</span>);</span><br><span class="line"><span class="comment"># Cluster.rejoinInstance()</span></span><br><span class="line">如果实例离开集群，比如丢失连接，并且没有自动重新加入集群。可以通过</span><br><span class="line">cluster.rejoinInstance()方法将实例重新加入到集群中。</span><br><span class="line"><span class="comment"># Cluster.setPrimaryInstance(instance)</span></span><br><span class="line">在线切换primary 实例。</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">cluster.setPrimaryInstance(<span class="string">&#x27;root@slave1:3306&#x27;</span>)</span><br><span class="line">cluster.status()</span><br><span class="line">cluster.setPrimaryInstance(<span class="string">&#x27;root@master:3306&#x27;</span>)</span><br><span class="line"><span class="comment"># cluster.switchToMultiPrimaryMode()</span></span><br><span class="line">切换为多primary模式。</span><br><span class="line"><span class="comment"># cluster.switchToSinglePrimaryMode(&#x27;root@master:3306&#x27;)</span></span><br><span class="line">切换为单primary模式。</span><br><span class="line">注：在切换为多 primary 模式后，<span class="number">6447</span>端口（默认只读）接收读写，并且可通过该端口访问所有集</span><br><span class="line">群成员。而<span class="number">6446</span>端口（默认读写）只能连接到其中一个成员（之前的primary成员）。</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-集群故障处理"><a href="#4-3-3-集群故障处理" class="headerlink" title="4.3.3 集群故障处理"></a>4.3.3 集群故障处理</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dba.rebootClusterFromCompleteOutage()</span></span><br><span class="line">用于在集群完全断电后重新配置集群。如果dba.rebootClusterFromCompleteOutage() 方法失</span><br><span class="line">败，可以通过一下方式删除所有集群元数据。</span><br><span class="line"><span class="comment"># dba.dropMetadataSchema()</span></span><br><span class="line">删除集群元数据，然后dba.createCluster() 重建集群。</span><br><span class="line"><span class="comment">#删除已注册的router</span></span><br><span class="line">Cluster.removeRouterMetadata(router)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>日志管理、备 份、恢复、迁移</title>
    <url>/2024/07/15/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E3%80%81%E5%A4%87%20%E4%BB%BD%E3%80%81%E6%81%A2%E5%A4%8D%E3%80%81%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="1-MySQL-8-0-的日志管理"><a href="#1-MySQL-8-0-的日志管理" class="headerlink" title="1. MySQL 8.0 的日志管理"></a>1. MySQL 8.0 的日志管理</h1><h2 id="1-1-general-log"><a href="#1-1-general-log" class="headerlink" title="1.1 general_log"></a>1.1 general_log</h2><h3 id="1-1-1-作用"><a href="#1-1-1-作用" class="headerlink" title="1.1.1 作用"></a>1.1.1 作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般不会开启开功能，因为log的量会非常庞大。但个别情况下可能会临时的开</span><br><span class="line">一会儿general log以供调试使用。</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h3 id="1-1-2查询及配置"><a href="#1-1-2查询及配置" class="headerlink" title="1.1.2查询及配置"></a>1.1.2查询及配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;general_log&#x27;;       -- 查看日志是否开启</span><br><span class="line">show variables like &#x27;general_log_file&#x27;;  -- 看看日志文件保存位置</span><br><span class="line">show variables like &#x27;log_output&#x27;;        -- 看看日志输出类型 table或file</span><br><span class="line">set global general_log=on;               -- 开启日志功能</span><br><span class="line">set global general_log_file=&#x27;/data/logs/general.log&#x27;; --设置日志文件保存位置</span><br><span class="line">set global log_output=&#x27;table&#x27;;      --设置输出类型为 table</span><br><span class="line">set global log_output=&#x27;file&#x27;;       --设置输出类型为 file</span><br><span class="line">set global log_output=&#x27;table,file&#x27;;     --设置多位置保存</span><br></pre></td></tr></table></figure>



<h3 id="1-1-3-使用"><a href="#1-1-3-使用" class="headerlink" title="1.1.3 使用"></a>1.1.3 使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检测mysqldump备份过程。</span><br></pre></td></tr></table></figure>



<h2 id="1-2-binlog"><a href="#1-2-binlog" class="headerlink" title="1.2 binlog *"></a>1.2 binlog *</h2><h3 id="1-2-1-作用"><a href="#1-2-1-作用" class="headerlink" title="1.2.1 作用"></a>1.2.1 作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)备份恢复必须依赖二进制日志</span><br><span class="line">(2)复制环境必须依赖二进制日志</span><br><span class="line">8.0之后，默认自动开启。</span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-配置"><a href="#1-2-2-配置" class="headerlink" title="1.2.2 配置"></a>1.2.2 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#注意：MySQL默认是没有开启二进制日志的。</span><br><span class="line">基础参数查看:</span><br><span class="line">开关:</span><br><span class="line">[(none)]&gt;select @@log_bin;                          </span><br><span class="line"></span><br><span class="line">日志路径及名字：</span><br><span class="line">[(none)]&gt;select @@log_bin_basename;         </span><br><span class="line"></span><br><span class="line">服务ID号:</span><br><span class="line">[(none)]&gt;select @@server_id;</span><br><span class="line"></span><br><span class="line">二进制日志格式:</span><br><span class="line">[(none)]&gt;select @@binlog_format;</span><br><span class="line"></span><br><span class="line">二进制日志只记录修改类的操作日志。对于DML（i u d ） 有以下格式</span><br><span class="line">S : statement SQL ，日志量少，但可能不准确.</span><br><span class="line">R ： ROW 记录行变化，日志量比较大，很准确.</span><br><span class="line">M : Mixed 略.</span><br><span class="line"></span><br><span class="line">###双一标准之二:</span><br><span class="line">select @@innodb_flush_log_at_trx_commit=1/2</span><br><span class="line">select @@sync_binlog=1</span><br><span class="line"></span><br><span class="line">SBR 、 RBR 、MBR binlog_format的区别？</span><br><span class="line">略</span><br><span class="line">binlog 记录了些什么内容？       </span><br><span class="line">略</span><br></pre></td></tr></table></figure>



<h3 id="1-2-3-使用"><a href="#1-2-3-使用" class="headerlink" title="1.2.3 使用"></a>1.2.3 使用</h3><h4 id="日志内容查看"><a href="#日志内容查看" class="headerlink" title="日志内容查看"></a>日志内容查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db01 [(none)]&gt;show binary logs;</span><br><span class="line">+------------------+-----------+-----------+</span><br><span class="line">| Log_name         | File_size | Encrypted |</span><br><span class="line">| mysql-bin.000001 | 179       | No        |</span><br><span class="line">| mysql-bin.000002 | 723901    | No        |</span><br><span class="line">| mysql-bin.000003 | 21097721  | No        |</span><br><span class="line">| mysql-bin.000004 | 34583     | No        |</span><br><span class="line">| mysql-bin.000005 | 1011      | No        |</span><br><span class="line">| mysql-bin.000006 | 243       | No        |</span><br><span class="line">| mysql-bin.000007 | 243       | No        |</span><br><span class="line">| mysql-bin.000008 | 2662      | No        |</span><br><span class="line">+------------------+-----------+-----------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">db01 [(none)]&gt;show master status ;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| File              | Position | Binlog_Do_DB |Binlog_Ignore_DB | Executed_Gtid_Set|</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| mysql-bin.000008 | 2662      |             |                   | 483e9795-ad5b-11ea-86e8-000c298e182d:1-85 |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">Master [binlog]&gt;show binlog events in &#x27;mysql-bin.000003&#x27;;</span><br><span class="line"></span><br><span class="line">Log_name：           binlog文件名</span><br><span class="line">Pos：                开始的position *****</span><br><span class="line">Event_type：         事件类型</span><br><span class="line">Format_desc：        格式描述，每一个日志文件的第一个事件，多用户没有意义，MySQL识别binlog必要信息</span><br><span class="line">Server_id：          mysql服务号标识</span><br><span class="line">End_log_pos：        事件的结束位置号 *****</span><br><span class="line">Info：               事件内容*****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#补充: 如何快速的定位drop操作的pos号 </span><br><span class="line">SHOW BINLOG EVENTS</span><br><span class="line">[IN &#x27;log_name&#x27;]</span><br><span class="line">[FROM pos]</span><br><span class="line">[LIMIT [offset,] row_count]</span><br><span class="line">[root@db01 binlog]# mysql -e &quot;show binlog events in&#x27;  mysql-bin.000004&#x27;&quot; |  grep drop</span><br></pre></td></tr></table></figure>



<h4 id="binlog文件内容详细查看"><a href="#binlog文件内容详细查看" class="headerlink" title="binlog文件内容详细查看"></a>binlog文件内容详细查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog   /data/mysql/mysql-bin.000006</span><br><span class="line">mysqlbinlog --base64-output=decode-rows -vvv  /data/binlog/mysql-bin.000003</span><br><span class="line">mysqlbinlog  -d binlog /data/binlog/mysql-bin.000003</span><br><span class="line"></span><br><span class="line">[root@db01 binlog]# mysqlbinlog --start-datetime=&#x27;2019-05-06 17:00:00&#x27; --stop-datetime=&#x27;2019-05-06 17:01:00&#x27; /data/binlog/mysql-bin.000004</span><br></pre></td></tr></table></figure>



<h4 id="基于Position号进行日志截取"><a href="#基于Position号进行日志截取" class="headerlink" title="基于Position号进行日志截取"></a>基于Position号进行日志截取</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#核心就是找截取的起点和终点</span><br><span class="line">--start-position=321</span><br><span class="line">--stop-position=513</span><br><span class="line"></span><br><span class="line">mysqlbinlog --start-position=219 --stop-position=1347/data/binlog/mysql-bin.000003 &gt;/tmp/bin.sql</span><br><span class="line"></span><br><span class="line">#面试案例:</span><br><span class="line">1. 备份策略每天全备,有全量的二进制日志</span><br><span class="line">2. 业务中一共10个库,其中一个被误drop了</span><br><span class="line">3. 需要在其他9个库正常工作过程中进行数据恢复</span><br></pre></td></tr></table></figure>



<h4 id="彩蛋：-截取日志痛点"><a href="#彩蛋：-截取日志痛点" class="headerlink" title="彩蛋： 截取日志痛点"></a>彩蛋： 截取日志痛点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###思考一下：如果生产中会有什么痛点？</span><br><span class="line">1. 需要的日志在多个文件中，怎么截取？</span><br><span class="line">方法1： 分段截取</span><br><span class="line">方法2:  时间戳截取</span><br><span class="line">方法3： gtid</span><br><span class="line"></span><br><span class="line">2. binlog属于全局日志，日志中有其他库的操作，怎么排除掉？</span><br><span class="line">mysqlbinlog -d oldboy mysql-bin.000008 &gt; /tmp/bin.sql1.2.4 gtid特性</span><br><span class="line"></span><br><span class="line">3. binlog中100w个事件，怎么快速找到drop database的位置点？</span><br><span class="line">mysql&gt; pager grep &quot;DROP&quot;</span><br><span class="line">[root@db01 ~]# mysql -e &quot;show binlog events in &#x27;mysqlbin.000014&#x27;&quot; |less</span><br><span class="line">[root@db01 ~]# mysql -e &quot;show binlog events in &#x27;mysqlbin.000014&#x27;&quot; |grep</span><br><span class="line"></span><br><span class="line">4. 比如删除的库，建库是在2年前操作的。这种情况怎么办？</span><br><span class="line">每天全备，binlog完好的。</span><br><span class="line">可以使用全备+binlog方式实现恢复数据故障之前。</span><br><span class="line"></span><br><span class="line">5. 恢复中只想要某张表的binlog，怎么办？</span><br><span class="line">binlog2sql</span><br></pre></td></tr></table></figure>



<h3 id="1-2-4-gtid特性"><a href="#1-2-4-gtid特性" class="headerlink" title="1.2.4 gtid特性"></a>1.2.4 gtid特性</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.6 版本新加的特性,5.7中做了加强</span><br><span class="line">5.6 中不开启,没有这个功能.</span><br><span class="line">5.7+ 中的GTID,即使不开也会有自动生成</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;</span><br><span class="line">是对于一个已提交事务的编号，并且是一个全局唯一的编号。</span><br><span class="line">它的官方定义如下：</span><br><span class="line">GTID = server_uuid ：transaction_id</span><br><span class="line">7E11FA47-31CA-19E1-9E56-C43AA21293967:1-29</span><br><span class="line">重要参数介绍：</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>



<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#具备GTID后,截取查看某些事务日志:</span><br><span class="line">--include-gtids</span><br><span class="line">--exclude-gtids</span><br><span class="line">--skip-gtidscase:</span><br><span class="line">mysqlbinlog --include-gtids=&#x27;dff98809-55c3-11e9-a58b-000c2928f5dd:1-6&#x27; --exclude-gtids=&#x27;dff98809-55c3-11e9-</span><br><span class="line">a58b-000c2928f5dd:4&#x27; /data/binlog/mysql-bin.000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开启GTID后,MySQL恢复Binlog时,重复GTID的事务不会再执行了</span><br><span class="line">就想恢复?怎么办?</span><br><span class="line">--skip-gtids</span><br><span class="line">mysqlbinlog --include-gtids=&#x27;3ca79ab5-3e4d-11e9-a709-</span><br><span class="line">000c293b577e:4&#x27; /data/binlog/mysql-bin.000004</span><br><span class="line">/data/binlog/mysql-bin.000004</span><br><span class="line">set sql_log_bin=0;</span><br><span class="line">source /tmp/binlog.sql</span><br><span class="line">set sql_log_bin=1;</span><br></pre></td></tr></table></figure>



<h4 id="case"><a href="#case" class="headerlink" title="case:"></a>case:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db01 [(none)]&gt;show master status ;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| File | Position | Binlog_Do_DB              |Binlog_Ignore_DB | Executed_Gtid_Set</span><br><span class="line">|</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| mysql-bin.000009 | 196      |             |</span><br><span class="line">| 483e9795-ad5b-11ea-86e8-000c298e182d:1-86 |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">db01 [(none)]&gt;create database gtdb;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">db01 [(none)]&gt;use gtdb;</span><br><span class="line">Database changed</span><br><span class="line">db01 [gtdb]&gt;create table t1 (id int);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">db01 [gtdb]&gt;show master status ;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| File | Position | Binlog_Do_DB |Binlog_Ignore_DB | Executed_Gtid_Set</span><br><span class="line">|+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| mysql-bin.000009 | 570        |               |                | 483e9795-ad5b-11ea-86e8-000c298e182d:1-88 |</span><br><span class="line">  +------------------+----------+--------------+-----------------+-------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;insert into t1 values(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;insert into t1 values(2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;insert into t1 values(3);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;show master status ;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| File | Position  | Binlog_Do_DB | Binlog_Ignore_DB            | Executed_Gtid_Set                          |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| mysql-bin.000009 | 1019      |              |                | 483e9795-ad5b-11ea-86e8-000c298e182d:1-89   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)db01 [gtdb]&gt;begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;insert into t1 values(11);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;insert into t1 values(12);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;show master status ;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| File | Position | Binlog_Do_DB |Binlog_Ignore_DB | Executed_Gtid_Set|</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| mysql-bin.000009 | 1380 |   |              | 483e9795-ad5b-11ea-86e8-000c298e182d:1-90 |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">db01 [gtdb]&gt;drop database gtdb;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">db01 [(none)]&gt;</span><br><span class="line">db01 [(none)]&gt;</span><br><span class="line">db01 [(none)]&gt;</span><br><span class="line">db01 [(none)]&gt;show master status ;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| File | Position | Binlog_Do_DB |Binlog_Ignore_DB | Executed_Gtid_Set                                                                          |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">| mysql-bin.000009 | 1561 |    |             | 483e9795-ad5b-11ea-86e8-000c298e182d:1-91                                    |</span><br><span class="line">| mysql-bin.000009 | 1380 |    |             | 483e9795-ad5b-11ea-86e8-000c298e182d:1-90                                        |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[root@db01 binlog]# mysqlbinlog --skip-gtids --include-gtids=&#x27;483e9795-ad5b-11ea-86e8-000c298e182d:87-90&#x27; mysql-bin.000009 &gt;/data/bin1.sql</span><br><span class="line"></span><br><span class="line">注意： 只要显示的设定了gtid，不管是传统方式截取日志还是gtid截取，都需</span><br><span class="line">要加--skip-gtids做恢复。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设： 我要截取 1-20号gtid,跳过 14 ，18号gtid</span><br><span class="line">mysqlbinlog --skip-gtids --include-gtids=&#x27;483e9795-ad5b-11ea-86e8-000c298e182d:1-20&#x27;--exclude-gtids=&#x27;483e9795-ad5b-11ea-86e8-000c298e182d:14&#x27;,&#x27;483e9795-ad5b-11ea-86e8-000c298e182d:18&#x27; mysql-bin.000009 &gt;/data/bin1.sql</span><br></pre></td></tr></table></figure>



<h3 id="1-2-5-二进制日志其他操作"><a href="#1-2-5-二进制日志其他操作" class="headerlink" title="1.2.5 二进制日志其他操作"></a>1.2.5 二进制日志其他操作</h3><h4 id="自动清理日志"><a href="#自动清理日志" class="headerlink" title="自动清理日志"></a>自动清理日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%expire%&#x27;;</span><br><span class="line">expire_logs_days 0</span><br><span class="line">#自动清理时间,是要按照全备周期+1</span><br><span class="line">set global expire_logs_days=8;</span><br><span class="line"></span><br><span class="line">#永久生效:</span><br><span class="line">my.cnf</span><br><span class="line">expire_logs_days=15;</span><br><span class="line"></span><br><span class="line">#企业建议,至少保留两个全备周期+1的binlog</span><br><span class="line">8.0 变化：</span><br><span class="line">binlog_expire_logs_seconds=2592000</span><br></pre></td></tr></table></figure>



<h4 id="手工清理"><a href="#手工清理" class="headerlink" title="手工清理"></a>手工清理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PURGE BINARY LOGS BEFORE now() - INTERVAL 3 day;</span><br><span class="line">PURGE BINARY LOGS TO &#x27;mysql-bin.000010&#x27;;</span><br><span class="line">注意:不要手工 rm binlog文件</span><br><span class="line">1. my.cnf binlog关闭掉,启动数据库</span><br><span class="line">2. 把数据库关闭,开启binlog,启动数据库</span><br><span class="line">删除所有binlog,并从000001开始重新记录日志</span><br></pre></td></tr></table></figure>



<h4 id="日志滚动"><a href="#日志滚动" class="headerlink" title="日志滚动"></a>日志滚动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush logs;</span><br><span class="line">重启mysql也会自动滚动一个新的</span><br><span class="line">日志文件达到1G大小(max_binlog_size)</span><br><span class="line">| max_binlog_size | 1073741824</span><br><span class="line">备份时,加入参数也可以自动滚动</span><br></pre></td></tr></table></figure>



<h3 id="1-2-6-binlog2sql应用"><a href="#1-2-6-binlog2sql应用" class="headerlink" title="1.2.6 binlog2sql应用"></a>1.2.6 binlog2sql应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 功能</span><br><span class="line">1. 友好的展示或管理binlog</span><br><span class="line">2. 快速DML闪回（通过日志翻转方式）。</span><br><span class="line"></span><br><span class="line"># 安装配置binlog2sql</span><br><span class="line">[root@db01 ] git clone https://github.com/danfengcao/binlog2sql.git &amp;&amp;</span><br><span class="line">[root@db01 ] cd binlog2sql</span><br><span class="line">[root@db01 ] yum install python3</span><br><span class="line">[root@db01 ] pip3 install -r requirements.txt (Pymysql 0.9.3)</span><br><span class="line">[root@db01 ]</span><br><span class="line">db03 [(none)]&gt;create user root@&#x27;10.0.0.%&#x27; identified with</span><br><span class="line">mysql_native_password by &#x27;123&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">db03 [(none)]&gt;grant all on *.* to root@&#x27;10.0.0.%&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 模拟数据修改</span><br><span class="line">db01 [(none)]&gt;flush logs;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">db01 [(none)]&gt;create database test;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">db01 [(none)]&gt;use test;</span><br><span class="line">Database changed</span><br><span class="line">db01 [test]&gt;create table t1 (id int);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">db01 [test]&gt;insert into t1 values(1),(2),(3),(4),(5),(6),</span><br><span class="line">(7),(8);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3 Duplicates: 0 Warnings: 0</span><br><span class="line">db01 [test]&gt;commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">db01 [test]&gt;update t1 set id=10 where id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1 Changed: 1 Warnings: 0</span><br><span class="line">db01 [test]&gt;delete from t1 where id=3;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">db01 [test]&gt;commit;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">db01 [test]&gt;^DBye</span><br><span class="line"></span><br><span class="line">#解析日志事件SQL</span><br><span class="line">[root@db01 binlog2sql]# python3 binlog2sql.py -h 10.0.0.100 -P3306 -uroot -p123 -d test -t t1 --start-file=&#x27;binlog.000005&#x27;</span><br><span class="line">USE b&#x27;test&#x27;;</span><br><span class="line">create database test;</span><br><span class="line">USE b&#x27;test&#x27;;</span><br><span class="line">create table t1 (id int);</span><br><span class="line">INSERT INTO `test`.`t1`(`id`) VALUES (1); #start 649 end</span><br><span class="line">822 time 2020-06-13 19:58:40</span><br><span class="line">INSERT INTO `test`.`t1`(`id`) VALUES (2); #start 649 end</span><br><span class="line">822 time 2020-06-13 19:58:401.3 slowlog</span><br><span class="line">INSERT INTO `test`.`t1`(`id`) VALUES (3); #start 649 end</span><br><span class="line">822 time 2020-06-13 19:58:40</span><br><span class="line">UPDATE `test`.`t1` SET `id`=10 WHERE `id`=1 LIMIT 1;</span><br><span class="line">#start 932 end 1110 time 2020-06-13 19:58:56</span><br><span class="line">DELETE FROM `test`.`t1` WHERE `id`=3 LIMIT 1; #start 932</span><br><span class="line">end 1198 time 2020-06-13 19:59:05</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 只解析delete类型操作</span><br><span class="line">[root@db01 binlog2sql]# python3 binlog2sql.py -h</span><br><span class="line">10.0.0.51 -P3306 -uroot -p123 -d test -t t1 --startfile=&#x27;mysql-bin.000003&#x27; --sql-type=delete</span><br><span class="line"></span><br><span class="line">#生成指定事件回滚语句</span><br><span class="line">[root@db01 binlog2sql]# python3 binlog2sql.py -h</span><br><span class="line">10.0.0.51 -P3306 -uroot -p123 -d test -t t1 --start-file=&#x27;mysql-bin.000003&#x27; --sql-type=delete --start-position=932 --stop-position=1198 -B</span><br><span class="line">[root@db01 binlog2sql]# python3 binlog2sql.py -h</span><br><span class="line">10.0.0.51 -P3306 -uroot -p123 -d test -t t1 --start-file=&#x27;mysql-bin.000003&#x27; --sql-type=delete --start-position=932 --stop-position=1198 -B&gt;/tmp/flashback.sql</span><br></pre></td></tr></table></figure>



<h2 id="1-3-slowlog"><a href="#1-3-slowlog" class="headerlink" title="1.3 slowlog"></a>1.3 slowlog</h2><h3 id="1-3-1-作用"><a href="#1-3-1-作用" class="headerlink" title="1.3.1 作用"></a>1.3.1 作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">记录慢SQL语句的日志,定位低效SQL语句的工具日志</span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-配置"><a href="#1-3-2-配置" class="headerlink" title="1.3.2 配置"></a>1.3.2 配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开关:</span><br><span class="line">slow_query_log=1</span><br><span class="line"></span><br><span class="line">#文件位置及名字</span><br><span class="line">slow_query_log_file=/data/mysql/slow.log</span><br><span class="line"></span><br><span class="line">#设定慢查询时间:</span><br><span class="line">long_query_time=0.1</span><br><span class="line"></span><br><span class="line">#没走索引的语句也记录:</span><br><span class="line">log_queries_not_using_indexes</span><br><span class="line"></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">slow_query_log=1</span><br><span class="line">slow_query_log_file=/data/mysql/slow.log</span><br><span class="line">long_query_time=0.1</span><br><span class="line">log_queries_not_using_indexes</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>



<h3 id="1-3-3-分析及使用"><a href="#1-3-3-分析及使用" class="headerlink" title="1.3.3 分析及使用"></a>1.3.3 分析及使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s c -t 10 /data/mysql/slow.log</span><br></pre></td></tr></table></figure>



<h3 id="1-3-4-pt-query-digest-pqd-应用"><a href="#1-3-4-pt-query-digest-pqd-应用" class="headerlink" title="1.3.4 pt-query-digest(pqd)应用"></a>1.3.4 pt-query-digest(pqd)应用</h3><h4 id="安装及介绍："><a href="#安装及介绍：" class="headerlink" title="安装及介绍："></a>安装及介绍：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装工具：</span><br><span class="line">[root@master ~]# yum install -y percona-toolkit-3.1.0-2.el7.x86_64.rpm</span><br><span class="line">#命令语法：</span><br><span class="line">pt-query-digest [OPTIONS] [FILES] [DSN]</span><br><span class="line">--create-review-table 当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span><br><span class="line">--create-history-table 当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span><br><span class="line">--filter 对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span><br><span class="line">--limit 限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span><br><span class="line">--host mysql服务器地址</span><br><span class="line">--user mysql用户名</span><br><span class="line">--password mysql用户密码</span><br><span class="line">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span><br><span class="line"></span><br><span class="line">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span><br><span class="line"></span><br><span class="line">--output 分析结果输出类型，值可以是report(标准分析报告)、</span><br><span class="line"></span><br><span class="line">--slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span><br><span class="line">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd[hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span><br><span class="line">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span><br></pre></td></tr></table></figure>



<h4 id="结果说明："><a href="#结果说明：" class="headerlink" title="结果说明："></a>结果说明：</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1615100275127-51f1c6a7-649b-49b2-834a-b5738ee7ec88.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Overall：        总共有多少条查询</span><br><span class="line">Time range： 查询执行的时间范围</span><br><span class="line">unique：         唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</span><br><span class="line">total：          总计 min：最小 max：最大 avg：平均</span><br><span class="line">95%：                把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</span><br><span class="line">median：         中位数，把所有值从小到大排列，位置位于中间那个数</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1615100319440-4a3592aa-6454-45f1-895f-6ec8ab013dfb.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Response: 总的响应时间。</span><br><span class="line">time: 该查询在本次分析中总的时间占比。</span><br><span class="line">calls: 执行次数，即本次分析总共有多少条这种类型的查询语句。</span><br><span class="line">R/Call: 平均每次执行的响应时间。</span><br><span class="line">Item : 查询对象</span><br><span class="line"></span><br><span class="line">每部分详细统计结果</span><br><span class="line">1号查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、</span><br><span class="line">95%等各项目的统计。</span><br><span class="line">Databases: 库名</span><br><span class="line">Users: 各个用户执行的次数（占比）</span><br><span class="line">Query_time distribution : 查询时间分布, 长短体现区间占比，本例中</span><br><span class="line">查询集中在10ms。</span><br><span class="line">Tables: 查询中涉及到的表</span><br><span class="line">Explain: 示例</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1615100371147-775542dc-e477-49cb-9883-0c8a0871cddc.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###每部分详细统计结果</span><br><span class="line">1号查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、</span><br><span class="line">95%等各项目的统计。</span><br><span class="line">Databases: 库名</span><br><span class="line">Users: 各个用户执行的次数（占比）</span><br><span class="line">Query_time distribution : 查询时间分布, 长短体现区间占比，本例中</span><br><span class="line">查询集中在1s+。</span><br><span class="line">Tables: 查询中涉及到的表</span><br><span class="line">Explain: 执行计划</span><br></pre></td></tr></table></figure>



<h4 id="命令行应用实例："><a href="#命令行应用实例：" class="headerlink" title="命令行应用实例："></a>命令行应用实例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法示例</span><br><span class="line">1.直接分析慢查询文件:</span><br><span class="line">pt-query-digest slow.log &gt; slow_report.log</span><br><span class="line"></span><br><span class="line">2.分析最近12小时内的查询：</span><br><span class="line">pt-query-digest --since=12h slow.log &gt; slow_report2.log</span><br><span class="line"></span><br><span class="line">3.分析指定时间范围内的查询：</span><br><span class="line">pt-query-digest slow.log --since &#x27;2019-01-07 09:30:00&#x27; --</span><br><span class="line">until &#x27;2019-01-07 10:00:00&#x27;&gt; &gt; slow_report3.log</span><br><span class="line"></span><br><span class="line">4.分析指含有select语句的慢查询</span><br><span class="line">pt-query-digest --filter &#x27;$event-&gt;&#123;fingerprint&#125; =~m/^select/i&#x27; slow.log&gt; slow_report4.log</span><br><span class="line"></span><br><span class="line">5.针对某个用户的慢查询</span><br><span class="line">pt-query-digest --filter &#x27;($event-&gt;&#123;user&#125; || &quot;&quot;) =~m/^root/i&#x27; slow.log&gt; slow_report5.log</span><br><span class="line">6.查询所有所有的全表扫描或full join的慢查询</span><br><span class="line">pt-query-digest --filter &#x27;(($event-&gt;&#123;Full_scan&#125; || &quot;&quot;) eq &quot;yes&quot;) ||(($event-&gt;&#123;Full_join&#125; || &quot;&quot;) eq &quot;yes&quot;)&#x27; slow.log&gt;slow_report6.log</span><br><span class="line">7.把结果保存到query_review表</span><br><span class="line">pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_review --create-review-table slow.log</span><br><span class="line">8.把结果保存到query_history表</span><br><span class="line">pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_history --create-review-table slow.log_0001</span><br><span class="line">pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_history --create-review-table slow.log_0002</span><br><span class="line">9.通过tcpdump抓取mysql的tcp协议数据，然后再分析</span><br><span class="line">tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txt</span><br><span class="line">pt-query-digest --type tcpdump mysql.tcp.txt &gt;slow_report9.log</span><br><span class="line">10.分析binlog</span><br><span class="line">mysqlbinlog mysql-bin.000093 &gt; mysql-bin000093.sql pt-query-digest --type=binlog mysql-bin000093.sql &gt;slow_report10.log</span><br><span class="line">11.分析general log</span><br><span class="line">pt-query-digest --type=genlog localhost.log &gt;slow_report11.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###慢日志图形化展示项目：</span><br><span class="line">gui</span><br><span class="line">anemometer</span><br><span class="line">lepus</span><br></pre></td></tr></table></figure>



<h1 id="2-MySQL-8-0的备份、恢复、迁移"><a href="#2-MySQL-8-0的备份、恢复、迁移" class="headerlink" title="2.MySQL 8.0的备份、恢复、迁移"></a>2.MySQL 8.0的备份、恢复、迁移</h1><h2 id="2-1备份恢复中的职责"><a href="#2-1备份恢复中的职责" class="headerlink" title="2.1备份恢复中的职责"></a>2.1备份恢复中的职责</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设计备份策略</span><br><span class="line">日常备份巡检</span><br><span class="line">定期恢复演练(测试库)</span><br><span class="line">故障恢复</span><br><span class="line">升级迁移</span><br></pre></td></tr></table></figure>



<h2 id="2-2-MySQL8-0备份工具介绍"><a href="#2-2-MySQL8-0备份工具介绍" class="headerlink" title="2.2 MySQL8.0备份工具介绍"></a>2.2 MySQL8.0备份工具介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###逻辑：</span><br><span class="line">mysqldump</span><br><span class="line">load data/mysqlimport</span><br><span class="line">mydumper</span><br><span class="line"></span><br><span class="line">###物理：</span><br><span class="line">Percona Xtrabackup 8.0.12+</span><br><span class="line">Enterprise Backup</span><br><span class="line">8017+ Clone Plugin</span><br></pre></td></tr></table></figure>



<h2 id="2-3逻辑备份工具使用-mysqldump-✨"><a href="#2-3逻辑备份工具使用-mysqldump-✨" class="headerlink" title="2.3逻辑备份工具使用-mysqldump ✨"></a>2.3逻辑备份工具使用-mysqldump ✨</h2><p> <a href="https://zhuanlan.zhihu.com/p/687236988">mysqldump备份原理</a>  <a href="https://www.cnblogs.com/VicLiu/p/15492310.html">MySQL mysqldump备份恢复及原理 - VicLW - 博客园</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.调用FWRL（flush tables with read lock）,全局禁止读写</span><br><span class="line"></span><br><span class="line">2.开启快照读，获取此期间的快照（仅仅对innodb起作用）</span><br><span class="line"></span><br><span class="line">3.备份非innodb表数据（*.frm,*.myi,*.myd等）</span><br><span class="line"></span><br><span class="line">4.非innodb表备份完毕之后，释放FTWRL</span><br><span class="line"></span><br><span class="line">5.逐一备份innodb表数据</span><br><span class="line"></span><br><span class="line">6.备份完成</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/1581532/1713245256106-086ad27d-8f90-4cae-98f3-a22c1e1f170e.png"></p>
<h4 id="客户端通用参数"><a href="#客户端通用参数" class="headerlink" title="客户端通用参数"></a>客户端通用参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u -p -S -h -P</span><br><span class="line">本地备份:</span><br><span class="line">mysqldump -uroot -p -S /tmp/mysql.sock</span><br><span class="line">远程备份:</span><br><span class="line">mysqldump -uroot -p -h 10.0.0.51 -P3306</span><br></pre></td></tr></table></figure>



<h4 id="备份专用参数"><a href="#备份专用参数" class="headerlink" title="备份专用参数"></a>备份专用参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A 全备参数</span><br><span class="line">-B db1 db2 db3      备份多个单库备份单个或多个表</span><br><span class="line">-R                            备份存储过程及函数</span><br><span class="line">--triggers              备份触发器</span><br><span class="line">-E                          备份事件</span><br><span class="line">-F                            在备份开始时,刷新一个新binlog日志</span><br><span class="line">--master-data=2         以注释的形式,保存备份开始时间点的binlog的状态信息</span><br><span class="line"></span><br><span class="line">###功能：</span><br><span class="line">（1） 在备份时，会自动记录，二进制日志文件名和位置号</span><br><span class="line">（2） 自动锁表（FTWRL）</span><br><span class="line">（3）如果配合--single-transaction，只对非InnoDB表进行锁表备份，InnoDB表进行“热“”备，实际上是实现 快照备份。</span><br><span class="line">                        --single-transaction  innodb 存储引擎开启热备(快照备份)功能</span><br><span class="line">案例：</span><br><span class="line">1. 5.6 100+G 有MyISAM表，做大批量DML，mysqldump备份数据库 出现hang住。</span><br><span class="line">2. 5.6 3000w表做DDL，改数据类型，备份期间，锁严重。 master-data可以自动加锁</span><br><span class="line">（1）在不加--single-transaction ，启动所有表的温备份，所有表都锁定</span><br><span class="line">（2）加上--single-transaction ,对innodb进行快照备份,对非innodb表可以实现自动锁表功能</span><br><span class="line"></span><br><span class="line">--set-gtid-purged=auto  auto , (on)off</span><br><span class="line"></span><br><span class="line">使用场景:</span><br><span class="line">1. --set-gtid-purged=OFF,可以使用在日常备份参数中.</span><br><span class="line">mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --set-gtid-purged=OFF &gt;/data/backup/full.sql</span><br><span class="line"></span><br><span class="line">2. auto , on:在构建主从复制环境时需要的参数配置</span><br><span class="line">mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --set-gtid-purged=ON &gt;/data/backup/full.sql</span><br><span class="line"></span><br><span class="line">--max-allowed-packet=#</span><br><span class="line">mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --set-gtid-purged=OFF --max-allowed-packet=256M &gt;/data/backup/full.sql</span><br><span class="line"></span><br><span class="line">--max-allowed-packet=#</span><br><span class="line">The maximum packet length to send to or receive from server</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">mysqldump -uroot -p123 -A -R --triggers --master-data=2 --single-transaction|gzip &gt; /backup/full_$(date+%F).sql.gz</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p123 -A -R --triggers --master-data=2 --single-transaction|gzip &gt; /backup/full_$(date +%F-%T).sql.gz</span><br><span class="line"></span><br><span class="line">mysqldump备份的恢复方式    ###在生产中恢复要谨慎，恢复会删除重复的表</span><br><span class="line">set sql_log_bin=0;       #恢复的时候不记录日志</span><br><span class="line">source /backup/full_2018-06-28.sql</span><br><span class="line">set sql_log_bin=1;</span><br><span class="line"></span><br><span class="line">###注意：</span><br><span class="line">1、mysqldump在备份和恢复时都需要mysql实例启动为前提。</span><br><span class="line">2、一般数据量级100G以内，大约15-45分钟可以备份成功，但恢复时间通常需要5-10倍时间，数据量级很大很大的时候（PB、EB）</span><br><span class="line">3、 mysqldump是覆盖形式恢复的方法。</span><br><span class="line"></span><br><span class="line">#ps： 一般我们认为，在同数据量级，物理备份要比逻辑备份速度快.</span><br><span class="line"></span><br><span class="line">###逻辑备份的优势:</span><br><span class="line">1、可读性强</span><br><span class="line">2、压缩比很高</span><br><span class="line"></span><br><span class="line">master-data=2 : 记录备份开始binlog pos gtid</span><br></pre></td></tr></table></figure>



<h2 id="2-4逻辑备份工具使用-mydumper-amp-myloader"><a href="#2-4逻辑备份工具使用-mydumper-amp-myloader" class="headerlink" title="2.4逻辑备份工具使用-mydumper&amp;myloader"></a>2.4逻辑备份工具使用-mydumper&amp;myloader</h2><h3 id="2-4-0-介绍"><a href="#2-4-0-介绍" class="headerlink" title="2.4.0 介绍"></a>2.4.0 介绍</h3><blockquote>
<p><a href="https://blog.csdn.net/Hehuyi_In/article/details/105354786">https://blog.csdn.net/Hehuyi_In&#x2F;article&#x2F;details&#x2F;105354786</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL自身的mysqldump工具支持单线程工作，依次一个个导出多个表，没有一</span><br><span class="line">个并行的机，这就使得它无法迅速的备份数据。</span><br><span class="line">mydumper作为一个实用工具，能够良好支持多线程工作，可以并行的多线程的</span><br><span class="line">从表中读入数据并同时写到不同的文件里，这使得它在处理速度方面快于传统的</span><br><span class="line">mysqldump。其特征之一是在处理过程中需要对列表加以锁定，因此如果我们需</span><br><span class="line">要在工作时段执行备份工作，那么会引起DML阻塞。但一般现在的MySQL都有主</span><br><span class="line">从，备份也大部分在从上进行，所以锁的问题可以不用考虑。这样，mydumper</span><br><span class="line">能更好的完成备份任务。</span><br><span class="line"></span><br><span class="line">mydumper特性</span><br><span class="line">多线程备份</span><br><span class="line">因为是多线程逻辑备份，备份后会生成多个备份文件</span><br><span class="line">备份时对MyISAM表施加FTWRL(FLUSH TABLES WITH READ LOCK),会阻塞</span><br><span class="line"></span><br><span class="line">DML语句</span><br><span class="line">保证备份数据的一致性</span><br><span class="line">支持文件压缩</span><br><span class="line">支持导出binlog</span><br><span class="line">支持多线程恢复</span><br><span class="line">支持以守护进程模式工作，定时快照和连续二进制日志</span><br><span class="line">支持将备份文件切块</span><br></pre></td></tr></table></figure>



<h3 id="2-4-1-工作原理"><a href="#2-4-1-工作原理" class="headerlink" title="2.4.1 工作原理"></a>2.4.1 工作原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mydumper主要流程概括</span><br><span class="line">1、主线程 FLUSH TABLES WITH READ LOCK, 施加全局只读锁，以阻止DML语句写入，保证数据的一致性</span><br><span class="line">2、读取当前时间点的二进制日志文件名和日志写入的位置并记录在metadata文件中，以供即使点恢复使用</span><br><span class="line">3、N个（线程数可以指定，默认是4）dump线程 START TRANSACTION WITH CONSISTENT SNAPSHOT; 开启读一致的事务</span><br><span class="line">4、dump non-InnoDB tables, 首先导出非事务引擎的表</span><br><span class="line">5、主线程 UNLOCK TABLES 非 事务引擎备份完后，释放全局只读锁</span><br><span class="line">6、dump InnoDB tables, 基于 事务导出InnoDB表</span><br><span class="line">7、事务结束</span><br><span class="line"></span><br><span class="line"># 备份所生成的文件</span><br><span class="line">目录中包含一个metadata文件</span><br><span class="line">记录了备份数据库在备份时间点的二进制日志文件名，日志的写入位置，</span><br><span class="line">如果是在从库进行备份，还会记录备份时同步至主库的二进制日志文件及写入位置</span><br><span class="line">每个表有两个备份文件：</span><br><span class="line">database.table-schema.sql 表结构文件</span><br><span class="line">database.table.sql 表数据文件</span><br><span class="line"></span><br><span class="line">如果对表文件分片，将生成多个备份数据文件，可以指定行数或指定大小分片</span><br></pre></td></tr></table></figure>



<h3 id="2-4-2-参数介绍"><a href="#2-4-2-参数介绍" class="headerlink" title="2.4.2 参数介绍"></a>2.4.2 参数介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mydumper</span><br><span class="line">-B, --database 要备份的数据库，不指定则备份所有库</span><br><span class="line">-T, --tables-list 需要备份的表，名字用逗号隔开</span><br><span class="line">-o, --outputdir 备份文件输出的目录</span><br><span class="line">-s, --statement-size 生成的insert语句的字节数，默认</span><br><span class="line">1000000</span><br><span class="line">-r, --rows 将表按行分块时，指定的块行数，指定这</span><br><span class="line">个选项会关闭 --chunk-filesize</span><br><span class="line">-F, --chunk-filesize 将表按大小分块时，指定的块大小，单位</span><br><span class="line">是 MB</span><br><span class="line">-c, --compress 压缩输出文件-e, --build-empty-files 如果表数据是空，还是产生一个空文件</span><br><span class="line">（默认无数据则只有表结构文件）</span><br><span class="line">-x, --regex 是同正则表达式匹配 &#x27;db.table&#x27;</span><br><span class="line">-i, --ignore-engines 忽略的存储引擎，用都厚分割</span><br><span class="line">-m, --no-schemas 不备份表结构</span><br><span class="line">-k, --no-locks 不使用临时共享只读锁，使用这个选项会</span><br><span class="line">造成数据不一致</span><br><span class="line">--less-locking 减少对InnoDB表的锁施加时间（这种模</span><br><span class="line">式的机制下文详解）</span><br><span class="line">-l, --long-query-guard 设定阻塞备份的长查询超时时间，单位是</span><br><span class="line">秒，默认是60秒（超时后默认mydumper将会退出）</span><br><span class="line">--kill-long-queries 杀掉长查询 (不退出)</span><br><span class="line">-b, --binlogs 导出binlog</span><br><span class="line">-D, --daemon 启用守护进程模式，守护进程模式以某个</span><br><span class="line">间隔不间断对数据库进行备份</span><br><span class="line">-I, --snapshot-interval dump快照间隔时间，默认60s，需要在</span><br><span class="line">daemon模式下</span><br><span class="line">-L, --logfile 使用的日志文件名(mydumper所产生的日</span><br><span class="line">志), 默认使用标准输出</span><br><span class="line">--tz-utc 跨时区是使用的选项，不解释了</span><br><span class="line">--skip-tz-utc 同上</span><br><span class="line">--use-savepoints 使用savepoints来减少采集metadata</span><br><span class="line">所造成的锁时间，需要 SUPER 权限</span><br><span class="line">--success-on-1146 Not increment error count and</span><br><span class="line">Warning instead of Critical in case of table doesn&#x27;t exist</span><br><span class="line">-h, --host 连接的主机名</span><br><span class="line">-u, --user 备份所使用的用户</span><br><span class="line">-p, --pass 密码</span><br><span class="line">-P, --port 端口</span><br><span class="line">-S, --socket 使用socket通信时的socket文件</span><br><span class="line">-t, --threads 开启的备份线程数，默认是4</span><br><span class="line">-C, --compress-protocol 压缩与mysql通信的数据</span><br><span class="line">-V, --version 显示版本号</span><br><span class="line">-v, --verbose 输出信息模式, 0 = silent, 1 =</span><br><span class="line">errors, 2 = warnings, 3= info, 默认为 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># myloader</span><br><span class="line">-d, --directory 备份文件的文件夹</span><br><span class="line">-q, --queries-per-transaction 每次事物执行的查询数量，默认</span><br><span class="line">是1000</span><br><span class="line">-o, --overwrite-tables 如果要恢复的表存在，则先drop</span><br><span class="line">掉该表，使用该参数，需要备份时候要备份表结构</span><br><span class="line">-B, --database 需要还原的数据库</span><br><span class="line">-e, --enable-binlog 启用还原数据的二进制日志</span><br><span class="line">-h, --host 主机</span><br><span class="line">-u, --user 还原的用户</span><br><span class="line">-p, --pass 密码</span><br><span class="line">-P, --port 端口</span><br><span class="line">-S, --socket socket文件</span><br><span class="line">-t, --threads 还原所使用的线程数，默认是4</span><br><span class="line">-C, --compress-protocol 压缩协议</span><br><span class="line">-V, --version 显示版本</span><br><span class="line">-v, --verbose 输出模式, 0 = silent, 1 =</span><br><span class="line">errors, 2 = warnings,3 = info, 默认为2</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载地址：</span><br><span class="line">https://github.com/maxbube/mydumper/releases/</span><br><span class="line"></span><br><span class="line">#安装：</span><br><span class="line">[root@db01 app]# yum install -y mydumper-0.9.5-2.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>



<h3 id="2-4-3-使用"><a href="#2-4-3-使用" class="headerlink" title="2.4.3 使用"></a>2.4.3 使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#备份全库：</span><br><span class="line">mydumper -u root -p &#x27;123&#x27; -o /data/backup/</span><br><span class="line"># 备份test数据库：</span><br><span class="line">mydumper -u root -p &#x27;123&#x27; -B test -o /data/backup/</span><br><span class="line">#备份多张表(tableA,tableB)：</span><br><span class="line">mydumper -u root -p &#x27;123&#x27; -B test -T tableA,tableB -o</span><br><span class="line">/data/backup/</span><br><span class="line">#备份tableA表的数据，不备份表结构</span><br><span class="line">mydumper -u root -p &#x27;123&#x27; -B test -m -o /data/backup/</span><br><span class="line">#备份tableA表的数据，并进行压缩</span><br><span class="line">mydumper -u root -p &#x27;123&#x27; -B test -c -o /data/backup/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#还原test库：</span><br><span class="line">myloader -u root -p &#x27;123&#x27; -B test -d /data/backup/</span><br><span class="line">#还原tableA表</span><br><span class="line">myloader -u root -p &#x27;123&#x27; -B test -o tableA -d  /data/backup/</span><br><span class="line">Ps: 适合有很多的小表备份。</span><br></pre></td></tr></table></figure>



<h2 id="2-5逻辑导入导出-load-data"><a href="#2-5逻辑导入导出-load-data" class="headerlink" title="2.5逻辑导入导出-load data"></a>2.5逻辑导入导出-load data</h2><h3 id="2-5-0-功能"><a href="#2-5-0-功能" class="headerlink" title="2.5.0 功能"></a>2.5.0 功能</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 大数据量的录入</span><br><span class="line">2. 异构迁移</span><br><span class="line">    数据源： MySQL 、异构平台导出的、造数工具生成文本类的文件。</span><br></pre></td></tr></table></figure>



<h3 id="2-5-1-造数"><a href="#2-5-1-造数" class="headerlink" title="2.5.1 造数"></a>2.5.1 造数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use oldguo</span><br><span class="line">show tables;</span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_oldguo    |</span><br><span class="line">+---------------------+</span><br><span class="line">| test                |</span><br><span class="line">| test2             |</span><br><span class="line">+---------------------+</span><br><span class="line">create table test3(id int unsigned not null primary key</span><br><span class="line">auto_increment,test varchar(100),test2 varchar(100));</span><br><span class="line">insert into test3(test,test2) values(&#x27;a</span><br><span class="line">string&#x27;,&#x27;100.20&#x27;),(&#x27;a string containing a ,</span><br><span class="line">comma&#x27;,&#x27;102.20&#x27;),(&#x27;a string containing a &quot;</span><br><span class="line">quote&#x27;,&#x27;102.20&#x27;),\</span><br><span class="line">(&#x27;a string containing a &quot;, quote and comma&#x27;,&#x27;102.20&#x27;);</span><br><span class="line">                                 </span><br><span class="line">select * from test3;</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id |                                      test | test2 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string                                 | 100.20  |</span><br><span class="line">| 4 | a string containing a , comma            | 102.20  |</span><br><span class="line">| 6 | a string containing a &quot; quote            | 102.20  |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma | 102.20  |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="2-5-2-语法"><a href="#2-5-2-语法" class="headerlink" title="2.5.2 语法"></a>2.5.2 语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">help load data;</span><br><span class="line">Name: &#x27;LOAD DATA&#x27;</span><br><span class="line">Description:</span><br><span class="line">Syntax:</span><br><span class="line">LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE</span><br><span class="line">&#x27;file_name&#x27;</span><br><span class="line">[REPLACE | IGNORE]</span><br><span class="line">INTO TABLE tbl_name</span><br><span class="line">[PARTITION (partition_name,...)]</span><br><span class="line">[CHARACTER SET charset_name]</span><br><span class="line">[&#123;FIELDS | COLUMNS&#125;</span><br><span class="line">[TERMINATED BY &#x27;string&#x27;]</span><br><span class="line">[[OPTIONALLY] ENCLOSED BY &#x27;char&#x27;]</span><br><span class="line">[ESCAPED BY &#x27;char&#x27;]</span><br><span class="line">]</span><br><span class="line">[LINES</span><br><span class="line">[STARTING BY &#x27;string&#x27;]</span><br><span class="line">[TERMINATED BY &#x27;string&#x27;]</span><br><span class="line">]</span><br><span class="line">[IGNORE number &#123;LINES | ROWS&#125;]</span><br><span class="line">[(col_name_or_user_var,...)]</span><br><span class="line">[SET col_name = expr,...]</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">load data语句加载的数据源可以是mysqldump导出的纯文本数据文件，也可</span><br><span class="line">以是使用SELECT … INTO OUTFILE &#x27;/path/xx.txt&#x27;;</span><br><span class="line">语句生成的单表纯文本数据文件，或者其他的方式生成的txt（只要生成的纯文本数据列按指定分隔符分割的纯文本数据文件即可）</span><br><span class="line">从上面的帮助信息可以看到整个load data语句的语法结构，其中load datainfile &#x27;file.txt&#x27; into table tb_name; 是最基本的使用语句结构，</span><br><span class="line">其余的都为可选子句</span><br></pre></td></tr></table></figure>



<h3 id="2-5-3必选子句或关键字"><a href="#2-5-3必选子句或关键字" class="headerlink" title="2.5.3必选子句或关键字"></a>2.5.3必选子句或关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># load data语句简单示例</span><br><span class="line">如果文本文件中的数据字段与表结构中的字段定义顺序相同，则直接使用如下语</span><br><span class="line">句载入即可</span><br><span class="line">select * from test3;</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id | test                                     |  test2 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string                                  | 100.20 |</span><br><span class="line">| 4 | a string containing a , comma             | 102.20 |</span><br><span class="line">| 6 | a string containing a &quot; quote             | 102.20 |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma  | 102.20 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot;;</span><br><span class="line">truncate test3;</span><br><span class="line">load data infile &#x27;/tmp/t3.txt&#x27; into table test3;</span><br><span class="line">select * from test3;     #这里可以看到，数据到处导入正常</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id |                                     test | test2  |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string                                  | 100.20 |</span><br><span class="line">| 4 | a string containing a , comma             | 102.20 |</span><br><span class="line">| 6 | a string containing a &quot; quote             | 102.20 |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma  | 102.20 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br></pre></td></tr></table></figure>



<h3 id="2-5-4-设置字段顺序"><a href="#2-5-4-设置字段顺序" class="headerlink" title="2.5.4 设置字段顺序"></a>2.5.4 设置字段顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果文本文件中的数据字段与表结构中的字段定义顺序不同，则使用如下语句指</span><br><span class="line">定载入表中的字段顺序</span><br><span class="line"># 导出文本，导出文本时不使用select *，而是使用具体的字段，把顺序稍微</span><br><span class="line">调整一下</span><br><span class="line">system rm -f /tmp/t3.txt;</span><br><span class="line">desc test3; # 留意表的字段定义顺序，这里是id, test, test2</span><br><span class="line">+-------+------------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type              | Null | Key | Default | Extra|</span><br><span class="line">+-------+------------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL     |auto_increment |</span><br><span class="line">| test  | varchar(100)     | YES  |     | NULL     |               |</span><br><span class="line">| test2 | varchar(100)     | YES  |     | NULL     |               |</span><br><span class="line">+-------+------------------+------+-----+---------+----------------+</span><br><span class="line">select * from test3; # 留个表中各个字段的值大概是什么内容</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id |                                      test | test2 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string                                  | 100.20 |</span><br><span class="line">| 4 | a string containing a , comma             | 102.20 |</span><br><span class="line">| 6 | a string containing a &quot; quote             | 102.20 |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma  | 102.20 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">select id,test2,test from test3 into outfile</span><br><span class="line">&quot;/tmp/test3.txt&quot;;</span><br><span class="line">system cat /tmp/test3.txt; #这里可以看到文本文件中的test字段值</span><br><span class="line">放到最后去了</span><br><span class="line">2 100.20 a string</span><br><span class="line">4 102.20 a string containing a , comma</span><br><span class="line">6 102.20 a string containing a &quot; quote</span><br><span class="line">8 102.20 a string containing a &quot;, quote and comma</span><br><span class="line"></span><br><span class="line"># 现在，truncate掉表test3，执行load data载入数据</span><br><span class="line">truncate test3;</span><br><span class="line">load data infile &#x27;/tmp/test3.txt&#x27; into table</span><br><span class="line">test3(id,test2,test);</span><br><span class="line">select * from test3; #可以看到，使用(id,test2,test)子句指定</span><br><span class="line">了与文本文件中数据的字段一致的顺序，导入表表中之后数据的顺序是正确的</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id | test                                     | test2  |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string                                  | 100.20 |</span><br><span class="line">| 4 | a string containing a , comma             | 102.20 |</span><br><span class="line">| 6 | a string containing a &quot; quote             | 102.20 |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma  | 102.20 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br></pre></td></tr></table></figure>



<h3 id="2-5-5-LOCAL关键字"><a href="#2-5-5-LOCAL关键字" class="headerlink" title="2.5.5 LOCAL关键字"></a>2.5.5 LOCAL关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明： 如果要载入的文本文件不在mysql server数据库本身的本地磁盘，客户端也不是从mysql server本机登录的，则需要使用local关键字，指定mysql server从client host本地加载该文件，需要mysql server端使用</span><br><span class="line">     local_infile=true(或者设置为1，不设置时默认为1)启动，以及客户端连接mysql server时也使用local_infile=true(或者设置为1，不指定时默认为1)连接才能使用，server和client必须都开启这个参数才能使用local关键字，任意一个关闭都不能使用.</span><br><span class="line"></span><br><span class="line"># 登录到数据库，重新导出表数据到文本，并发送到10.0.0.52服务器</span><br><span class="line">system rm -f /tmp/test3.txt;</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot;;</span><br><span class="line">system scp /tmp/test3.txt 10.0.0.52:/tmp/test3.txt</span><br><span class="line"># 登录到10.0.0.52服务器，远程连接10.0.0.51数据库</span><br><span class="line">mysql -uroot -p123 h10.0.0.51</span><br><span class="line">mysql&gt; use oldguo</span><br><span class="line">mysql&gt; system ls -lh /tmp/test3.txt;</span><br><span class="line">-rw-r--r-- 1 root root 146 May 3 11:11 /tmp/test3.txt</span><br><span class="line">mysql&gt; system cat /tmp/test3.txt;</span><br><span class="line">2 a string 100.20</span><br><span class="line">4 a string containing a , comma 102.20</span><br><span class="line">6 a string containing a &quot; quote 102.20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8 a string containing a &quot;, quote and comma 102.20</span><br><span class="line">mysql&gt; show variables like &#x27;%local%&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| local_infile | ON     |</span><br><span class="line">+---------------+-------+</span><br><span class="line">mysql&gt; set global local_infile=OFF; #关闭server端的local_infile参数</span><br><span class="line">mysql&gt; truncate test3;</span><br><span class="line">mysql&gt; load data local infile &#x27;/tmp/test3.txt&#x27; into table test3; #执行导入数据时报错了</span><br><span class="line">ERROR 1148 (42000): The used command is not allowed with</span><br><span class="line">this MySQL version</span><br><span class="line">mysql&gt; set global local_infile=ON; #重新打开server端的local_infile参数</span><br><span class="line">mysql&gt; load data local infile &#x27;/tmp/test3.txt&#x27; into table test3; #导入成功</span><br><span class="line">Records: 4 Deleted: 0 Skipped: 0 Warnings: 0</span><br><span class="line">mysql&gt; select * from test3; #查看数据，可以看到数据已成功导入表</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id | test                                      | test2 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string                                   | 100.20 |</span><br><span class="line">| 4 | a string containing a , comma              | 102.20 |</span><br><span class="line">| 6 | a string containing a &quot; quote              | 102.20 |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma   | 102.20 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"># 对于客户端连接server时使用local_infile=0参数，在执行导入数据时也</span><br><span class="line">会报相同的错误：</span><br><span class="line">mysql -uroot -p123 -h10.0.0.51 --local-infile=0</span><br></pre></td></tr></table></figure>



<h3 id="2-5-6-REPLACE与IGNORE关键字"><a href="#2-5-6-REPLACE与IGNORE关键字" class="headerlink" title="2.5.6 REPLACE与IGNORE关键字"></a>2.5.6 REPLACE与IGNORE关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPLACE和IGNORE关键字控制对唯一键值冲突行的处理： 如果指定了REPLACE关键字，则输入行将覆盖现有行。</span><br><span class="line">换句话说，与主键或唯一 索引冲突的数据行将被执行覆盖写入，如果同时使用了local关键字，则与没有 使用local关键字行为相同 如果指定了IGNORE关键字，则与唯一键值冲突的数据行将被丢弃，</span><br><span class="line">如果同时使用 了local关键字，则与没有使用local关键字行为相同</span><br></pre></td></tr></table></figure>



<h3 id="2-5-7-fields关键字应用"><a href="#2-5-7-fields关键字应用" class="headerlink" title="2.5.7 fields关键字应用"></a>2.5.7 fields关键字应用</h3><h4 id="字段-列-分隔符应用"><a href="#字段-列-分隔符应用" class="headerlink" title="字段(列)分隔符应用"></a>字段(列)分隔符应用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认是\t，使用子句 fields terminated by &#x27;string&#x27; 指定，其中</span><br><span class="line">string代表指定的字段分隔符</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot; FIELDS</span><br><span class="line">TERMINATED BY &#x27;,&#x27;;</span><br><span class="line">system cat /tmp/test3.txt</span><br><span class="line">2,a string,100.20</span><br><span class="line">4,a string containing a \, comma,102.20</span><br><span class="line">6,a string containing a &quot; quote,102.20</span><br><span class="line">8,a string containing a &quot;\, quote and comma,102.20</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">db03 [oldguo]&gt;load data infile &#x27;/tmp/passwd&#x27; into table</span><br><span class="line">passwd FIELDS TERMINATED BY &#x27;:&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="字段引用符"><a href="#字段引用符" class="headerlink" title="字段引用符"></a>字段引用符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果加optionally选项则只用在char、varchar和text等字符型字段上，数</span><br><span class="line">值类型会忽略使用引用符，如果不指定该子句，则默认不使用引用符，使用子句</span><br><span class="line">fields [optionally] enclosed by &#x27;char&#x27;指定，其中char代表指定的</span><br><span class="line">字段引用符</span><br><span class="line">system rm -f /tmp/test3.txt;</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot; FIELDS</span><br><span class="line">ENCLOSED BY &#x27;&quot;&#x27;;</span><br><span class="line">system cat /tmp/test3.txt</span><br><span class="line">&quot;2&quot; &quot;a string&quot; &quot;100.20&quot;</span><br><span class="line">&quot;4&quot; &quot;a string containing a , comma&quot; &quot;102.20&quot;</span><br><span class="line">&quot;6&quot; &quot;a string containing a \&quot; quote&quot; &quot;102.20&quot;</span><br><span class="line">&quot;8&quot; &quot;a string containing a \&quot;, quote and comma&quot; &quot;102.20&quot;</span><br><span class="line">&quot;10&quot; &quot;\\t&quot; &quot;102.20&quot;</span><br><span class="line"># 指定字段引用符为&quot;，使用optionally关键字，可以看到id列的字段引用符</span><br><span class="line">去掉了</span><br><span class="line">system rm -f /tmp/test3.txt;</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot; FIELDS</span><br><span class="line">optionally ENCLOSED BY &#x27;&quot;&#x27;;</span><br><span class="line">system cat /tmp/test3.txt</span><br><span class="line">2 &quot;a string&quot; &quot;100.20&quot;</span><br><span class="line">4 &quot;a string containing a , comma&quot; &quot;102.20&quot;</span><br><span class="line">6 &quot;a string containing a \&quot; quote&quot; &quot;102.20&quot;</span><br><span class="line">8 &quot;a string containing a \&quot;, quote and comma&quot; &quot;102.20&quot;</span><br><span class="line">10 &quot;\\t&quot; &quot;102.20&quot;</span><br><span class="line">db03 [oldguo]&gt;select * from t5 into outfile &#x27;/tmp/t7.txt&#x27;</span><br><span class="line">FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;&quot;&#x27;;</span><br><span class="line">db03 [oldguo]&gt;select * from t5 into outfile &#x27;/tmp/t8.txt&#x27;</span><br><span class="line">FIELDS TERMINATED BY &#x27;,&#x27; optionally ENCLOSED BY &#x27;&quot;&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认为\，使用子句fields escaped by &#x27;char&#x27; 指定，其中char代表指定</span><br><span class="line">的转义字符</span><br><span class="line">system rm -f /tmp/test3.txt;</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot; fields</span><br><span class="line">escaped by &#x27;.&#x27;;</span><br><span class="line">system cat /tmp/test3.txt # 可以看到数据中指定的转义符.号被转义</span><br><span class="line">了，而数据\t没有被转义</span><br><span class="line">2 a string 100..20</span><br><span class="line">4 a string containing a , comma 102..20</span><br><span class="line">6 a string containing a &quot; quote 102..20</span><br><span class="line">8 a string containing a &quot;, quote and comma 102..20</span><br><span class="line">10 \t 102..20</span><br><span class="line">truncate test3; #清空表</span><br><span class="line">load data infile &quot;/tmp/test3.txt&quot; into table test3 fields</span><br><span class="line">escaped by &#x27;.&#x27;; #导入数据时指定转义符为.号</span><br><span class="line">select * from test3; #校验数据，可以看到导入数据正常</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id | 										test | test2 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string 									| 100.20 |</span><br><span class="line">| 4 | a string containing a , comma 			| 102.20 |</span><br><span class="line">| 6 | a string containing a &quot; quote 			| 102.20 |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma  | 102.20 |</span><br><span class="line">| 10 | \t 										| 102.20 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br></pre></td></tr></table></figure>



<h3 id="2-5-8-LINES-关键字应用"><a href="#2-5-8-LINES-关键字应用" class="headerlink" title="2.5.8 LINES 关键字应用"></a>2.5.8 LINES 关键字应用</h3><h4 id="行前缀字符串"><a href="#行前缀字符串" class="headerlink" title="行前缀字符串"></a>行前缀字符串</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># load data语句如下</span><br><span class="line">system rm -f /tmp/test3.txt;</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot; LINES</span><br><span class="line">STARTING BY &#x27;xxx&#x27;;</span><br><span class="line">system cat /tmp/test3.txt #可以看到每行数据前面多了个行前缀字符</span><br><span class="line">串xxx</span><br><span class="line">xxx2 a string 100.20</span><br><span class="line">xxx4 a string containing a , comma 102.20</span><br><span class="line">xxx6 a string containing a &quot; quote 102.20</span><br><span class="line">xxx8 a string containing a &quot;, quote and comma 102.20</span><br><span class="line">xxx10 \\t 102.20</span><br><span class="line"># 现在，到shell命令行去修改一下，增加两行</span><br><span class="line">system cat /tmp/test3.txt # 最后要加载的纯文本数据内容如下</span><br><span class="line">xxx2 a string 100.20</span><br><span class="line">xxx4 a string containing a , comma 102.20</span><br><span class="line">xxx6 a string containing a &quot; quote 102.20</span><br><span class="line">xxx8 a string containing a &quot;, quote and comma 102.20</span><br><span class="line">xxx10 \\t 102.20</span><br><span class="line">12 \\t 102.20</span><br><span class="line">dfadsfasxxx14 \\t 102.20</span><br><span class="line">truncate test3; #清空表</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">load data infile &quot;/tmp/test3.txt&quot; into table test3 LINES</span><br><span class="line">STARTING BY &#x27;xxx&#x27;; #导入数据，指定行前缀字符为xxx</span><br><span class="line">select * from test3; #校验表数据，可以看到没有xxx行前缀的行被忽</span><br><span class="line">略了，而包含xxx的最后一行，从xxx开始截断，xxx字符本身及其之前的内容被</span><br><span class="line">忽略，\</span><br><span class="line">xxx之后的内容被解析为行数据导入了</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id |										 test | test2 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string									 | 100.20 |</span><br><span class="line">| 4 | a string containing a , comma				 | 102.20 |</span><br><span class="line">| 6 | a string containing a &quot; quote 			 | 102.20 |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma   | 102.20 |</span><br><span class="line">| 10 | \t										 | 102.20 |</span><br><span class="line">| 14 | \t 										 | 102.20 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br></pre></td></tr></table></figure>



<h4 id="行结束符"><a href="#行结束符" class="headerlink" title="行结束符"></a>行结束符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux下默认为\n，使用子句lines terminated by &#x27;string&#x27; 指定，其</span><br><span class="line">中string代表指定的换行符</span><br><span class="line"># 指定换行符为\r\n导出数据</span><br><span class="line">system rm -f /tmp/test3.txt;</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot; lines</span><br><span class="line">terminated by &#x27;\r\n&#x27;;</span><br><span class="line"># 现在，把数据重新导入表，从下面的结果中可以看到，导入表中的数据正确</span><br><span class="line">truncate test3;</span><br><span class="line">load data infile &quot;/tmp/test3.txt&quot; into table test3 lines</span><br><span class="line">terminated by &#x27;\r\n&#x27;;</span><br><span class="line">select * from test3;</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| id |										 test | test2 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br><span class="line">| 2 | a string									 | 100.20 |</span><br><span class="line">| 4 | a string containing a , comma				 | 102.20 |</span><br><span class="line">| 6 | a string containing a &quot; quote 			 | 102.20 |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma   | 102.20 |</span><br><span class="line">| 10 | \t										 | 102.20 |</span><br><span class="line">| 14 | \t 										 | 102.20 |</span><br><span class="line">+----+------------------------------------------+--------+</span><br></pre></td></tr></table></figure>



<h3 id="2-5-9FIELDS和LINES注意事项"><a href="#2-5-9FIELDS和LINES注意事项" class="headerlink" title="2.5.9FIELDS和LINES注意事项"></a>2.5.9FIELDS和LINES注意事项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL中反斜杠是SQL语句中特殊字符的转义字符，因此在sql语句中碰到</span><br><span class="line">特殊字符时，您必须指定一个或者两个反斜杠来为特殊字符转义（如在mysql中</span><br><span class="line">或者一些其他程序中，\n代表换行符，\t代表制表符，\代表转义符，那么需要</span><br><span class="line">使用\t来转义制表符，\n来转义换行符，\来转义转义符本身，这样才能正确写</span><br><span class="line">入数据库或者生成导出的数据文本,使用FIELDS ESCAPED BY子句指定转义符.</span><br><span class="line">特殊字符列表如下</span><br><span class="line">\0 ASCII NUL (X&#x27;00&#x27;) 字符</span><br><span class="line">\b 退格字符</span><br><span class="line">\n 换行符</span><br><span class="line">\r 回车符</span><br><span class="line">\t 制表符</span><br><span class="line">\Z ASCII 26 (Control+Z)</span><br><span class="line">\N NULL值，如果转义符值为空，则会直接导出null字符串作为数据，这在导</span><br><span class="line">入时将把null作为数据导入</span><br><span class="line">例如： 数据中包含了ENCLOSED BY &#x27;&quot;&#x27;子句指定字段引用符号，则与字段引</span><br><span class="line">用符号相同数据字符也会被自动添加一个反斜杠进行转义（如果转义符指定为</span><br><span class="line">空，则可能会导致数据在导入时无法正确解析）。</span><br><span class="line">例如：</span><br><span class="line">select * from test3 into outfile &quot;/tmp/test3.txt&quot; FIELDS</span><br><span class="line">OPTIONALLY enclosed BY &#x27;&quot;&#x27;;</span><br><span class="line">system cat /tmp/test3.txt;</span><br><span class="line">2 &quot;a string&quot; &quot;100.20&quot;</span><br><span class="line">4 &quot;a string containing a , comma&quot; &quot;102.20&quot;</span><br><span class="line">6 &quot;a string containing a \&quot; quote&quot; &quot;102.20&quot;</span><br><span class="line">8 &quot;a string containing a \&quot;, quote and comma&quot; &quot;102.20&quot; #</span><br><span class="line">可以看到与字段引用符相同的符号数据被转义了</span><br></pre></td></tr></table></figure>



<h3 id="2-5-10-IGNORE-number-LINES-ROWS-子句"><a href="#2-5-10-IGNORE-number-LINES-ROWS-子句" class="headerlink" title="2.5.10 IGNORE number {LINES | ROWS}子句"></a>2.5.10 IGNORE number {LINES | ROWS}子句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">忽略输入文件中的前number行数据，使用子句ignore number lines指定忽</span><br><span class="line">略文本的前number行，在某些情况下生成的文本（如：mysql -e &quot;select</span><br><span class="line">….&quot; &gt; xx.txt中）带有字段名称，在导入时会把这一行字段名称也当作数据，</span><br><span class="line">所以需要忽略掉这行字段名称</span><br><span class="line">system cat /tmp/test3.txt</span><br><span class="line">id test test2 test3</span><br><span class="line">2 a string 100.20 null</span><br><span class="line">4 a string containing a , comma 102.20 NULL</span><br><span class="line">6 a string containing a &quot; quote 102.20 NULL</span><br><span class="line">8 a string containing a &quot;, quote and comma 102.20</span><br><span class="line">NULL</span><br><span class="line">10 \\t 102.20 NULL</span><br><span class="line">14 \\t 102.20 NULL</span><br><span class="line">truncate test4;</span><br><span class="line">load data infile &quot;/tmp/test3.txt&quot; into table test4 ignore</span><br><span class="line">1 lines; #载入文本时指定ignore 1 lines子句忽略文本中的前1行数据</span><br><span class="line">select * from test4; #查询表test4中的数据，从下面的结果中可以看</span><br><span class="line">到数据正确</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br><span class="line">| id | 										 test | test2 |test3 |</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br><span class="line">| 2 | a string | 100.20									   |null |</span><br><span class="line">| 4 | a string containing a , comma 			  | 102.20 |NULL |</span><br><span class="line">| 6 | a string containing a &quot; quote 			  | 102.20 |NULL |</span><br><span class="line">| 8 | a string containing a &quot;, quote and comma    | 102.20 |NULL |</span><br><span class="line">| 10 |\t									      | 102.20 |NULL |</span><br><span class="line">| 14 | \t 										  | 102.20 |NULL |</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br></pre></td></tr></table></figure>



<h3 id="2-5-11-SET-col-name-x3D-expr-…子句"><a href="#2-5-11-SET-col-name-x3D-expr-…子句" class="headerlink" title="2.5.11 SET col_name &#x3D; expr,…子句"></a>2.5.11 SET col_name &#x3D; expr,…子句</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">将列做一定的数值转换后再加载，使用子句set col_name = expr,.. 指</span><br><span class="line">定，要注意：col_name必须为表中真实的列名，expr可以是任意的表达式或者</span><br><span class="line">子查询，只要返回的数据结果值能对应上表中的字段数据定义类型即可，注意，</span><br><span class="line">非set语句生成的列名，必须使用括号括起来，否则报语法错误。</span><br><span class="line"># 如果系统将id列的文本数据加上<span class="number">10</span>以后再加载到表的test3列中，可以如下</span><br><span class="line">操作：</span><br><span class="line">system rm -f /tmp/test3.<span class="property">txt</span>;</span><br><span class="line">select * <span class="keyword">from</span> test3 into outfile <span class="string">&quot;/tmp/test3.txt&quot;</span>;</span><br><span class="line">system cat /tmp/test3.<span class="property">txt</span></span><br><span class="line"><span class="number">2</span> a string <span class="number">100.20</span> <span class="literal">null</span></span><br><span class="line"><span class="number">4</span> a string containing a , comma <span class="number">102.20</span> \N</span><br><span class="line"><span class="number">6</span> a string containing a <span class="string">&quot; quote 102.20 \N</span></span><br><span class="line"><span class="string">8 a string containing a &quot;</span>, quote and comma <span class="number">102.20</span> \N</span><br><span class="line"><span class="number">10</span> \\t <span class="number">102.20</span> \N</span><br><span class="line"><span class="number">14</span> \\t <span class="number">102.20</span> \N</span><br><span class="line">create table test4 like test3;</span><br><span class="line">alter table test4 add column test3 <span class="title function_">varchar</span>(<span class="number">10</span>);</span><br><span class="line">truncate test4;</span><br><span class="line">load data infile <span class="string">&quot;/tmp/test3.txt&quot;</span> into table test4</span><br><span class="line">(id,test,test2) set test3=id+<span class="number">10</span> ;</span><br><span class="line"><span class="variable constant_">ERROR</span> <span class="number">1262</span> (<span class="number">01000</span>): <span class="title class_">Row</span> <span class="number">1</span> was truncated; it contained more</span><br><span class="line">data than there were input columns</span><br><span class="line">select * <span class="keyword">from</span> test4; #严格模式下因为文本中多了一个字段被截断了，</span><br><span class="line">所以拒绝导入,修改sql_mode后导入。</span><br><span class="line">load data local infile <span class="string">&quot;/tmp/test3.txt&quot;</span> into table test4</span><br><span class="line">(id,test,test2) set test3=id+<span class="number">10</span> ;</span><br><span class="line">#可以使用local关键字强制进行截断最后一个字段的<span class="literal">null</span>值列进行导入</span><br><span class="line">注意，如果不使用local关键字，那就需要修改sql_mode才能导入</span><br><span class="line">select * <span class="keyword">from</span> test4;</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br><span class="line">| id | test | test2 |test3 |</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br><span class="line">| <span class="number">2</span> | a string | <span class="number">100.20</span> |<span class="number">12</span> |</span><br><span class="line">| <span class="number">4</span> | a string containing a , comma | <span class="number">102.20</span> |<span class="number">14</span> |</span><br><span class="line">| <span class="number">6</span> | a string containing a <span class="string">&quot; quote | 102.20 |16 |</span></span><br><span class="line"><span class="string">| 8 | a string containing a &quot;</span>, quote and comma | <span class="number">102.20</span> |<span class="number">18</span> |</span><br><span class="line">| <span class="number">10</span> | \t | <span class="number">102.20</span> |<span class="number">20</span> |</span><br><span class="line">| <span class="number">14</span> | \t | <span class="number">102.20</span> |<span class="number">24</span> |</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br><span class="line"><span class="number">6</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br><span class="line"># 或者使用txt文件中的某些列进行计算后生成新的列插入，这里演示两个字段</span><br><span class="line">进行相加后导入另外一个字段中：</span><br><span class="line">load data local infile <span class="string">&quot;/tmp/test3.txt&quot;</span> into table test4</span><br><span class="line">(id,test,test2) set test3=id+test2 ; # 注意，如果不使用local</span><br><span class="line">关键字，那就需要修改sql_mode才能导入</span><br><span class="line">select * <span class="keyword">from</span> test4;</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br><span class="line">| id | 		test																	 | test2 |test3  |</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br><span class="line">| <span class="number">2</span> | a string																 	| <span class="number">100.20</span> |<span class="number">102.2</span> |</span><br><span class="line">| <span class="number">4</span> | a string containing a , comma 				  	| <span class="number">102.20</span> |<span class="number">106.2</span> |</span><br><span class="line">| <span class="number">6</span> | a string containing a <span class="string">&quot; quote 					  | 102.20 |108.2 |</span></span><br><span class="line"><span class="string">| 8 | a string containing a &quot;</span>, quote and comma  | <span class="number">102.20</span> |<span class="number">110.2</span> |</span><br><span class="line">| <span class="number">10</span> | \t 																			| <span class="number">102.20</span> |<span class="number">112.2</span> |</span><br><span class="line">| <span class="number">14</span> | \t 																			| <span class="number">102.20</span> |<span class="number">116.2</span> |</span><br><span class="line">+----+------------------------------------------+--------+-------+</span><br><span class="line"><span class="number">6</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>



<h3 id="2-5-12使用mysqldump批量导出"><a href="#2-5-12使用mysqldump批量导出" class="headerlink" title="2.5.12使用mysqldump批量导出"></a>2.5.12使用mysqldump批量导出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -u username -p&#x27;xxx&#x27; -T target_dir db_name</span><br><span class="line"></span><br><span class="line">tb_name [option];</span><br><span class="line">其中option参数是以下几种可选参数：</span><br><span class="line">	--fields-terminated-by &#x27;string&#x27; 字段分隔符</span><br><span class="line">	--fields-enclosed-by &#x27;char&#x27; 字段引用符</span><br><span class="line">	--fields-optionally-enclosed-by &#x27;char&#x27; 字段引用符，只在char,varchar,text等字段类型上生效</span><br><span class="line">	--fields-escaped-by &#x27;char&#x27; 转义字符</span><br><span class="line">	--lines-terminated-by &#x27;string&#x27; 记录结束符，即换行符</span><br><span class="line"></span><br><span class="line">mkdir /data/backup/</span><br><span class="line">chown mysql.mysql /data/backup -R</span><br><span class="line">mysqldump -uroot -p123 -h 10.0.0.53 --single-transaction --master-data=2 --triggers --routines --events--fields-terminated-by &#x27;,&#x27; --fields-enclosed-by &#x27;&quot;&#x27; world -T /data/backup/</span><br></pre></td></tr></table></figure>



<h3 id="2-5-13-使用mysqlimport批量导入"><a href="#2-5-13-使用mysqlimport批量导入" class="headerlink" title="2.5.13 使用mysqlimport批量导入"></a>2.5.13 使用mysqlimport批量导入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p <span class="string">&#x27;xxx&#x27;</span> [--local] db_name</span><br><span class="line">order_tab.<span class="property">txt</span> [iption]</span><br><span class="line"># 参数：</span><br><span class="line">--fields-terminated-by=name 指定字段分隔符</span><br><span class="line">--fields-enclosed-by=name 指定字段引用符</span><br><span class="line">--fields-optionally-enclosed-by=name 指定字段引用符，但只在</span><br><span class="line">char、varchar、text字段上使用引用符</span><br><span class="line">--fields-escaped-by=name 指定转义字符</span><br><span class="line">--lines-terminated-by=name 指定行记录结束符（换行符）</span><br><span class="line">--ignore-liens=number 忽略前几行</span><br><span class="line">--low-priority 碰到有其他线程update操作操作的表与导入操作表相同</span><br><span class="line">时，延迟执行导入操作</span><br><span class="line">-i, --ignore 如果碰到唯一键冲突就忽略冲突行导入</span><br><span class="line">-r, --replace 如果碰到唯一键冲突就覆盖冲突行导入</span><br><span class="line">-L, --local 从客户端主机加载数据文本文件</span><br><span class="line">-C, --compress 在C/S模型之间使用压缩传输数据</span><br><span class="line">-c, --columns=name 指定需要导入哪些列，与load data语句中一样需</span><br><span class="line">要指定表定义中真实的列名，有多个列名时使用逗号分隔</span><br><span class="line">--<span class="keyword">default</span>-character-set=name 设置使用该选项指定的字符集来解析文</span><br><span class="line">本文件中的内容</span><br><span class="line">-h, --host 指定导入server的主机<span class="variable constant_">IP</span></span><br><span class="line">-p, --password[=name] 指定导入server的用户密码</span><br><span class="line">-P, --port=# 指定导入server的监听端口</span><br><span class="line">--use-threads=# 指定多少个线程并发执行load data语句（实测单表时</span><br><span class="line">指定多线程时要比单线程要快，由于数据量小，测试出来的差别并不大，官方并</span><br><span class="line">没有说明是基于什么级别的并发，\</span><br><span class="line">只写了一句：<span class="title class_">Load</span> files <span class="keyword">in</span> parallel using N threads，推测可能是</span><br><span class="line">基于类似mydumper的并发，但是多表导入时指定多线程就明显比单线程要快很</span><br><span class="line">多）</span><br><span class="line">-u, --user=name 指定导入server的用户名</span><br><span class="line">-d, --<span class="keyword">delete</span> 指定导入操作之前先把表清空（实测重复导入时加了这个选项</span><br><span class="line">之后可以正常执行，，通过解析binlog发现，发现binlog中记录的第二次和第</span><br><span class="line">一次导入的语句完全相同是，\</span><br><span class="line">第二次导入时如果发现表中有冲突数据，就先执行的不带where条件的</span><br><span class="line"><span class="keyword">delete</span>，所有表先<span class="keyword">delete</span>掉，然后再执行load data语句导入数据，另外，</span><br><span class="line">当与replace一起使用时，忽略replace选项）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># mysqlimport用法演示示例</span><br><span class="line">## 单表</span><br><span class="line">mysqlimport -uroot -p123 -h10<span class="number">.0</span><span class="number">.0</span><span class="number">.51</span> world</span><br><span class="line">/data/backup/city.<span class="property">txt</span></span><br><span class="line">## 多表</span><br><span class="line">mysqlimport -uroot -p123 -h10<span class="number">.0</span><span class="number">.0</span><span class="number">.51</span> --replace world</span><br><span class="line">/data/backup<span class="comment">/*.txt</span></span><br><span class="line"><span class="comment">## 多表导入时可以使用参数--use-threads指定多个线程</span></span><br><span class="line"><span class="comment">mysqlimport -uroot -p123 -h10.0.0.51 --replace --use-threads=8 world /data/backup/*.txt</span></span><br></pre></td></tr></table></figure>



<h2 id="2-6物理备份工具使用-PerconaXtrabackup-✨"><a href="#2-6物理备份工具使用-PerconaXtrabackup-✨" class="headerlink" title="2.6物理备份工具使用-PerconaXtrabackup ✨"></a>2.6物理备份工具使用-PerconaXtrabackup ✨</h2><h3 id="2-6-1-安装"><a href="#2-6-1-安装" class="headerlink" title="2.6.1 安装"></a>2.6.1 安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install percona-xtrabackup</span><br><span class="line">对于8.0.20版本，需要使用PXB 8.0.12+以上版本。</span><br><span class="line">PXB 8.0 只能备份 MySQL 8.0 ，不能备份低版本</span><br><span class="line">低版本MySQL 使用PXB2.4版本</span><br></pre></td></tr></table></figure>



<h3 id="2-6-2-全量备份"><a href="#2-6-2-全量备份" class="headerlink" title="2.6.2 全量备份"></a>2.6.2 全量备份</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>全量备份</span><br><span class="line">xtrabackup --defaults-file=<span class="regexp">/etc/my</span>.<span class="property">cnf</span> --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --</span><br><span class="line">user=root --password=<span class="number">123</span> --port=<span class="number">3306</span> --backup --target-dir=<span class="regexp">/data/</span>backup/full</span><br><span class="line">或者：使用参数--datadir替换掉参数--defaults-file.</span><br><span class="line"># xtrabackup --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --user=root --password=<span class="number">123</span> -</span><br><span class="line">-port=<span class="number">3306</span> --datadir=<span class="regexp">/data/</span>crm/ --backup --target-dir=<span class="regexp">/data/</span>backup/</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>数据恢复：</span><br><span class="line"><span class="number">2.1</span> 准备：</span><br><span class="line">xtrabackup --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --user=root --password=<span class="number">123</span> --</span><br><span class="line">port=<span class="number">3306</span> --prepare --target-dir=<span class="regexp">/data/</span>backup/</span><br><span class="line"><span class="number">2.2</span> 拷回数据：</span><br><span class="line">xtrabackup --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --user=root --password=<span class="number">123</span> --</span><br><span class="line">port=<span class="number">3306</span> --datadir=<span class="regexp">/data/</span>bak --copy-back --targetdir=<span class="regexp">/data/</span>backup/</span><br><span class="line"><span class="number">2.3</span> 修改目录属性启动数据库：</span><br><span class="line">chown -R mysql.<span class="property">mysql</span> /data/bak</span><br><span class="line">chmod -R <span class="number">755</span> /data/bak</span><br><span class="line"><span class="number">2.4</span> 启动数据库实例:</span><br><span class="line"><span class="number">2.5</span> 若有主从的问题可以查看备份目录下的文件：</span><br><span class="line">cat xtrabackup_binlog_pos_innodb</span><br></pre></td></tr></table></figure>



<h3 id="2-6-3-增量备份"><a href="#2-6-3-增量备份" class="headerlink" title="2.6.3 增量备份"></a>2.6.3 增量备份</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">全量备份的目录为： mkdir -p /data/backup/full</span><br><span class="line">增量备份的目录为： mkdir -p /data/backup/inc</span><br><span class="line"><span class="number">1.</span>备份操作：</span><br><span class="line"><span class="number">1.1</span>.全量备份：</span><br><span class="line">xtrabackup --defaults-file=<span class="regexp">/etc/my</span>.<span class="property">cnf</span> --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --</span><br><span class="line">user=root --password=<span class="number">123</span> --port=<span class="number">3306</span> --backup --parallel=<span class="number">4</span></span><br><span class="line">--target-dir=<span class="regexp">/data/</span>backup/full</span><br><span class="line"><span class="number">1.2</span>.增量备份：</span><br><span class="line">xtrabackup --defaults-file=<span class="regexp">/etc/my</span>.<span class="property">cnf</span> --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --</span><br><span class="line">user=root --password=<span class="number">123</span> --port=<span class="number">3306</span> --backup --parallel=<span class="number">4</span></span><br><span class="line">--target-dir=<span class="regexp">/data/</span>backup/inc --incremental-basedir=<span class="regexp">/data/</span>backup/full</span><br><span class="line"><span class="number">2.</span>恢复操作：</span><br><span class="line"><span class="number">2.1</span> 准备全备份的日志：</span><br><span class="line">xtrabackup --prepare --apply-log-only --target-dir=<span class="regexp">/data/</span>backup/full</span><br><span class="line"><span class="number">2.2</span> 准备增量备份的日志：</span><br><span class="line">xtrabackup --prepare --apply-log-only --target-dir=<span class="regexp">/data/</span>backup/full --incremental-dir=<span class="regexp">/data/</span>backup/inc</span><br><span class="line"><span class="number">2.3</span> 全备份准备：</span><br><span class="line"># xtrabackup --prepare --target-dir=<span class="regexp">/data/</span>backup</span><br><span class="line"><span class="number">2.4</span> 拷回数据：</span><br><span class="line">xtrabackup --host=<span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> --user=root --password=<span class="number">123</span> --</span><br><span class="line">port=<span class="number">3306</span> --datadir=<span class="regexp">/data/</span>bak1 --copy-back --target-dir=<span class="regexp">/data/</span>backup/full</span><br><span class="line"><span class="number">2.5</span> 修改数据目录的权限和属性：</span><br><span class="line">chown -R <span class="attr">mysql</span>:mysql /data/bak1</span><br><span class="line">chmod -R <span class="number">755</span> /data/bak1</span><br></pre></td></tr></table></figure>



<h2 id="2-7企业级备份工具MEB介绍及使用"><a href="#2-7企业级备份工具MEB介绍及使用" class="headerlink" title="2.7企业级备份工具MEB介绍及使用"></a>2.7企业级备份工具MEB介绍及使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载地址</span><br><span class="line">https://edelivery.oracle.com/</span><br><span class="line">#全备及恢复</span><br><span class="line">mysqlbackup --backup_dir=/data/backup backup</span><br><span class="line">mysqlbackup --backup-dir=/data/backup/ apply-log</span><br><span class="line">mysqlbackup --backup-dir=/data/backup/ copy-back</span><br><span class="line"># 单文件</span><br><span class="line">mysqlbackup --backup-image=/data/backup/img/bak.img --</span><br><span class="line">backup-dir=/data/backup/tmp backup-to-image</span><br><span class="line">#增量:</span><br><span class="line">mysqlbackup --incremental=optimistic --incrementalbase=history:last_backup --backup-dir=/data/back/incr1 --</span><br><span class="line">backup-image=incremental_image1.bi backup-to-image</span><br><span class="line">mysqlbackup --incremental=optimistic --incrementalbase=dir:/back/full1 --backup-dir=/back/incr1 --backupimage=incremental_image1.bi backup-to-image</span><br><span class="line">mysqlbackup --incremental=optimistic --incrementalbase=dir:/back/incr1 --backup-dir=/back/incr2 --backupimage=incremental_image2.bi backup-to-image</span><br><span class="line"># 恢复：</span><br><span class="line">方法一：</span><br><span class="line">使用copy-back-and-apply-log恢复全量</span><br><span class="line">使用copy-back-and-apply-log恢复增量</span><br><span class="line">方法二：</span><br><span class="line">前滚全量</span><br><span class="line">mysqlbackup --backup-dir=/full-backup/ apply-log</span><br><span class="line">前滚增量</span><br><span class="line">mysqlbackup --incremental-backup-dir=/incr-backup</span><br><span class="line">–backup-dir=/full-backup apply-incremental-backup</span><br></pre></td></tr></table></figure>



<h2 id="2-8-MySQL-8-0-8-0-17-Clone-plugin"><a href="#2-8-MySQL-8-0-8-0-17-Clone-plugin" class="headerlink" title="2.8 MySQL 8.0 (8.0.17+) Clone-plugin"></a>2.8 MySQL 8.0 (8.0.17+) Clone-plugin</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 . Clone Plugin介绍</span><br><span class="line">本地克隆：</span><br><span class="line">启动克隆操作的MySQL服务器实例中的数据，克隆到同服务器或同节点上的一个</span><br><span class="line">目录里</span><br><span class="line">远程克隆：</span><br><span class="line">默认情况下，远程克隆操作会删除接受者(recipient)数据目录中的数据，并</span><br><span class="line">将其替换为捐赠者(donor)的克隆数据。您也可以将数据克隆到接受者的其他目</span><br><span class="line">录，以避免删除现有数据。(可选)</span><br><span class="line"></span><br><span class="line">2. 原理</span><br><span class="line"># PAGE COPY</span><br><span class="line">这里有两个动作开启redo archiving功能，从当前点开始存储新增的redo log，这样从当前</span><br><span class="line">点开始所有的增量修改都不会丢失。同时上一步在page track的page被发送到</span><br><span class="line">目标端。确保当前点之前所做的变更一定发送到目标端。</span><br><span class="line">关于redo archiving，实际上这是官方早就存在的功能，主要用于官方的企业</span><br><span class="line">级备份工具，但这里clone利用了该特性来维持增量修改产生的redo。</span><br><span class="line">在开始前会做一次checkpoint， 开启一个后台线程</span><br><span class="line">log_archiver_thread()来做日志归档。当有新的写入时</span><br><span class="line">(notify_about_advanced_write_lsn)也会通知他去archive。当</span><br><span class="line">arch_log_sys处于活跃状态时，他会控制日志写入以避免未归档的日志被覆盖</span><br><span class="line">(log_writer_wait_on_archiver), 注意如果log_writer等待时间过长</span><br><span class="line">的话， archive任务会被中断掉.</span><br><span class="line"># Redo Copy</span><br><span class="line">停止Redo Archiving&quot;, 所有归档的日志被发送到目标端，这些日志包含了从</span><br><span class="line">page copy阶段开始到现在的所有日志，另外可能还需要记下当前的复制点，例</span><br><span class="line">如最后一个事务提交时的binlog位点或者gtid信息，在系统页中可以找到。</span><br><span class="line"># Done</span><br><span class="line">目标端重启实例，通过crash recovery将redo log应用上去。</span><br><span class="line"></span><br><span class="line">3. 限制</span><br><span class="line">官方文档列出的一些限制：</span><br><span class="line">The clone plugin is subject to these limitations:</span><br><span class="line">* DDL, is not permitted during a cloning operation. This</span><br><span class="line">limitation should be considered when selecting data</span><br><span class="line">sources. A workaround is to use dedicated donor instances,</span><br><span class="line">which can accommodate DDL operations being blocked while</span><br><span class="line">data is cloned. Concurrent DML is permitted.</span><br><span class="line">* An instance cannot be cloned from a different MySQL</span><br><span class="line">server version. The donor and recipient must have the same</span><br><span class="line">MySQL server version. For example, you cannot clone</span><br><span class="line">between MySQL 5.7 and MySQL 8.0\. The clone plugin is only</span><br><span class="line">supported in MySQL 8.0.17 and higher.</span><br><span class="line">* Only a single MySQL instance can be cloned at a time.</span><br><span class="line">Cloning multiple MySQL instances in a single cloning</span><br><span class="line">operation is not supported.</span><br><span class="line">* The X Protocol port specified byis not supported for</span><br><span class="line">remote cloning operations</span><br><span class="line">* The clone plugin does not support cloning of MySQL</span><br><span class="line">server configurations.</span><br><span class="line">* The clone plugin does not support cloning of binary</span><br><span class="line">logs.* The clone plugin only clones data stored in `InnoDB`.</span><br><span class="line">Other storage engine data is not cloned.</span><br><span class="line">* Connecting to the donor MySQL server instance through</span><br><span class="line">MySQL Router is not supported.</span><br><span class="line">* Local cloning operations do not support cloning of</span><br><span class="line">general tablespaces that were created with an absolute</span><br><span class="line">path. A cloned tablespace file with the same path as the</span><br><span class="line">source tablespace file would cause a conflict.</span><br><span class="line"></span><br><span class="line">4. 应用</span><br><span class="line">4.1 本地</span><br><span class="line">4.1.1 加载插件</span><br><span class="line">INSTALL PLUGIN clone SONAME &#x27;mysql_clone.so&#x27;;</span><br><span class="line">或</span><br><span class="line">[mysqld]</span><br><span class="line">plugin-load-add=mysql_clone.so</span><br><span class="line">clone=FORCE_PLUS_PERMANENT</span><br><span class="line">SELECT PLUGIN_NAME, PLUGIN_STATUS</span><br><span class="line">FROM INFORMATION_SCHEMA.PLUGINS</span><br><span class="line">WHERE PLUGIN_NAME LIKE &#x27;clone&#x27;;</span><br><span class="line">4.1.2 创建克隆专用用户</span><br><span class="line">CREATE USER clone_user@&#x27;%&#x27; IDENTIFIED by &#x27;password&#x27;;</span><br><span class="line">GRANT BACKUP_ADMIN ON *.* TO &#x27;clone_user&#x27;;</span><br><span class="line"># BACKUP_ADMIN是MySQL8.0 才有的备份锁的权限</span><br><span class="line">4.1.3 本地克隆</span><br><span class="line">[root@db01 3306]# mkdir -p /data/test/</span><br><span class="line">[root@db01 3306]# chown -R mysql.mysql /data/</span><br><span class="line">mysql -uclone_user -ppassword</span><br><span class="line">CLONE LOCAL DATA DIRECTORY = &#x27;/data/test/clonedir&#x27;;</span><br><span class="line"># 观测状态</span><br><span class="line">db01 [(none)]&gt; SELECT STAGE, STATE, END_TIME FROM</span><br><span class="line">performance_schema.clone_progress;</span><br><span class="line">+-----------+-------------+----------------------------+</span><br><span class="line">| STAGE | STATE | END_TIME |</span><br><span class="line">+-----------+-------------+----------------------------+</span><br><span class="line">| DROP DATA | Completed | 2020-04-20 21:13:19.264003 |</span><br><span class="line">| FILE COPY | Completed | 2020-04-20 21:13:20.025444 |</span><br><span class="line">| PAGE COPY | Completed | 2020-04-20 21:13:20.028552 |</span><br><span class="line">| REDO COPY | Completed | 2020-04-20 21:13:20.030042 |</span><br><span class="line">| FILE SYNC | Completed | 2020-04-20 21:13:20.439444 |</span><br><span class="line">| RESTART | Not Started | NULL |</span><br><span class="line">| RECOVERY | Not Started | NULL |</span><br><span class="line">+-----------+-------------+----------------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line">#日志观测：</span><br><span class="line">set global log_error_verbosity=3;</span><br><span class="line">tail -f db01.err</span><br><span class="line">CLONE LOCAL DATA DIRECTORY = &#x27;/data/test/3308&#x27;;</span><br><span class="line">4.1.4 启动新实例</span><br><span class="line">[root@db01 clonedir]# mysqld_safe --</span><br><span class="line">datadir=/data/test/3307 --port=3333 --</span><br><span class="line">socket=/tmp/mysql3333.sock --user=mysql --mysqlx=OFF &amp;</span><br><span class="line">4.2 远程clone</span><br><span class="line">INSTALL PLUGIN clone SONAME &#x27;mysql_clone.so&#x27;;</span><br><span class="line">或</span><br><span class="line">[mysqld]</span><br><span class="line">plugin-load-add=mysql_clone.so</span><br><span class="line">clone=FORCE_PLUS_PERMANENT</span><br><span class="line">SELECT PLUGIN_NAME, PLUGIN_STATUS</span><br><span class="line">FROM INFORMATION_SCHEMA.PLUGINS</span><br><span class="line">WHERE PLUGIN_NAME LIKE &#x27;clone&#x27;;</span><br><span class="line">4.2.1 创建远程clone用户</span><br><span class="line"># 捐赠者授权</span><br><span class="line">create user test@&#x27;%&#x27; identified by &#x27;123&#x27;;</span><br><span class="line">grant backup_admin on *.* to test@&#x27;%&#x27;;</span><br><span class="line"># 接受者授权</span><br><span class="line">create user test@&#x27;%&#x27; identified by &#x27;123&#x27;;</span><br><span class="line">grant clone_admin on *.* to test@&#x27;%&#x27;;</span><br><span class="line">4.2.2 远程clone</span><br><span class="line"># 开始克隆</span><br><span class="line">SET GLOBAL clone_valid_donor_list=&#x27;10.0.0.51:3306&#x27;;</span><br><span class="line">mysql -utest -p123 -h10.0.0.53 -P3306</span><br><span class="line">CLONE INSTANCE FROM test@&#x27;10.0.0.51&#x27;:3306 IDENTIFIED BY</span><br><span class="line">&#x27;123&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="2-9-MySQL升级及迁移实战"><a href="#2-9-MySQL升级及迁移实战" class="headerlink" title="2.9 MySQL升级及迁移实战"></a>2.9 MySQL升级及迁移实战</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. MySQL升级和降级</span><br><span class="line">1.1 方式</span><br><span class="line">1.1.1 INPLACE 就地</span><br><span class="line">在一台服务器上，原版本升级到新版本。</span><br><span class="line">风险较大。</span><br><span class="line">**** 建议 ： 不管哪种方式升级，都应该先做备份。方便失败回退。****</span><br><span class="line">1.1.2 Mergeing 迁移 ----&gt; 建议</span><br><span class="line">备份迁移</span><br><span class="line">主从迁移 （主库（低）---&gt; 从库（高））</span><br><span class="line">1.2 升级注意事项</span><br><span class="line">Upgrade is only supported between General Availability</span><br><span class="line">(GA) releases.</span><br><span class="line">Upgrade from MySQL 5.6 to 5.7 is supported. Upgrading to</span><br><span class="line">the latest release is recommended before upgrading to the</span><br><span class="line">next version. For example, upgrade to the latest MySQL 5.6</span><br><span class="line">release before upgrading to MySQL 5.7.</span><br><span class="line">Upgrade that skips versions is not supported. For example,</span><br><span class="line">upgrading directly from MySQL 5.5 to 5.7 is not supported.</span><br><span class="line">Upgrade within a release series is supported. For example,</span><br><span class="line">upgrading from MySQL 5.7.x to 5.7.y is supported. Skipping</span><br><span class="line">a release is also supported. For example, upgrading from</span><br><span class="line">MySQL 5.7.x to 5.7.z is supported.</span><br><span class="line">a. 支持GA版本之间升级</span><br><span class="line">b. 5.6--&gt; 5.7 ,先将5.6升级至最新版，再升级到5.7</span><br><span class="line">c. 5.5 ---&gt; 5.7 ,先将5.5 升级至最新，再5.5---&gt; 5.6最新，再5.6--</span><br><span class="line">-&gt;5.7 最新</span><br><span class="line">d. 回退方案要提前考虑好，最好升级前要备份(特别是往8.0版本升级)。</span><br><span class="line">e. 降低停机时间（停业务的时间）</span><br><span class="line">1.3 INPLACE 升级过程原理</span><br><span class="line">0. 备份原数据库数据</span><br><span class="line">a. 安装新版本软件</span><br><span class="line">b. 关闭原数据库（挂维护页）</span><br><span class="line">c. 使用新版本软件 “挂” 旧版本数据启动(--skip-grant-tables ,--</span><br><span class="line">skip-networking)</span><br><span class="line">d. 升级 ： 只是升级系统表。升级时间和数据量无关的。(8.0 和 5.7 区</span><br><span class="line">别)</span><br><span class="line">e. 正常重启数据库。</span><br><span class="line">f. 验证各项功能是否正常。</span><br><span class="line">g. 业务恢复。</span><br><span class="line">1.4 5.6.46 ----&gt; 5.7.28 Inplace 升级演练</span><br><span class="line">a. 安装 新版本软件</span><br><span class="line">b. 停原库</span><br><span class="line"># 1. 快速关库功能关闭(优雅关闭)</span><br><span class="line">mysql&gt; set global innodb_fast_shutdown=0 ;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">[root@db01 app]# /data/app/mysql56/bin/mysqladmin -S</span><br><span class="line">/tmp/mysql56.scok shutdown</span><br><span class="line">c. 使用高版本软件挂低版本数据启动</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/data/app/mysql</span><br><span class="line">datadir=/data/mysql56/data</span><br><span class="line">socket=/tmp/mysql56.scok</span><br><span class="line">port=3356</span><br><span class="line">[root@db01 data]# /data/app/mysql/bin/mysqld_safe --</span><br><span class="line">defaults-file=/etc/my.cnf --skip-grant-tables --skipnetworking &amp;</span><br><span class="line">d. 升级 （升级到8.0可以省略）</span><br><span class="line">[root@db01 data]# /data/app/mysql/bin/mysql_upgrade -S</span><br><span class="line">/tmp/mysql56.scok --force</span><br><span class="line">e. 重启数据库到正常状态</span><br><span class="line">[root@db01 data]# mysqladmin -S /tmp/mysql3316.sock</span><br><span class="line">shutdown</span><br><span class="line">f: 正常启动数据库</span><br><span class="line">[root@db01 app]# /data/app/mysql/bin/mysqld_safe &amp;</span><br><span class="line"># 连接查看[root@db01 app]# /data/app/mysql56/bin/mysql -S</span><br><span class="line">/tmp/mysql56.scok</span><br><span class="line">mysql&gt; show variables like &#x27;%version%&#x27;;</span><br><span class="line">+-------------------------+------------------------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-------------------------+------------------------------+</span><br><span class="line">| innodb_version | 5.7.28 |</span><br><span class="line">| protocol_version | 10 |</span><br><span class="line">| slave_type_conversions | |</span><br><span class="line">| tls_version | TLSv1,TLSv1.1,TLSv1.2 |</span><br><span class="line">| version | 5.7.28 |</span><br><span class="line">| version_comment | MySQL Community Server (GPL) |</span><br><span class="line">| version_compile_machine | x86_64 |</span><br><span class="line">| version_compile_os | linux-glibc2.12 |</span><br><span class="line">+-------------------------+------------------------------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 测试应用</span><br><span class="line">1、各项功能验证</span><br><span class="line">2、SQL_MODE: 日期、group by</span><br><span class="line">临时：关闭相应 SQL_mode</span><br><span class="line">建议：让应用满足 SQL_mode</span><br><span class="line">1.5 5.7.28 ----&gt; 8.0.20 Inplace 升级演练</span><br><span class="line">彩蛋： 8.0的新功能</span><br><span class="line">mysql-shell工具，8.0以后，可以调用这个命令，升级之前的预检查。</span><br><span class="line">[root@db01 ~]# mysqlsh root:123@10.0.0.51:3306 -e</span><br><span class="line">&quot;util.checkForServerUpgrade()&quot;</span><br><span class="line">例如： 5.7.28 升级至 8.0.20 版本</span><br><span class="line">1. 下载 8.0.20 版本的 mysql-shell，并安装 。</span><br><span class="line">[root@db01 app]# yum install -y mysql-shell-8.0.18-</span><br><span class="line">1.el7.x86_64.rpm</span><br><span class="line">2. 创建用户</span><br><span class="line">mysql&gt; grant all on *.* to root@&#x27;10.0.0.%&#x27; identified by</span><br><span class="line">&#x27;123&#x27;;</span><br><span class="line">3. 预 检查</span><br><span class="line">mysqlsh root:123@10.0.0.51:3306 -e</span><br><span class="line">&quot;util.checkForServerUpgrade()&quot;</span><br><span class="line"># 开始升级</span><br><span class="line">a. 安装 8.0.20 软件</span><br><span class="line">b. 优雅关闭5728</span><br><span class="line">[root@db01 app]# /data/app/mysql/bin/mysql -S</span><br><span class="line">/tmp/mysql56.scok</span><br><span class="line">mysql&gt; set global innodb_fast_shutdown=0 ;</span><br><span class="line">mysql&gt; shutdown;</span><br><span class="line">c. 使用高版本软件挂低版本数据启动</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/data/app/mysql8</span><br><span class="line">datadir=/data/mysql56/data</span><br><span class="line">socket=/tmp/mysql56.scok</span><br><span class="line">port=3356</span><br><span class="line">d.高版本软件挂低版本数据启动</span><br><span class="line">[root@db01 data]# /data/app/mysql8/bin/mysqld_safe --</span><br><span class="line">defaults-file=/etc/my.cnf --skip-grant-tables --skipnetworking &amp;</span><br><span class="line">e. 正常启动数据库</span><br><span class="line">[root@db01 data]# /data/app/mysql8/bin/mysqladmin -S</span><br><span class="line">/tmp/mysql56.sock shutdown</span><br><span class="line">f: 正常启动数据库</span><br><span class="line">[root@db01 app]# /data/app/mysql8/bin/mysqld_safe &amp;</span><br><span class="line">1.6 通过mysqldump迁移升级方式：5.7.28到8.0.20</span><br><span class="line">源端： 10.0.0.51 : 3306 ,MySQL 5.7.28 ,binlog开启。</span><br><span class="line">目标端： 10.0.0.53 : 3306 ,MySQL 8.0.20 , binlog开启</span><br><span class="line">预装mysql5728版本软件。</span><br><span class="line">周日凌晨：2:00-3:00</span><br><span class="line">a. 周六全备（凌晨）</span><br><span class="line">[root@db03 ~]# /data/app/mysql/bin/mysqldump -uroot -p123</span><br><span class="line">-h10.0.0.51 -P3356 -A --master-data=2 &gt;/data/full.sql</span><br><span class="line">b. 初始化一个5728新实例</span><br><span class="line">[root@db03 ~]# mv /etc/my.cnf /etc/my.cnf.bak</span><br><span class="line">[root@db03 ~]# mkdir -p /data/3357/data[root@db03 data]# /data/app/mysql/bin/mysqld --initializeinsecure --user=mysql --basedir=/data/app/mysql --</span><br><span class="line">datadir=/data/3357/data</span><br><span class="line">c. 配置文件</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/data/app/mysql</span><br><span class="line">datadir=/data/3357/data</span><br><span class="line">socket=/tmp/mysql57.scok</span><br><span class="line">port=3357</span><br><span class="line">server_id=57</span><br><span class="line">log_bin=mysql-bin</span><br><span class="line">d. 启动新环境</span><br><span class="line">[root@db03 bin]# /data/app/mysql/bin/mysqld_safe &amp;</span><br><span class="line">e. 恢复周六数据</span><br><span class="line">f. 拉取源端日志</span><br><span class="line">/data/app/mysql/bin/mysqlbinlog -R --host=10.0.0.51 --</span><br><span class="line">port=3306 --user=root --password=123 --raw --stop-never</span><br><span class="line">mysql-bin.000003 &amp;</span><br><span class="line">g.依次恢复需要的日志</span><br><span class="line">原端： flush logs</span><br><span class="line">目标端：</span><br><span class="line">[root@db03 data]# /data/app/mysql/bin/mysqlbinlog</span><br><span class="line">/data/binlog/mysql-bin.000004 |/data/app/mysql/bin/mysql -</span><br><span class="line">S /tmp/mysql57.sock</span><br><span class="line">断开远端数据库所有连接，将所有剩余binlog，恢复。</span><br><span class="line">h. 目标端inplace升级到8.0</span><br><span class="line">略。</span><br><span class="line">i. 测试应用</span><br><span class="line">j. 应用端割接，重启业务。</span><br><span class="line">1.7 降级</span><br><span class="line">官方解释：</span><br><span class="line">https://dev.mysql.com/doc/refman/5.7/en/downgradepaths.htmlDowngrade from MySQL 5.7 to 5.6 is supported using the</span><br><span class="line">logical downgrade method.</span><br><span class="line">https://dev.mysql.com/doc/refman/5.7/en/downgrade-binarypackage.html#downgrade-procedure-inplace</span><br><span class="line">In-place downgrade is supported for downgrades between GA</span><br><span class="line">releases within the same release series. 5.7.y ---&gt; 5.7.x</span><br><span class="line">## 5.7.28 ---》 5.7.10 inplace downgrade ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###原环境：</span><br><span class="line">5.7.28 二进制版本 + /data/3306/data</span><br><span class="line">1. 安装 5.7.10 （低） 二进制版本</span><br><span class="line">/data/app/mysql5710</span><br><span class="line">2. 针对5728版本（高）进行处理工作</span><br><span class="line">https://dev.mysql.com/doc/refman/5.7/en/downgrading-toprevious-series.html</span><br><span class="line">set</span><br><span class="line">sql_mode=&#x27;STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,N</span><br><span class="line">O_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27; ;</span><br><span class="line">set global</span><br><span class="line">sql_mode=&#x27;STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,N</span><br><span class="line">O_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27; ;</span><br><span class="line">ALTER TABLE mysql.proc MODIFY definer char(77) CHARACTER</span><br><span class="line">SET utf8 COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.event MODIFY definer char(77) CHARACTER</span><br><span class="line">SET utf8 COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.tables_priv MODIFY Grantor char(77)</span><br><span class="line">COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.procs_priv MODIFY Grantor char(77)</span><br><span class="line">COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;;</span><br><span class="line">3. 优雅的关闭5.7.28（高）。</span><br><span class="line">set global innodb_fast_shutdown=0 ;</span><br><span class="line">mysqladmin shutdown</span><br><span class="line">4. 删除ib_logfile*</span><br><span class="line">[root@db01 mysql5710]# rm -rf /data/3306/data/ib_logfile*5. 替换配置文件、环境变量 （替换成低版本）</span><br><span class="line">[root@db01 mysql5710]# vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/data/app/mysql5710</span><br><span class="line">#basedir=/data/app/mysql56</span><br><span class="line">datadir=/data/3306/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">[mysql]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">~</span><br><span class="line">[root@db01 mysql5710]# vim /etc/profile</span><br><span class="line">export PATH=/data/app/mysql5710/bin:$PATH</span><br><span class="line">[root@db01 mysql5710]# source /etc/profile</span><br><span class="line">[root@db01 mysql5710]# mysql -V</span><br><span class="line">mysql Ver 14.14 Distrib 5.7.10, for linux-glibc2.5</span><br><span class="line">(x86_64) using EditLine wrapper</span><br><span class="line">6. 启动数据库</span><br><span class="line">[root@db01 mysql5710]# /etc/init.d/mysqld start</span><br><span class="line">Starting MySQL.. SUCCESS!</span><br><span class="line">7. 执行upgrade</span><br><span class="line">[root@db01 mysql5710]# mysql_upgrade --force</span><br><span class="line">## 5.7.28 ---》 5.6.46 logical downgrade ok</span><br><span class="line">0. 恢复5.7.28 环境</span><br><span class="line">[root@db01 data]# pkill mysqld</span><br><span class="line">[root@db01 data]# rm -rf /data/3306/data/*</span><br><span class="line"># 恢复配置文件</span><br><span class="line">[root@db01 data]# vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/data/app/mysql</span><br><span class="line">#basedir=/data/app/mysql56</span><br><span class="line">datadir=/data/3306/datasocket=/tmp/mysql.sock</span><br><span class="line">[mysql]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line"># 恢复环境变量</span><br><span class="line">export PATH=/data/app/mysql/bin:$PATH</span><br><span class="line">[root@db01 data]# source /etc/profile</span><br><span class="line">[root@db01 data]# mysql -V</span><br><span class="line">mysql Ver 14.14 Distrib 5.7.28, for linux-glibc2.12</span><br><span class="line">(x86_64) using EditLine wrapper</span><br><span class="line"># 初始化数据</span><br><span class="line">mysqld --initialize-insecure --user=mysql --</span><br><span class="line">basedir=/data/app/mysql --datadir=/data/3306/data</span><br><span class="line"># 启动数据库</span><br><span class="line">[root@db01 data]# /etc/init.d/mysqld start</span><br><span class="line">Starting MySQL.Logging to &#x27;/data/3306/data/db01.err&#x27;.</span><br><span class="line">SUCCESS!</span><br><span class="line">mysql&gt; select version();</span><br><span class="line">+-----------+</span><br><span class="line">| version() |</span><br><span class="line">+-----------+</span><br><span class="line">| 5.7.28 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 安装5.6.46二进制版本软件</span><br><span class="line">/data/app/mysql56</span><br><span class="line">2. 处理5.7.28高版本数据</span><br><span class="line">set</span><br><span class="line">sql_mode=&#x27;STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,N</span><br><span class="line">O_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27; ;</span><br><span class="line">set global</span><br><span class="line">sql_mode=&#x27;STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,N</span><br><span class="line">O_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27; ;ALTER TABLE mysql.proc MODIFY definer char(77) CHARACTER</span><br><span class="line">SET utf8 COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.event MODIFY definer char(77) CHARACTER</span><br><span class="line">SET utf8 COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.tables_priv MODIFY Grantor char(77)</span><br><span class="line">COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.procs_priv MODIFY Grantor char(77)</span><br><span class="line">COLLATE utf8_bin NOT NULL DEFAULT &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.tables_priv MODIFY User char(16) NOT</span><br><span class="line">NULL default &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.columns_priv MODIFY User char(16) NOT</span><br><span class="line">NULL default &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.user MODIFY User char(16) NOT NULL</span><br><span class="line">default &#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.db MODIFY User char(16) NOT NULL default</span><br><span class="line">&#x27;&#x27;;</span><br><span class="line">ALTER TABLE mysql.procs_priv MODIFY User char(16) binary</span><br><span class="line">DEFAULT &#x27;&#x27; NOT NULL;</span><br><span class="line">ALTER TABLE mysql.user ADD Password char(41) character set</span><br><span class="line">latin1</span><br><span class="line">collate latin1_bin NOT NULL default &#x27;&#x27; AFTER user;</span><br><span class="line">UPDATE mysql.user SET password = authentication_string</span><br><span class="line">WHERE</span><br><span class="line">LENGTH(authentication_string) = 41 AND plugin =</span><br><span class="line">&#x27;mysql_native_password&#x27;;</span><br><span class="line">UPDATE mysql.user SET authentication_string = &#x27;&#x27; WHERE</span><br><span class="line">LENGTH(authentication_string) = 41 AND plugin =</span><br><span class="line">&#x27;mysql_native_password&#x27;;</span><br><span class="line">ALTER TABLE mysql.help_category ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.help_keyword ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.help_relation ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.help_topic ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.time_zone ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;ALTER TABLE mysql.time_zone_leap_second ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.time_zone_name ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.time_zone_transition ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.time_zone_transition_type</span><br><span class="line">ENGINE=&#x27;MyISAM&#x27; STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.plugin ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.servers ENGINE=&#x27;MyISAM&#x27;</span><br><span class="line">STATS_PERSISTENT=DEFAULT;</span><br><span class="line">ALTER TABLE mysql.user MODIFY plugin CHAR(64) COLLATE</span><br><span class="line">utf8_bin</span><br><span class="line">DEFAULT &#x27;mysql_native_password&#x27;;</span><br><span class="line">DROP DATABASE sys;</span><br><span class="line"></span><br><span class="line">3. 逻辑备份5.7.28数据</span><br><span class="line">[root@db01 ~]# mysqldump -A &gt;/tmp/full.sql</span><br><span class="line"></span><br><span class="line">4. 初始化一套5.6.46的空环境</span><br><span class="line">[root@db01 ~]# vim /etc/profile</span><br><span class="line">export PATH=/data/app/mysql56/bin:$PATH</span><br><span class="line"></span><br><span class="line">[root@db01 ~]# source /etc/profile</span><br><span class="line">[root@db01 ~]# mysql -V</span><br><span class="line">mysql Ver 14.14 Distrib 5.6.46, for linux-glibc2.12</span><br><span class="line">(x86_64) using EditLine wrapper</span><br><span class="line"></span><br><span class="line">[root@db01 ~]# mv /etc/my.cnf /etc/my.cnf.bak</span><br><span class="line">mv: overwrite ‘/etc/my.cnf.bak’? y</span><br><span class="line">[root@db01 data]# rm -rf /data/3316/data/*</span><br><span class="line">[root@db01 data]#</span><br><span class="line">/data/app/mysql56/scripts/mysql_install_db --user=mysql -</span><br><span class="line">-basedir=/data/app/mysql56 --datadir=/data/3316/data</span><br><span class="line">[root@db01 data]# systemctl start mysqld3316</span><br><span class="line"></span><br><span class="line">5. 恢复备份数据到5.6.46中</span><br><span class="line">[root@db01 data]# mysql -S /tmp/mysql3316.sock</span><br><span class="line">mysql&gt; source /tmp/full.sql</span><br></pre></td></tr></table></figure>



<h2 id="2-10-MySQL备份策略定制、备份巡检思路"><a href="#2-10-MySQL备份策略定制、备份巡检思路" class="headerlink" title="2.10 MySQL备份策略定制、备份巡检思路"></a>2.10 MySQL备份策略定制、备份巡检思路</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 备份策略：</span><br><span class="line">	a. 备份工具</span><br><span class="line">	逻辑：</span><br><span class="line">	mysqldump ： 数据量较小</span><br><span class="line">	mydumper ： 数据量小，表个数比较多，每个表都不大</span><br><span class="line">	replication ： 延时从库</span><br><span class="line">	mysqlbinlog ： -R --raws --stop-never</span><br><span class="line">	navicat</span><br><span class="line">	binlog2sql</span><br><span class="line">物理：</span><br><span class="line">	PXB</span><br><span class="line">	MEB</span><br><span class="line"></span><br><span class="line">存储镜像</span><br><span class="line">	cp冷备</span><br><span class="line"></span><br><span class="line">	b. 时间点</span><br><span class="line">		凌晨</span><br><span class="line">	c. 策略</span><br><span class="line">		每天全备+binlog</span><br><span class="line">		每周全备+inc+binlog</span><br><span class="line">		每月全备+inc</span><br><span class="line">2. 恢复策略</span><br><span class="line">	大量数据损坏： 全备+增量+binlog</span><br><span class="line">	部分： 从全备+增量提取备份+部分binlog ，延时从库</span><br><span class="line">3. 定期备份检查和恢复演练</span><br><span class="line">	a. 逻辑备份 ： 检查备份文件 头部 、 抽查备份文件中核心的业务表存在性、数据量。</span><br><span class="line">	b. 物理备份 ： 备份目录下的日志。备份的大小。</span><br><span class="line">	c. 恢复演练 ： 按季度。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Redis并启动</title>
    <url>/2024/11/06/Docker%E5%AE%89%E8%A3%85Redis%E5%B9%B6%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p><font style="background:#F8CED3;color:#70000D">Docker</font> <font style="background:#DBF1B7;color:#2A4200">Redis</font></p>
<h2 id="1、拉取Redis镜像"><a href="#1、拉取Redis镜像" class="headerlink" title="1、拉取Redis镜像"></a>1、拉取Redis镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<h2 id="2、启动Redis实例"><a href="#2、启动Redis实例" class="headerlink" title="2、启动Redis实例"></a>2、启动Redis实例</h2><p><font style="color:#F5222D;">不推荐</font>直接启动，请使用设置密码启动的命令</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis redis</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1609297031729-040af577-c558-46f5-82ca-c8341d8b212b.png"></p>
<p>设置访问密码的启动（**<font style="color:#52C41A;">推荐</font>**）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name redis -d -p 6379:6379 -d redis --requirepass <span class="string">&quot;You Password&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、一键式部署启动脚本"><a href="#3、一键式部署启动脚本" class="headerlink" title="3、一键式部署启动脚本"></a>3、一键式部署启动脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis redis --requirepass <span class="string">&quot;You Password&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Cluster 配置</title>
    <url>/2024/11/06/Redis%20Cluster%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><font style="background:#F8CED3;color:#70000D">Redis</font><font style="background:#DBF1B7;color:#2A4200">Redis Cluster</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">Redis Cluster 集群相关配置，使用集群方式的必须重视和知晓。别嘴上原理说的头头是道，而集群有哪些配置？如何配置让集群快到飞起，实现真正的高可用却一头雾水，通过下面这些配置详解也让你对集群原理更加深刻。</font></p>
<h3 id="cluster-enabled"><a href="#cluster-enabled" class="headerlink" title="cluster-enabled"></a><font style="color:rgb(244, 138, 0);">cluster-enabled</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">普通的 Redis 实例是不能成为集群的一员，想要将该节点加入 Redis Cluster，需要设置 </font><font style="color:rgb(244, 138, 0);">cluster-enabled yes</font><font style="color:rgba(0, 0, 0, 0.85);">。</font></p>
<h3 id="cluster-config-file"><a href="#cluster-config-file" class="headerlink" title="cluster-config-file"></a><font style="color:rgb(244, 138, 0);">cluster-config-file</font></h3><p><font style="color:rgb(244, 138, 0);">cluster-config-file nodes-6379.conf</font><font style="color:rgba(0, 0, 0, 0.85);"> 指定集群中的每个节点文件。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">集群中的每个节点都有一个配置文件，这个文件并不是让程序员编辑的，是自己创建和更新的，每个节点都要使用不同的配置文件，一定要确保同一个集群中的不同节点使用的是不同的文件。</font></p>
<span id="more"></span>
<h3 id="cluster-node-timeout"><a href="#cluster-node-timeout" class="headerlink" title="cluster-node-timeout"></a><font style="color:rgb(244, 138, 0);">cluster-node-timeout</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">设置集群节点不可用的最大超时时间，节点失效检测。集群中当一个节点向另一个节点发送PING命令，但是目标节点未在给定的时限内返回PING命令的回复时，那么发送命令的节点会将目标节点标记为PFAIL(possible failuer，可能已失效)；</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">如果master 节点超过这个时间还是无响应，则用它的从节点将启动故障迁移，升级成主节点。</font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.85);">注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。</font></strong></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">默认配置是 </font><font style="color:rgb(244, 138, 0);">cluster-node-timeout 15000</font><font style="color:rgba(0, 0, 0, 0.85);">，单位是毫秒数。</font></p>
<h3 id="cluster-port"><a href="#cluster-port" class="headerlink" title="cluster-port"></a><font style="color:rgb(244, 138, 0);">cluster-port</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">该端口是集群总线监听 TCP 连接的端口，默认配置为 </font><font style="color:rgb(244, 138, 0);">cluster-port 0</font><font style="color:rgba(0, 0, 0, 0.85);">，我就会把端口绑定为客户端命令端口 + 10000（客户端端口默认 6379，所以绑定为 16379 作为集群总线端口）。每个 Redis Cluster 节点都需要开放两个端口：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.55);">一个用于服务于客户端的 TCP 端口，比如 6379.</font></li>
<li><font style="color:rgba(0, 0, 0, 0.55);">另一个称为集群总线端口，节点使用集群总线进行故障监测、配置更新、故障转移等。客户端不要与集群总线端口通信，另外请确保在防火墙打开这两个端口，否则 Redis 集群接地那将无法通信。</font></li>
</ul>
<h3 id="cluster-replica-validity-factor"><a href="#cluster-replica-validity-factor" class="headerlink" title="cluster-replica-validity-factor"></a><font style="color:rgb(244, 138, 0);">cluster-replica-validity-factor</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">该配置用于决定当 Redis Cluster 集群中，一个 master 宕机后，如何选择一个 slave 节点完成故障转移自动恢复（failover）。如果设置为 0 ，则不管 slave 与 master 之间断开多久，都认为自己有资格成为 master。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">下面提供了两种方式来评估 slave 的数据是否太旧。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.55);">如果有多个 slave 可以 failover，他们之间会通过交换信息选出拥有拥有最大复制 offset 的 slave 节点。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.55);">每个 slave 节点计算上次与 master 节点交互的时间，这个交互包含最后一次 </font><font style="color:rgb(244, 138, 0);">ping</font><font style="color:rgba(0, 0, 0, 0.55);"> 操作、master 节点传输过来的写指令、上次可 master 断开的时间等。如果上次交互的时间过去很久，那么这个节点就不会发起 failover。</font></li>
</ul>
<p><font style="color:rgba(0, 0, 0, 0.85);">针对第二点，交互时间可以通过配置定义，如果 slave 与 master 上次交互的时间大于 </font><font style="color:rgb(244, 138, 0);">(node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period</font><font style="color:rgba(0, 0, 0, 0.85);">，该 slave 就不会发生 failover。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">例如，&#96;&#96;node-timeout &#x3D; 30</font><font style="color:rgb(244, 138, 0);"> 秒，</font><font style="color:rgba(0, 0, 0, 0.85);">cluster-replica-validity-factor&#x3D;10</font><font style="color:rgb(244, 138, 0);">，</font><font style="color:rgba(0, 0, 0, 0.85);">repl-ping-slave-period&#x3D;10&#96;秒， 表示slave节点与master节点上次交互时间已经过去了310秒，那么slave节点就不会做failover。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">调大 </font><font style="color:rgb(244, 138, 0);">cluster-replica-validity-factor</font><font style="color:rgba(0, 0, 0, 0.85);"> 则允许存储过旧数据的 slave 节点提升为 master，调小的话可能会导致没有 slave 节点可以升为 master 节点。</font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.85);">考虑高可用，建议大家设置为 </font><strong><strong><font style="color:rgb(244, 138, 0);">cluster-replica-validity-factor 0</font></strong></strong><font style="color:rgba(0, 0, 0, 0.85);">。</font></strong></p>
<h3 id="cluster-migration-barrier"><a href="#cluster-migration-barrier" class="headerlink" title="cluster-migration-barrier"></a><font style="color:rgb(244, 138, 0);">cluster-migration-barrier</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">没有 slave 节点的 master 节点称为孤儿 master节点，这个配置就是用于防止出现裸奔的 master。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">当某个 master 的 slave 节点宕机后，集群会从其他 master 中选出一个富余的 slave 节点迁移过来，确保每个 master 节点至少有一个 slave 节点，防止当孤立 master 节点宕机时，没有slave节点可以升为 master 导致集群不可用。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">默认配置为 </font><font style="color:rgb(244, 138, 0);">cluster-migration-barrier 1</font><font style="color:rgba(0, 0, 0, 0.85);">，是一个迁移临界值。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">含义是：迁移后 master 节点至少还有 1 个 slave 节点才能做迁移操作。比如 master A 节点有2个以上 slave 节点 ，当集群出现孤儿 master B 节点时，A 节点富余的 slave 节点可以迁移到 master B 节点上。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">生产环境建议维持默认值，最大可能保证高可用，设置为非常大的值或者配置  </font><font style="color:rgb(244, 138, 0);">cluster-allow-replica-migration no</font><font style="color:rgba(0, 0, 0, 0.85);"> 禁用自动迁移功能。</font></p>
<p><font style="color:rgb(244, 138, 0);">cluster-allow-replica-migration</font><font style="color:rgba(0, 0, 0, 0.85);"> 默认配置为 yes，表示允许自动迁移。</font></p>
<h3 id="cluster-require-full-coverage"><a href="#cluster-require-full-coverage" class="headerlink" title="cluster-require-full-coverage"></a><font style="color:rgb(244, 138, 0);">cluster-require-full-coverage</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">默认配置是 </font><font style="color:rgb(244, 138, 0);">yes</font><font style="color:rgba(0, 0, 0, 0.85);">，表示为当 redis cluster 发现至少还有一个 哈希槽没有被分配时禁止查询操作。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">这就会导致集群部分宕机，整个集群就不可用了，当所有哈希槽都有分配，集群会自动变为可用状态。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">如果你希望 cluster 的子集依然可用，配置成 </font><font style="color:rgb(244, 138, 0);">cluster-require-full-coverage yes</font><font style="color:rgba(0, 0, 0, 0.85);">。</font></p>
<h3 id="cluster-replica-no-failover"><a href="#cluster-replica-no-failover" class="headerlink" title="cluster-replica-no-failover"></a><font style="color:rgb(244, 138, 0);">cluster-replica-no-failover</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">默认配置为 </font><font style="color:rgb(244, 138, 0);">no</font><font style="color:rgba(0, 0, 0, 0.85);">，当配置成 </font><font style="color:rgb(244, 138, 0);">yes</font><font style="color:rgba(0, 0, 0, 0.85);">，在master 宕机时，slave 不会做故障转移升为 master。</font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.85);">这个配置在多数据中心的情况下会很有用，你可能希望某个数据中心永远不要升级为 master 节点，否则 master 节点就漂移到其他数据中心了。</font></strong></p>
<h3 id="cluster-allow-reads-when-down"><a href="#cluster-allow-reads-when-down" class="headerlink" title="cluster-allow-reads-when-down"></a><font style="color:rgb(244, 138, 0);">cluster-allow-reads-when-down</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">默认是 </font><font style="color:rgb(244, 138, 0);">no</font><font style="color:rgba(0, 0, 0, 0.85);">，表示当集群因主节点数量达不到最小值或者哈希槽没有完全分配而被标记为失效时，节点将停止所有客户端请求。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">设置成 </font><font style="color:rgb(244, 138, 0);">yes</font><font style="color:rgba(0, 0, 0, 0.85);">，则允许集群失效的情况下依然可从节点中读取数据，保证了高可用。</font></p>
<h3 id="cluster-allow-pubsubshard-when-down"><a href="#cluster-allow-pubsubshard-when-down" class="headerlink" title="cluster-allow-pubsubshard-when-down"></a><font style="color:rgb(244, 138, 0);">cluster-allow-pubsubshard-when-down</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">配置成 </font><font style="color:rgb(244, 138, 0);">yes</font><font style="color:rgba(0, 0, 0, 0.85);">，表示当集群因主节点数量达不到最小值或者哈希槽没有完全分配而被标记为失效时，pub&#x2F;sub 依然可以正常运行。</font></p>
<h3 id="cluster-link-sendbuf-limit"><a href="#cluster-link-sendbuf-limit" class="headerlink" title="cluster-link-sendbuf-limit"></a><font style="color:rgb(244, 138, 0);">cluster-link-sendbuf-limit</font></h3><p><font style="color:rgba(0, 0, 0, 0.85);">设置每个集群总线连接的发送字节缓冲区的内存使用限制，超过限制缓冲区将被清空（主要为了防止发送缓冲区发送给慢速连接时无限延长时间的问题）。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.85);">默认禁用，建议最小设置1gb，这样默认情况下集群连接缓冲区可以容纳至少一pubsub消息（client-query-buffer-limit 默认是1gb）；</font></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Linux安装</title>
    <url>/2024/11/06/Redis%20Linux%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-下载官方镜像"><a href="#1-下载官方镜像" class="headerlink" title="1.下载官方镜像"></a>1.下载官方镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis:7.0.5</span><br></pre></td></tr></table></figure>

<h2 id="2-准备安装位置"><a href="#2-准备安装位置" class="headerlink" title="2.准备安装位置"></a>2.准备安装位置</h2><p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/server/redis/conf</span><br><span class="line">chmod -R 777 /opt/server/redis</span><br><span class="line">cd /opt/server/redis/conf</span><br><span class="line">wget http://download.redis.io/redis-stable/redis.conf #下载redis的配置文件 (跳此步,直接下一步,我已经写好配置了)</span><br><span class="line">vim redis.conf #更改配置文件, 让宿主机可以访问redis-server #保存并退出</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="3-编辑配置文件"><a href="#3-编辑配置文件" class="headerlink" title="3.编辑配置文件"></a>3.编辑配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开启保护</span><br><span class="line">protected-mode yes</span><br><span class="line">#开启远程连接 </span><br><span class="line">#bind 127.0.0.1 </span><br><span class="line">#自定义密码</span><br><span class="line">requirepass 12345678 </span><br><span class="line">port 6379</span><br><span class="line">timeout 0</span><br><span class="line"># 900s内至少一次写操作则执行bgsave进行RDB持久化</span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">rdbcompression yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir /data</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">参数说明:</font></p>
<p><font style="color:rgb(77, 77, 77);">1.修改保护模式protected-mode yes 默认为yes 可以跳过这一步</font></p>
<p><font style="color:rgb(77, 77, 77);">Redis protected-mode属性解读</font></p>
<p><font style="color:rgb(77, 77, 77);">设置外部网络连接redis服务，设置说明如下：</font></p>
<p><font style="color:rgb(77, 77, 77);">a.关闭protected-mode模式，此时外部网络可以直接访问</font></p>
<p><font style="color:rgb(77, 77, 77);">b.开启protected-mode保护模式，需配置bind ip 和设置访问密码 redis3.2版本后新增protected-mode配置，默认是yes，即开启。</font></p>
<p><font style="color:rgb(77, 77, 77);">2.把bind 127.0.0.1 注释掉 #bind 127.0.0.1, 这样所有的ip都可以访问了</font></p>
<p><font style="color:rgb(77, 77, 77);">3.设置密码（根据自己的需要）</font></p>
<p><font style="color:rgb(77, 77, 77);">设置永久密码的方法</font></p>
<p><font style="color:rgb(77, 77, 77);">找到requirepass foobared 把foobared改为自己的登陆密码 这里我设置为123456</font></p>
<p><font style="color:rgb(77, 77, 77);">requirepass 123456</font></p>
<p><font style="color:rgb(77, 77, 77);">设置临时密码的方法</font></p>
<p><font style="color:rgb(77, 77, 77);">在连接上redis后,config set设置临时密码,redis重启后,设置的密码就失效了</font></p>
<p><font style="color:rgb(77, 77, 77);">127.0.0.1:6379&gt; config set requirepass “123456” # 设置密码为123456<br></font><font style="color:rgb(77, 77, 77);">OK<br></font><font style="color:rgb(77, 77, 77);">127.0.0.1:6379&gt; config get requirepass # 获取密码的值</font></p>
<p><font style="color:rgb(77, 77, 77);">“requirepass”<br></font><font style="color:rgb(77, 77, 77);">“123456”</font></p>
<p><font style="color:rgb(77, 77, 77);">4.appendonly yes #开启AOF模式</font></p>
<h2 id="4-书写docker-compose文件"><a href="#4-书写docker-compose文件" class="headerlink" title="4.书写docker-compose文件"></a>4.书写docker-compose文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line">services:</span><br><span class="line">  myredis:</span><br><span class="line">    container_name: myredis</span><br><span class="line">    image: redis:7.0.5</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">    privileged: true</span><br><span class="line">    command: redis-server /etc/redis/redis.conf --appendonly yes</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis/data:/data</span><br><span class="line">      - ./redis/conf/redis.conf:/etc/redis/redis.conf</span><br><span class="line">    networks:</span><br><span class="line">      - myweb</span><br><span class="line">networks:</span><br><span class="line">  myweb:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure>

<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a><font style="color:rgb(77, 77, 77);">启动容器</font></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># docker-compose up -d # 后台启动</span><br><span class="line"># docker ps -a #查看启动的容器</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 运维工具</title>
    <url>/2024/11/06/Redis%20%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="10-1-运维脚本"><a href="#10-1-运维脚本" class="headerlink" title="10.1 运维脚本"></a>10.1 运维脚本</h1><p>[root@db01 ~]# cat redis_shell.sh</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="title function_">USAG</span>(<span class="params"></span>)&#123;</span><br><span class="line"> echo <span class="string">&quot;sh $0 &#123;start|stop|restart|login|ps|tail&#125; PORT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$#&quot;</span> = <span class="number">1</span> ]</span><br><span class="line">then</span><br><span class="line"> <span class="variable constant_">REDIS_PORT</span>=<span class="string">&#x27;6379&#x27;</span></span><br><span class="line">elif</span><br><span class="line"> [ <span class="string">&quot;$#&quot;</span> = <span class="number">2</span> -a -z <span class="string">&quot;$(echo &quot;</span>$2<span class="string">&quot;|sed &#x27;s#[0-9]##g&#x27;)&quot;</span> ]</span><br><span class="line">then</span><br><span class="line"> <span class="variable constant_">REDIS_PORT</span>=<span class="string">&quot;$2&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="variable constant_">USAG</span></span><br><span class="line"> exit <span class="number">0</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">REDIS_IP</span>=$(hostname -I|awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"><span class="variable constant_">PATH_DIR</span>=<span class="regexp">/opt/</span>redis_cluster/redis_$&#123;<span class="variable constant_">REDIS_PORT</span>&#125;/</span><br><span class="line"><span class="variable constant_">PATH_CONF</span>=<span class="regexp">/opt/</span>redis_cluster/redis_$&#123;<span class="variable constant_">REDIS_PORT</span>&#125;/conf/redis_$&#123;<span class="variable constant_">REDIS_PORT</span>&#125;.<span class="property">conf</span></span><br><span class="line"><span class="variable constant_">PATH_LOG</span>=<span class="regexp">/opt/</span>redis_cluster/redis_$&#123;<span class="variable constant_">REDIS_PORT</span>&#125;/logs/redis_$&#123;<span class="variable constant_">REDIS_PORT</span>&#125;.<span class="property">log</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">CMD_START</span>(<span class="params"></span>)&#123;</span><br><span class="line">      redis-server $&#123;<span class="variable constant_">PATH_CONF</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title function_">CMD_SHUTDOWN</span>(<span class="params"></span>)&#123;</span><br><span class="line">      redis-cli -c -h $&#123;<span class="variable constant_">REDIS_IP</span>&#125; -p $&#123;<span class="variable constant_">REDIS_PORT</span>&#125; shutdown</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title function_">CMD_LOGIN</span>(<span class="params"></span>)&#123;</span><br><span class="line">      redis-cli -c -h $&#123;<span class="variable constant_">REDIS_IP</span>&#125; -p $&#123;<span class="variable constant_">REDIS_PORT</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title function_">CMD_PS</span>(<span class="params"></span>)&#123;</span><br><span class="line">      ps -ef|grep redis</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title function_">CMD_TAIL</span>(<span class="params"></span>)&#123;</span><br><span class="line">      tail -f $&#123;<span class="variable constant_">PATH_LOG</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">case</span> $1 <span class="keyword">in</span></span><br><span class="line">     start)</span><br><span class="line">     <span class="variable constant_">CMD_START</span></span><br><span class="line">     <span class="variable constant_">CMD_PS</span></span><br><span class="line">     ;;</span><br><span class="line">     stop)</span><br><span class="line">     <span class="variable constant_">CMD_SHUTDOWN</span></span><br><span class="line">     <span class="variable constant_">CMD_PS</span></span><br><span class="line">     ;;</span><br><span class="line">     restart)</span><br><span class="line">     <span class="variable constant_">CMD_START</span></span><br><span class="line">     <span class="variable constant_">CMD_SHUTDOWN</span></span><br><span class="line">     <span class="variable constant_">CMD_PS</span></span><br><span class="line">     ;;</span><br><span class="line">     login)</span><br><span class="line">     <span class="variable constant_">CMD_LOGIN</span></span><br><span class="line">     ;;</span><br><span class="line">     ps)</span><br><span class="line">     <span class="variable constant_">CMD_PS</span></span><br><span class="line">     ;;</span><br><span class="line">     tail)</span><br><span class="line">     <span class="variable constant_">CMD_TAIL</span></span><br><span class="line">     ;;</span><br><span class="line">     *)</span><br><span class="line">     <span class="variable constant_">USAG</span></span><br><span class="line">    esac</span><br></pre></td></tr></table></figure>



<h1 id="10-2-数据导入导出工具"><a href="#10-2-数据导入导出工具" class="headerlink" title="10.2 数据导入导出工具"></a>10.2 数据导入导出工具</h1><p>需求背景 </p>
<p>刚切换到 redis 集群的时候肯定会面临数据导入的问题,所以这里推荐使用 redis-migrate-tool 工具来导 入单节点数据到集群里</p>
<p><a href="http://www.oschina.net/p/redis-migrate-tool">官方地址：</a></p>
<p>安装工具:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd /opt/redis_cluster/</span><br><span class="line">git clone <span class="attr">https</span>:<span class="comment">//github.com/vipshop/redis-migrate-tool.git</span></span><br><span class="line">cd redis-migrate-tool/</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>创建配置文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@db01 ~]# cat redis_6379_to_6380.<span class="property">conf</span></span><br><span class="line">[source]</span><br><span class="line"><span class="attr">type</span>: single</span><br><span class="line"><span class="attr">servers</span>:</span><br><span class="line">- <span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6379</span></span><br><span class="line">[target]</span><br><span class="line"><span class="attr">type</span>: redis cluster</span><br><span class="line"><span class="attr">servers</span>:</span><br><span class="line">- <span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span>:<span class="number">6380</span></span><br><span class="line">[common]</span><br><span class="line"><span class="attr">listen</span>: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8888</span></span><br><span class="line"><span class="attr">source_safe</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>生成测试数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@db01 ~]# cat input_key.<span class="property">sh</span></span><br><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq <span class="number">1</span> <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> redis-cli -c -h db01 -p <span class="number">6379</span> set k_$&#123;i&#125; v_$&#123;i&#125; &amp;&amp; echo <span class="string">&quot;set k_$&#123;i&#125; is ok&quot;</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>执行导入命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@db01 ~]# redis-migrate-tool -c redis_6379_to_6380.<span class="property">conf</span> </span><br></pre></td></tr></table></figure>

<p>数据校验</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@db01 ~]# redis-migrate-tool -c redis_6379_to_6380.<span class="property">conf</span> -C redis_check</span><br></pre></td></tr></table></figure>

<h1 id="10-3-分析键值大小"><a href="#10-3-分析键值大小" class="headerlink" title="10.3 分析键值大小"></a>10.3 分析键值大小</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">需求背景</span><br><span class="line">redis 的内存使用太大键值太多,不知道哪些键值占用的容量比较大,而且在线分析会影响性能.</span><br><span class="line"></span><br><span class="line">安装工具</span><br><span class="line">yum install python-pip gcc python-devel</span><br><span class="line">cd /opt/</span><br><span class="line">git clone <span class="attr">https</span>:<span class="comment">//github.com/sripathikrishnan/redis-rdb-tools</span></span><br><span class="line">cd redis-rdb-tools</span><br><span class="line">python setup.<span class="property">py</span> install</span><br><span class="line"></span><br><span class="line">使用方法</span><br><span class="line">cd /data/redis_cluster/redis_6380/</span><br><span class="line">rdb -c memory redis_6380.<span class="property">rdb</span> -f redis_6380.<span class="property">rdb</span>.<span class="property">csv</span></span><br><span class="line"></span><br><span class="line">分析 rdb 并导出</span><br><span class="line">awk -F <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $4,$2,$3,$1&#125;&#x27;</span> redis_6380.<span class="property">rdb</span>.<span class="property">csv</span> |sort &gt; <span class="number">6380.</span>txt</span><br></pre></td></tr></table></figure>

<h1 id="10-4-监控过期键"><a href="#10-4-监控过期键" class="headerlink" title="10.4 监控过期键"></a>10.4 监控过期键</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">需求背景</span><br><span class="line">因为开发重复提交，导致电商网站优惠卷过期时间失效</span><br><span class="line">问题分析</span><br><span class="line">如果一个键已经设置了过期时间，这时候在 set 这个键，过期时间就会取消</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">解决思路</span><br><span class="line">如何在不影响机器性能的前提下批量获取需要监控键过期时间</span><br><span class="line"><span class="number">1.</span><span class="title class_">Keys</span> * 查出来匹配的键名。然后循环读取 ttl 时间</span><br><span class="line"><span class="number">2.</span>scan * 范围查询键名。然后循环读取 ttl 时间</span><br><span class="line"><span class="title class_">Keys</span> 重操作，会影响服务器性能，除非是不提供服务的从节点</span><br><span class="line"><span class="title class_">Scan</span> 负担小，但是需要去多次才能取完，需要写脚本</span><br></pre></td></tr></table></figure>

<p>脚本内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat 01get_key.<span class="property">sh</span></span><br><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">key_num=<span class="number">0</span></span><br><span class="line">&gt; key_name.<span class="property">log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> $(cat key_list.<span class="property">txt</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">      scan_num=$(redis-cli -h <span class="number">192.168</span><span class="number">.47</span><span class="number">.75</span> -p <span class="number">6380</span> <span class="variable constant_">SCAN</span> $&#123;key_num&#125; match $&#123;line&#125;\* count</span><br><span class="line">     <span class="number">1000</span>|awk <span class="string">&#x27;NR==1&#123;print $0&#125;&#x27;</span>)</span><br><span class="line">      key_name=$(redis-cli -h <span class="number">192.168</span><span class="number">.47</span><span class="number">.75</span> -p <span class="number">6380</span> <span class="variable constant_">SCAN</span> $&#123;key_num&#125; match $&#123;line&#125;\* count</span><br><span class="line">     <span class="number">1000</span>|awk <span class="string">&#x27;NR&gt;1&#123;print $0&#125;&#x27;</span>)</span><br><span class="line">      echo $&#123;key_name&#125;|xargs -n <span class="number">1</span> &gt;&gt; key_name.<span class="property">log</span></span><br><span class="line">      ((key_num=scan_num))</span><br><span class="line">      <span class="keyword">if</span> [ $&#123;key_num&#125; == <span class="number">0</span> ]</span><br><span class="line">      then</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      fi</span><br><span class="line">   done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 使用场景</title>
    <url>/2024/11/06/Redis%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong><font style="color:rgb(72, 179, 120);">前言</font></strong></h2><p><font style="color:rgb(63, 63, 63);">Redis作为一种优秀的基于key&#x2F;value的缓存，有非常不错的性能和稳定性，无论是在工作中，还是面试中，都经常会出现。</font></p>
<p><font style="color:rgb(63, 63, 63);">总结一下在实际工作中使用Redis的10种场景，希望对你会有所帮助。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/396745/1705650079483-5a10f8da-dfe0-40b3-bea7-8d61661f6012.png"></p>
<span id="more"></span>
<h2 id="1、统计访问次数"><a href="#1、统计访问次数" class="headerlink" title="1、统计访问次数"></a><strong><font style="color:rgb(72, 179, 120);">1、统计访问次数</font></strong></h2><p><font style="color:rgb(63, 63, 63);">对于很多官方网站的首页，经常会有一些统计首页访问次数的需求。</font></p>
<p><font style="color:rgb(63, 63, 63);">访问次数只有一个字段，如果保存到数据库中，再最后做汇总显然有些麻烦。</font></p>
<p><font style="color:rgb(63, 63, 63);">该业务场景可以使用Redis，定义一个key，比如：OFFICIAL_INDEX_VISIT_COUNT。</font></p>
<p><font style="color:rgb(63, 63, 63);">在Redis中有incr命令，可以实现给value值加1操作：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">incr OFFICIAL_INDEX_VISIT_COUNT</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">当然如果想一次加的值大于1，可以用incrby命令，例如：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">incrby OFFICIAL_INDEX_VISIT_COUNT 5</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">这样可以一次性加5。</font></p>
<h2 id="2、获取分类树"><a href="#2、获取分类树" class="headerlink" title="2、获取分类树"></a><strong><font style="color:rgb(72, 179, 120);">2、获取分类树</font></strong></h2><p><font style="color:rgb(63, 63, 63);">在很多网站都有分类树的功能，如果没有生成静态的html页面，想通过调用接口的方式获取分类树的数据。</font></p>
<p><font style="color:rgb(63, 63, 63);">一般为了性能考虑，会将分类树的json数据缓存到Redis当中，为了后面在网站当中能够快速获取数据。</font></p>
<p><font style="color:rgb(63, 63, 63);">不然在接口中需要使用递归查询数据库，然后拼接成分类树的数据结构。</font></p>
<p><font style="color:rgb(63, 63, 63);">这个过程非常麻烦，而且需要多次查询数据库，性能很差。</font></p>
<p><font style="color:rgb(63, 63, 63);">因此，可以考虑用一个定时任务，异步将分类树的数据，直接缓存到Redis当中，定义一个key，比如：MALL_CATEGORY_TREE。</font></p>
<p><font style="color:rgb(63, 63, 63);">然后接口中直接使用MALL_CATEGORY_TREE这个key从缓存中获取数据即可。</font></p>
<p><font style="color:rgb(63, 63, 63);">可以直接用key&#x2F;value字符串保存数据。</font></p>
<h2 id="3、做分布式锁"><a href="#3、做分布式锁" class="headerlink" title="3、做分布式锁"></a><strong><font style="color:rgb(72, 179, 120);">3、做分布式锁</font></strong></h2><p><font style="color:rgb(63, 63, 63);">分布式锁可能是使用Redis最常见的场景之一，相对于其他的分布式锁，比如：数据库分布式锁或者Zookeeper分布式锁，基于Redis的分布式锁，有更好的性能，被广泛使用于实际工作中。</font></p>
<p><font style="color:rgb(63, 63, 63);">使用下面这段代码可以加锁：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    unlock(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">但上面这段代码在有些场景下，会有一些问题，释放锁可能会释放了别人的锁。</font></p>
<p><font style="color:rgb(63, 63, 63);">说实话Redis分布式锁虽说很常用，但坑也挺多的，如果用不好的话，很容易踩坑。</font></p>
<h2 id="4、做排行榜"><a href="#4、做排行榜" class="headerlink" title="4、做排行榜"></a><strong><font style="color:rgb(72, 179, 120);">4、做排行榜</font></strong></h2><p><font style="color:rgb(63, 63, 63);">很多网站有排行榜的功能，比如：商城中有商品销量的排行榜，游戏网站有玩家获得积分的排行榜。</font></p>
<p><font style="color:rgb(63, 63, 63);">通常情况下，可以使用</font><font style="color:rgb(40, 202, 113);">Sorted Set</font><font style="color:rgb(63, 63, 63);">保存排行榜的数据。</font></p>
<p><font style="color:rgb(63, 63, 63);">使用</font><font style="color:rgb(40, 202, 113);">ZADD</font><font style="color:rgb(63, 63, 63);">可以添加排行榜的数据，使用</font><font style="color:rgb(40, 202, 113);">ZRANGE</font><font style="color:rgb(63, 63, 63);">可以获取排行榜的数据。</font></p>
<p><font style="color:rgb(63, 63, 63);">例如：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZADD rank:score 100 <span class="string">&quot;周星驰&quot;</span></span><br><span class="line">ZADD rank:score 90 <span class="string">&quot;周杰伦&quot;</span></span><br><span class="line">ZADD rank:score 80 <span class="string">&quot;周润发&quot;</span></span><br><span class="line">ZRANGE rank:score 0 -1 WITHSCORES</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">返回数据：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1) <span class="string">&quot;周星驰&quot;</span></span><br><span class="line">2) <span class="string">&quot;100&quot;</span></span><br><span class="line">3) <span class="string">&quot;周杰伦&quot;</span></span><br><span class="line">4) <span class="string">&quot;90&quot;</span></span><br><span class="line">5) <span class="string">&quot;周润发&quot;</span></span><br><span class="line">6) <span class="string">&quot;80&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="5、记录用户登录状态"><a href="#5、记录用户登录状态" class="headerlink" title="5、记录用户登录状态"></a><strong><font style="color:rgb(72, 179, 120);">5、记录用户登录状态</font></strong></h2><p><font style="color:rgb(63, 63, 63);">通常下，用户登录成功之后，用户登录之后的状态信息，会保存到Redis中。</font></p>
<p><font style="color:rgb(63, 63, 63);">这样后面该用户访问其他接口的时候，会直接从Redis中查询用户登录状态，如果可以查到数据，说明用户已登录，则允许做后续的操作。</font></p>
<p><font style="color:rgb(63, 63, 63);">如果从Redis中没有查到用户登录状态，说明该用户没有登录，或者登录状态失效了，则直接跳转到用户登录页面。</font></p>
<p><font style="color:rgb(63, 63, 63);">使用Redis保存用户登录状态，有个好处是它可以设置一个过期时间，比如：该时间可以设置成30分钟。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(userId, userInfo, <span class="number">1800</span>);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">在Redis内部有专门的job，会将过期的数据删除，也有获取数据时实时删除的逻辑。</font></p>
<h2 id="6、限流"><a href="#6、限流" class="headerlink" title="6、限流"></a><strong><font style="color:rgb(72, 179, 120);">6、限流</font></strong></h2><p><font style="color:rgb(63, 63, 63);">使用Redis还有一个非常常用的的业务场景是</font><font style="color:rgb(40, 202, 113);">做限流</font><font style="color:rgb(63, 63, 63);">。</font></p>
<p><font style="color:rgb(63, 63, 63);">当然还有其他的限流方式，比如：使用nginx，但使用Redis控制可以更精细。</font></p>
<p><font style="color:rgb(63, 63, 63);">比如：限制同一个ip，1分钟之内只能访问10次接口，10分钟之内只能访问50次接口，1天之内只能访问100次接口。</font></p>
<p><font style="color:rgb(63, 63, 63);">如果超过次数，则接口直接返回：请求太频繁了，请稍后重试。</font></p>
<p><font style="color:rgb(63, 63, 63);">跟上面保存用户登录状态类似，需要在Redis中保存用户的请求记录。</font></p>
<p><font style="color:rgb(63, 63, 63);">比如：key是用户ip，value是访问的次数从1开始，后面每访问一次则加1。</font></p>
<p><font style="color:rgb(63, 63, 63);">如果value超过一定的次数，则直接拦截这种异常的ip。</font></p>
<p><font style="color:rgb(63, 63, 63);">当然也需要设置一个过期时间，异常ip如果超过这个过期时间，比如：1天，则恢复正常了，该ip可以再发起请求了。</font></p>
<p><font style="color:rgb(63, 63, 63);">或者限制同一个用户id。</font></p>
<h2 id="7、位统计"><a href="#7、位统计" class="headerlink" title="7、位统计"></a><strong><font style="color:rgb(72, 179, 120);">7、位统计</font></strong></h2><p><font style="color:rgb(63, 63, 63);">比如现在有个需求：有个网站需要统计一周内连续登陆的用户，以及一个月内登陆过的用户。</font></p>
<p><font style="color:rgb(63, 63, 63);">这个需求使用传统的数据库，实现起来比较麻烦，但使用Redis的</font><font style="color:rgb(40, 202, 113);">bitmap</font><font style="color:rgb(63, 63, 63);">可以实时的进行类似的统计。</font></p>
<p><font style="color:rgb(63, 63, 63);">bitmap 是二进制的byte数组，也可以简单理解成是一个普通字符串。它将二进制数据存储在byte数组中以达到存储数据的目的。</font></p>
<p><font style="color:rgb(63, 63, 63);">保存数据命令使用setbit，语法：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">具体示例：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit user:view:2024-01-17 123456 1</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">往bitmap数组中设置了用户id&#x3D;123456的登录状态为1，标记2024-01-17已登录。</font></p>
<p><font style="color:rgb(63, 63, 63);">然后通过命令getbit获取数据，语法：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">具体示例：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getbit user:view:2024-01-17 123456</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">如果获取的值是1，说明这一天登录了。</font></p>
<p><font style="color:rgb(63, 63, 63);">如果想统计一周内连续登录的用户，只需要遍历用户id，根据日期中数组中去查询状态即可。</font></p>
<h2 id="8、缓存加速"><a href="#8、缓存加速" class="headerlink" title="8、缓存加速"></a><strong><font style="color:rgb(72, 179, 120);">8、缓存加速</font></strong></h2><p><font style="color:rgb(63, 63, 63);">在工作中使用Redis作为缓存加速，这种用法也是非常常见的。</font></p>
<p><font style="color:rgb(63, 63, 63);">如果查询订单数据，先从Redis缓存中查询，如果缓存中存在，则直接将数据返回给用户。</font></p>
<p><font style="color:rgb(63, 63, 63);">如果缓存中不存在，则再从数据库中查询数据，如果数据存在，则将数据保存到缓存中，然后再返回给用户。</font></p>
<p><font style="color:rgb(63, 63, 63);">如果缓存和数据库都不存在，则直接给用户返回数据不存在。</font></p>
<p><font style="color:rgb(63, 63, 63);">流程图如下：</font><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/396745/1705650079525-ad1cc08c-d266-44d2-ae4b-7fc8d9e256ec.png"><font style="color:rgb(63, 63, 63);">但使用缓存加速的业务场景，需要注意一下，可能会出现：缓存击穿、穿透和雪崩等问题。</font></p>
<h2 id="9、做消息队列"><a href="#9、做消息队列" class="headerlink" title="9、做消息队列"></a><strong><font style="color:rgb(72, 179, 120);">9、做消息队列</font></strong></h2><p><font style="color:rgb(63, 63, 63);">说起队列经常想到是：kafka、rabbitMQ、RocketMQ等这些分布式消息队列。</font></p>
<p><font style="color:rgb(63, 63, 63);">其实Redis也有消息队列的功能，之前有个支付系统，就是用的Redis队列功能。</font></p>
<p><font style="color:rgb(63, 63, 63);">PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。</font></p>
<p><font style="color:rgb(63, 63, 63);">顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。对应channel发送消息后，所有订阅者都能收到相关消息。</font></p>
<p><font style="color:rgb(63, 63, 63);">在java代码中可以实现MessageListener接口，来消费队列中的消息。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisMessageListenerListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] pattern)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(pattern);</span><br><span class="line">        RedisSerializer&lt;?&gt; valueSerializer = redisTemplate.getValueSerializer();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">deserialize</span> <span class="operator">=</span> valueSerializer.deserialize(message.getBody());</span><br><span class="line">        <span class="keyword">if</span> (deserialize == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5DigestAsHex</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(deserialize.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(md5DigestAsHex, <span class="string">&quot;1&quot;</span>, <span class="number">20</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.equals(result)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收的结果：&#123;&#125;&quot;</span>, deserialize.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;其他服务处理中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、生成全局ID"><a href="#10、生成全局ID" class="headerlink" title="10、生成全局ID"></a><strong><font style="color:rgb(72, 179, 120);">10、生成全局ID</font></strong></h2><p><font style="color:rgb(63, 63, 63);">在有些需要生成全局ID的业务场景，其实也可以使用Redis。</font></p>
<p><font style="color:rgb(63, 63, 63);">可以使用incrby命令，利用原子性操作，可以执行下面这个命令：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">incrby userid 10000</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(63, 63, 63);">在分库分表的场景，对于有些批量操作，可以从Redis中，一次性拿一批id出来，然后给业务系统使用。</font></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Pipeline管道</title>
    <url>/2024/11/06/Redis-Pipeline%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p><font style="background:#F8CED3;color:#70000D">Redis</font> <font style="background:#DBF1B7;color:#2A4200">Pipeline</font> <font style="background:#C0DDFC;color:#00346B">管道</font></p>
<h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><blockquote>
<p>Linux（CentOS7.3）-Redis6.0.5源码编译版</p>
</blockquote>
<hr>
<h1 id="1、Redis客户端与服务端通信分析"><a href="#1、Redis客户端与服务端通信分析" class="headerlink" title="1、Redis客户端与服务端通信分析"></a>1、Redis客户端与服务端通信分析</h1><p>Redis 性能瓶颈主要是网络，主要原因就在于 Redis 执行命令的时间通常在微秒级别。正常情况下，执行一条 Redis 命令流程要经过如下几个步骤：</p>
<ol>
<li><font style="color:#4A4A4A;">客户端发送 Redis 命令，阻塞等待 Redis 应答</font></li>
<li><font style="color:#4A4A4A;">Redis 接收到命令，执行命令</font></li>
<li><font style="color:#4A4A4A;">应答，客户端收到响应信息</font></li>
</ol>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593255821904-3b60671e-8865-423a-893e-f9abdf6cc908.png"></p>
<span id="more"></span>
<p><font style="color:#4A4A4A;">其中 1 、3 称之为一次 RTT（Round Trip Time）。在这种情况下，如果同时执行大量命令，那当前命令需要等待上一条命令应答完成后才会执行，这个过程不仅仅只有多次 RTT，还有频繁的调用系统 IO，发送网络请求，如下图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593256561687-03a7f134-07e2-42e5-a3ad-13bb9b4d76b0.png"></p>
<p><font style="color:#4A4A4A;">把大量的时间消耗在来回路上，真正办事的时间就只有一点点，这种做法是非常不明智且低效的，为了解决这种低效的做法，pipeline 出现了，它允许客户端一次性发送多条命令，减少 RTT 和 IO 的调用次数（IO 调用涉及到用户态到内核态之间的切换）。如下图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593257317620-fe39c154-5821-466b-99a0-4beda2dffc47.png"></p>
<h1 id="2、实现原理"><a href="#2、实现原理" class="headerlink" title="2、实现原理"></a>2、实现原理</h1><p>要支持 pipeline，除了需要 Redis 服务端支持，也需要各个客户端的支持，例如 jedis 就对 pipeline 提供了很好的支持。对于服务端来说，所需要的就是能够处理客户端通过一个 TCP 连接发送的多个命令，对多个命令进行排队，执行。而客户端，则需要将多个命令缓存起来，待缓冲区满了就发送，同时还需要处理 Redis 的应答。</p>
<p>pipeline 能提供性能的核心就在于：<strong>它能将一组 Redis 命令进行组装，通过一次 RTT 传输给 Redis，同时再将这组命令的执行结果按照顺序返回给客户端</strong>。将原来一组命令多次 RTT 以及 IO 交互变成了一组 RTT 和 IO 交互，大大减少了网络传输时间和 IO 调用的时间。</p>
<p>下图是一次请求交互的流程</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593258035647-e037916a-3530-4e6d-85de-0dc781737ed3.png"></p>
<p><font style="color:#4A4A4A;">需要注意的是，在使用 pipeline 的过程中需要控制其中命令的大小，如果一次组装的命令过多，则会增加造成一定的网络阻塞，也会增加客户端的等待时间。</font></p>
<h1 id="3、性能压测"><a href="#3、性能压测" class="headerlink" title="3、性能压测"></a>3、性能压测</h1><p>Redis 提供了一个压测工具 <code>redis-benchmark</code>，该工具在Redis安装包的src目录下，通过redis-benchmark可以进行 pipeline 测试。如下：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1595559269428-4f01da0a-b2c3-45d1-8996-e879265fa104.png"></p>
<p>-P 参数：它表示单个管道内并行的请求数量</p>
<h1 id="4、与批量的比较"><a href="#4、与批量的比较" class="headerlink" title="4、与批量的比较"></a>4、与批量的比较</h1><p>pipeline 的批次提交命令与 Redis 的批量命令有很多相似之处，可以利用 pipeline 模拟出批次的效果，但是他们还是存在一些不同之处：</p>
<ol>
<li><font style="color:#4A4A4A;">pipeline 可以一次性发送多个不同的命令，例如 set、get、而批量这是一次一个命令，只不过这一次对应的是多个 key 而已。</font></li>
<li><font style="color:#4A4A4A;">pipeline 只是将多个命令一起发出去而已，不保证这些命令的执行是原子性，而批量则是原子性的，他需要保证整个操作的正确性，避免中途出错而导致最后产生的数据不一致。</font></li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从架构</title>
    <url>/2024/11/06/Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><font style="background:#F8CED3;color:#70000D">Redis</font></p>
<p><font style="color:rgb(34, 34, 34);">单机的 Redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑</font><strong><font style="color:rgb(34, 34, 34);">读高并发</font></strong><font style="color:rgb(34, 34, 34);">的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的</font><strong><font style="color:rgb(34, 34, 34);">读请求全部走从节点</font></strong><font style="color:rgb(34, 34, 34);">。这样也可以很轻松实现水平扩容，</font><strong><font style="color:rgb(34, 34, 34);">支撑读高并发</font></strong><font style="color:rgb(34, 34, 34);">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/396745/1676981173688-47d05856-4a20-4709-9f23-ee252ae8f2d9.png"></p>
<p><font style="color:rgb(34, 34, 34);">Redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</font></p>
<span id="more"></span>
<h2 id="Redis-replication-的核心机制"><a href="#Redis-replication-的核心机制" class="headerlink" title="Redis replication 的核心机制"></a><font style="color:rgb(53, 179, 120);">Redis replication 的核心机制</font></h2><ul>
<li><font style="color:rgb(34, 34, 34);">Redis 采用</font><strong><font style="color:rgb(34, 34, 34);">异步方式</font></strong><font style="color:rgb(34, 34, 34);">复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</font></li>
<li><font style="color:rgb(34, 34, 34);">一个 master node 是可以配置多个 slave node 的；</font></li>
<li><font style="color:rgb(34, 34, 34);">slave node 也可以连接其他的 slave node；</font></li>
<li><font style="color:rgb(34, 34, 34);">slave node 做复制的时候，不会 block master node 的正常工作；</font></li>
<li><font style="color:rgb(34, 34, 34);">slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</font></li>
<li><font style="color:rgb(34, 34, 34);">slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</font></li>
</ul>
<p><font style="color:rgb(34, 34, 34);">注意，如果采用了主从架构，那么建议必须</font><strong><font style="color:rgb(34, 34, 34);">开启</font></strong><font style="color:rgb(34, 34, 34);"> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</font></p>
<p><font style="color:rgb(34, 34, 34);">另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能</font><strong><font style="color:rgb(34, 34, 34);">确保启动的时候，是有数据的</font></strong><font style="color:rgb(34, 34, 34);">，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</font></p>
<h2 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a><font style="color:rgb(53, 179, 120);">Redis 主从复制的核心原理</font></h2><p><font style="color:rgb(34, 34, 34);">当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</font></p>
<p><font style="color:rgb(34, 34, 34);">如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先</font><strong><font style="color:rgb(34, 34, 34);">写入本地磁盘，然后再从本地磁盘加载到内存</font></strong><font style="color:rgb(34, 34, 34);">中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/396745/1676981173703-84789937-9009-4c26-a9b8-382b4b98aff4.png"></p>
<h3 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a><font style="color:rgb(34, 34, 34);">主从复制的断点续传</font></h3><p><font style="color:rgb(34, 34, 34);">从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</font></p>
<p><font style="color:rgb(34, 34, 34);">master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> 。</font></p>
<p><font style="color:rgb(34, 34, 34);">&gt; 如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</font></p>
<h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a><font style="color:rgb(34, 34, 34);">无磁盘化复制</font></h3><p><font style="color:rgb(34, 34, 34);">master 在内存中直接创建 <code>RDB</code> ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure>

<h3 id="过期-key-处理"><a href="#过期-key-处理" class="headerlink" title="过期 key 处理"></a><font style="color:rgb(34, 34, 34);">过期 key 处理</font></h3><p><font style="color:rgb(34, 34, 34);">slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</font></p>
<h3 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a><font style="color:rgb(34, 34, 34);">复制的完整流程</font></h3><p><font style="color:rgb(34, 34, 34);">slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始。</font></p>
<p><font style="color:rgb(34, 34, 34);">slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node </font><strong><font style="color:rgb(34, 34, 34);">第一次执行全量复制</font></strong><font style="color:rgb(34, 34, 34);">，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2023/png/396745/1676981173697-c41d207c-5580-4edb-871f-ce9cb34a437f.png"></p>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a><font style="color:rgb(34, 34, 34);">全量复制</font></h3><ul>
<li><font style="color:rgb(34, 34, 34);">master 执行 bgsave ，在本地生成一份 rdb 快照文件。</font></li>
<li><font style="color:rgb(34, 34, 34);">master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</font></li>
<li><font style="color:rgb(34, 34, 34);">master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</font></li>
<li><font style="color:rgb(34, 34, 34);">如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</font></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure>

<ul>
<li><font style="color:rgb(34, 34, 34);">slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时</font><strong><font style="color:rgb(34, 34, 34);">基于旧的数据版本</font></strong><font style="color:rgb(34, 34, 34);">对外提供服务。</font></li>
<li><font style="color:rgb(34, 34, 34);">如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</font></li>
</ul>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a><font style="color:rgb(34, 34, 34);">增量复制</font></h3><ul>
<li><font style="color:rgb(34, 34, 34);">如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</font></li>
<li><font style="color:rgb(34, 34, 34);">master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</font></li>
<li><font style="color:rgb(34, 34, 34);">master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</font></li>
</ul>
<h3 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a><font style="color:rgb(34, 34, 34);">heartbeat</font></h3><p><font style="color:rgb(34, 34, 34);">主从节点互相都会发送 heartbeat 信息。</font></p>
<p><font style="color:rgb(34, 34, 34);">master 默认每隔 10 秒发送一次 heartbeat，slave node 每隔 1 秒发送一个 heartbeat。</font></p>
<h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a><font style="color:rgb(34, 34, 34);">异步复制</font></h3><p><font style="color:rgb(34, 34, 34);">master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</font></p>
<h2 id="Redis-如何才能做到高可用"><a href="#Redis-如何才能做到高可用" class="headerlink" title="Redis 如何才能做到高可用"></a><font style="color:rgb(53, 179, 120);">Redis 如何才能做到高可用</font></h2><p><font style="color:rgb(34, 34, 34);">如果系统在 365 天内，有 99.99% 的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的。</font></p>
<p><font style="color:rgb(34, 34, 34);">一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务。</font></p>
<p><font style="color:rgb(34, 34, 34);">但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。</font></p>
<p><font style="color:rgb(34, 34, 34);">Redis 的高可用架构，叫做 <code>failover</code> </font><strong><font style="color:rgb(34, 34, 34);">故障转移</font></strong><font style="color:rgb(34, 34, 34);">，也可以叫做主备切换。</font></p>
<p><font style="color:rgb(34, 34, 34);">master node 在故障时，自动检测，并且将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了 Redis 的主从架构下的高可用。</font></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2024/11/06/Redis/</url>
    <content><![CDATA[<h4 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h4><p><em><font style="color:rgb(247, 49, 49);">Redis</font></em><font style="color:rgb(51, 51, 51);">（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。官网地址为：</font><font style="color:rgb(51, 51, 51);">redis.io</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<span id="more"></span>
<h4 id="Redis能做什么"><a href="#Redis能做什么" class="headerlink" title="Redis能做什么"></a>Redis能做什么</h4><p><font style="color:rgb(51, 51, 51);">redis是一个key-value</font><a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F">存储系统</a><font style="color:rgb(51, 51, 51);">。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(</font><a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8">链表</a><font style="color:rgb(51, 51, 51);">)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些</font><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a><font style="color:rgb(51, 51, 51);">都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</font></p>
<p><font style="color:rgb(51, 51, 51);">Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了</font>memcached<font style="color:rgb(51, 51, 51);">这类key&#x2F;value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C&#x2F;C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。</font><font style="color:rgb(51, 102, 204);"> [1]</font><font style="color:rgb(19, 110, 194);"> </font></p>
<p><font style="color:rgb(51, 51, 51);">Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了</font><a href="https://baike.baidu.com/item/%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85">发布&#x2F;订阅</a><font style="color:rgb(51, 51, 51);">机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</font></p>
<h4 id="Redis都支持哪些语言"><a href="#Redis都支持哪些语言" class="headerlink" title="Redis都支持哪些语言"></a>Redis都支持哪些语言</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25873401/1644650393217-b2ac6b9b-cf08-485e-b1d9-ebd4e8692474.png"></p>
<h4 id="Redis的特性"><a href="#Redis的特性" class="headerlink" title="Redis的特性"></a>Redis的特性</h4><ul>
<li>开源</li>
<li>持久化<ul>
<li>RDB操作</li>
<li>AOF操作</li>
</ul>
</li>
<li>集群</li>
<li>事务</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis内存优化</title>
    <url>/2024/11/06/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="内存配置和查看"><a href="#内存配置和查看" class="headerlink" title="内存配置和查看"></a>内存配置和查看</h2><p><strong>Redis最大内存配置建议</strong></p>
<ul>
<li>Redis默认占用的内存：在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB。</li>
<li>在生产环境下，一般推荐设置为最大物理内存的四分之三。</li>
<li>配置单位是字节Bytes，如果设置为<code>maxmemory 0</code>即代表内存无限制。<span id="more"></span>
<strong>如何修改Redis的最大内存？</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：修改redis.conf配置文件。需重启Redis</span></span><br><span class="line">#maxmemory &lt;bytes&gt;</span><br><span class="line">maxmemory <span class="number">1</span></span><br><span class="line">#MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过命令修改。无需重启Redis</span></span><br><span class="line">config set maxmemory <span class="number">1</span></span><br><span class="line">config get maxmemory</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/696107/1646381474990-e234251f-74ea-4d93-805b-b0d0c3773052.png"></p>
<p><strong>查看内存占用情况</strong></p>
<p>使用<code>info memory</code>命令</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/696107/1646381894028-a1552038-e01d-4246-97aa-3b443e37777f.png"></p>
<h2 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h2><p><font style="color:rgb(51, 51, 51);">Redis处理过期Key有两种删除策略：被动方式、主动方式。</font><a href="https://www.redis.io/commands/expire">参考：Redis的过期删除策略</a></p>
<p><strong><font style="color:rgb(51, 51, 51);">被动方式：惰性删除</font></strong></p>
<p>描述：数据到达过期时间后不做处理，等下次访问该数据时，如果未过期则返回数据，如果发现已过期则删除，返回不存在。</p>
<p>优点：对于CPU来讲是友好的，不需要随时去遍历哪些Key已经过期了。</p>
<p>缺点：它对内存是最不友好的。如果一个键已经过期，而这个键又仍然保留在redis中，那么只要这个过期键不被删除，它所占用的内存就不会释放。在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏，即无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。</p>
<p><strong><font style="color:rgb(51, 51, 51);">主动方式：立即删除</font></strong></p>
<p>描述：立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。</p>
<p>缺点：立即删除对cpu是最不友好的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力。</p>
<p><strong><font style="color:rgb(51, 51, 51);">主动方式：定期删除</font></strong></p>
<p>描述：定期删除策略是每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。redis默认每隔100ms检查，是否有过期的key，有过期key则删除。注意：redis不是每隔100ms将所有的key检查一次而是随机抽取进行检查。</p>
<p>策略细化：周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度： </p>
<p>特点1：CPU性能占用设置有峰值，检测频度可自定义设置 </p>
<p>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 </p>
<p>总结：周期性抽查存储空间 （随机抽查，重点抽查）</p>
<p>难点：如何确定删除操作执行的时长和频率？</p>
<p>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成立即删除策略，以至于将CPU时间过多地消耗在删除过期键上面。如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除束略一样，出现浪费内存的情况。因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p>
<h2 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h2><p><a href="https://www.redis.io/topics/lru-cache">缓存的淘汰策略：https://www.redis.io/topics/lru-cache</a></p>
<p><strong>问题背景</strong></p>
<p>Redis的键在过期后会有综合策略将其淘汰出内存，但是问题出现了：如果用户所有的key都没有配置过期时间，或者有配置过期时间，Redis在使用删除策略时，部分键总是没有能淘汰出内存，这时候就会出现大量Key堆积到内存甚至OOM的情况。而缓存的淘汰就是解决的该个问题。</p>
<p><strong>缓存淘汰策略有哪些(6.0.8版本下)</strong></p>
<ul>
<li><font style="color:#E8323C;">noeviction（默认但严禁使用）</font>：不会del掉任务key。默认情况下的配置，生产环境下严禁使用。</li>
<li><font style="color:#E8323C;">allkeys-lru（推荐）</font>：通过首先尝试删除最近较少使用的（LRU）键来驱逐键，以便为添加的新数据腾出空间。</li>
<li>volatile-lru：通过首先尝试删除最近较少使用的（LRU）密钥来驱逐密钥，但仅在具有过期集的密钥中，以便为添加的新数据腾出空间。</li>
<li>allkeys-random：随机驱逐键，以便为添加的新数据腾出空间。</li>
<li>volatile-random：随机逐出键，以便为添加的新数据腾出空间，但仅逐出带有expire set的键。</li>
<li>volatile-ttl：驱逐设置了 expire的键，并尝试首先驱逐具有较短生存时间（TTL）的密钥，以便为添加的新数据腾出空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory is reached. You can select among five behaviors:</span><br><span class="line"></span><br><span class="line"># <span class="keyword">volatile</span>-lru -&gt; Evict using approximated LRU among the keys with an expire set.</span><br><span class="line"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line"># <span class="keyword">volatile</span>-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</span><br><span class="line"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="line"># <span class="keyword">volatile</span>-random -&gt; Remove a random key among the ones with an expire set.</span><br><span class="line"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="line"># <span class="keyword">volatile</span>-ttl -&gt; Remove the key with the nearest expire <span class="title function_">time</span> <span class="params">(minor TTL)</span></span><br><span class="line"># noeviction -&gt; Don<span class="string">&#x27;t evict anything, just return an error on write operations.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># LRU means Least Recently Used。LFU means Least Frequently Used。Both LRU, LFU and volatile-ttl are implemented using approximated randomized algorithms.</span></span><br><span class="line"><span class="string"># The default is: maxmemory-policy noeviction</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 将缓存策略更改为所有键使用LRU淘汰。LRU算法为：最近最少使用的淘汰。</span></span><br><span class="line"><span class="string">maxmemory-policy allkeys-lru</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵实战</title>
    <url>/2024/11/06/Redis%E5%93%A8%E5%85%B5%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="7-1-哨兵介绍"><a href="#7-1-哨兵介绍" class="headerlink" title="7.1 哨兵介绍"></a>7.1 哨兵介绍</h1><p> Redis 的<font style="color:#F5222D;">主从模式下</font>，主节点一旦发生故障不能提供服务，<font style="color:#F5222D;">需要人工干预</font>，将从节点晋升为主节点， 同时还<font style="color:#F5222D;">需要修改客户端配置。</font>对于很多应用场景这种方式无法接受。 </p>
<p>Sentinel（哨兵）架构解决了 redis 主从人工干预的问题。 Redis Sentinel 是 redis 的高可用实现方案，实际生产环境中，对提高整个系统可用性非常有帮助的。</p>
<span id="more"></span>

<h1 id="7-2-哨兵主要功能"><a href="#7-2-哨兵主要功能" class="headerlink" title="7.2 哨兵主要功能"></a>7.2 哨兵主要功能</h1><p>Redis Sentinel 是一个分布式系统， Redis Sentinel 为 Redis 提供高可用性。<font style="color:#F5222D;">可以在没有人为干预的 情况下阻止某种类型的故障。</font> Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）该系统执行以下三个任务：</p>
<p>1.监控（Monitoring）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Sentinel</span> 会不断地定期检查你的主服务器和从服务器是否运作正常。</span><br></pre></td></tr></table></figure>

<p>2.提醒（Notification）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">当被监控的某个 <span class="title class_">Redis</span> 服务器出现问题时， <span class="title class_">Sentinel</span> 可以通过 <span class="variable constant_">API</span> 向管理员或者其他应用程序发送通知。</span><br></pre></td></tr></table></figure>

<p>3.<font style="color:#F5222D;">自动故障迁移（Automatic failover）</font>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">当一个主服务器不能正常工作时， <span class="title class_">Sentinel</span> 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器</span><br></pre></td></tr></table></figure>

<p>架构图：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1610877929723-a1dfc439-0ef4-4327-971d-cec37e372e9a.png"></p>
<h1 id="7-3-目录规划"><a href="#7-3-目录规划" class="headerlink" title="7.3 目录规划"></a>7.3 目录规划</h1><table>
<thead>
<tr>
<th>**角色 **</th>
<th><strong>IP</strong></th>
<th><strong>端口</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Master</td>
<td>10.0.0.51</td>
<td>6379</td>
</tr>
<tr>
<td>Sentinel-01</td>
<td></td>
<td>26379</td>
</tr>
<tr>
<td>slave01</td>
<td>10.0.0.52</td>
<td>6379</td>
</tr>
<tr>
<td>Sentinel-02</td>
<td></td>
<td>26379</td>
</tr>
<tr>
<td>slave02</td>
<td>10.0.0.53</td>
<td>26379</td>
</tr>
<tr>
<td>Sentinel-03</td>
<td></td>
<td>26379</td>
</tr>
</tbody></table>
<h1 id="7-4-安装配置命令"><a href="#7-4-安装配置命令" class="headerlink" title="7.4 安装配置命令"></a>7.4 安装配置命令</h1><p>哨兵是基于主从复制，所以需要先部署好主从复制</p>
<p>手工操作步骤如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>先配置和创建好 <span class="number">1</span> 台服务器的节点和哨兵</span><br><span class="line"><span class="number">2.</span>使用 rsync 传输到另外 <span class="number">2</span> 台机器</span><br><span class="line"><span class="number">3.</span>修改另外两台机器的 <span class="variable constant_">IP</span> 地址</span><br><span class="line">	<span class="attr">ps</span>: 建议使用 ansible 剧本批量部署</span><br></pre></td></tr></table></figure>

<h3 id="7-4-1-db01-命令"><a href="#7-4-1-db01-命令" class="headerlink" title="7.4.1 db01 命令"></a>7.4.1 db01 命令</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/redis_cluster/redis_26379</span><br><span class="line">mkdir -p /opt/redis_cluster/redis_26379/&#123;conf,pid,logs&#125;</span><br><span class="line"></span><br><span class="line">cat &gt; <span class="regexp">/opt/</span>redis_cluster/redis_26379/conf/redis_26379.<span class="property">conf</span>&lt;&lt;<span class="variable constant_">EOF</span></span><br><span class="line">bind <span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile /opt/redis_cluster/redis_26379/logs/redis_26379.<span class="property">log</span></span><br><span class="line">dir /data/redis_cluster/redis_26379</span><br><span class="line">sentinel monitor mymaster <span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">3000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">1800</span></span><br><span class="line"><span class="variable constant_">EOF</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-2-db02-命令"><a href="#7-4-2-db02-命令" class="headerlink" title="7.4.2 db02 命令"></a>7.4.2 db02 命令</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/redis_cluster/redis_26379</span><br><span class="line">mkdir -p /opt/redis_cluster/redis_26379/&#123;conf,pid,logs&#125;</span><br><span class="line"></span><br><span class="line">cat &gt; <span class="regexp">/opt/</span>redis_cluster/redis_26379/conf/redis_26379.<span class="property">conf</span>&lt;&lt;<span class="variable constant_">EOF</span></span><br><span class="line">bind <span class="number">10.0</span><span class="number">.0</span><span class="number">.52</span></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile /opt/redis_cluster/redis_26379/logs/redis_26379.<span class="property">log</span></span><br><span class="line">dir /data/redis_cluster/redis_26379</span><br><span class="line">sentinel monitor mymaster <span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">3000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">1800</span></span><br><span class="line"><span class="variable constant_">EOF</span></span><br></pre></td></tr></table></figure>



<h3 id="7-4-3-db03-命令"><a href="#7-4-3-db03-命令" class="headerlink" title="7.4.3 db03 命令"></a>7.4.3 db03 命令</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/redis_cluster/redis_26379</span><br><span class="line">mkdir -p /opt/redis_cluster/redis_26379/&#123;conf,pid,logs&#125;</span><br><span class="line">cat &gt; <span class="regexp">/opt/</span>redis_cluster/redis_26379/conf/redis_26379.<span class="property">conf</span>&lt;&lt;<span class="variable constant_">EOF</span></span><br><span class="line">bind <span class="number">10.0</span><span class="number">.0</span><span class="number">.53</span></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile /opt/redis_cluster/redis_26379/logs/redis_26379.<span class="property">log</span></span><br><span class="line">dir /data/redis_cluster/redis_26379</span><br><span class="line">sentinel monitor mymaster <span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">3000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">1800</span></span><br><span class="line"><span class="variable constant_">EOF</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-4-配置文件解释"><a href="#7-4-4-配置文件解释" class="headerlink" title="7.4.4 配置文件解释"></a>7.4.4 配置文件解释</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster <span class="number">10.0</span><span class="number">.0</span><span class="number">.51</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">#mymaster 主节点别名 主节点 ip 和端口，判断主节点失败，两个 sentinel 节点同意</span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">3000</span></span><br><span class="line">#选项指定了 <span class="title class_">Sentinel</span> 认为服务器已经断线所需的毫秒数。</span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">#向新的主节点发起复制操作的从节点个数，<span class="number">1</span> 轮询发起复制</span><br><span class="line">sentinel failover-timeout mymaster <span class="number">18000</span></span><br><span class="line">#故障转移超时时间</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1610878275263-d98266eb-1c71-447f-a62b-b4355e9c0e2a.png"></p>
<h3 id="7-4-5-db02-x2F-db03-命令"><a href="#7-4-5-db02-x2F-db03-命令" class="headerlink" title="7.4.5 db02&#x2F;db03 命令"></a>7.4.5 db02&#x2F;db03 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-db01</span><br><span class="line">rsync -avz /opt/* db02:/opt/</span><br><span class="line">rsync -avz /opt/* db03:/opt/</span><br><span class="line"></span><br><span class="line">-db02</span><br><span class="line"><span class="built_in">mkdir</span> -p /data/redis_cluster/redis_26379</span><br><span class="line"><span class="built_in">cd</span> /opt/redis_cluster/redis</span><br><span class="line">make install</span><br><span class="line">sed -i <span class="string">&#x27;s#bind 10.0.0.51#bind 10.0.0.52#g&#x27;</span> /opt/redis_cluster/redis_6379/conf/redis_6379.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#bind 10.0.0.51#bind 10.0.0.52#g&#x27;</span> /opt/redis_cluster/redis_26379/conf/redis_26379.conf</span><br><span class="line"></span><br><span class="line">-db03</span><br><span class="line"><span class="built_in">mkdir</span> -p /data/redis_cluster/redis_26379</span><br><span class="line"><span class="built_in">cd</span> /opt/redis_cluster/redis</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s#bind 10.0.0.51#bind 10.0.0.53#g&#x27;</span> /opt/redis_cluster/redis_6379/conf/redis_6379.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#bind 10.0.0.51#bind 10.0.0.53#g&#x27;</span> /opt/redis_cluster/redis_26379/conf/redis_26379.conf</span><br></pre></td></tr></table></figure>



<h3 id="7-4-6-配置主从关系"><a href="#7-4-6-配置主从关系" class="headerlink" title="7.4.6 配置主从关系"></a>7.4.6 配置主从关系</h3><p>db02 和 db03</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server /opt/redis_cluster/redis_6379/conf/redis_6379.conf</span><br><span class="line">redis-cli slaveof 10.0.0.51 6379</span><br><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>



<h3 id="7-4-7-启动哨兵"><a href="#7-4-7-启动哨兵" class="headerlink" title="7.4.7 启动哨兵"></a>7.4.7 启动哨兵</h3><p>3 台都操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-sentinel /opt/redis_cluster/redis_26379/conf/redis_26379.conf</span><br></pre></td></tr></table></figure>

<h1 id="7-5-配置文件的变化"><a href="#7-5-配置文件的变化" class="headerlink" title="7.5 配置文件的变化"></a>7.5 配置文件的变化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当所有节点启动后,配置文件的内容发生了变化,体现在三个方面:</span><br><span class="line">1)Sentinel 节点自动发现了从节点,其余 Sentinel 节点</span><br><span class="line">2)去掉了默认配置,例如 parallel-syncs failover-timeout 参数</span><br><span class="line">3)添加了配置纪元相关参数</span><br></pre></td></tr></table></figure>

<p>查看配置文件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@db01 ~]<span class="comment"># tail -6 /opt/redis_cluster/redis_26379/conf/redis_26379.conf</span></span><br><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">sentinel known-slave mymaster 10.0.0.52 6379</span><br><span class="line">sentinel known-slave mymaster 10.0.0.53 6379</span><br><span class="line">sentinel known-sentinel mymaster 10.0.0.53 26379 7794fbbb9dfb62f4d2d7f06ddef06bacb62e4c97</span><br><span class="line">sentinel known-sentinel mymaster 10.0.0.52 26379 17bfab23bc53a531571790b9b31558dddeaeca40</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure>

<h1 id="7-6-哨兵常用操作-API"><a href="#7-6-哨兵常用操作-API" class="headerlink" title="7.6 哨兵常用操作 API"></a>7.6 哨兵常用操作 API</h1><p>登陆命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@db01 ~]<span class="comment"># redis-cli -h db01 -p 26379</span></span><br></pre></td></tr></table></figure>

<p>Sentinel 节点是一个特殊的 Redis 节点,他们有自己专属的 API</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Info Sentinel</span><br><span class="line">Sentinel masters</span><br><span class="line">Sentinel master &lt;master name&gt;</span><br><span class="line">Sentinel slaves &lt;master name&gt;</span><br><span class="line">Sentinel sentinels &lt;master name&gt;</span><br><span class="line">Sentinel get-master-addr-by-name &lt;master name&gt;</span><br><span class="line">Sentinel failover &lt;master name&gt;</span><br><span class="line">Sentinel flushconfig</span><br></pre></td></tr></table></figure>

<h1 id="7-7-模拟故障转移"><a href="#7-7-模拟故障转移" class="headerlink" title="7.7 模拟故障转移"></a>7.7 模拟故障转移</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/1581532/1610878608305-2435777b-43db-456e-91bb-e1a8ea97033c.png"></p>
<ul>
<li>停掉其中 1 个节点，然后观察其他节点的日志变化 故障转移后配置文件变化</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Redis Sentinel 存在多个从节点时,如果想将指定的从节点晋升为主节点,可以将其他从节点的 slavepriority 配置为 0,但是需要注意 failover 后,将 slave-priority 调回原值.</span><br><span class="line"></span><br><span class="line">1.查询命令:CONFIG GET slave-priority</span><br><span class="line">2.设置命令:CONFIG SET slave-priority 0</span><br><span class="line">3.主动切换:sentinel failover mymaster</span><br></pre></td></tr></table></figure>

<p>操作过程： db02&#x2F;db03 操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h db02 -p 6379 CONFIG SET slave-priority 0</span><br><span class="line">redis-cli -h db03 -p 6379 CONFIG SET slave-priority 0</span><br></pre></td></tr></table></figure>

<p>db01 操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h db01 -p 26379 Sentinel failover mymaster</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的持久化机制：RDB和AOF</title>
    <url>/2024/11/06/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%9ARDB%E5%92%8CAOF/</url>
    <content><![CDATA[<p><font style="background:#F8CED3;color:#70000D">Redis</font> <font style="background:#C0DDFC;color:#00346B">持久化</font> <font style="background:#DBF1B7;color:#2A4200">RDB</font> <font style="background:#C0CAFC;color:#101E60">AOF</font></p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，如下所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1595947486480-a9da248e-7b33-49f1-a2e1-34f6860258ee.png"></p>
<p><strong>这样做有什么问题呢？</strong></p>
<p>存储在内存当中的数据，只要服务器关机(各种原因引起的)，内存中的数据就会消失了，不仅服务器关机会造成数据消失，Redis服务器守护进程退出，内存中的数据也一样会消失。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1595947587065-79abeaa4-c341-40dd-80b1-327e6274e9cc.png"></p>
<p>对于只把Redis当缓存来用的项目来说，数据消失或许问题不大，重新从数据源把数据加载进来就可以了，但如果直接把用户提交的业务数据存储在Redis当中，把Redis作为数据库来使用，在其放存储重要业务数据，那么Redis的内存数据丢失所造成的影响也许是毁灭性。</p>
<p>为了避免内存中数据丢失，Redis提供了对持久化的支持，可以选择不同的方式将数据从内存中保存到硬盘当中，使数据可以持久化保存。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1595947635480-edd0424f-a715-4fbe-b098-6e0b2207a81b.png"></p>
<p>Redis提供了RDB和AOF两种不同的数据持久化方式。</p>
<hr>
<span id="more"></span>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p>
<h3 id="开启RDB持久化方式"><a href="#开启RDB持久化方式" class="headerlink" title="开启RDB持久化方式"></a>开启RDB持久化方式</h3><p>开启RDB持久化方式很简单，客户端可以通过向Redis服务器发送save或bgsave命令让服务器生成rdb文件，或者通过服务器配置文件指定触发RDB条件。</p>
<h4 id="1-save命令"><a href="#1-save命令" class="headerlink" title="1. save命令"></a>1. save命令</h4><p>save命令是一个同步操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同步数据到磁盘上</span></span><br><span class="line">&gt; save</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1595947995230-b9be3099-e153-4589-85eb-5f0dad21b53a.png"></p>
<p>当客户端向服务器发送save命令请求进行持久化时，服务器会阻塞save命令之后的其他客户端的请求，直到数据同步完成。</p>
<p>如果数据量太大，同步数据会执行很久，而这期间Redis服务器也无法接收其他请求，所以，最好不要在生产环境使用save命令。</p>
<h4 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2. bgsave"></a>2. bgsave</h4><p>与save命令不同，bgsave命令是一个异步操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 异步保存数据集到磁盘上</span></span><br><span class="line">&gt; bgsave</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1595947852470-eaba962f-4ff1-47c2-b2cb-56336de93b9d.png"></p>
<p>当客户端发服务发出bgsave命令时，Redis服务器主进程会forks一个子进程来数据同步问题，在将数据保存到rdb文件之后，子进程会退出。</p>
<p>所以，与save命令相比，Redis服务器在处理bgsave采用子线程进行IO写入，而主进程仍然可以接收其他请求，但forks子进程是同步的，所以forks子进程时，一样不能接收其他请求，这意味着，如果forks一个子进程花费的时间太久(一般是很快的)，bgsave命令仍然有阻塞其他客户的请求的情况发生。</p>
<h4 id="3-服务器配置自动触发"><a href="#3-服务器配置自动触发" class="headerlink" title="3. 服务器配置自动触发"></a>3. 服务器配置自动触发</h4><p>除了通过客户端发送命令外，还有一种方式，就是在Redis配置文件中的save指定到达触发RDB持久化的条件，比如【多少秒内至少达到多少写操作】就开启RDB数据同步。</p>
<p>例如可以在配置文件redis.conf指定如下的选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 900s内至少达到一条写命令</span><br><span class="line">save 900 1</span><br><span class="line"># 300s内至少达至10条写命令</span><br><span class="line">save 300 10</span><br><span class="line"># 60s内至少达到10000条写命令</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>之后在启动服务器时加载配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动服务器加载配置文件</span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

<p>这种通过服务器配置文件触发RDB的方式，与bgsave命令类似，达到触发条件时，会forks一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。</p>
<h3 id="rdb文件"><a href="#rdb文件" class="headerlink" title="rdb文件"></a>rdb文件</h3><p>前面介绍了三种让服务器生成rdb文件的方式，无论是由主进程生成还是子进程来生成，其过程如下：</p>
<ul>
<li>生成临时rdb文件，并写入数据。</li>
<li>完成数据写入，用临时文代替代正式rdb文件。</li>
<li>删除原来的db文件。</li>
</ul>
<p>RDB默认生成的文件名为dump.rdb，当然，可以通过配置文件进行更加详细配置，比如在单机下启动多个redis服务器进程时，可以通过端口号配置不同的rdb名称，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 是否压缩rdb文件</span><br><span class="line">rdbcompression yes</span><br><span class="line"># rdb文件的名称</span><br><span class="line">dbfilename redis-6379.rdb</span><br><span class="line"># rdb文件保存目录</span><br><span class="line">dir ~/redis/</span><br></pre></td></tr></table></figure>

<p><strong>RDB的几个优点</strong></p>
<ul>
<li>与AOF方式相比，通过rdb文件恢复数据比较快。</li>
<li>rdb文件非常紧凑，适合于数据备份。</li>
<li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li>
</ul>
<p><strong>RDB的几个缺点</strong></p>
<ul>
<li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li>
<li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li>
<li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li>
</ul>
<hr>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Redis的另外一个持久化方式：AOF(Append-only file)。</p>
<p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1595948362986-82adb4d6-9656-43a4-be66-0a22284241af.png"></p>
<p><strong>开启AOF持久化方式</strong></p>
<p>Redis默认不开启AOF持久化方式，可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启aof机制</span><br><span class="line">appendonly yes</span><br><span class="line"># aof文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no</span><br><span class="line">appendfsync always</span><br><span class="line"># 默认不重写aof文件</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"># 保存目录</span><br><span class="line">dir ~/redis/</span><br></pre></td></tr></table></figure>

<h3 id="三种写入策略"><a href="#三种写入策略" class="headerlink" title="三种写入策略"></a>三种写入策略</h3><p>在上面的配置文件中，可以通过appendfsync选项指定写入策略,有三个选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfsync always</span><br><span class="line"># appendfsync everysec</span><br><span class="line"># appendfsync no</span><br></pre></td></tr></table></figure>

<h4 id="1-always"><a href="#1-always" class="headerlink" title="1. always"></a>1. always</h4><p>客户端的每一个写操作都保存到aof文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。</p>
<h4 id="2-everysec"><a href="#2-everysec" class="headerlink" title="2. everysec"></a>2. everysec</h4><p>appendfsync的默认写入策略，每秒写入一次aof文件，因此，最多可能会丢失1s的数据。</p>
<h4 id="3-no"><a href="#3-no" class="headerlink" title="3. no"></a>3. no</h4><p>Redis服务器不负责写入aof，而是交由操作系统来处理什么时候写入aof文件。更快，但也是最不安全的选择，不推荐使用。</p>
<h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候，aof保存每一次命令到aof文件中，aof文件会变得非常大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">incr num 1</span><br><span class="line">incr num 2</span><br><span class="line">incr num 3</span><br><span class="line">incr num 4</span><br><span class="line">incr num 5</span><br><span class="line">incr num 6</span><br><span class="line">...</span><br><span class="line">incr num 100000</span><br></pre></td></tr></table></figure>

<p>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决这个问题，Redis支持aof文件重写，通过重写aof，可以生成一个恢复当前数据的最少命令集，比如上面的例子中那么多条命令，可以重写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set num 100000</span><br></pre></td></tr></table></figure>

<p>aof文件是一个二进制文件，并不是像上面的例子一样，直接保存每个命令，而使用Redis自己的格式，上面只是方便演示。<font style="color:#000000;"></font></p>
<h3 id="两种重写方式"><a href="#两种重写方式" class="headerlink" title="两种重写方式"></a>两种重写方式</h3><p>通过在redis.conf配置文件中的选项 <code>no-appendfsync-on-rewrite</code> 可以设置是否开启重写，这种方式会在每次fsync时都重写，影响服务器性以，因此默认值为no，不推荐使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认不重写aof文件</span><br><span class="line">no-appendfsync-on-rewrite no</span><br></pre></td></tr></table></figure>

<p>客户端向服务器发送bgrewriteaof命令，也可以让服务器进行AOF重写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 让服务器异步重写追加aof文件命令</span><br><span class="line">&gt; bgrewriteaof</span><br></pre></td></tr></table></figure>

<p>AOF重写方式也是异步操作，即如果要写入aof文件，则Redis主进程会forks一个子进程来处理，如下所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1595948490006-2c4231ef-ac2c-41a5-ad4c-db3f3425e157.png"></p>
<p>重写aof文件的好处</p>
<ul>
<li>压缩aof文件，减少磁盘占用量。</li>
<li>将aof的命令压缩为最小命令集，加快了数据恢复的速度。</li>
</ul>
<p><font style="color:#000000;">Redis 配置文件中有两个对应的参数是来决定重写机制的触发时机的。</font><font style="color:#000000;"></font></p>
<p><strong><font style="color:#000000;">auto-aof-rewrite-percentage：</font></strong><font style="color:#000000;">AOF 文件</font><font style="color:#000000;">距离上次文件增长超过多少百分比</font></p>
<p><strong><font style="color:#000000;">auto-aof-rewrite-min-size：</font></strong><font style="color:#000000;">AOF 文件体积最小多大以上触发</font><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">满足所设置的条件时，会自动触发 AOF 重写，此时 Redis 会扫描整个实例的数据，重新生成一个 AOF 文件来达到瘦身的效果。</font></p>
<h3 id="AOF文件损坏的恢复"><a href="#AOF文件损坏的恢复" class="headerlink" title="AOF文件损坏的恢复"></a>AOF文件损坏的恢复</h3><p>在写入aof日志文件时，如果Redis服务器宕机，则aof日志文件文件会出格式错误，在重启Redis服务器时，Redis服务器会拒绝载入这个aof文件，可以通过以下步骤修复aof并恢复数据。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1604539358891-aca7e579-9fe2-484e-aaee-586850e74fb7.png"></p>
<p>和 RBD 不同的是，Redis 中是通过创建一个不带网络连接的伪客户端来进行实现的。为什么要创建伪客户端呢？AOF 文件中的数据格式，都是由命令组成的。通过客户端直接执行每条命令就可以将数据进行恢复。</p>
<p>1、备份现在aof文件，以防万一。</p>
<p>2、使用redis-check-aof命令修复aof文件，该命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修复aof日志文件</span></span><br><span class="line">$ redis-check-aof -fix file.aof</span><br></pre></td></tr></table></figure>

<p>3、重启Redis服务器，加载已经修复的aof文件，恢复数据。</p>
<p>:::tips<br>注意的是，如果服务器开启了 AOF 持久化功能，会优先使用 AOF 文件来进行恢复。只有在 AOF 关闭状态下，服务器才会使用 RDB 文件来进行还原。</p>
<p>:::</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1604539359112-6b1a2cf0-6d11-4895-969d-42c400a8df75.png"></p>
<h3 id="AOF的优点"><a href="#AOF的优点" class="headerlink" title="AOF的优点"></a>AOF的优点</h3><ul>
<li>AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li>
</ul>
<h3 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h3><ul>
<li>AOF方式生成的日志文件太大，即使通过AOF重写，文件体积仍然很大。</li>
<li>恢复数据的速度比RDB慢。</li>
</ul>
<hr>
<h2 id="RDB和AOF对比选择"><a href="#RDB和AOF对比选择" class="headerlink" title="RDB和AOF对比选择"></a>RDB和AOF对比选择</h2><h3 id="1、RDB-优点与缺点"><a href="#1、RDB-优点与缺点" class="headerlink" title="1、RDB 优点与缺点"></a>1、RDB 优点与缺点</h3><h4 id="（1）优点"><a href="#（1）优点" class="headerlink" title="（1）优点"></a>（1）优点</h4><p><u>文件体积小</u>：RDB 的文件内容是二进制格式，因此体积比实例内存小。<u>恢复速度快</u>：当 Redis 实例恢复时，加载 RDB 文件速度很快，能在很短时间内迅速恢复数据。</p>
<h4 id="（2）缺点"><a href="#（2）缺点" class="headerlink" title="（2）缺点"></a>（2）缺点</h4><p><u>数据缺失</u>：RDB 保存的是某一时刻的数据，当 Redis 实例某一时刻异常时，会导致数据丢失。<u>消耗资源</u>：RDB 文件的生成会消耗大量的 CPU 和内存资源，有一定代价。</p>
<h3 id="2、AOF-优点与缺点"><a href="#2、AOF-优点与缺点" class="headerlink" title="2、AOF 优点与缺点"></a>2、AOF 优点与缺点</h3><h4 id="（1）优点-1"><a href="#（1）优点-1" class="headerlink" title="（1）优点"></a>（1）优点</h4><p><u>数据更完整</u>：AOF 中是及时写入的方式，数据保存更完整。恢复时降低数据的损失率<u>易读性强</u>：AOF 中保存的数据格式是客户端的写入命令，可读性性强。</p>
<h4 id="（2）缺点-1"><a href="#（2）缺点-1" class="headerlink" title="（2）缺点"></a>（2）缺点</h4><p><u>文件体积大</u>：AOF 中存储客户端所有的写命令，未经压缩，随着命令的写入，文件会越来越大。<u>增加磁盘IO</u>：AOF 文件刷盘如果采用每秒刷一次的方式会导致磁盘IO升高，影响性能。</p>
<p>通过上面的介绍，了解了RDB与AOF各自的优点与缺点，到底要如何选择呢？</p>
<p>通过下面的表，可以从几个方面对比一下RDB与AOF，在应用时，要根本自己的实际需求，选择RDB或者AOF，其实，如果想要数据足够安全，可以两种方式都开启，但两种持久化方式同时进行IO操作，会严重影响服务器性能，因此有时候不得不做出选择。</p>
<table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>RDB</strong></th>
<th><strong>AOF</strong></th>
</tr>
</thead>
<tbody><tr>
<td>启动优化级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>由策略决定</td>
</tr>
<tr>
<td>数据安全性</td>
<td>会丢数据</td>
<td>由策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody></table>
<p>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</p>
<h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>既然 RDB 与 AOF 持久化都存在各自的缺点，那么有没有一种更好的持久化方式？</p>
<p>那就是混合持久化。其实就是 RDB 与 AOF 的混合模式，这是 Redis4 之后新增的。</p>
<p>1、持久化方式</p>
<p>混合持久化是通过 aof-use-rdb-preamble 参数来开启的。它的操作方式是这样的，在写入的时候先把数据以 RDB 的形式写入文件的开头，再将后续的写命令以 AOF 的格式追加到文件中。这样既能保证数据恢复时的速度，同时又能减少数据丢失的风险。</p>
<p>2、文件恢复</p>
<p>那么混合持久化中是如何来进行数据恢复的呢？在 Redis 重启时，先加载 RDB 的内容，然后再重放增量 AOF 格式命令。这样就避免了 AOF 持久化时的全量加载，从而使加载速率得到大幅提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><ul>
<li>将某一时刻的数据以二进制形式写入到磁盘里，服务重启时检测到对应文件自动加载进行数据恢复。</li>
<li>有手动触发和自动触发两种机制。</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><ul>
<li>以文件追加的方式写入客户端执行的写命令。</li>
<li>数据恢复时，通过创建伪客户端的方式执行命令，直到恢复完成。</li>
</ul>
<h3 id="混合持久化-1"><a href="#混合持久化-1" class="headerlink" title="混合持久化"></a>混合持久化</h3><ul>
<li>在写入的时候先把数据以 RDB 的形式写入文件的开头，再将后续的写命令以 AOF 的格式追加到文件中。</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的VM机制</title>
    <url>/2024/11/06/Redis%E7%9A%84VM%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><font style="background:#F8CED3;color:#70000D">Redis</font></p>
<h3 id="Redis-之-VM-机制"><a href="#Redis-之-VM-机制" class="headerlink" title="Redis 之 VM 机制"></a>Redis 之 VM 机制</h3><p><font style="color:black;">Redis 的 VM (虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过 VM 功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。Redis 提高数据库容量的办法有两种：一种是可以将数据分割到多个 Redis Server上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。</font><strong><font style="color:rgb(53, 179, 120);">「需要特别注意的是 Redis 并没有使用 OS 提供的 Swap，而是自己实现。」</font></strong></p>
<p><font style="color:black;">Redis 为了保证查找的速度，只会将 value 交换出去，而在内存中保留所有的 Key。所以它非常适合 Key 很小，Value 很大的存储结构。如果 Key 很大，value 很小，那么vm可能还是无法满足需求。</font></p>
<span id="more"></span>
<h3 id="VM-相关配置"><a href="#VM-相关配置" class="headerlink" title="VM 相关配置"></a>VM 相关配置</h3><p><font style="color:black;">通过在 redis 的 redis.conf 文件里，设置 VM 的相关参数来实现数据在内存和磁盘之间 换入和 换出操作。相关配置如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开启vm功能</span><br><span class="line">vm-enabled yes</span><br><span class="line">#交换出来的value保存的文件路径</span><br><span class="line">vm-swap-file /tmp/redis.swap</span><br><span class="line">#设置当内存消耗达到上限时开始将value交换出来</span><br><span class="line">vm-max-memory 1000000</span><br><span class="line">#设置单个页面的大小，单位是字节</span><br><span class="line">vm-page-size 32</span><br><span class="line">#设置最多能交换保存多少个页到磁盘</span><br><span class="line">vm-pages 13417728</span><br><span class="line">#设置完成交换动作的工作线程数，设置为0表示不使用工作线程而使用主线程,这会以阻塞的方式来运行。建议设置成CPU核个数</span><br><span class="line">vm-max-threads 4</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">redis 规定同一个数据页面只能保存一个对象，但一个对象可以保存在多个数据页面中。在 redis 使用的内存没超过 vm-max-memory 时，是不会交换任何 value 到磁盘上的。当超过最大内存限制后，redis 会选择较老的对象(如果两个对象一样老会优先交换比较大的对象)将它从内存中移除，这样会更加节约内存。</font></p>
<p>对于 Redis 来说，一个数据页面只会保存一个对象，也就是一个 Value 值，所以应该将 vm-page-size 设置成大多数 value 可以保存进去。如果设置太小，一个 value 对象就会占用几个数据页面，如果设置太大，就会造成页面空闲空间浪费。</p>
<h3 id="VM-的工作机制"><a href="#VM-的工作机制" class="headerlink" title="VM 的工作机制"></a>VM 的工作机制</h3><p><font style="color:black;">redis 的 VM 的工作机制分为两种：一种是 vm-max-threads&#x3D;0，一种是 vm-max-threads &gt; 0。</font></p>
<p><strong><font style="color:rgb(53, 179, 120);">「第一种：vm-max-threads &#x3D; 0」</font></strong></p>
<ul>
<li><font style="color:rgb(53, 179, 120);">数据换出：</font><font style="color:black;">主线程定期检查使用的内存大小，如果发现内存超出最大上限，会直接以阻塞的方式，将选中的对象 换出 到磁盘上(保存到文件中)，并释放对象占用的内存，此过程会一直重复直到下面条件满足任意一条才结束：</font><ol>
<li><font style="color:rgb(1, 1, 1);">内存使用降到最大限制以下。</font></li>
<li><font style="color:rgb(1, 1, 1);">设置的交换文件数量达到上限。</font></li>
<li><font style="color:rgb(1, 1, 1);">几乎全部的对象都被交换到磁盘了。</font></li>
</ol>
</li>
<li><font style="color:rgb(53, 179, 120);">数据换入：</font><font style="color:black;">当有 client 请求 key 对应的 value 已被换出到磁盘中时，主线程会以阻塞的方式从换出文件中加载对应的 value 对象，加载时此时会阻塞所有 client，然后再处理 client 的请求。</font><strong><font style="color:rgb(53, 179, 120);">「这种方式会阻塞所有的 client。」</font></strong></li>
</ul>
<p><strong><font style="color:rgb(53, 179, 120);">「第二种：vm-max-threads &gt; 0」</font></strong></p>
<ul>
<li><font style="color:rgb(53, 179, 120);">数据换出：</font><font style="color:rgb(1, 1, 1);">当主线程检测到使用内存超过最大上限，会将选中的要交换的数据放到一个队列中交由工作线程后台处理，主线程会继续处理 client 请求。</font></li>
<li><font style="color:rgb(53, 179, 120);">数据换入：</font><font style="color:rgb(1, 1, 1);">当有 client 请求 key 的对应的 value 已被换出到磁盘中时，主线程先阻塞当前 client，然后将加载对象的信息放到一个队列中，让工作线程去加载，此时进主线程继续处理其他 client 请求。加载完毕后工作线程通知主线程，主线程再执行被阻塞的 client 的命令。</font><strong><font style="color:rgb(53, 179, 120);">「这种方式只阻塞单个 client。」</font></strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><font style="color:black;">Redis 直接自己构建了 VM 机制 ，不会像一般的系统会调用系统函数处理，会浪费一定的时间去 移动 和 请求，而 Redis 不存在。这也是 Redis 能够那么快的一个原因之一了。</font></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis配置文件详解</title>
    <url>/2024/11/06/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Redis服务配置"><a href="#Redis服务配置" class="headerlink" title="Redis服务配置"></a>Redis服务配置</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 是否以守护进程启动 默认：no</span><br><span class="line">daemonize no</span><br><span class="line"># 用于设置Redis绑定的网络接口（网卡）。如果不配置bind，默认情况下Redis监听所有可用的网卡，redis只接受来自绑定网络接口的请求。</span><br><span class="line"># Redis的配置文件中一般默认有bind 127.0.0.1，只允许本地连接，如果想要被远程访问注释掉bind配置或者bind外网ip即可。</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"># 是否开启保护模式 默认：yes，是否有效会被bind和requirepass配置影响</span><br><span class="line">## 当protected-mode为yes</span><br><span class="line">### 注释bind和requirepass，redis的保护模式生效，只能通过本地连接</span><br><span class="line">### 只注释bind，配置requirepass，redis的保护模式失效，可以通过密码远程连接</span><br><span class="line">### 只注释requirepass，redis的保护模式失效，可以通过bind的ip无密码连接</span><br><span class="line">## 当protected-mode为no</span><br><span class="line">### 无论上面的哪种场景，客户端都可以根据 bind 及 requirepass 实际参数来连接到 redis</span><br><span class="line">protected-mode yes</span><br><span class="line"># redis服务端口 默认：6379</span><br><span class="line">port 6379</span><br><span class="line"># 客户端连接空闲时间单位秒，如果在指定时间内没有操作则会断开连接 默认：0（不超时）</span><br><span class="line">timeout 0</span><br><span class="line"># tcp心跳检测时间单位秒，对访问客户端的一种心跳检测，每个n秒检测一次 默认：0（不检测），建议设置成60</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"># 客户端最大连接数，设置redis同时可以与多少个客户端进行连接 默认：10000</span><br><span class="line">maxclients 10000</span><br><span class="line"># 日志级别配置 默认：notice</span><br><span class="line">## debug：能设置的最高的日志级别，打印所有信息，包括debug信息。</span><br><span class="line">## verbose：打印除了debug日志之外的所有日志。</span><br><span class="line">## notice：打印除了debug和verbose级别的所有日志。</span><br><span class="line">## warning：仅打印非常重要的信息。</span><br><span class="line">loglevel notice</span><br><span class="line"># 日志文件输出路径配置</span><br><span class="line">## 该路径默认为空。可以根据自己需要把日志文件输出到指定位置。</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"># 数据库数量配置 默认：16</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>

<h2 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h2><h3 id="RDB全量持久化配置（默认开启）"><a href="#RDB全量持久化配置（默认开启）" class="headerlink" title="RDB全量持久化配置（默认开启）"></a>RDB全量持久化配置（默认开启）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 持久化数据存储在本地的文件名称 默认：dump.rdb</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 持久化数据存储在本地的路径，默认：./（当前工作目录）</span><br><span class="line">dir /data</span><br><span class="line"></span><br><span class="line"># 用于设置RDB持久化的时间间隔和条件</span><br><span class="line">## 表示每900秒内有至少1个写操作就保存一次RDB文件</span><br><span class="line">save 900 1</span><br><span class="line">## 表示每300秒内有至少10个写操作就保存一次RDB文件</span><br><span class="line">save 300 10</span><br><span class="line">## 表示每10秒内有至少1000个写操作就保存一次RDB文件</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 当RDB持久化时出现错误无法继续时，是否阻塞客户端变更操作，错误可能因为磁盘已满/磁盘故障/OS级别异常等 默认：yes</span><br><span class="line">stop-writes-on-bgsave-error yes  </span><br><span class="line"># 是否启用RDB文件压缩，默认: yes，压缩往往意味着额外的cpu消耗，同时也意味这较小的文件尺寸以及较短的网络传输时间  </span><br><span class="line">rdbcompression yes  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AOF增量持久化配置"><a href="#AOF增量持久化配置" class="headerlink" title="AOF增量持久化配置"></a><font style="color:rgb(79, 79, 79);">AOF增量持久化配置</font></h3><p>可以简单的认为 AOF 就是日志文件，此文件只会记录“变更操作”(例如：set&#x2F;del 等)，如果 server 中持续的大量变更操作，将会导致 AOF 文件非常的庞大，意味着 server 失效后，数据恢复的过程将会很长；事实上，一条数据经过多次变更，将会产生多条 AOF 记录，其实只要保存当前的状态，历史的操作记录是可以抛弃的；因为 AOF 持久化模式还伴生了“AOF rewrite”。</p>
<p>优点：可以保持更高的数据完整性，如果设置追加file的时间是1s，如果redis发生故障，最多会丢失1s的数据；且如果日志写入不完整支持redis-check-aof来进行日志修复；AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）</p>
<p>缺点：AOF文件比RDB文件大，且恢复速度慢。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 是否开启AOF 默认：no</span><br><span class="line">appendonly yes  </span><br><span class="line"></span><br><span class="line"># 指定AOF文件名称  </span><br><span class="line">appendfilename appendonly.aof  </span><br><span class="line"></span><br><span class="line"># 用于设置AOF文件的同步策略 默认：everysec</span><br><span class="line">## 可以选择&quot;always&quot;、&quot;everysec&quot;或&quot;no&quot;。always表示每次写入都同步，everysec表示每秒同步一次，no表示由操作系统决定何时同步</span><br><span class="line">appendfsync everysec  </span><br><span class="line"></span><br><span class="line">#当同时执行主进程的写操作和子进程的重写操作时，两者都会操作磁盘，而重写往往会涉及到大量的磁盘操作，这样就会造成主进程在写aof文件的时候出现阻塞的情形。</span><br><span class="line">##如果该参数设置为no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题；</span><br><span class="line">##如果设置为yes，这就相当于将appendfsync设置为no，这说明并没有执行磁盘操作，只是写入了缓冲区。因此这样并不会造成阻塞（因为没有竞争磁盘），但是如果这个时候redis挂掉，就会丢失数据。丢失多少数据呢？在linux的操作系统的默认设置下，最多会丢失30s的数据。</span><br><span class="line">##如果应用系统无法忍受延迟，而可以容忍少量的数据丢失，则设置为yes；如果应用系统无法忍受数据丢失，则设置为no。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 用于设置自动AOF重写的阈值。当AOF文件的扩展比例超过该值时，Redis会自动执行重写操作。默认值为100，表示当AOF文件的大小是上一次重写后大小的一倍时触发重写。  </span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line"></span><br><span class="line"># 用于设置自动AOF重写的最小大小。只有在AOF文件的大小大于该值时，才会执行重写操作。默认值为64MB，建议512mb</span><br><span class="line">auto-aof-rewrite-min-size 64mb  </span><br><span class="line"></span><br><span class="line"># 用于设置在执行AOF文件重写时是否禁用同步。如果设置为yes，则在进行重写时不会进行同步操作，默认：no</span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line"># 用于设置在加载AOF文件时是否允许Redis忽略出现错误的命令。如果设置为&quot;yes&quot;，则忽略错误；如果设置为&quot;no&quot;，则不允许加载出现错误的AOF文件。默认：yes</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 用于设置AOF文件的开头是否包含RDB格式的部分。如果设置为&quot;yes&quot;，则在AOF文件的开头会先保存一份RDB格式的数据，这有助于加速数据加载。默认：no</span><br><span class="line">aof-use-rdb-preamble no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安全认证配置"><a href="#安全认证配置" class="headerlink" title="安全认证配置"></a>安全认证配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 连接密码配置 默认无密码</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure>

<h2 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主库的ip及端口 5.0以上使用replica的指令</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># 主库，如果设置密码，需要加主库的密码</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># 当从节点与主节点连接失败了。这是yes，则表示从节点继续应答客户端；设置no，所有连接到这台从节点的客户端，会提示正在与主节点进行同步</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 从节点只读。</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># 新的从节点或者从节点与主节点长期没有增量同步，需要全量同步</span><br><span class="line"># 使用磁盘模式，会在从节点上新建redis快照的文件（根据配置）</span><br><span class="line"># 使用socket方式，同步数据到从节点，不落地磁盘上，效率更高， 主节点可并行传输到多个从节点上。</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 从节点，配置x秒，向主节点ping一次。</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># 同时时间设置</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># 使用更少的宽带同步，但是会导致从节点数据延迟，建议不设置</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 当从节点与主节点断开后，主节点同步的数据会缓存到缓冲区；开启这个配置，设置大小</span><br><span class="line"># 如果不开启配置，则不缓存</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># 当从节点一直没起来，设置这个数据为了是否缓冲区，如果配置0，则永久不释放。</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># 选举权重，越小权重越大，设置0，不参与</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 副本同步会存在延迟，至少3个写操作，时间延迟小于等于10秒的副本，主节点就停止写入操作。这两个参数只要一个设置为0，就禁用该功能</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line">#</span><br><span class="line"># redis服务没有跟哨兵在同一个网络，比如：在容器里面跑，info replication查看到IP和端口，哨兵就有可能访问不到，这时候就需要，指定对外的IP和端口，提供给哨兵检测。</span><br><span class="line"># slave-announce-ip 5.5.5.5</span><br><span class="line"># slave-announce-port 1234</span><br></pre></td></tr></table></figure>

<h2 id="Redis-key过期监听配置"><a href="#Redis-key过期监听配置" class="headerlink" title="Redis key过期监听配置"></a><font style="color:rgb(79, 79, 79);">Redis key过期监听配置</font></h2><p><font style="color:rgb(77, 77, 77);">过期key事件监听可用于订单超时处理和已完成订单自动评价等功能，当给对应的key设置的过期时间到了会自动通知客户端，客户端将监听到的数据进行处理。</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># key过期监听 默认：&quot;&quot;（关闭），将notify-keyspace-events设置为Ex代表开启</span><br><span class="line">notify-keyspace-events Ex</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Redis内存淘汰策略"><a href="#Redis内存淘汰策略" class="headerlink" title="Redis内存淘汰策略"></a>Redis内存淘汰策略</h2><p>内存淘汰算法</p>
<p>noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键</p>
<p>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</p>
<p>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</p>
<p>allkeys-random：加入键的时候如果过限，从所有key随机删除</p>
<p>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</p>
<p>volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键</p>
<p>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</p>
<p>allkeys-lfu：从所有键中驱逐使用频率最少的键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将redis存储内存设置100mb的界限，当超过这个数值开始走淘汰策略</span><br><span class="line">maxmemory 100mb</span><br><span class="line"></span><br><span class="line"># 配置策略 默认：noeviction</span><br><span class="line">maxmemory-policy allkeys-lru</span><br><span class="line"></span><br><span class="line"># LRU、LFU和最小TTL算法不是精确算法，而是近似算法</span><br><span class="line">算法（为了节省内存），因此您可以根据速度或精确默认情况下，Redis将检查五个键并选择最近使用较少，可以使用以下命令更改样本大小</span><br><span class="line">配置指令。默认值为5会产生足够好的结果。10非常接近真正的LRU，但成本更高的CPU。3更快，但不是很准确。</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="LAZY-FREEING（惰性删除主要用于bigkey删除）"><a href="#LAZY-FREEING（惰性删除主要用于bigkey删除）" class="headerlink" title="LAZY FREEING（惰性删除主要用于bigkey删除）"></a>LAZY FREEING（惰性删除主要用于bigkey删除）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lazy free可以认为是惰性删除或延迟释放，针对bigkey也有很好的释放策略，有效的针对bigkey带来的性能问题</span><br><span class="line"># lazyfree-lazy-eviction 针对redis的超过了maxmeory，并设置了meory-prolicy情况下，在淘汰，释放使用lazy-free</span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line"># lazyfree-lazy-expire 针对redis设置ttl淘汰策略，达到过期后，是否使用lazy-free</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line"># lazyfree-lazy-server-del 是针对已经存在的key，会存在隐式的带来del操作，比如rename操作，就是先del操作。如果有bigkey，就可能会带来阻塞的情况</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line"># slave-lazy-flush 针对slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己的数据场景， 参数设置决定是否采用异常flush机制</span><br><span class="line">slave-lazy-flush no</span><br></pre></td></tr></table></figure>

<h2 id="lua-脚本"><a href="#lua-脚本" class="headerlink" title="lua 脚本"></a>lua 脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lua脚本执行最大的时间</span><br><span class="line"># lua脚本的好处①高效，在服务器上执行，节省了网络传输开销等，特别lua脚本，执行多个脚本，好处就体现出来了。</span><br><span class="line"># lua脚本的好处②原子性；一个业务需要多个指令完成，lua脚本比较好的选择</span><br><span class="line"># lua脚本的坏处：那就是如果你lua过于复杂，假如在里面取bigkey操作了，就会阻塞；执行时间过长；</span><br><span class="line">lua-time-limit 5000</span><br></pre></td></tr></table></figure>



<h2 id="redis-cluster-集群"><a href="#redis-cluster-集群" class="headerlink" title="redis cluster 集群"></a>redis cluster 集群</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># 是否开启集群</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># 集群配置文件名，这个文件不需要人为配置，集群会自动更新这个配置</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># 节点连接超时时间(毫秒)</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># 在master宕机后，所有slave节点都会申请成为master；当由于redis节点与master连接过久，数据过于陈旧了。可能不适合做为master</span><br><span class="line">#  通过过下公式可以来判断是否不适合</span><br><span class="line">#   (node-timeout * slave-validity-factor) + repl-ping-slave-period</span><br><span class="line">#  假设15秒超时 * 这个默认配置10 + 从节点配置ping一次时间</span><br><span class="line"># 15 * 10 + 10  = 160</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"># master的slave节点大于这个配置，则尝试把这个节点迁移到其他的master上。</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># 默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全</span><br><span class="line">部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而</span><br><span class="line">造成很长时间数据不一致</span><br><span class="line"># cluster-slave-no-failover no</span><br></pre></td></tr></table></figure>

<h2 id="慢记录-SLOW-LOG"><a href="#慢记录-SLOW-LOG" class="headerlink" title="慢记录 SLOW LOG"></a>慢记录 SLOW LOG</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 记录执行慢的指令，建议开启，这里单位是微妙</span><br><span class="line"># 1000000 这里就是1秒;10000 = 100毫秒 = 0.1秒</span><br><span class="line"># 设置0，强制记录所有，设置 &lt; 0 则不记录慢日志</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足</span><br><span class="line">够的内存就行。你可以通过 SLOWLOG RESET 来释放内存</span><br><span class="line"># Redis使用了一个列表来存储慢查询日志。Redis 使用了一个List 实现了一个先进先出的队列</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line"># 可通过slowlog get 数量 slowlog len | slowlog reset</span><br></pre></td></tr></table></figure>

<h2 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hash命令，个数及长度大于阈值就进行压缩，这里内部是为了节省空间</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line"># list指令，是否可以进行压缩 0：表示禁止列表压缩 1：表示内部节点压缩</span><br><span class="line"># 头部 -&gt; 节点 -&gt; 节点 ...&gt; 尾部；内部节点进行压缩</span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"># zset指令，个数及长度大于阈值就进行压缩，这里内部是为了节省空间</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># HyperLogLog 指令设置</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># 客户端输出缓冲区阈值设置，达到这些上限，客户端会断开连接</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"> </span><br><span class="line"># client-query-buffer-limit 1gb</span><br><span class="line"></span><br><span class="line"># proto-max-bulk-len 512mb</span><br><span class="line"></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"># lfu-log-factor 10</span><br><span class="line"># lfu-decay-time 1</span><br></pre></td></tr></table></figure>

<h2 id="碎片清理"><a href="#碎片清理" class="headerlink" title="碎片清理"></a>碎片清理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 为什么会有redis内存碎片？</span><br><span class="line"># Redis存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间或者频繁的进行修改 就会导致内存碎片</span><br><span class="line"># redis 内存碎片整理，默认是关闭，打开就开启内存碎片整理；要么就直接重启</span><br><span class="line"># 要么设置这个地方</span><br><span class="line"># activedefrag yes</span><br><span class="line"></span><br><span class="line"># 内存碎片大于100m的时候就进行清理</span><br><span class="line"># 内存碎片：used_memory_rss - used_memory</span><br><span class="line"># active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line"># 内存碎片率计算：used_memory_rss(从操作角度来看，给redis分配的空间)/used_memory (redis使用的内容) ; 如果这里超过1.5，内存碎片就比较严重 </span><br><span class="line"># active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="line"># active-defrag-threshold-upper 100</span><br><span class="line"></span><br><span class="line"># 内存碎片清理占用cpu比例不读与25</span><br><span class="line"># active-defrag-cycle-min 25</span><br><span class="line"></span><br><span class="line"># 内存碎片清理占用cpu比例不读与75</span><br><span class="line"># active-defrag-cycle-max 75</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis通信协议-RESP</title>
    <url>/2024/11/06/Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-RESP/</url>
    <content><![CDATA[<p><font style="background:#F8CED3;color:#70000D">Redis</font> <font style="background:#DBF1B7;color:#2A4200">通信协议</font> <font style="background:#C0DDFC;color:#00346B">RESP</font></p>
<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>Redis 的通信协议是 Redis Serialization Protocol，翻译为 Redis 序列化协议，简称 RESP。它具有如下特征：</p>
<ul>
<li><font style="color:#4A4A4A;">在 TCP 层</font></li>
<li><font style="color:#4A4A4A;">是二进制安全的</font></li>
<li><font style="color:#4A4A4A;">基于请求 - 响应模式</font></li>
<li><font style="color:#4A4A4A;">简单、易懂（人都可以看懂）</font></li>
</ul>
<p>RESP 所描述的是 Redis 客户端 - 服务端的交互方式。</p>
<span id="more"></span>
<h1 id="2、RESP-描述"><a href="#2、RESP-描述" class="headerlink" title="2、RESP 描述"></a>2、RESP 描述</h1><p>Redis 协议将传输的结构数据分为 5 种类型，单元结束时统一加上回车换行符号 <code>\r\n</code>。</p>
<ul>
<li><font style="color:#4A4A4A;">单行字符串，第一个字节为 </font><code>&lt;font style=&quot;color:#4A4A4A;&quot;&gt;+&lt;/font&gt;</code></li>
<li><font style="color:#4A4A4A;">错误消息，第一个字节为 </font><code>&lt;font style=&quot;color:#4A4A4A;&quot;&gt;-&lt;/font&gt;</code></li>
<li><font style="color:#4A4A4A;">整型数字，第一个字节为 </font><code>&lt;font style=&quot;color:#4A4A4A;&quot;&gt;:&lt;/font&gt;</code><font style="color:#4A4A4A;">，后跟整数的字符串</font></li>
<li><font style="color:#4A4A4A;">多行字符串，第一个字节为 </font><code>&lt;font style=&quot;color:#4A4A4A;&quot;&gt;$&lt;/font&gt;</code><font style="color:#4A4A4A;">，后跟字符串的长度</font></li>
<li><font style="color:#4A4A4A;">数组，第一个字节为 </font><code>&lt;font style=&quot;color:#4A4A4A;&quot;&gt;*&lt;/font&gt;</code><font style="color:#4A4A4A;">，后跟跟着数组的长度</font></li>
</ul>
<p><strong>单行字符串</strong> chenssy</p>
<blockquote>
<p>+chenssy</p>
</blockquote>
<p><strong>错误消息</strong></p>
<blockquote>
<p>-ERR unknown command ‘sets’….</p>
</blockquote>
<p><strong>整型字符串</strong> 29</p>
<blockquote>
<p>:29</p>
</blockquote>
<p><strong>多行字符串</strong> chenssy</p>
<blockquote>
<p>$7 chenssy</p>
</blockquote>
<p><strong>数组</strong>[chenssy,29]</p>
<blockquote>
<p>*2 $7 chenssy $2 29</p>
</blockquote>
<p><strong>为了更加直观的阅读，将 <strong><code>**\r\n**</code></strong> 替换为换行</strong></p>
<h3 id="请求命令"><a href="#请求命令" class="headerlink" title="请求命令"></a>请求命令</h3><p>Redis 对每一条请求命令都做了统一规范，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*&lt;number of arguments&gt; CR LF</span><br><span class="line">$&lt;number of bytes of argument 1&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;number of bytes of argument N&gt; CR LF</span><br><span class="line">&lt;argument data&gt; CR LF</span><br></pre></td></tr></table></figure>

<p>翻译如下：</p>
<ul>
<li><font style="color:#4A4A4A;">number of arguments ：参数的数量</font></li>
<li><font style="color:#4A4A4A;">CR LF：\r\n</font></li>
<li><font style="color:#4A4A4A;">number of bytes of argument 1：参数 1 的字节数</font></li>
<li><font style="color:#4A4A4A;">number of bytes of argument N：参数 N 的字节数</font></li>
</ul>
<p>以命令 <code>setuserName chenssy</code> 为例，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$8</span><br><span class="line">userName</span><br><span class="line">$7</span><br><span class="line">chenssy</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3 数组，表明有三个参数 SET、userName、chenssy</span><br><span class="line">$3 多行字符串，第一个参数 SET ，有 3 个字符</span><br><span class="line">$8 多行字符串，第二个参数 userName，有 8 个字符</span><br><span class="line">$7 多行字符串，第三个参数 chenssy，有 7 个字符</span><br></pre></td></tr></table></figure>

<p>上面只是格式化显示的结果，真正传输的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3\r\n$3\r\nSET\r\n$8\r\nuserName\r\n$7\r\nchenssy\r\n</span><br></pre></td></tr></table></figure>

<h3 id="回复命令"><a href="#回复命令" class="headerlink" title="回复命令"></a>回复命令</h3><p>Redis 服务端响应要支持多种数据格式，所以回复命令一般都会显得复杂些，但是无论如何它都逃脱不了上面 5 中类型及其组合。</p>
<p><strong>单行字符串</strong></p>
<blockquote>
<p>set name chenssy +OK</p>
</blockquote>
<p>当行字符串响应一般都用于状态类的请求，比如 set、del、hset 等等诸如此类的</p>
<p><strong>错误消息</strong></p>
<blockquote>
<p>sets birthday 02-30 -ERR unknown command ‘sets’….</p>
</blockquote>
<p>因为没有 <code>sets</code> 这个命令，所以回复错误信息</p>
<p><strong>整数型</strong></p>
<blockquote>
<p>incrby age 29 :58</p>
</blockquote>
<p><strong>多行字符串</strong></p>
<blockquote>
<p>get name $7 chenssy</p>
</blockquote>
<p>返回的 value chenssy 有 7 个字符，所以类型为 <code>$7</code></p>
<p><strong><font style="color:#000000;">数组类型</font></strong></p>
<blockquote>
<p>mget name age *2 $7 chenssy $2 58</p>
</blockquote>
<p>通过 mget 获取 name 和 age 的值，因为结果要返回两个结果集，所以 <code>*2</code> 表示返回的结果类型为数组且有两个元素， <code>$7</code>、 <code>$2</code> 就不过多解释了。</p>
<blockquote>
<p>lrange listkey 0 -1 *4 $8 chenssy3 $8 chenssy2 $8 chenssy1 $7 chenssy</p>
</blockquote>
<p>lrange 命令是获取列表（list）中的数据的，返回结果依然是以数组方式组合起来的，和 mget 命令返回的结果集一致。</p>
<p>RESP 协议是非常简单直观的一种协议，而且数据结构类型也只有五种。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Window安装Redis</title>
    <url>/2024/11/06/Window%E5%AE%89%E8%A3%85Redis/</url>
    <content><![CDATA[<p><font style="background:#F8CED3;color:#70000D">Window</font> <font style="background:#C0DDFC;color:#00346B">Redis3.2</font></p>
<h2 id="1、安装包-Package"><a href="#1、安装包-Package" class="headerlink" title="1、安装包-Package"></a>1、安装包-Package</h2><h3 id="官网下载地址"><a href="#官网下载地址" class="headerlink" title="官网下载地址"></a>官网下载地址</h3><p><a href="https://github.com/microsoftarchive/redis/releases">Redis安装包github的下载地址</a></p>
<p><a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></p>
<span id="more"></span>
<h3 id="版本-Version"><a href="#版本-Version" class="headerlink" title="版本-Version"></a>版本-Version</h3><h4 id="Redis-x64-3-2-100"><a href="#Redis-x64-3-2-100" class="headerlink" title="Redis-x64-3.2.100"></a>Redis-x64-3.2.100</h4><p><a href="https://www.yuque.com/attachments/yuque/0/2024/zip/25873401/1718855561276-8a74eae9-2a27-4e5a-bae7-a99646a716f9.zip">Redis-x64-3.2.100.zip</a></p>
<h2 id="2、安装步骤-Install-Step"><a href="#2、安装步骤-Install-Step" class="headerlink" title="2、安装步骤-Install Step"></a>2、安装步骤-Install Step</h2><h3 id="将下载的压缩包解压并放在指定的程序包目录"><a href="#将下载的压缩包解压并放在指定的程序包目录" class="headerlink" title="将下载的压缩包解压并放在指定的程序包目录"></a>将下载的压缩包解压并放在指定的程序包目录</h3><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><h4 id="此电脑-属性"><a href="#此电脑-属性" class="headerlink" title="此电脑-属性"></a>此电脑-属性</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593443356355-ee8074e2-f999-43b4-8042-9d8d4b8e1d8e.png"></p>
<h4 id="高级系统设置-gt-环境变量-gt-在Path变量添加Redis解压包的路径-gt-依次确定后退出"><a href="#高级系统设置-gt-环境变量-gt-在Path变量添加Redis解压包的路径-gt-依次确定后退出" class="headerlink" title="高级系统设置-&gt;环境变量-&gt;在Path变量添加Redis解压包的路径-&gt;依次确定后退出"></a>高级系统设置-&gt;环境变量-&gt;在Path变量添加Redis解压包的路径-&gt;依次确定后退出</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593443628678-59ef1ed4-6767-4cb2-b7f8-b575820fd79f.png"></p>
<h3 id="在Redis目录下启动Redis服务"><a href="#在Redis目录下启动Redis服务" class="headerlink" title="在Redis目录下启动Redis服务"></a>在Redis目录下启动Redis服务</h3><h4 id="在文件夹打开Redis目录，选中路径栏输入cmd回车"><a href="#在文件夹打开Redis目录，选中路径栏输入cmd回车" class="headerlink" title="在文件夹打开Redis目录，选中路径栏输入cmd回车"></a>在文件夹打开Redis目录，选中路径栏输入cmd回车</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444904380-efc3d45f-2f58-4339-8a23-91ecaf3a655d.png"></p>
<h4 id="在弹出的命令行输入命令启动程序"><a href="#在弹出的命令行输入命令启动程序" class="headerlink" title="在弹出的命令行输入命令启动程序"></a>在弹出的命令行输入命令启动程序</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">D:\DevTools\Redis&gt;redis<span class="literal">-server</span>.exe redis.windows.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593443818990-c67ec8ca-cb30-4a1e-845f-7002fa44469b.png"></p>
<h3 id="注册Redis服务到Window服务下"><a href="#注册Redis服务到Window服务下" class="headerlink" title="注册Redis服务到Window服务下"></a>注册Redis服务到Window服务下</h3><h4 id="在Redis目录下新开一个cmd命令行程序"><a href="#在Redis目录下新开一个cmd命令行程序" class="headerlink" title="在Redis目录下新开一个cmd命令行程序"></a>在Redis目录下新开一个cmd命令行程序</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">D:\DevTools\Redis&gt;redis<span class="literal">-server</span> <span class="literal">--service-install</span> redis.windows<span class="literal">-service</span>.conf <span class="literal">--loglevel</span> verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444017304-7fab3561-79e4-48f7-ab9f-d483bcb942e3.png"></p>
<h3 id="启动Redis服务"><a href="#启动Redis服务" class="headerlink" title="启动Redis服务"></a>启动Redis服务</h3><h4 id="不以管理员身份启动报权限访问错误"><a href="#不以管理员身份启动报权限访问错误" class="headerlink" title="不以管理员身份启动报权限访问错误"></a>不以管理员身份启动报权限访问错误</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444115535-5c3c234e-a4cb-48af-8c9a-529c3730e1b5.png"></p>
<h4 id="以管理员身份打开cmd"><a href="#以管理员身份打开cmd" class="headerlink" title="以管理员身份打开cmd"></a>以管理员身份打开cmd</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444158272-8a4e518e-2162-4abc-bb75-e05f7cd9b4c5.png"></p>
<h4 id="输入Redis服务启动命令"><a href="#输入Redis服务启动命令" class="headerlink" title="输入Redis服务启动命令"></a>输入Redis服务启动命令</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;net <span class="built_in">start</span> Redis</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444257405-e7f9a422-0073-4168-a5d5-6ea43bf8ea68.png"></p>
<h3 id="打开Redis客户端进行测试"><a href="#打开Redis客户端进行测试" class="headerlink" title="打开Redis客户端进行测试"></a>打开Redis客户端进行测试</h3><h4 id="在cmd命令行输入打开客户端的目录redis-cli"><a href="#在cmd命令行输入打开客户端的目录redis-cli" class="headerlink" title="在cmd命令行输入打开客户端的目录redis-cli"></a>在cmd命令行输入打开客户端的目录redis-cli</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;redis<span class="literal">-cli</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444303955-4c2af323-1f9b-43e7-8352-01999ce61796.png"></p>
<h4 id="使用ping命令检测Redis服务器是否启动"><a href="#使用ping命令检测Redis服务器是否启动" class="headerlink" title="使用ping命令检测Redis服务器是否启动"></a>使用ping命令检测Redis服务器是否启动</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444413003-ab4602cf-8223-4b0e-87cc-cf560a87796a.png"></p>
<h4 id="进行简单的赋值取值操作"><a href="#进行简单的赋值取值操作" class="headerlink" title="进行简单的赋值取值操作"></a>进行简单的赋值取值操作</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;redis<span class="literal">-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> <span class="built_in">Fc</span> <span class="number">123</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get <span class="built_in">Fc</span></span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444443388-280dcb98-8584-4cc9-91bb-f8db4a80a8e0.png"></p>
<h3 id="配置Redis服务器访问的密码"><a href="#配置Redis服务器访问的密码" class="headerlink" title="配置Redis服务器访问的密码"></a>配置Redis服务器访问的密码</h3><h4 id="在Redis文件夹下打开redis-windows-service-conf文件"><a href="#在Redis文件夹下打开redis-windows-service-conf文件" class="headerlink" title="在Redis文件夹下打开redis.windows-service.conf文件"></a>在Redis文件夹下打开redis.windows-service.conf文件</h4><p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444506317-362797f0-2750-41e6-bd0d-a728db85f424.png"></p>
<h4 id="编辑444行设置访问密码"><a href="#编辑444行设置访问密码" class="headerlink" title="编辑444行设置访问密码"></a>编辑444行设置访问密码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444669428-998e70de-3ba6-43d2-babb-108187bd2d64.png"></p>
<h3 id="重启Redis服务使密码生效"><a href="#重启Redis服务使密码生效" class="headerlink" title="重启Redis服务使密码生效"></a>重启Redis服务使密码生效</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;net stop Redis</span><br><span class="line"></span><br><span class="line">Redis 服务已成功停止。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;net <span class="built_in">start</span> Redis</span><br><span class="line"></span><br><span class="line">Redis 服务已经启动成功。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;redis<span class="literal">-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; auth <span class="number">123456</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2020/png/396745/1593444794452-3cb01b6f-8a67-467b-a05b-3f98ff491d67.png"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>02 类加载子系统</title>
    <url>/2023/08/16/02%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1. 流程图"></a>1. 流程图</h1><blockquote>
<p><strong>案例与图示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>&#123;</span><br><span class="line">        Customer cust=<span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span> &#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<span id="more"></span>
<p>下面是程序运行的简易步骤：</p>
<p>1、LoadClass：加载入口函数</p>
<p>在命令行上敲java MainApp。<font style="background-color:#FADB14;">系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为MainApp.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载</font>。</p>
<p>2、运行入口Main函数</p>
<p>JVM找到MainApp的主函数入口，开始执行main函数</p>
<p>3、执行Customer cust&#x3D;new Customer()</p>
<p>最后如上代码最终在JVM内存分布的情况示意图如下：</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/1bba0ee2a8a614b80d6cac9fecbb3f8a.png&sign=14496da61dfd593cea012ff619e441b343c951208d6adfb2d7761658f1f51dea"></p>
<h1 id="2-类加载器与类的加载过程"><a href="#2-类加载器与类的加载过程" class="headerlink" title="2. 类加载器与类的加载过程"></a>2. 类加载器与类的加载过程</h1><h2 id="2-1-类加载器子系统所处阶段和作用"><a href="#2-1-类加载器子系统所处阶段和作用" class="headerlink" title="2.1 类加载器子系统所处阶段和作用"></a>2.1 类加载器子系统所处阶段和作用</h2><h3 id="类加载子系统在整个体系中的位置"><a href="#类加载子系统在整个体系中的位置" class="headerlink" title="类加载子系统在整个体系中的位置"></a>类加载子系统在整个体系中的位置</h3><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/e4bc9ed374db7f35e68f23f4813205bd.png&sign=8d7c993626ee9dd40f2365964a8b9130960cf75f872a87fa53112f81ff8a72fd"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/5f06cd7e27506a91940c7b87e01d0b46.png&sign=d7b7a9fd9618621960b5a4b4f9a5197936189f6c9368fdd9572ae9d973ee5aa5"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990688818-60e52055-e01e-4f42-8763-0b71fd3faf1d.png"></p>
<ul>
<li>类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。</li>
<li>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li>
</ul>
<h3 id="类加载器-ClasLoader-角色"><a href="#类加载器-ClasLoader-角色" class="headerlink" title="类加载器 ClasLoader 角色"></a>类加载器 ClasLoader 角色</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990688818-dd8ac4a4-93f5-400d-842d-ad9cf1812cb3.png"></p>
<ul>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。</li>
<li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区。</li>
<li>在.class 文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li>
</ul>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用流程图表示上述示例代码：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990688825-c81dc99c-dc26-4691-8fd7-c0256dbbb219.png"></p>
<p>如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？</p>
<ul>
<li>类加载器</li>
<li>执行引擎</li>
</ul>
<h2 id="2-2-加载-Loading-阶段"><a href="#2-2-加载-Loading-阶段" class="headerlink" title="2.2 加载(Loading)阶段"></a>2.2 加载(Loading)阶段</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990688810-2c1748ed-8294-48a9-b471-529bc48ef3e1.png"></p>
<pre><code>1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口
</code></pre>
<p><strong>补充：加载 class 文件的方式</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从 zip压缩包中读取，成为日后 jar、war 格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP 应用</li>
<li>从专有数据库中提取.class 文件，比较少见</li>
<li>从加密文件中获取，典型的防 Class 文件被反编译的保护措施</li>
</ul>
<h2 id="2-3-链接-Linking-阶段"><a href="#2-3-链接-Linking-阶段" class="headerlink" title="2.3 链接(Linking)阶段"></a>2.3 链接(Linking)阶段</h2><ul>
<li><strong>验证（Verify）</strong>：<ul>
<li>目的在子确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ul>
</li>
<li><strong>准备（Prepare）</strong>：<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li>
<li>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li>
</ul>
</li>
<li><strong>解析（Resolve）</strong>：<ul>
<li>将常量池内的符号引用转换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li>
</ul>
</li>
</ul>
<h2 id="2-4-初始化-Initialization-阶段"><a href="#2-4-初始化-Initialization-阶段" class="headerlink" title="2.4 初始化(Initialization)阶段"></a>2.4 初始化(Initialization)阶段</h2><ul>
<li>初始化阶段就是执行类构造器方法<clinit>()的过程。</li>
<li>此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li><clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）</li>
<li><font style="background-color:#FADB14;">若该类具有父类，JVM 会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕。</font></li>
<li>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。确保多个线程加载类时只会加载一份。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1631784649672-2954a571-1005-43f7-9dcf-0d8eb6ab89da.png"></p>
<h1 id="3-类加载器分类"><a href="#3-类加载器分类" class="headerlink" title="3. 类加载器分类"></a>3. 类加载器分类</h1><p>JVM 支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990688831-452986f8-806f-4f1b-81cf-7eff9137b8dc.png"></p>
<p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p>
<h2 id="3-1-虚拟机自带的加载器"><a href="#3-1-虚拟机自带的加载器" class="headerlink" title="3.1. 虚拟机自带的加载器"></a>3.1. 虚拟机自带的加载器</h2><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p>
<ul>
<li>这个类加载使用 C&#x2F;C++语言实现的，嵌套在 JVM 内部。</li>
<li>它用来加载 Java 的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li>
<li>并不继承自 ava.lang.ClassLoader，没有父加载器。</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li>
</ul>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li>
<li>派生于 ClassLoader 类</li>
<li>父类加载器为启动类加载器</li>
<li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre&#x2F;1ib&#x2F;ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p>
<ul>
<li>java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现</li>
<li>派生于 ClassLoader 类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载</li>
<li>通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</li>
</ul>
<h2 id="3-2-用户自定义类加载器"><a href="#3-2-用户自定义类加载器" class="headerlink" title="3.2. 用户自定义类加载器"></a>3.2. 用户自定义类加载器</h2><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
<p>用户自定义类加载器实现步骤：</p>
<ol>
<li>开发人员可以通过继承抽象类 ava.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 findClass()方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ol>
<h1 id="4-ClassLoader-的使用说明"><a href="#4-ClassLoader-的使用说明" class="headerlink" title="4. ClassLoader 的使用说明"></a>4. ClassLoader 的使用说明</h1><p>ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990689302-fdc0d354-cfe8-420f-8383-7beab29db05a.png"></p>
<p>sun.misc.Launcher 它是一个 java 虚拟机的入口应用</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990689246-1a6729fe-a4e0-4bb3-b1d4-7f568a5cbe15.png"></p>
<p><strong>获取 ClassLoader 的途径</strong></p>
<ul>
<li>方式一：获取当前 ClassLoader</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：获取当前线程上下文的 ClassLoader</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>

<ul>
<li>方式三：获取系统的 ClassLoader</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>

<ul>
<li>方式四：获取调用者的 ClassLoader</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>

<h1 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5. 双亲委派机制"></a>5. 双亲委派机制</h1><p>Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<p><strong>工作原理</strong></p>
<ul>
<li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>3）如果父类加载器可以完成类加载任务，就成功返回，<font style="background-color:#FADB14;">倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990689415-62b21311-1945-48d4-bdfe-29af06e803e9.png"></p>
<p><strong>举例</strong></p>
<p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990689205-230ced52-13fb-427c-9442-9b4b515defb4.png"></p>
<p><strong>优势</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心 API 被随意篡改<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li>
</ul>
</li>
</ul>
<p><strong>沙箱安全机制</strong></p>
<hr>
<p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p>
<h1 id="6-类的主动使用和被动使用"><a href="#6-类的主动使用和被动使用" class="headerlink" title="6 类的主动使用和被动使用"></a>6 类的主动使用和被动使用</h1><p>Java 程序对类的使用方式分为：主动使用和被动使用。</p>
<p>主动使用，又分为七种情况：</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如：Class.forName（”com.atguigu.Test”））</li>
<li>初始化一个类的子类</li>
<li>Java 虚拟机启动时被标明为启动类的类</li>
<li>JDK 7 开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle 实例的解析结果<br>REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化</li>
</ul>
<p>除了以上七种情况，其他使用 Java 类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>
<h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h1><h2 id="如何判断两个-class-对象是否相同"><a href="#如何判断两个-class-对象是否相同" class="headerlink" title="如何判断两个 class 对象是否相同"></a>如何判断两个 class 对象是否相同</h2><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。</li>
</ul>
<p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p>
<h2 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h2><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>01 JVM与Java体系结构</title>
    <url>/2023/08/11/01%20JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="1-JVM体系"><a href="#1-JVM体系" class="headerlink" title="1. JVM体系"></a><font style="background-color:#FADB14;"></font>1. JVM体系</h1><h2 id="1-1-JVM概览-javac-exe-java-exe，以-class文件作为纽带"><a href="#1-1-JVM概览-javac-exe-java-exe，以-class文件作为纽带" class="headerlink" title="1.1 JVM概览(javac.exe+java.exe，以.class文件作为纽带)"></a>1.1 JVM概览(javac.exe+java.exe，以.class文件作为纽带)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">简易记录：javac.exe和java.exe两个程序指令</span><br><span class="line"></span><br><span class="line">javac：Java编译器，负责将Java源代码换成字节码.class字节码。javac编译后得到的class文件是二进制指令，但不是机器指令，而是java虚拟机可识别的指令。这样class文件就有了可移植行。可以把class文件拿到windows、linux或者solaris等不同的系统上去，在jvm上执行。</span><br><span class="line">java：Java解析器，将.class类文件加载到JVM里面执行，由JVM做到跨平台。</span><br><span class="line"></span><br><span class="line">jvm虚拟机是绑定操作系统的，编译器是绑定语言和操作系统的。</span><br><span class="line">jvm是跨语言的平台，java是跨平台的语言。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大 Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ul>
<li>作为一个平台，Java 虚拟机扮演着举足轻重的作用<ul>
<li>Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分</li>
</ul>
</li>
<li>作为灯种文化，Java 几乎成为了“开源”的代名词。<ul>
<li>第三方开源软件和框架。如 Tomcat、Struts，MyBatis，Spring 等。</li>
<li>就连 JDK 和 JVM 自身也有不少开源的实现，如 openJDK、Harmony。</li>
</ul>
</li>
<li>作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1631763620716-6b40faf8-c806-464c-8281-06fb5fd4eb5d.png"></p>
<p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过 Java 虚拟机进行运行和处理</p>
<ul>
<li>随着 Java7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在Java 虚拟机平台上运行非 Java 语言编写的程序。</li>
<li>Java 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说 Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li>
</ul>
<p><strong>字节码</strong></p>
<ul>
<li>我们平时说的 java 字节码，指的是用 java 语言编译成的字节码。准确的说任何能在 jvm 平台上执行的字节码格式都是一样的。所以应该统称为：jvm 字节码。</li>
<li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</li>
<li>Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式—Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</li>
</ul>
<p><strong>多语言混合编程</strong></p>
<ul>
<li>Java 平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</li>
<li>试想一下，在一个项目之中，并行处理用 Clojure 语言编写，展示层使用 JRuby&#x2F;Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为它们最终都运行在一个虚拟机之上。</li>
<li>对这些运行于 Java 虚拟机之上、Java 之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如 Da Vinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），推动 Java 虚拟机从“Java 语言的虚拟机”向 “多语言虚拟机”的方向发展。</li>
</ul>
<h2 id="1-2-JVM-的整体结构"><a href="#1-2-JVM-的整体结构" class="headerlink" title="1.2 JVM 的整体结构"></a>1.2 JVM 的整体结构</h2><p><font style="background-color:#FADB14;">总览&#x3D;&gt;Class-REN：ClassLoaderSubSystem，RuntimeDataArea、ExecutionEngine、NativeMethodInterface</font></p>
<p><font style="background-color:#FADB14;">RuntimeDataArea&#x3D;&gt;HM+VPN：Heap、MethodArea、VirtualMachineStack、ProgramCountRegister、NativeMethodStack</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1631778734055-a534c1db-7318-4364-aa31-251a3494ba57.png"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/1bf0b96d082d684a818bc36a8f864a89.png&sign=4b1d14b99fcfdff9a40a7b78d3774960c66a280d53cede09195b72d6be4eae4c"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/5f06cd7e27506a91940c7b87e01d0b46.png&sign=d7b7a9fd9618621960b5a4b4f9a5197936189f6c9368fdd9572ae9d973ee5aa5"></p>
<ul>
<li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构。</li>
<li>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C&#x2F;C++程序一较高下的地步。</li>
</ul>
<h2 id="1-3-虚拟机与-Java-虚拟机"><a href="#1-3-虚拟机与-Java-虚拟机" class="headerlink" title="1.3 虚拟机与 Java 虚拟机"></a>1.3 虚拟机与 Java 虚拟机</h2><p><strong>虚拟机</strong></p>
<p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<ul>
<li>大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是 Java 虚拟机，它专门为执行单个计算机程序而设计，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<p><strong>Java 虚拟机</strong></p>
<ul>
<li>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。</li>
<li>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li>
<li>Java 技术的核心就是 Java 虚拟机（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。</li>
</ul>
<p>作用</p>
<ul>
<li>Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li>
</ul>
<p>特点</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<p><strong>JVM 的位置</strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990670370-894da546-ef8b-484a-8119-25b9f5333328.png"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/cd8b795cf080b8ba40f6915b6242c8af.png&sign=f24dbc7c277657160512f30c9da5bb31d90f9c34fc7c18920add2abc6e9f1ea0"></p>
<p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互</p>
<h2 id="1-4-JVM-的架构模型"><a href="#1-4-JVM-的架构模型" class="headerlink" title="1.4 JVM 的架构模型"></a>1.4 JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</p>
<p>具体来说：这两种架构之间的区别：</p>
<p><strong>基于栈式架构的特点</strong></p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
<p><strong>基于寄存器架构的特点</strong></p>
<ul>
<li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li>
</ul>
<p><strong>举例 1</strong></p>
<p>同样执行 2+3 这种逻辑操作，其指令分别如下：</p>
<p>基于栈的计算流程（以 Java 虚拟机为例）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></table></figure>

<p>而基于寄存器的计算流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> <span class="comment">//将eax寄存器的值设为1</span></span><br><span class="line">add eax,<span class="number">3</span> <span class="comment">//使eax寄存器的值加3</span></span><br></pre></td></tr></table></figure>

<p><strong>举例 2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; javap -c Test.class</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">    Stack=<span class="number">2</span>,Locals=<span class="number">4</span>,Args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">       <span class="number">2</span>: istore_1</span><br><span class="line">       <span class="number">3</span>: sipush        <span class="number">200</span></span><br><span class="line">       <span class="number">6</span>: istore_2</span><br><span class="line">       <span class="number">7</span>: sipush        <span class="number">300</span></span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_1</span><br><span class="line">      <span class="number">12</span>: iload_2</span><br><span class="line">      <span class="number">13</span>: iadd</span><br><span class="line">      <span class="number">14</span>: iload_3</span><br><span class="line">      <span class="number">15</span>: imul</span><br><span class="line">      <span class="number">16</span>: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说应该是 HotSpotVM 的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
<h2 id="1-5-JVM-的生命周期"><a href="#1-5-JVM-的生命周期" class="headerlink" title="1.5 JVM 的生命周期"></a>1.5 JVM 的生命周期</h2><p><strong>虚拟机的启动</strong></p>
<p>Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<p><strong>虚拟机的执行</strong></p>
<ul>
<li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</li>
<li>程序开始执行时他才运行，程序结束时他就停止。</li>
<li>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</li>
</ul>
<p><strong>虚拟机的退出</strong></p>
<p>有如下的几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统用现错误而导致 Java 虚拟机进程终止</li>
<li>某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。</li>
</ul>
<h1 id="2-Java-代码执行流程"><a href="#2-Java-代码执行流程" class="headerlink" title="2. Java 代码执行流程"></a>2. Java 代码执行流程</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990670527-9283d199-8dd9-44ed-8983-176899fef653.png"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="10-Java-发展的重大事件"><a href="#10-Java-发展的重大事件" class="headerlink" title="10. Java 发展的重大事件"></a>10. Java 发展的重大事件</h1><ul>
<li>1990 年，在 Sun 计算机公司中，由 Patrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 oak，后期命名为 Java</li>
<li>1995 年，Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。</li>
<li>1996 年 1 月 23 日，Sun Microsystems 发布了 JDK 1.0。</li>
<li>1998 年，JDK1.2 版本发布。同时，sun 发布了 JSP&#x2F;Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用 3 大领域挺进。</li>
<li>2000 年，JDK1.3 发布，Java HotSpot Virtual Machine 正式发布，成为 Java 的默认虚拟机。</li>
<li>2002 年，JDK1.4 发布，古老的 Classic 虚拟机退出历史舞台。</li>
<li>2003 年年底，Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营。</li>
<li>2004 年，JDK1.5 发布。同时 JDK1.5 改名为 JavaSE5.0。</li>
<li>2006 年，JDK6 发布。同年，Java 开源并建立了 OpenJDK。顺理成章，Hotspot 虚拟机也成为了 openJDK 中的默认虚拟机。</li>
<li>2007 年，Java 平台迎来了新伙伴 Clojure。</li>
<li>2008 年，Oracle 收购了 BEA，得到了 JRockit 虚拟机。</li>
<li>2009 年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 Scala，这是 Java 平台的又一次大规模应用。</li>
<li>2010 年，Oracle 收购了 Sun，获得 Java 商标和最真价值的 HotSpot 虚拟机。此时，Oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合：HotRockit</li>
<li>2011 年，JDK7 发布。在 JDK1.7u4 中，正式启用了新的垃圾回收器 G1。</li>
<li>2017 年，JDK9 发布。将 G1 设置为默认 Gc，替代 CMS</li>
<li>同年，IBM 的 J9 开源，形成了现在的 Open J9 社区</li>
<li>2018 年，Android 的 Java 侵权案判决，Google 赔偿 Oracle 计 88 亿美元</li>
<li>同年，Oracle 宣告 JavaEE 成为历史名词 JDBC、JMS、Servlet 赠予 Eclipse 基金会</li>
<li>同年，JDK11 发布，LTS 版本的 JDK，发布革命性的 ZGC，调整 JDK 授权许可</li>
<li>2019 年，JDK12 发布，加入 RedHat 领导开发的shenandoah GC</li>
</ul>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/577ba2f5110b972116602fb2ce3291e8.png&sign=477c3b010f44fc70da289b3d56d99281f57e9b95489159847efa9c7f89eeb77e"></p>
<p>在 JDK11 之前，OracleJDK 中还会存在一些 OpenJDK 中没有的、闭源的功能。但在 JDK11 中，我们可以认为 OpenJDK 和 OracleJDK 代码实质上已经完全一致的程度。</p>
<p>不过，主流的 JDK 8 在 2019 年 01 月之后就被宣布停止更新了。另外， JDK 11 及以后的版本也不再提供免费的长期支持（LTS），而且 JDK 15 和 JDK 16 也不是一个长期支持的版本，最新的 JDK 15 只支持 6 个月时间，到 2021 年 3 月，所以千万不要把 JDK 15 等非长期支持版本用在生产。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/8a37d7f7b848e7453e622270217ce7dc.png&sign=0d26d67d0ec0faae77dfa0e2dc71ef5a60f62402cc03b59946e1bf401653e467"></p>
<h1 id="11-JVM-的发展历程"><a href="#11-JVM-的发展历程" class="headerlink" title="11. JVM 的发展历程"></a>11. JVM 的发展历程</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1631777134504-de1ca9eb-db69-41af-8d67-39d1eb3c68c6.png"><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1631777155613-7061ef7b-416c-42dd-a3a5-6b08ea540de7.png"></p>
<p><strong>总结：</strong>具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。</p>
<table>
<thead>
<tr>
<th><strong>JVM产品</strong></th>
<th><strong>概述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>### HotSpot VM</td>
<td>+ HotSpot 历史<br/>    - 最初由一家名为“Longview Technologies”的小公司设计<br/>    - 1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。<br/>    - JDK1.3 时，HotSpot VM 成为默认虚拟机<br/>+ 目前 Hotspot 占有绝对的市场地位，称霸武林。<br/>    - 不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot<br/>    - Sun &#x2F; Oracle JDK 和 OpenJDK 的默认虚拟机<br/>    - 因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）<br/>+ 从服务器、桌面到移动端、嵌入式都有应用。<br/>+ 名称中的 HotSpot 指的就是它的热点代码探测技术。<br/>    - 通过计数器找到最具编译价值代码，触发即时编译或栈上替换<br/>    - 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</td>
</tr>
<tr>
<td>### Sun Classic VM</td>
<td>+ 早在 1996 年 Java1.0 版本的时候，Sun 公司发布了一款名为 sun classic VM 的 Java 虚拟机，它同时也是世界上第一款商用 Java 虚拟机，JDK1.4 时完全被淘汰。<br/>+ 这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。<br/>+ 如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。<br/>+ 现在 hotspot 内置了此虚拟机。</td>
</tr>
<tr>
<td>### Exact VM</td>
<td>+ 为了解决上一个虚拟机问题，jdk1.2 时，Sun 提供了此虚拟机。<br/>+ Exact Memory Management：准确式内存管理<br/>    - 也可以叫 Non-Conservative&#x2F;Accurate Memory Management<br/>    - 虚拟机可以知道内存中某个位置的数据具体是什么类型。<br/>+ 具备现代高性能虚拟机的维形<br/>    - 热点探测<br/>    - 编译器与解释器混合工作模式<br/>+ 只在 solaris 平台短暂使用，其他平台上还是 classic vm<br/>    - 英雄气短，终被 Hotspot 虚拟机替换</td>
</tr>
<tr>
<td>### JRockit</td>
<td>+ 专注于服务器端应用<br/>    - 它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。<br/>+ 大量的行业基准测试显示，JRockit JVM 是世界上最快的 JVM。<br/>    - 使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。<br/>+ 优势：全面的 Java 运行时解决方案组合<br/>    - JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要<br/>    - MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。<br/>+ 2008 年，JRockit 被 oracle 收购。<br/>+ Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。<br/>+ 高斯林：目前就职于谷歌，研究人工智能和水下机器人</td>
</tr>
<tr>
<td>### IBM 的 J9</td>
<td>+ 全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9<br/>+ 市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM<br/>+ 广泛用于 IBM 的各种 Java 产品。<br/>+ 目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机。<br/>+ 2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9</td>
</tr>
<tr>
<td>### KVM 和 CDC &#x2F; CLDC Hotspot</td>
<td>+ Oracle 在 Java ME 产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM<br/>+ KVM（Kilobyte）是 CLDC-HI 早期产品<br/>+ 目前移动领域地位尴尬，智能机被 Android 和 iOS 二分天下。<br/>+ KVM 简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场<br/>    - 智能控制器、传感器<br/>    - 老人手机、经济欠发达地区的功能手机<br/>+ 所有的虚拟机的原则：一次编译，到处运行。</td>
</tr>
<tr>
<td>### Azul VM</td>
<td>+ 前面三大“高性能 Java 虚拟机”使用在通用硬件平台上这里 Azul VW 和 BEA Liquid VM 是与特定硬件平台绑定、软硬件配合的专有虚拟机<br/>    - 高性能 Java 虚拟机中的战斗机。<br/>+ Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机。<br/>+ 每个 Azul VM 实例都可以管理至少数十个 CPU 和数百 GB 内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。<br/>+ 2010 年，AzulSystems 公司开始从硬件转向软件，发布了自己的 Zing JVM，可以在通用 x86 平台上提供接近于 Vega 系统的特性。</td>
</tr>
<tr>
<td>### Apache Harmony</td>
<td>+ Apache 也曾经推出过与 JDK1.5 和 JDK1.6 兼容的 Java 运行平台 Apache Harmony。<br/>+ 它是 IBM 和 Intel 联合开发的开源 JVM，受到同样开源的 OpenJDK 的压制，Sun 坚决不让 Harmony 获得 JCP 认证，最终于 2011 年退役，IBM 转而参与 OpenJDK<br/>+ 虽然目前并没有 Apache Harmony 被大规模商用的案例，但是它的 Java 类库代码吸纳进了 Android SDK。</td>
</tr>
<tr>
<td>### Micorsoft JVM</td>
<td>+ 微软为了在 IE3 浏览器中支持 Java Applets，开发了 Microsoft JVM。<br/>+ 只能在 Windows 平台下运行。但确是当时 Windows 下性能最好的 Java VM。<br/>+ 1997 年，Sun 以侵犯商标、不正当竞争罪名指控微软成功，赔了 Sun 很多钱。微软 WindowsXP SP3 中抹掉了其 VM。现在 Windows 上安装的 jdk 都是 HotSpot。</td>
</tr>
<tr>
<td>### Liquid VM</td>
<td>+ 高性能 Java 虚拟机中的战斗机。<br/>+ BEA 公司开发的，直接运行在自家 Hypervisor 系统上<br/>+ Liquid VM 即是现在的 JRockit VE（Virtual Edition），Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。<br/>+ 随着 JRockit 虚拟机终止开发，Liquid vM 项目也停止了。</td>
</tr>
<tr>
<td>### Taobao JVM</td>
<td>+ 由 AliJVM 团队发布。阿里，国内使用 Java 最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。<br/>+ 基于 OpenJDK 开发了自己的定制版本 AlibabaJDK，简称 AJDK。是整个阿里 Java 体系的基石。<br/>+ 基于 OpenJDK Hotspot VM 发布的国内第一个优化、深度定制且开源的高性能服务器版 Java 虚拟机。<br/>    - 创新的 GCIH（GC invisible heap）技术实现了 off-heap，即将生命周期较长的 Java 对象从 heap 中移到 heap 之外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。<br/>    - GCIH 中的对象还能够在多个 Java 虚拟机进程中实现共享<br/>    - 使用 crc32 指令实现 JVM intrinsic 降低 JNI 的调用开销<br/>    - PMU hardware 的 Java profiling tool 和诊断协助功能<br/>    - 针对大数据场景的 ZenGc<br/>+ taobao vm 应用在阿里产品上性能高，硬件严重依赖 intel 的 cpu，损失了兼容性，但提高了性能<br/>    - 目前已经在淘宝、天猫上线，把 oracle 官方 JvM 版本全部替换了。</td>
</tr>
<tr>
<td>### Dalvik VM</td>
<td>+ 谷歌开发的，应用于 Android 系统，并在 Android2.2 中提供了 JIT，发展迅猛。<br/>+ Dalvik VM 只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循 Java 虚拟机规范，不能直接执行 Java 的 Class 文件<br/>+ 基于寄存器架构，不是 jvm 的栈架构。<br/>+ 执行的是编译以后的 dex（Dalvik Executable）文件。执行效率比较高。<br/>    - 它执行的 dex（Dalvik Executable）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。<br/>+ Android 5.0 使用支持提前编译（Ahead of Time Compilation，AoT）的 ART VM 替换 Dalvik VM。</td>
</tr>
<tr>
<td>### Graal VM</td>
<td>+ 2018 年 4 月，oracle Labs 公开了 Graal VM，号称 “Run Programs Faster Anywhere”，野心勃勃。与 1995 年 java 的”write once，run anywhere”遥相呼应。<br/>+ Graal VM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R 等<br/>+ 支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件<br/>+ 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。Graal VM 提供 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。<br/>+ 如果说 HotSpot 有一天真的被取代，Graal VM 希望最大。但是 Java 的软件生态没有丝毫变化。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>05 本地方法接口和本地方法栈</title>
    <url>/2023/08/19/05%20%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
    <content><![CDATA[<h1 id="1-什么是本地方法？"><a href="#1-什么是本地方法？" class="headerlink" title="1. 什么是本地方法？"></a>1. 什么是本地方法？</h1><p>简单地讲，一个 Native Method 是一个 Java 调用非 Java 代码的接囗。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C中，你可以用 extern “c” 告知 c编译器去调用一个 c 的函数。</p>
<blockquote>
<p>A native method is a Java method whose implementation is provided by non-java code.</p>
</blockquote>
<p>在定义一个 native method 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 java 语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C&#x2F;C++程序。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990737203-78a924b6-df80-4945-b101-50bffb01172f.png"></p>
<span id="more"></span>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">methodNative1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">methodNative2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">methodNative3</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">methodNative4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标识符 native 可以与其它 java 标识符连用，但是 abstract 除外</p>
<h1 id="2-为什么使用-Native-Method？"><a href="#2-为什么使用-Native-Method？" class="headerlink" title="2. 为什么使用 Native Method？"></a>2. 为什么使用 Native Method？</h1><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<p><strong>与 Java 环境的交互</strong></p>
<p>有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。你可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</p>
<p><strong>与操作系统的交互</strong></p>
<p>JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 c 写的。还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<p><strong>Sun’s Java</strong></p>
<p>Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority()方法是用 Java 实现的，但是它实现调用的是该类里的本地方法 setPriority()。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 Windows 95 的平台上，这个本地方法最终将调用 Win32 setPriority() ApI。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVw 调用。</p>
<p><strong>现状</strong></p>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p>
<h1 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h1><p>Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</p>
<p>本地方法栈，也是线程私有的。</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li>
</ul>
<p>本地方法是使用 C 语言实现的。</p>
<p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990737227-cd2854c8-b401-4c77-91ac-f6ef5991e047.png"></p>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
<p>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p>
<p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</p>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>04 虚拟机栈(栈管运行，堆管存储)</title>
    <url>/2023/08/18/04%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88(%E6%A0%88%E7%AE%A1%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%A0%86%E7%AE%A1%E5%AD%98%E5%82%A8)/</url>
    <content><![CDATA[<h1 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1. 虚拟机栈概述"></a>1. 虚拟机栈概述</h1><h2 id="1-1-虚拟机栈出现的背景"><a href="#1-1-虚拟机栈出现的背景" class="headerlink" title="1.1 虚拟机栈出现的背景"></a>1.1 虚拟机栈出现的背景</h2><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p>
<p>有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p>
<h2 id="1-2-内存中的栈与堆"><a href="#1-2-内存中的栈与堆" class="headerlink" title="1.2 内存中的栈与堆"></a>1.2 内存中的栈与堆</h2><p>栈是运行时的单位，而堆是存储的单位</p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724048-f9f1a7e4-5287-45d0-bfd1-0743a5195d3b.png"></p>
<span id="more"></span>
<h2 id="1-3-虚拟机栈基本内容"><a href="#1-3-虚拟机栈基本内容" class="headerlink" title="1.3 虚拟机栈基本内容"></a>1.3 虚拟机栈基本内容</h2><h3 id="Java-虚拟机栈是什么？"><a href="#Java-虚拟机栈是什么？" class="headerlink" title="Java 虚拟机栈是什么？"></a>Java 虚拟机栈是什么？</h3><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。<font style="background-color:#FADB14;">每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用，是线程私有的</font>。</p>
<p><font style="background-color:#FADB14;">一个栈帧就是一个方法。</font></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期和线程一致</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。</p>
<p>JVM 直接对 Java 栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
<p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990723980-dfdf863a-0d72-4ba4-925c-0a81aa1c5849.png"></p>
<h3 id="面试题：开发中遇到哪些异常？"><a href="#面试题：开发中遇到哪些异常？" class="headerlink" title="面试题：开发中遇到哪些异常？"></a>面试题：开发中遇到哪些异常？</h3><p><strong>栈中可能出现的异常</strong></p>
<p>Java 虚拟机规范允许Java 栈的大小是动态的或者是固定不变的。</p>
<ul>
<li>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个StackOverflowError 异常。</li>
<li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出异常：Exception in thread&quot;main&quot;java.lang.StackoverflowError</span></span><br><span class="line"><span class="comment">//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</span></span><br></pre></td></tr></table></figure>

<p><strong>设置栈内存大小</strong></p>
<p>我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackDeepTest</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">()</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        recursion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            recursion();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;deep of calling=&quot;</span>+count);</span><br><span class="line">            e.printstackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-虚拟机栈的内部构成"><a href="#1-4-虚拟机栈的内部构成" class="headerlink" title="1.4 虚拟机栈的内部构成"></a>1.4 虚拟机栈的内部构成</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p>
<p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”&#x2F;“后进先出”原则。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724040-8075d831-cab1-4083-82d9-2cd3471e80c6.png"></p>
<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p>
<h1 id="2-栈帧的内部结构"><a href="#2-栈帧的内部结构" class="headerlink" title="2 栈帧的内部结构"></a>2 栈帧的内部结构</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（operand Stack）（或表达式栈）</li>
<li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724016-22aa9dc8-b4e5-452b-b458-28687cd48c82.png"></p>
<p><font style="background-color:#FADB14;">并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724041-90f0858a-2c2d-413b-90f1-56b2bba9a413.png"></p>
<h2 id="2-2-局部变量表-Local-Variables"><a href="#2-2-局部变量表-Local-Variables" class="headerlink" title="2.2 局部变量表(Local Variables)"></a>2.2 局部变量表(Local Variables)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>局部变量表也被称之为局部变量数组或本地变量表</p>
<ul>
<li>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型。</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li>
<li>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li>
</ul>
<h3 id="关于-Slot-的理解"><a href="#关于-Slot-的理解" class="headerlink" title="关于 Slot 的理解"></a>关于 Slot 的理解</h3><ul>
<li>局部变量表，最基本的存储单元是 Slot（变量槽）</li>
<li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束。</li>
<li>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference），returnAddress 类型的变量。</li>
<li>在局部变量表里，32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 slot。</li>
<li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。</li>
<li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个 slot 上</li>
<li>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可。（比如：访问 long 或 doub1e 类型变量）</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 slot 处，其余的参数按照参数表顺序继续排列。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724506-19510a2f-ef2a-4394-a052-6affcb61177e.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1631868266770-36937819-8521-486e-925e-d3184e58c19c.png"></p>
<h3 id="Slot-的重复利用"><a href="#Slot-的重复利用" class="headerlink" title="Slot 的重复利用"></a>Slot 的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlotTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVar2</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的就会复用a的槽位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    System. out. println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码是错误的，没有赋值不能够使用。</p>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h2 id="2-3-操作数栈（Operand-Stack）–加工处栈"><a href="#2-3-操作数栈（Operand-Stack）–加工处栈" class="headerlink" title="2.3 操作数栈（Operand Stack）–加工处栈"></a>2.3 操作数栈（Operand Stack）–加工处栈</h2><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724475-5804ac1b-e65a-4e8e-b25f-b9a601b3cdb6.png"></p>
<p>代码举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">public void testAddOperation();</span><br><span class="line">    Code:</span><br><span class="line">    0: bipush 15</span><br><span class="line">    2: istore_1</span><br><span class="line">    3: bipush 8</span><br><span class="line">    5: istore_2</span><br><span class="line">    6:iload_1</span><br><span class="line">    7:iload_2</span><br><span class="line">    8:iadd</span><br><span class="line">    9:istore_3</span><br><span class="line">    10:return</span><br></pre></td></tr></table></figure>

<p><strong>操作数栈，<strong><strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></strong>。</strong></p>
<p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性中，为 max_stack 的值。</p>
<p>栈中的任何一个元素都是可以任意的 Java 数据类型</p>
<ul>
<li>32bit 的类型占用一个栈单位深度</li>
<li>64bit 的类型占用两个栈单位深度</li>
</ul>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
<p><strong>另外，我们说 Java 虚拟机的<strong><strong>解释引擎是基于栈的执行引擎</strong></strong>，其中的栈指的就是操作数栈。</strong></p>
<h2 id="2-4-动态链接（Dynamic-Linking）"><a href="#2-4-动态链接（Dynamic-Linking）" class="headerlink" title="2.4 动态链接（Dynamic Linking）"></a>2.4 动态链接（Dynamic Linking）</h2><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p>
<p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p>
<p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724511-ae39db74-6353-49e6-960b-01fe588bc648.png"></p>
<p>为什么需要运行时常量池呢？</p>
<p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
<h2 id="2-5-方法返回地址（return-address）"><a href="#2-5-方法返回地址（return-address）" class="headerlink" title="2.5 方法返回地址（return address）"></a>2.5 方法返回地址（return address）</h2><p>存放调用该方法的 pc 寄存器的值。一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；<ul>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long 类型），freturn（Float 类型），dreturn（Double 类型），areturn。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。</li>
</ul>
</li>
<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</li>
</ol>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Exception table:from to target type4	 16	  19   any19	 21	  19   any</span><br></pre></td></tr></table></figure>

<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<h2 id="2-6-一些附加信息"><a href="#2-6-一些附加信息" class="headerlink" title="2.6 一些附加信息"></a>2.6 一些附加信息</h2><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h2 id="2-8-栈顶缓存技术（Top-Of-Stack-Cashing）技术"><a href="#2-8-栈顶缓存技术（Top-Of-Stack-Cashing）技术" class="headerlink" title="2.8 栈顶缓存技术（Top Of Stack Cashing）技术"></a>2.8 栈顶缓存技术（Top Of Stack Cashing）技术</h2><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</p>
<h2 id="2-9-代码综合演示"><a href="#2-9-代码综合演示" class="headerlink" title="2.9 代码综合演示"></a>2.9 代码综合演示</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void testAddOperation() &#123;</span><br><span class="line">    byte i = 15;</span><br><span class="line">    int j = 8;</span><br><span class="line">    int k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap 命令反编译 class 文件：<code>javap -v 类名.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddoperation</span><span class="params">()</span>; 		Code:	<span class="number">0</span>: bipush <span class="number">15</span> 	<span class="number">2</span>: istore_1 	<span class="number">3</span>: bipush <span class="number">8</span>	<span class="number">5</span>: istore_2	<span class="number">6</span>: iload_1	<span class="number">7</span>: iload_2	<span class="number">8</span>: iadd	<span class="number">9</span>: istore_3    <span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/da41b01ad08238a2c8065552aaa7d676.png&sign=01d4697186ff1f45b586de40738785603a95e3a38e7202dc3b15d5d9d6384113"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/6867c7a53a4faff29318783b46aef097.png&sign=3e1099b6163a04491755aad6128b12d21aa042f6a5932f88b94f3998371eefa3"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/f2d6c5d906914ebdca0a472fee33e047.png&sign=dcbe62c23689d3aff162d9f38b754c54277895f394f5187e4f6f7a044dd34efd"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/6ef9c2eb8ac3395133950caf8ef80da3.png&sign=a05cf0b1bc4c1a20a5e7fc2ca9c5d3c399fba52f3ff80ce5428dd46a8aaa4543"></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/28113c3dc724bbffe677ea61b49e7c56.png&sign=28b75154e9a3917a9ddfee96b9d5046bcc9f8b11487cb97e4ed8dc9e81630b29"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/f960c074fb4a6b1f35e862568ed23d04.png&sign=c72dd7fa8f1a9f31d3530ea49c3e8d60f0e6a25b4a01c834938f6e777caf9111"></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/73a07a0e10bef2537b6da97a5348fee2.png&sign=41682d899e3e917a902c63ee0e4306ffe6f06ebe1f006561a97d359943cd667e"><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/17309b8150015a8b359f2cb2ef78cb60.png&sign=617ec8e63b6610ac1a53c446dde0869b13c3b5a70fdde23979fd05d97273c315"></p>
<p>程序员面试过程中，常见的 i和i 的区别，放到字节码篇章时再介绍。</p>
<h1 id="3-方法的调用：解析与分配"><a href="#3-方法的调用：解析与分配" class="headerlink" title="3. 方法的调用：解析与分配"></a>3. 方法的调用：解析与分配</h1><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<h2 id="3-1-静态链接"><a href="#3-1-静态链接" class="headerlink" title="3.1. 静态链接"></a>3.1. 静态链接</h2><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<h2 id="3-2-动态链接"><a href="#3-2-动态链接" class="headerlink" title="3.2. 动态链接"></a>3.2. 动态链接</h2><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<p>静态链接和动态链接不是名词，而是动词，这是理解的关键。</p>
<hr>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<h2 id="3-3-早期绑定"><a href="#3-3-早期绑定" class="headerlink" title="3.3. 早期绑定"></a>3.3. 早期绑定</h2><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
<h2 id="3-4-晚期绑定"><a href="#3-4-晚期绑定" class="headerlink" title="3.4. 晚期绑定"></a>3.4. 晚期绑定</h2><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p>
<hr>
<p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C语言中的虚函数（C中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p>
<hr>
<h2 id="3-5-虚方法和非虚方法"><a href="#3-5-虚方法和非虚方法" class="headerlink" title="3.5. 虚方法和非虚方法"></a>3.5. 虚方法和非虚方法</h2><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p>
<p>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。</p>
<p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;        System. out. println(<span class="string">&quot;father &quot;</span>+str);     &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String str)</span>&#123;        System. out. println(<span class="string">&quot;father&quot;</span>+str);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualMethodTest</span>&#123;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;            Son.print(<span class="string">&quot;coder&quot;</span>);            <span class="comment">//Father fa=new Father();            //fa.show(&quot;atguigu.com&quot;);        &#125;    &#125;</span></span><br></pre></td></tr></table></figure>

<p>虚拟机中提供了以下几条方法调用指令：</p>
<h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
<h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。</p>
<p><strong>关于 invokednamic 指令</strong></p>
<ul>
<li>JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是Java 为了实现「动态类型语言」支持而做的一种改进。</li>
<li>但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</li>
<li>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</li>
</ul>
<h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<h2 id="3-6-方法重写的本质"><a href="#3-6-方法重写的本质" class="headerlink" title="3.6. 方法重写的本质"></a>3.6. 方法重写的本质</h2><p><strong>Java 语言中方法重写的本质：</strong></p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li>
<li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出 java.1ang.AbstractMethodsrror 异常。</li>
</ol>
<p><strong>IllegalAccessError 介绍</strong></p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h2 id="3-7-方法的调用：虚方法表"><a href="#3-7-方法的调用：虚方法表" class="headerlink" title="3.7. 方法的调用：虚方法表"></a>3.7. 方法的调用：虚方法表</h2><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
<p>虚方法表是什么时候被创建的呢？</p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p>
<p>举例 1：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724599-ffd4ad0f-cb39-4a04-a4d0-e7b4a1f702f1.png"></p>
<p>举例 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Friendly</span>&#123;    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span>; &#125;<span class="keyword">class</span> <span class="title class_">Dog</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">public</span> String <span class="title function_">tostring</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span>;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Friendly</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;     &#125;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">CockerSpaniel</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Friendly</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;         <span class="built_in">super</span>.sayHello();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span> &#123;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990724494-39c92fb4-ad12-44a5-9d21-fe1d9cf7dce5.png"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="10-栈的相关面试题"><a href="#10-栈的相关面试题" class="headerlink" title="10. 栈的相关面试题"></a>10. 栈的相关面试题</h1><ul>
<li>举例栈溢出的情况？（StackOverflowError）<ul>
<li>通过 -Xss 设置栈的大小</li>
</ul>
</li>
<li>调整栈大小，就能保证不出现溢出么？<ul>
<li>不能保证不溢出</li>
</ul>
</li>
<li>分配的栈内存越大越好么？<ul>
<li>不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li>
</ul>
</li>
<li>垃圾回收是否涉及到虚拟机栈？<ul>
<li>不会</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全？<ul>
<li>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">运行时数据区</th>
<th align="left">是否存在 Error</th>
<th align="left">是否存在 GC</th>
</tr>
</thead>
<tbody><tr>
<td align="left">程序计数器</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">虚拟机栈</td>
<td align="left">是（SOE）</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">本地方法栈</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">方法区</td>
<td align="left">是（OOM）</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">堆</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>03 运行时数据区及程序计数器</title>
    <url>/2023/08/17/03%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1 运行时数据区"></a>1 运行时数据区</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990707720-a596c82b-2ce6-4227-857e-15067886955e.png"></p>
<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990707517-b9e84c47-10a5-4b3c-be24-c0c403ddab7e.png"></p>
<p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。</p>
<span id="more"></span>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990707760-96c1ee16-f8ba-43f6-8567-5a37d2529942.png"></p>
<p>我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990707597-ee42e2a3-14a3-4127-b6d2-1cac9e17d42c.png"></p>
<p>我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说内存充当了 CPU 和磁盘之间的桥梁</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990707717-b7d98a65-f61d-4f9e-bd34-634fcbc635c0.png"></p>
<p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990707937-46f0e2af-7eae-41f3-b50e-505b89f0804b.png"></p>
<p>每个 JVM 只有一个 Runtime 实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990708192-990feb55-60e4-452d-a88d-188e77c489a5.png"></p>
<h2 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h2><p><font style="background-color:#FADB14;">线程是一个程序里的运行单元，是CPU动态分配资源去执行一个程序内的代码路径，即一个代码执行路径。线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)</font>。JVM 允许一个应用有多个线程并行的执行。 在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射。</p>
<p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。</p>
<p>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run()方法。</p>
<p>扩展：程序、进程、线程、单核CPU、多核CPU的概念说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、程序(program)</span><br><span class="line">是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</span><br><span class="line"><span class="number">2</span>、进程(process)</span><br><span class="line">是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程(生命周期)。如：运行中的QQ，运行中的MP3播放器。</span><br><span class="line">程序是静态的，进程是动态的。进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</span><br><span class="line"><span class="number">3</span>、线程(thread)</span><br><span class="line">进程可进一步细化为线程，是CPU动态分配资源去执行一个程序内的代码路径，即一个代码执行路径。线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。</span><br><span class="line">若一个进程同一时间并行执行多个线程，就是支持多线程的。一个进程中的多个线程共享相同的内存单元/内存地址空间。它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</span><br><span class="line">一个Java应用程序java.exe，其实至少有三个线程：main()主线程、gc()垃圾回收线程、异常处理线程(然如果发生异常，会影响主线程)</span><br><span class="line"><span class="number">4</span>、单核CPU </span><br><span class="line">单核CPU:其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。但是因为CPU切换的时间单元特别短，因此感觉不出来。</span><br><span class="line"><span class="number">5</span>、多核CPU</span><br><span class="line">如果是多核的话程序可以多核并行运行。</span><br></pre></td></tr></table></figure>

<h2 id="1-3-JVM-系统线程"><a href="#1-3-JVM-系统线程" class="headerlink" title="1.3 JVM 系统线程"></a>1.3 JVM 系统线程</h2><p>如果你使用 console 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[] args)</code>的 main 线程以及所有这个 main 线程自己创建的线程。</p>
<p>这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：</p>
<ul>
<li>虚拟机线程：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
<h1 id="2-程序计数器-PC-寄存器"><a href="#2-程序计数器-PC-寄存器" class="headerlink" title="2 程序计数器(PC 寄存器)"></a>2 程序计数器(PC 寄存器)</h1><p>JVM 中的程序计数寄存器（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990708313-d6e884d0-2043-4128-a762-b428aa6b3993.png"></p>
<p><strong>作用</strong></p>
<p>PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990708462-27c8c215-4647-42ec-bc80-2f91ce69db15.png"></p>
<p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>
<p>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（undefined）。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>它是唯一一个在 Java 虚拟机规范中没有规定任何 OutofMemoryError 情况的区域。</p>
<p><strong>举例说明</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minus</span><span class="params">()</span>&#123;</span><br><span class="line">    intc = <span class="number">3</span>;</span><br><span class="line">    intd = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> c - d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0: iconst_3</span><br><span class="line">1: istore_1</span><br><span class="line">2: iconst_4</span><br><span class="line">3: istore_2</span><br><span class="line">4: iload_1</span><br><span class="line">5: iload_2</span><br><span class="line">6: isub</span><br><span class="line">7: ireturn</span><br></pre></td></tr></table></figure>

<p><strong>使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？</strong></p>
<p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>
<p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990708445-177bff3b-58e4-4fca-b623-58c6caac02d8.png"></p>
<p><strong>PC 寄存器为什么被设定为私有的？</strong></p>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<p><strong>CPU 时间片</strong></p>
<p>CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990708396-1f5ae366-c9c5-4f7a-acd2-a6d0917e9ffb.png"></p>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>06 堆</title>
    <url>/2023/08/20/06%20%E5%A0%86/</url>
    <content><![CDATA[<h1 id="1-堆-Heap-的核心概述"><a href="#1-堆-Heap-的核心概述" class="headerlink" title="1. 堆(Heap)的核心概述"></a>1. 堆(Heap)的核心概述</h1><h2 id="1-1-核心概述"><a href="#1-1-核心概述" class="headerlink" title="1.1 核心概述"></a>1.1 核心概述</h2><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/0be60cad417bedd46d651f710ae585ce.png&sign=26913cbe6c64b806cf64d9bd818a2941e44f7bd8523012f99cbe148a33beb9c5"></p>
<p>堆针对一个 JVM 进程来说是唯一的，也就是一个进程只有一个 JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p>
<p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p>
<p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
<p>《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
<p>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<p>《Java 虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（<code>The heap is the run-time data area from which memory for all class instances and arrays is allocated</code>）</p>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<p>堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990752656-96126fb9-bec5-4860-a0e2-3ac682154b39.png"></p>
<span id="more"></span>
<h2 id="1-2-堆内存细分-新生代-x2F-老年代"><a href="#1-2-堆内存细分-新生代-x2F-老年代" class="headerlink" title="1.2 堆内存细分(新生代&#x2F;老年代)"></a>1.2 堆内存细分(新生代&#x2F;老年代)</h2><blockquote>
<p><strong>逻辑区分</strong></p>
</blockquote>
<p>Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>
<ul>
<li>Young Generation Space 新生区 Young&#x2F;New 又被划分为 Eden 区和 Survivor 区</li>
<li>Tenure generation space 养老区 Old&#x2F;Tenure</li>
<li>Permanent Space 永久区 Perm</li>
</ul>
<p>Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+元空间</p>
<ul>
<li>Young Generation Space 新生区 Young&#x2F;New 又被划分为 Eden 区和 Survivor 区</li>
<li>Tenure generation space 养老区 Old&#x2F;Tenure</li>
<li>Meta Space 元空间 Meta</li>
</ul>
<p>约定：新生区（代）&lt;&#x3D;&gt;年轻代 、 养老区&lt;&#x3D;&gt;老年区（代）、 永久区&lt;&#x3D;&gt;永久代</p>
<blockquote>
<p><strong>年轻代与老年代</strong></p>
</blockquote>
<p>存储在 JVM 中的 Java 对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致</li>
</ul>
<p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
<p>其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/f3ee86daaf5076fe22265ffcaa831175.png&sign=99e75dccbcab781dff4f166a3ba8671af4fc2a1f25ee222afd292f4b600121eb"></p>
<p>下面这参数开发中一般不会调：</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/7d9c2d1f9ef9f315f01b3441c6e81660.png&sign=c19845acfc0c07c34e075618cc2192ca3a4106e22e2c42e9f62c879c356fd187"></p>
<p>配置新生代与老年代在堆结构的占比。</p>
<ul>
<li>默认<code>-XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，新生代占整个堆的 1&#x2F;3</li>
<li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占 1，老年代占 4，新生代占整个堆的 1&#x2F;5</li>
</ul>
<p>在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 8：1：1</p>
<p>当然开发人员可以通过选项“<code>-xx:SurvivorRatio</code>”调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></p>
<p>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。绝大部分的 Java 对象的销毁都在新生代进行了。</p>
<ul>
<li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的。</li>
</ul>
<p>可以使用选项”<code>-Xmn</code>“设置新生代最大内存大小，这个参数一般使用默认值就可以了。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/31fd90d99565ec8ce0682a4468076f94.png&sign=cd05c98ecd1265a13961f2777f983c2f38eda44f721086b6892cdcaaf3e73bd0"></p>
<h2 id="1-3-堆空间内部结构"><a href="#1-3-堆空间内部结构" class="headerlink" title="1.3 堆空间内部结构"></a>1.3 堆空间内部结构</h2><h3 id="内部结构-JDK7"><a href="#内部结构-JDK7" class="headerlink" title="内部结构(JDK7)"></a>内部结构(JDK7)</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990752872-77907876-bfa9-4a8a-9eb3-96ae2d3c8ef2.png"></p>
<h3 id="堆空间内部结构-JDK8"><a href="#堆空间内部结构-JDK8" class="headerlink" title="堆空间内部结构(JDK8)"></a>堆空间内部结构(JDK8)</h3><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990752581-9fbebaad-5025-411b-ac8d-a8b71875261b.png"></p>
<h2 id="1-4-堆空间大小的设置"><a href="#1-4-堆空间大小的设置" class="headerlink" title="1.4 堆空间大小的设置"></a>1.4 堆空间大小的设置</h2><blockquote>
<p><strong>基本概念</strong></p>
</blockquote>
<p>Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<ul>
<li>“-Xms”用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li>
<li>“-Xmx”则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li>
</ul>
<p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出 OutOfMemoryError 异常。</p>
<p>命令参考文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
<blockquote>
<p><strong>默认情况下</strong></p>
</blockquote>
<ul>
<li>初始内存大小：物理电脑内存大小 &#x2F; 64</li>
<li>最大内存大小：物理电脑内存大小 &#x2F; 4</li>
<li>再IDEA-VM中更改(-Xms600M -Xmx2000M)</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632019056157-bc4ca8e6-d30e-4b75-a368-4768b327c808.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">### 代码演示 ###</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//初始化内容</span></span><br><span class="line"> 	<span class="type">long</span> <span class="variable">initMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"> 	<span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">打印输出的结果为：</span><br><span class="line"><span class="number">575</span></span><br><span class="line"><span class="number">1778</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>开发建议</strong></p>
</blockquote>
<p>通常会将-Xms 和-Xmx 两个参数配置相同的值，其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</p>
<h2 id="1-5-OutOfMemory-举例"><a href="#1-5-OutOfMemory-举例" class="headerlink" title="1.5 OutOfMemory 举例"></a>1.5 OutOfMemory 举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span>*<span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutofMemoryError: Java heap space</span><br><span class="line">    at com.atguigu. java.Picture.&lt;init&gt;(OOMTest. java:<span class="number">25</span>)</span><br><span class="line">    at com.atguigu.java.O0MTest.main(OOMTest.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990752686-7bce6056-0aa4-486a-a199-3d751e793f2d.png"></p>
<p>下面这参数开发中一般不会调：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990752783-c8f88a79-cef7-4a21-af29-2640756ad390.png"></p>
<p>配置新生代与老年代在堆结构的占比。</p>
<ul>
<li>默认<code>-XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，新生代占整个堆的 1&#x2F;3</li>
<li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占 1，老年代占 4，新生代占整个堆的 1&#x2F;5</li>
</ul>
<p>在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 8：1：1，当然开发人员可以通过选项“<code>-xx:SurvivorRatio</code>”调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></p>
<p>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。绝大部分的 Java 对象的销毁都在新生代进行了。</p>
<ul>
<li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的。</li>
</ul>
<p>可以使用选项”<code>-Xmn</code>“设置新生代最大内存大小，这个参数一般使用默认值就可以了。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/31fd90d99565ec8ce0682a4468076f94.png&sign=cd05c98ecd1265a13961f2777f983c2f38eda44f721086b6892cdcaaf3e73bd0"></p>
<h1 id="2-图解对象分配过程"><a href="#2-图解对象分配过程" class="headerlink" title="2 图解对象分配过程"></a>2 图解对象分配过程</h1><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li>new 的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者 0 区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是 15 次。<ul>
<li>可以设置参数：进行设置<code>-Xx:MaxTenuringThreshold= N</code></li>
</ul>
</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutofMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/9d588ca1c3495a21ada5b7fce89c6633.png&sign=1cf6c4f70922dcfcdb47c8d60f9f3ca734a7fbd9f3b2753415f98e12fb829775"></p>
<p><strong>流程图</strong></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/23b91eb543fc0072cb628365267f0089.png&sign=dbdd8780f4c44368ad169312299c5c187850c14f39329c1e7e615233110036ea"></p>
<p><strong>总结</strong></p>
<ul>
<li>针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是 to</li>
<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>
</ul>
<p><strong>常用调优工具（在 JVM 下篇：性能监控与调优篇会详细介绍）</strong></p>
<ul>
<li>JDK 命令行</li>
<li>Eclipse:Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofiler</li>
<li>Java Flight Recorder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
<h1 id="3-GC回收机制概览-Minor-GC-x2F-MajorGC-x2F-Full-GC"><a href="#3-GC回收机制概览-Minor-GC-x2F-MajorGC-x2F-Full-GC" class="headerlink" title="3 GC回收机制概览(Minor GC&#x2F;MajorGC&#x2F;Full GC)"></a>3 GC回收机制概览(Minor GC&#x2F;MajorGC&#x2F;Full GC)</h1><h2 id="3-1-总体概述"><a href="#3-1-总体概述" class="headerlink" title="3.1 总体概述"></a>3.1 总体概述</h2><p>JVM 在进行 GC 时，并非每次都对上面三个内存区域(新生代、老年代、方法区(元空间&#x2F;永久代))一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对 Hotspot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
<ul>
<li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代的垃圾收集</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的圾收集。<ul>
<li>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆<font style="background-color:#FFEC3D;">回收。</font><font style="background-color:#FFEC3D;">同时，目前只有 CMSGC 会有单独收集老年代的行为。</font></li>
</ul>
</li>
<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有 G1 GC 会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</li>
</ul>
<h2 id="3-2-年轻代-GC-Minor-GC-触发机制"><a href="#3-2-年轻代-GC-Minor-GC-触发机制" class="headerlink" title="3.2 年轻代 GC(Minor GC)触发机制"></a>3.2 年轻代 GC(Minor GC)触发机制</h2><ul>
<li>当年轻代空间不足时，就会触发 MinorGC，这里的年轻代满指的是 Eden 代满，<font style="background-color:#FADB14;">Survivor 满不会引发 GC。（每次 Minor GC 会清理年轻代的内存，即会一次性清理Eden和Survivor。Survivor区是被动收集的）</font></li>
<li>因为Java 对象大多都具备朝生夕灭的特性.，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC 会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
</ul>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/29146da9c1f3a3241d52201641899020.png&sign=8c1faa32aa7e08b57b26eecb06ece609e711428b9cc8a79edc3a5562c63159cd"></p>
<h2 id="3-3-老年代-GC-Major-GC-x2F-Full-GC-触发机制"><a href="#3-3-老年代-GC-Major-GC-x2F-Full-GC-触发机制" class="headerlink" title="3.3 老年代 GC(Major GC &#x2F; Full GC)触发机制"></a>3.3 老年代 GC(Major GC &#x2F; Full GC)触发机制</h2><ul>
<li>指发生在老年代的 GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了</li>
<li>出现了 Major Gc，经常会伴随至少一次的 Minor GC（但非绝对的，在 Paralle1 Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）<ul>
<li>也就是在老年代空间不足时，会先尝试触发 Minor Gc。如果之后空间还不足，则触发 Major GC</li>
</ul>
</li>
<li>Major GC 的速度一般会比 Minor GC 慢 10 倍以上，STW 的时间更长</li>
<li>如果 Major GC 后，内存还不足，就报 OOM 了</li>
</ul>
<h2 id="3-4-Full-GC-触发机制-后面细讲"><a href="#3-4-Full-GC-触发机制-后面细讲" class="headerlink" title="3.4 Full GC 触发机制(后面细讲)"></a>3.4 Full GC 触发机制(后面细讲)</h2><p>触发 Full GC 执行的情况有如下五种：</p>
<ol>
<li>调用 System.gc()时，系统建议执行 Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li>
<li>由 Eden 区、survivor space0（From Space）区向 survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p>
<h1 id="4-堆空间分代与提升策略"><a href="#4-堆空间分代与提升策略" class="headerlink" title="4 堆空间分代与提升策略"></a>4 堆空间分代与提升策略</h1><h2 id="4-1-堆空间分代思想"><a href="#4-1-堆空间分代思想" class="headerlink" title="4.1 堆空间分代思想"></a>4.1 堆空间分代思想</h2><p>为什么要把 Java 堆分代？不分代就不能正常工作了吗？</p>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有 Eden、两块大小相同的 survivor（又称为 from&#x2F;to，s0&#x2F;s1）构成，to 总为空。</li>
<li>老年代：存放新生代中经历多次 GC 仍然存活的对象。</li>
</ul>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/d776de4eb3a801b6e271b3f870317aa1.png&sign=018e0fce214c99f1a0f0732182beb2d09320315ccfa9e40d59dc4d88cadde147"></p>
<p>其实不分代完全可以，分代的唯一理由就是优化 GC 性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/9b5ad9b0a881973d2955e61f7ebed160.png&sign=f9214ee16adc8f698100c6527372438c563bd552ca7119cef52bcf13ee0332d5"></p>
<h2 id="4-2-堆内存分配-提升-策略"><a href="#4-2-堆内存分配-提升-策略" class="headerlink" title="4.2 堆内存分配(提升)策略"></a>4.2 堆内存分配(提升)策略</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 survivor 空间中，并将对象年龄设为 1。对象在 survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代</p>
<p>对象晋升老年代的年龄阀值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到 Eden</li>
<li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断：如果 survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li>
<li>空间分配担保： <code>-XX:HandlePromotionFailure</code></li>
</ul>
<h1 id="5-为对象分配内存：TLAB"><a href="#5-为对象分配内存：TLAB" class="headerlink" title="5 为对象分配内存：TLAB"></a>5 为对象分配内存：TLAB</h1><h2 id="5-1-为什么有-TLAB（Thread-Local-Allocation-Buffer）？"><a href="#5-1-为什么有-TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="5.1 为什么有 TLAB（Thread Local Allocation Buffer）？"></a>5.1 为什么有 TLAB（Thread Local Allocation Buffer）？</h2><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h2 id="5-2-什么是-TLAB？"><a href="#5-2-什么是-TLAB？" class="headerlink" title="5.2 什么是 TLAB？"></a>5.2 什么是 TLAB？</h2><ul>
<li>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。</li>
<li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</li>
<li>据我所知所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990753068-d1f9e98a-fb52-4151-9188-cece9b8c6756.png"></p>
<h2 id="5-3-TLAB-的再说明"><a href="#5-3-TLAB-的再说明" class="headerlink" title="5.3 TLAB 的再说明"></a>5.3 TLAB 的再说明</h2><ul>
<li>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但JVM 确实是将 TLAB 作为内存分配的首选。</li>
<li>在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启 TLAB 空间。</li>
<li>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，当然我们可以通过选项 “<code>-XX:TLABWasteTargetPercent</code>” 设置 TLAB 空间所占用 Eden 空间的百分比大小。</li>
<li>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990753582-fb485207-15c5-465d-a5d5-ffe702e8f1ca.png"></p>
<h1 id="9-小结：堆空间的参数设置"><a href="#9-小结：堆空间的参数设置" class="headerlink" title="9. 小结：堆空间的参数设置"></a>9. 小结：堆空间的参数设置</h1><p>官网地址：<a href="ca4119c40ca1bd32640aaa12f7ab6b64">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 详细的参数内容会在JVM下篇：性能监控与调优篇中进行详细介绍，这里先熟悉下</span></span><br><span class="line">-XX:+PrintFlagsInitial  <span class="comment">//查看所有的参数的默认初始值</span></span><br><span class="line">-XX:+PrintFlagsFinal  <span class="comment">//查看所有的参数的最终值（可能会存在修改，不再是初始值）</span></span><br><span class="line">-Xms  <span class="comment">//初始堆空间内存（默认为物理内存的1/64）</span></span><br><span class="line">-Xmx  <span class="comment">//最大堆空间内存（默认为物理内存的1/4）</span></span><br><span class="line">-Xmn  <span class="comment">//设置新生代的大小。（初始值及最大值）</span></span><br><span class="line">-XX:NewRatio  <span class="comment">//配置新生代与老年代在堆结构的占比</span></span><br><span class="line">-XX:SurvivorRatio  <span class="comment">//设置新生代中Eden和S0/S1空间的比例</span></span><br><span class="line">-XX:MaxTenuringThreshold  <span class="comment">//设置新生代垃圾的最大年龄</span></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">//输出详细的GC处理日志</span></span><br><span class="line"><span class="comment">//打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</span></span><br><span class="line">-XX:HandlePromotionFalilure：<span class="comment">//是否设置空间分配担保</span></span><br></pre></td></tr></table></figure>

<p>在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<ul>
<li>如果大于，则此次 Minor GC 是安全的</li>
<li>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允担保失败。<ul>
<li>如果<code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul>
<li>如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的；</li>
<li>如果小于，则改为进行一次 Full GC。</li>
</ul>
</li>
<li>如果<code>HandlePromotionFailure=false</code>，则改为进行一次 Full Gc。</li>
</ul>
</li>
</ul>
<p>在 JDK6 Update24 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 openJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 FullGC。</p>
<h1 id="10-堆是分配对象的唯一选择么？"><a href="#10-堆是分配对象的唯一选择么？" class="headerlink" title="10. 堆是分配对象的唯一选择么？"></a>10. 堆是分配对象的唯一选择么？</h1><p>在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述：</p>
<blockquote>
<p>随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
</blockquote>
<p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p>
<h2 id="10-1-逃逸分析概述"><a href="#10-1-逃逸分析概述" class="headerlink" title="10.1 逃逸分析概述"></a>10.1 逃逸分析概述</h2><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
<p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<p><strong>举例 1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法如果想要<code>StringBuffer sb</code>不发生逃逸，可以这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举例 2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数设置</strong></p>
<p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</p>
<p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li>选项“<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析</li>
<li>通过选项“<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果</li>
</ul>
<p><strong>结论</strong>：开发中能使用局部变量的，就不要使用在方法外定义。</p>
<h2 id="10-2-逃逸分析：代码优化"><a href="#10-2-逃逸分析：代码优化" class="headerlink" title="10.2 逃逸分析：代码优化"></a>10.2 逃逸分析：代码优化</h2><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p>一、栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p>
<p>二、同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>三、分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。</p>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p><strong>常见的栈上分配的场景</strong></p>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>
<h4 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h4><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对 hellis 这个对象加锁，但是 hellis 对象的生命周期只在 f()方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉，优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，经过标量替换后，就会变成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。</p>
<p><strong>标量替换参数设置</strong></p>
<p>参数<code>-XX:EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配到栈上。</p>
<p>上述代码在主函数中进行了 1 亿次 alloc。调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure>

<p>这里设置参数如下：</p>
<ul>
<li>参数<code>-server</code>：启动 Server 模式，因为在 server 模式下，才可以启用逃逸分析。</li>
<li>参数<code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</li>
<li>参数<code>-Xmx10m</code>：指定了堆空间最大为 10MB</li>
<li>参数<code>-XX:+PrintGC</code>：将打印 Gc 日志</li>
<li>参数<code>-XX:+EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ul>
<h2 id="10-3-逃逸分析小结：逃逸分析并不成熟"><a href="#10-3-逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="10.3 逃逸分析小结：逃逸分析并不成熟"></a>10.3 逃逸分析小结：逃逸分析并不成熟</h2><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟。</p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</p>
<p>注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里<font style="background-color:#FADB14;">已经说明，所以可以明确</font><font style="background-color:#FADB14;">所有的对象实例都是创建在堆上</font><font style="background-color:#FADB14;">(性能优化来自于标量替换)。</font></p>
<p>目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>老年代放置长生命周期的对象，通常都是从 survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 MinorGc。</p>
<p>当 GC 发生在老年代时则被称为 MajorGc 或者 FullGC。一般的，MinorGc 的发生频率要比 MajorGC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>07 方法区</title>
    <url>/2023/08/21/07%20%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="1-方法区概述"><a href="#1-方法区概述" class="headerlink" title="1. 方法区概述"></a>1. 方法区概述</h1><h2 id="1-1-在内存中的概览"><a href="#1-1-在内存中的概览" class="headerlink" title="1.1 在内存中的概览"></a>1.1 在内存中的概览</h2><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/b802b35c3936900c290f8ad123e68b9b.png&sign=17315fbaf650cd673a0379e3980560b72b4a7b47347cb57a0361ea479d29399b"></p>
<p>从线程共享与否的角度来看</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/f356e103d9f75e3c0086079bba2b28a9.png&sign=bdeb9e8e597b17589e36c323949edfdc95a72918c823be059b76dde4ce6075a5"></p>
<span id="more"></span>
<h2 id="1-2-栈、堆、方法区的交互关系"><a href="#1-2-栈、堆、方法区的交互关系" class="headerlink" title="1.2 栈、堆、方法区的交互关系"></a>1.2 栈、堆、方法区的交互关系</h2><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/b9f11764ee47b28d37f7764dfd9c9f55.png&sign=557b3437e2e5d640ac7aa68b8ac8266530f9a11a761e4d739e668d24cbd8b0cd"></p>
<h2 id="1-3-方法区的官方理解"><a href="#1-3-方法区的官方理解" class="headerlink" title="1.3 方法区的官方理解"></a>1.3 方法区的官方理解</h2><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990769501-250ecdbc-e57a-4c61-a0db-215d28ca8448.png"></p>
<h2 id="1-4-方法区在哪里？"><a href="#1-4-方法区在哪里？" class="headerlink" title="1.4 方法区在哪里？"></a>1.4 方法区在哪里？</h2><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 HotSpotJVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。&#x2F;&#x2F;&#x2F;台湾从逻辑是属于中华人民共和国的一部分，但是现实上又是没有完全统一的。</p>
<p>所以，方法区看作是一块独立于 Java 堆的内存空间。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/6a7f2350e0f4e0cde0ac246225e2acdd.png&sign=be559f98dd5c0b6f9e4206164521f3df85cd55367a5584a9ec14265dab86818b"></p>
<h2 id="1-5-方法区的基本理解"><a href="#1-5-方法区的基本理解" class="headerlink" title="1.5 方法区的基本理解"></a>1.5 方法区的基本理解</h2><ul>
<li>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域。</li>
<li>方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>**<font style="background-color:#FFEC3D;">方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出</font>**，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMemoryError: PermGen space</code> 或者<code>java.lang.OutOfMemoryError: Metaspace</code><ul>
<li>加载大量的第三方的 jar 包；Tomcat 部署的工程过多（30~50 个）；大量动态的生成反射类</li>
</ul>
</li>
<li>关闭 JVM 就会释放这个区域的内存。</li>
</ul>
<h2 id="1-6-HotSpot-中方法区的演进"><a href="#1-6-HotSpot-中方法区的演进" class="headerlink" title="1.6 HotSpot 中方法区的演进"></a>1.6 HotSpot 中方法区的演进</h2><p>在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代。方法区是规范或约束或接口，永久代和元空间是具体的实现。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990769338-b2418855-775e-4768-b0ee-18cf4681c4ea.png"></p>
<p>本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。《Java 虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit &#x2F; IBM J9 中不存在永久代的概念。</p>
<p>现在来看，当年使用永久代，不是好的 idea。导致 Java 程序更容易 OOM（超过<code>-XX:MaxPermsize</code>上限）</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/7d0789c206d53bfb4b6004052236197a.png&sign=567ecbf2e4e9a16f4421ef6297e1f4fdef0ac4dc04bdc7d37bbce3ad3413a525"></p>
<p>而到了 JDK8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Metaspace）来代替</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/1c229dc39ffc79e8e4f3abf765378d3b.png&sign=fb55aa45af640007aabf83680ac18c36c8c098af8dc3869dee62a6645ce509fe"></p>
<p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p>
<p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p>
<p>根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常</p>
<h1 id="2-设置方法区大小与-OOM"><a href="#2-设置方法区大小与-OOM" class="headerlink" title="2 设置方法区大小与 OOM"></a>2 设置方法区大小与 OOM</h1><h2 id="2-1-设置方法区内存的大小"><a href="#2-1-设置方法区内存的大小" class="headerlink" title="2.1. 设置方法区内存的大小"></a>2.1. 设置方法区内存的大小</h2><p>方法区的大小不必是固定的，JVM 可以根据应用的需要动态调整。</p>
<p><strong>jdk7 及以前</strong></p>
<ul>
<li>通过来设置永久代初始分配空间。默认值是 20.75M<code>-XX:Permsize</code></li>
<li>通过来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器模式是 82M<code>-XX:MaxPermsize</code></li>
<li>当 JVM 加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code>。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990769402-9d1ed641-8e26-4fd5-993f-3b3d1823d83c.png"></p>
<p><strong>JDK8 以后</strong></p>
<ul>
<li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</li>
<li>默认值依赖于平台。windows 下，<code>-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制</code>。</li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></li>
<li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的<code>-XX:MetaspaceSize</code>值为 21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li>
</ul>
<p><strong>举例 1：《深入理解 Java 虚拟机》的例子</strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990769372-3afb2eb8-c6ba-438b-aecd-9c1905ac61ec.png"></p>
<p><strong>举例 2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m-XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                <span class="comment">//创建Classwriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, nu1l, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">//CLass对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-如何解决这些-OOM"><a href="#2-2-如何解决这些-OOM" class="headerlink" title="2.2. 如何解决这些 OOM"></a>2.2. 如何解决这些 OOM</h2><ol>
<li>要解决 OOM 异常或 heap space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GCRoots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GCRoots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（<code>-Xmx</code>与<code>-Xms</code>），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h1 id="3-方法区的内部结构"><a href="#3-方法区的内部结构" class="headerlink" title="3 方法区的内部结构"></a>3 方法区的内部结构</h1><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/8a5fcba10ccb773f185288ac22bde206.png&sign=f207e3ba26cc318f13b81e5de35283716f3d15cf733ac094e374d70f2c4c07fd"></p>
<h2 id="3-1-方法区（Method-Area）存储什么？"><a href="#3-1-方法区（Method-Area）存储什么？" class="headerlink" title="3.1. 方法区（Method Area）存储什么？"></a>3.1. 方法区（Method Area）存储什么？</h2><p>《深入理解 Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：</p>
<blockquote>
<p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
</blockquote>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/fbe3915506e7979c7d591d17c216fbb1.png&sign=720c93b72dfc0413e55529c1faddb7de5211c9c1b8ba5b95a5673e76836d4f85"></p>
<h2 id="3-2-方法区的内部结构"><a href="#3-2-方法区的内部结构" class="headerlink" title="3.2. 方法区的内部结构"></a>3.2. 方法区的内部结构</h2><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient 的某个子集）</p>
<h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ol>
<li>方法名称</li>
<li>方法的返回类型（或 void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ol>
<h4 id="non-final-的类变量"><a href="#non-final-的类变量" class="headerlink" title="non-final 的类变量"></a>non-final 的类变量</h4><ul>
<li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li>
<li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="补充说明：全局常量（static-final）"><a href="#补充说明：全局常量（static-final）" class="headerlink" title="补充说明：全局常量（static final）"></a>补充说明：全局常量（static final）</h4><p>被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>
<h2 id="3-3-常量池-符号引用-VS运行时常量池-符号引用-gt-字节引用"><a href="#3-3-常量池-符号引用-VS运行时常量池-符号引用-gt-字节引用" class="headerlink" title="3.3 常量池(符号引用)VS运行时常量池(符号引用-&gt;字节引用)"></a>3.3 常量池(符号引用)VS运行时常量池(符号引用-&gt;字节引用)</h2><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/7ec9b450764c623c89e7de7e0d3c8d19.png&sign=ea83930daa9fd52dc91f72eea0428c7667e49f78d110794451026048fd1ede22"></p>
<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚 ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。</li>
</ul>
<p>官方文档：<a href="7c43ac48a322b645928a72bb499035e1">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/be6d675673b353a266d48df43b0411f4.png&sign=b3664362f0adfa2a0c071c0bae4a5d61a1fd341684f00046c3e415b56381ae09"></p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p>
<h4 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h4><p>一个 java 源文件中的类、接口，编译后产生一个字节码文件。<font style="background-color:#FADB14;">而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池</font>，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p>
<p>常量池：原料库，具体的方法：实际的一道菜品。</p>
<p>比如：如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然只有 194 字节，但是里面却使用了 String、System、PrintStream 及 Object 等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990769368-f1791bb3-c11b-412b-8cd0-530f010ec729.png"></p>
<h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么?"></a>常量池中有什么?</h4><p>击中常量池内存储的数据类型包括：</p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>例如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Object obj = new Object();</code>将会被翻译成如下字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span> #<span class="number">2</span>  <span class="comment">// Class java/lang/Object</span></span><br><span class="line"><span class="number">1</span>: dup</span><br><span class="line"><span class="number">2</span>: invokespecial <span class="comment">// Method java/lang/Object &quot;&lt;init&gt;&quot;() V</span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p>
<h2 id="3-4-运行时常量池"><a href="#3-4-运行时常量池" class="headerlink" title="3.4. 运行时常量池"></a>3.4. 运行时常量池</h2><ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li>
<li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li><font style="background-color:#FADB14;">JVM 为每个已加载的类型（类或接口）都维护一个常量池</font>(<strong>炒菜-&gt;原料表</strong>)。池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li>
<li>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性。</li>
<li>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li>
</ul>
<h1 id="4-方法区使用举例"><a href="#4-方法区使用举例" class="headerlink" title="4 方法区使用举例"></a>4 方法区使用举例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/b5b9e7f8efd1cf8e889650cea5318b61.png&sign=2ecea5db89d02c368293b91d19634130e0feae1bc12c24d448444289ca7ff5f4"></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/84396fa6be6164ffc54868e78c59dde6.png&sign=9b5a195741ff13da7ffd1f9ad88b887fd274cf27e3d2ee142f20da5ab6c50fd4"></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/2214af3dfe294eec73899c935589f569.png&sign=ed205127054ca472287e597ea421574946b095c310326d61b75e3ca4e467381b"></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/64b6b95d37e97205b2f23a089addf321.png&sign=249fef6fa83e321265919f06addf9d012afe3a8affb9d262becea25763e0d5e5"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990769903-97dddd58-aa21-4484-bc97-c89a65e496b3.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990769910-436dd63b-9500-4c62-818f-d66031f9b752.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990770023-9f33be0b-4a30-47a7-927b-cb93f0a97359.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990770071-87c7c58a-854b-4171-a3e0-7acd27a981eb.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990769984-472f00c2-c854-49bf-8c78-a1d7acd23c29.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990770436-2734717e-cd66-4afa-8514-41e2f9da6354.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990770420-23f53f68-898c-480d-94f9-3fe7c64541af.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990770749-887ab64e-95cb-4ee1-b5bb-536bbb259b6c.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990770688-7c08ded1-463e-4a25-ae99-362a03755409.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990770753-1b417932-f100-4c8e-bd7c-241880b11567.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990770974-7c9360ff-4fd9-4750-94c2-4a1f7f76c410.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990771063-3a1b80fd-0b83-4e92-b045-58007d412459.png"></p>
<h1 id="5-方法区的演进细节"><a href="#5-方法区的演进细节" class="headerlink" title="5 方法区的演进细节"></a>5 方法区的演进细节</h1><ol>
<li>首先明确：只有 Hotspot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java 虚拟机规范》管束，并不要求统一</li>
<li>Hotspot 中方法区的变化：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">JDK1.6 及之前</th>
<th align="left">有永久代（permanet），静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>JDK1.7</strong></td>
<td align="left"><strong>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td align="left"><strong>JDK1.8</strong></td>
<td align="left"><strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</strong></td>
</tr>
</tbody></table>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990771167-145ae043-14ad-4429-943b-2af41bd34ed2.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990771381-c2ce9135-032a-4b38-ab1a-04f03c88946d.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990771379-7374f1aa-e372-45fc-95a7-8c11bc7e713d.png"></p>
<h2 id="5-1-为什么永久代要被元空间替代？"><a href="#5-1-为什么永久代要被元空间替代？" class="headerlink" title="5.1 为什么永久代要被元空间替代？"></a>5.1 为什么永久代要被元空间替代？</h2><p>官网地址：<a href="http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation (java.net)</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990771439-d4c2c2b1-6ff9-4d17-aef6-e462ec9a7a65.png"></p>
<p>JRockit 是和 HotSpot 融合后的结果，因为 JRockit 没有永久代，所以他们不需要配置永久代</p>
<p>随着 Java8 的到来，HotSpot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p>
<p>这项改动是很有必要的，原因有：</p>
<ul>
<li>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生 Perm 区的 oom。比如某个实际 Web 工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Exception in thread &#x27;dubbo client x.x connector&#x27; java.lang.OutOfMemoryError:PermGen space&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li>
<li>对永久代进行调优是很困难的。</li>
</ul>
<p>有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p>
<h2 id="5-2-StringTable-为什么要调整位置？"><a href="#5-2-StringTable-为什么要调整位置？" class="headerlink" title="5.2 StringTable 为什么要调整位置？"></a>5.2 StringTable 为什么要调整位置？</h2><p>jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h2 id="5-3-静态变量存放在那里？"><a href="#5-3-静态变量存放在那里？" class="headerlink" title="5.3 静态变量存放在那里？"></a>5.3 静态变量存放在那里？</h2><p><font style="background-color:#FADB14;">note：静态引用对应的对象实体始终都存在堆空间</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态引用对应的对象实体始终都存在堆空间</span></span><br><span class="line"><span class="comment"> * jdk7:</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk8:</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m-XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * staticobj、instanceobj、Localobj存放在哪里？ */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticobjTest</span> &#123;    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();        <span class="type">ObjectHolder</span> <span class="variable">instanceobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;            <span class="type">ObjectHolder</span> <span class="variable">localobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();            System.out.println(<span class="string">&quot;done&quot;</span>);        &#125;        &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span>&#123;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;            <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticobjTest</span>.Test();            test.foo();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 JHSDB 工具进行分析，这里细节略掉</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990771673-068f8119-f664-4b39-a5e5-88215016cf64.png"></p>
<p>staticobj 随着 Test 的类型信息存放在方法区，instanceobj 随着 Test 的对象实例存放在 Java 堆，localobject 则是存放在 foo()方法栈帧的局部变量表中。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990771679-8ad24684-58f5-42c5-a6e7-d1169f2f9d02.png"></p>
<p>测试发现：三个对象的数据在内存中的地址都落在 Eden 区范围内，所以结论：只要是对象实例必然会在 Java 堆中分配。</p>
<p>接着，找到了一个引用该 staticobj 对象的地方，是在一个 java.lang.Class 的实例里，并且给出了这个实例的地址，通过 Inspector 查看该对象实例，可以清楚看到这确实是一个 java.lang.Class 类型的对象实例，里面有一个名为 staticobj 的实例字段：</p>
<p>从《Java 虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 class 对象存放在一起，存储于 Java 堆之中，从我们的实验中也明确验证了这一点</p>
<h1 id="6-方法区的垃圾回收"><a href="#6-方法区的垃圾回收" class="headerlink" title="6 方法区的垃圾回收"></a>6 方法区的垃圾回收</h1><p>有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 zGC 收集器就不支持类卸载）。</p>
<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>回收废弃常量与回收 Java 堆中的对象非常类似。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息</p>
<p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，<u>通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</u>。</p>
<h1 id="10-总结与面试"><a href="#10-总结与面试" class="headerlink" title="10 总结与面试"></a>10 总结与面试</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990771865-26015be6-4424-4d34-9897-877d09e5578b.png"></p>
<p><strong>常见面试题</strong></p>
<blockquote>
<p>百度：</p>
<p>说一下 JVM 内存模型吧，有哪些区？分别干什么的？</p>
<p>蚂蚁金服：</p>
<p>Java8 的内存分代改进 JVM 内存分哪几个区，每个区的作用是什么？</p>
<p>一面：JVM 内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个 survivor 区？</p>
<p>二面：Eden 和 survior 的比例分配</p>
<p>小米：</p>
<p>jvm 内存分区，为什么要有新生代和老年代</p>
<p>字节跳动：</p>
<p>二面：Java 的内存分区</p>
<p>二面：讲讲 vm 运行时数据库区 什么时候对象会进入老年代？</p>
<p>京东：</p>
<p>JVM 的内存结构，Eden 和 Survivor 比例。</p>
<p>JVM 内存为什么要分成新生代，老年代，持久代。</p>
<p>新生代中为什么要分为 Eden 和 survivor。</p>
<p>天猫：</p>
<p>一面：Jvm 内存模型以及分区，需要详细到每个区放什么。</p>
<p>一面：JVM 的内存模型，Java8 做了什么改</p>
<p>拼多多：</p>
<p>JVM 内存分哪几个区，每个区的作用是什么？</p>
<p>美团：</p>
<p>java 内存分配 jvm 的永久代中会发生垃圾回收吗？</p>
<p>一面：jvm 内存分区，为什么要有新生代和老年代？</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>08 对象在内存中的动静形态</title>
    <url>/2023/08/22/08%20%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%8A%A8%E9%9D%99%E5%BD%A2%E6%80%81/</url>
    <content><![CDATA[<h1 id="1-对象实例化的过程"><a href="#1-对象实例化的过程" class="headerlink" title="1 对象实例化的过程"></a>1 对象实例化的过程</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990813210-944f9556-5cff-432e-afc9-2741b812f0f1.png"></p>
<span id="more"></span>
<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ul>
<li>new：最常见的方式、Xxx 的静态方法，XxxBuilder&#x2F;XxxFactory 的静态方法</li>
<li>Class 的 newInstance 方法：反射的方式，只能调用空参的构造器，权限必须是 public</li>
<li>Constructor 的 newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li>
<li>使用 clone()：不调用任何的构造器，要求当前的类需要实现 Cloneable 接口，实现 clone()</li>
<li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li>
<li>第三方库 Objenesis</li>
</ul>
<h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><p>前面所述是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析：</p>
<hr>
<p><strong>Step1 判断对象对应的类是否加载、链接、初始化</strong></p>
<p>虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p>
<p>如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 key 进行查找对应的 .class 文件；</p>
<ul>
<li>如果没有找到文件，则抛出 ClassNotFoundException 异常</li>
<li>如果找到，则进行类加载，并生成对应的 Class 对象</li>
</ul>
<hr>
<p><strong>Step2 为对象分配内存</strong></p>
<p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小。</p>
<ul>
<li>如果内存规整：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。</li>
</ul>
<p>如果垃圾收集器选择的是 Serial ，ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。</p>
<ul>
<li>如果内存不规整：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li>
</ul>
<p>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</p>
<p>选择哪种分配方式由 Java 堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<hr>
<p><strong>Step3 处理并发问题</strong></p>
<ul>
<li>采用 CAS 失败重试、区域加锁保证更新的原子性。</li>
<li>每个线程预先分配一块 TLAB：通过设置 <code>-XX:+UseTLAB</code>参数来设定</li>
<li>注意：这一步骤和Step2是一起的，即在对象分配内存的过程中就要处理并发的问题。</li>
</ul>
<hr>
<p><strong>Step4 初始化分配到的内存</strong></p>
<p>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p>
<hr>
<p><strong>Step5 设置对象的对象头</strong></p>
<p>将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。</p>
<hr>
<p><strong>Step6 执行 init 方法进行显性初始化</strong></p>
<p>在 Java 程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说（由字节码中跟随 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">扩展：属性赋值的先后顺序：类型默认初始化（<span class="type">int</span>值为<span class="number">0</span>）（第一步）-&gt;显示初始化值和代码块顺序执行（第二步）-&gt;构造器中初始化（第三步）-&gt;方法手动更改设置</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">int</span> age=<span class="number">21</span>;<span class="comment">//第二步</span></span><br><span class="line">	&#123;</span><br><span class="line">		age=<span class="number">22</span>;<span class="comment">//第二步：显示初始化和代码块内顺序执行，谁先在前面谁先执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	Person()&#123;</span><br><span class="line">		age=<span class="number">3</span>;<span class="comment">//第三步</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：对象实例化的过程</strong></p>
<ol>
<li>加载类元信息</li>
<li>为对象分配内存</li>
<li>处理并发问题</li>
<li>属性的默认初始化（零值初始化）</li>
<li>设置对象头信息</li>
<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>
</ol>
<p>简记：加载类元信息（加）-&gt;内存分配（内）-&gt;并发问题处理（并-&gt;特）-&gt;属性零值初始化（零值-&gt;光）-&gt;对象头设置（头）-&gt;init初始化包括属性显示初始化&amp;代码块中初始化&amp;构造器中初始化（显性）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象在 JVM 中是怎么存储的？</span><br><span class="line">对象头信息里面有哪些东西？</span><br><span class="line">Java 对象头有什么？</span><br></pre></td></tr></table></figure>

<h1 id="2-对象在堆内存中的存储布局"><a href="#2-对象在堆内存中的存储布局" class="headerlink" title="2 对象在堆内存中的存储布局"></a>2 对象在堆内存中的存储布局</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><p><font style="color:rgb(77, 77, 77);">对象内部结构分为：对象头、实例数据、对齐填充（保证8个字节的倍数）。</font><strong><font style="background-color:#FFEC3D;">对象，HI，Padding</font></strong><font style="background-color:#FFEC3D;">。Header、InstanceData、Padding，其中Header&#x3D;&gt;MK：MarkWord+KlassPointer。</font></p>
<p>参考文章：<a href="https://blog.csdn.net/TZ845195485/article/details/118142823">对象在堆内存的存储布局</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645358338190-1e9ca9dc-96cd-4578-b1cf-a4ad69544722.png"></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">语句：</font><code>Object obj=&lt;font style=&quot;color:#cc7832;&quot;&gt;new &lt;/font&gt;Object()&lt;font style=&quot;color:#cc7832;&quot;&gt;;&lt;/font&gt;</code>在内存里面创建的空Object对象占据16个字节数据。</li>
<li>如果类存在继承，父类的实例属性会出现在当前类实例数据的最前面。</li>
</ul>
<h2 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h2><h3 id="对象头有多大"><a href="#对象头有多大" class="headerlink" title="对象头有多大"></a>对象头有多大</h3><ul>
<li>普通的Java对象头包含对象标记（Mark Word）和类型指针。在64位系统中，MarkWord占了8个字节，类型指针占了8个字节，一共16个字节。</li>
<li>如果是数组对象，还需要记录数组的长度（4个Byte字节位置）。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645340755411-7795447a-e495-4e32-975c-5b8461f5ed0e.png"></p>
<h3 id="对象标记MarkWord"><a href="#对象标记MarkWord" class="headerlink" title="对象标记MarkWord"></a>对象标记MarkWord</h3><ul>
<li><font style="color:#E8323C;">HGL对象头默认存储：哈希值（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等信息。</font>这些信息都是与对象自身定义无关的，所以MarkWord被设计成了一个非固定的数据结果以便在极小的空间内存储尽量多的数据。</li>
<li>具体存储的信息还会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位变化而变化。关于JVM锁升级就是更改的Header里面MarkWord各个标志位。</li>
<li>在64位系统中，MarkWord占了64Bit，合计8 Byte。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645341780908-66f4e840-6adc-4334-9d59-0679238be86e.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645341788045-9dcb602e-bdae-40c1-8a3d-0d070da9561e.png"></p>
<h3 id="类型指针KlassPointer"><a href="#类型指针KlassPointer" class="headerlink" title="类型指针KlassPointer"></a>类型指针KlassPointer</h3><p><font style="color:rgba(0, 0, 0, 0.75);">对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例</font></p>
<h2 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h2><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的属性字段（Field）数据信息，<font style="color:#E8323C;">也包括从父类继承下来的和本身拥有的字段</font>。</p>
<ul>
<li>相同宽度的字段总是被分配在一起</li>
<li><font style="color:#E8323C;">父类中定义的变量会出现在子类之前</font></li>
<li><font style="color:#E8323C;">各个变量的实例占据空间：引用类型（包括String、数组）：4bytes；int：4bytes；long：8bytes</font></li>
<li>如果 CompactFields 参数为 true（默认为 true）：子类的窄变量可能插入到父类变量的空隙</li>
<li>如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</li>
</ul>
<h2 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h2><ul>
<li><font style="color:rgb(77, 77, 77);">虚拟机要求对象起始地址必须是8字节的整数倍。</font></li>
<li><font style="color:rgb(77, 77, 77);">填充数据不是必须存在的仅仅是为了字节对齐。这部分内存按8字节补充对齐。</font>不是必须的，也没有特别的含义，仅仅起到占位符的作用。</li>
</ul>
<h2 id="案例与图示"><a href="#案例与图示" class="headerlink" title="案例与图示"></a>案例与图示</h2><p><strong>案例1：计算各对象的对象头大小</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 前提</span></span><br><span class="line">&lt;!--JAVA object layout。官网:http:<span class="comment">//openjdk.java.net/projects/code-tools/jol/。定位:分析对象在JVM的大小和分布 --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">0.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 JVM前提</span></span><br><span class="line">JVM需要去掉自动开启压缩指针功能：-XX:-UseCompressedClassPointers</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//测试3：测试单个对象的内存布局</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student student= <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.hashCode();</span><br><span class="line">        student.age=<span class="number">20</span>;</span><br><span class="line">        student.name=<span class="string">&quot;Fly&quot;</span>;</span><br><span class="line">        student.id=<span class="number">123</span>;</span><br><span class="line">        student.neighbor=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> Student neighbor;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：解析可再见下方截图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试4：测试数组的内存布局</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] student= <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(student).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//结果：解析可再见下方截图</span></span><br><span class="line">[Lfly.Student; object internals:</span><br><span class="line"> OFFSET  SIZE          TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>               (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>               (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>               (object header)                           <span class="number">80</span> <span class="number">39</span> b9 <span class="title function_">fb</span> <span class="params">(<span class="number">10000000</span> <span class="number">00111001</span> <span class="number">10111001</span> <span class="number">11111011</span>)</span> (-<span class="number">71747200</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>               (object header)                           cd <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">11001101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">461</span>)</span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>               (object header)                           <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000011</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">3</span>)</span><br><span class="line">     <span class="number">20</span>     <span class="number">4</span>               (alignment/padding gap)                  </span><br><span class="line">     <span class="number">24</span>    <span class="number">12</span>   fly.Student Student;.&lt;elements&gt;                       N/A</span><br><span class="line">     <span class="number">36</span>     <span class="number">4</span>               (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">40</span> bytes</span><br><span class="line">Space losses: <span class="number">4</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">8</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试5：单独new Object()空对象占据16个Byte.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> 1c 4b <span class="title function_">c4</span> <span class="params">(<span class="number">00000000</span> <span class="number">00011100</span> <span class="number">01001011</span> <span class="number">11000100</span>)</span> (-<span class="number">1001710592</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)                           <span class="number">34</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00110100</span> <span class="number">00000010</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">564</span>)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">0</span> bytes total</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试6：关于继承的关系说明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Teacher teacher=<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;Fly&quot;</span>,<span class="keyword">new</span> <span class="title class_">Teacher</span>());</span><br><span class="line">        System.out.println(teacher.HEIGHT);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(teacher).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> Teacher neighbor;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name,Teacher neighbor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.neighbor = neighbor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> HEIGHT=<span class="number">14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line">fly.Teacher object internals:</span><br><span class="line"> OFFSET  SIZE          TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>               (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>               (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>               (object header)                           <span class="number">18</span> 3b ba 7c (<span class="number">00011000</span> <span class="number">00111011</span> <span class="number">10111010</span> <span class="number">01111100</span>) (<span class="number">2092579608</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>               (object header)                           <span class="number">59</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01011001</span> <span class="number">00000010</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">601</span>)</span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>           <span class="type">int</span> Person.age                                <span class="number">0</span></span><br><span class="line">     <span class="number">20</span>     <span class="number">4</span>           <span class="type">int</span> Teacher.age                               <span class="number">0</span></span><br><span class="line">     <span class="number">24</span>     <span class="number">4</span>   fly.Teacher Teacher.neighbor                          (object)</span><br><span class="line">     <span class="number">28</span>     <span class="number">4</span>               (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">32</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<p>上方的截图说明</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645360510474-0348fba5-9450-4539-8738-07696e3fc35e.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645350754008-3c5b472c-d521-410c-8de5-bf1e31743b9c.png"></p>
<p>演示多类继承的对象内存效果</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1646707950518-6a3d106f-cc06-413c-a17d-949e1d65457a.png"></p>
<p>辅助上面打印的日志说明</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645348728616-bca94354-a787-4ac5-9b4a-1c2a1522267f.png"></p>
<p><strong>关于面向对象的多态与继承问题分析</strong></p>
<blockquote>
<p>扩展：从面向对象的角度分析（详见文档<a href="https://www.yuque.com/zhuyufei-x9kmd/zx2opk/zp6v6s">面向对象三大特性</a>）</p>
</blockquote>
<blockquote>
<ol>
<li>多态分为编译阶段和运行阶段，若编译时类型和运行时类型不一致，就出现了对象的多态性<ol>
<li>多态只针对子类重写的方法有效，在编译的时候，编译器看左边（<font style="background-color:#FBDE28;">所以在编译的时候变量就不能再访问子类中添加的属性和方法，编译器通不过</font>），运行的时候解释器看右边。</li>
</ol>
</li>
</ol>
<p>一定要注意：是子类重写的方法，如果子类有可变参数格式一样的但不是重写的，也不能访问。</p>
<pre><code>2. &lt;font style=&quot;background-color:#FCE75A;&quot;&gt;对于成员变量（属性），其不具备多态性。此时访问和使用属性，编译运行均看左边的类型。added  on 2023-04-04&lt;/font&gt;
</code></pre>
</blockquote>
<blockquote>
<p>例子：类Person有属性name，方法sayHello()，其子类Student也有同名的name和重写的sayHello()方法。如果<code>Person p=new Student();</code>此时p.name在运行时调用的是Person类的</p>
<p>name（因为属性没有多态），p.sayHello()在运行时调用的是Student子类的sayHello（只有方法才有多态性）。特别需要说的是：<code>Person p=new Student();</code>该语句变量p实际生成的是</p>
<p>Student对象，那么Student对象里面的所有属性和方法都在内存里，部分属性p不能使用到是因为编译器通不过的问题，不是内存的问题。</p>
<ol start="2">
<li>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。</li>
</ol>
<p>即：对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或”动态绑定”。</p>
<p><font style="color:#F5222D;">多态是编译时行为还是运行时行为？答案：运行时。</font></p>
</blockquote>
<p><strong>案例2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span> &#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>&#123;</span><br><span class="line">        Customer cust=<span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上的类在JVM内存分布的情况示意图</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1643169520817-c2bb29d3-aa52-4292-ad6c-907870f1baf2.png"></p>
<h2 id="补充：对象大小的计算（深堆和浅堆）"><a href="#补充：对象大小的计算（深堆和浅堆）" class="headerlink" title="补充：对象大小的计算（深堆和浅堆）"></a>补充：对象大小的计算（深堆和浅堆）</h2><p><a href="https://www.yuque.com/zhuyufei-x9kmd/npm5bq/f46ced8c42d4947c7f6e5c01822ed87b">补充：浅堆深堆与内存泄露</a></p>
<h1 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3 对象的访问定位"></a>3 对象的访问定位</h1><h2 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990812995-cca50ce2-4027-41b6-9f36-cf6a320f3b31.png"></p>
<p>JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990813054-fc75e846-091f-4c5a-889c-33b2cede7515.png"></p>
<h2 id="3-2-句柄访问"><a href="#3-2-句柄访问" class="headerlink" title="3.2 句柄访问"></a>3.2 句柄访问</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990813106-688483a9-a195-4a2b-81fe-572df055fea7.png"></p>
<p>reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改</p>
<h2 id="3-3-直接指针（HotSpot-采用）"><a href="#3-3-直接指针（HotSpot-采用）" class="headerlink" title="3.3 直接指针（HotSpot 采用）"></a>3.3 直接指针（HotSpot 采用）</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990813210-fe5d80e7-848d-4687-bf77-73435bbdb2e5.png"></p>
<p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>
<h1 id="4-直接内存（Direct-Memory）"><a href="#4-直接内存（Direct-Memory）" class="headerlink" title="4 直接内存（Direct Memory）"></a>4 直接内存（Direct Memory）</h1><h2 id="4-1-直接内存概述"><a href="#4-1-直接内存概述" class="headerlink" title="4.1 直接内存概述"></a>4.1 直接内存概述</h2><p>不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。直接内存是在 Java 堆外的、直接向系统申请的内存区间。来源于 NIO，通过存在堆中的 DirectByteBuffer 操作 Native 内存。通常，访问直接内存的速度会优于 Java 堆，即读写性能高。</p>
<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>
<li>Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区</li>
</ul>
<h2 id="4-2-非直接缓存区-使用IO"><a href="#4-2-非直接缓存区-使用IO" class="headerlink" title="4.2 非直接缓存区(使用IO)"></a>4.2 非直接缓存区(使用IO)</h2><p>使用 IO 读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990813538-8ebf0c4e-ae44-4f2e-a59c-0cc7981fe6d1.png"></p>
<h2 id="4-3-直接缓存区-使用NIO"><a href="#4-3-直接缓存区-使用NIO" class="headerlink" title="4.3 直接缓存区(使用NIO)"></a>4.3 直接缓存区(使用NIO)</h2><p>使用 NIO 时，操作系统划出的直接缓存区可以被 java 代码直接访问，只有一份。NIO 适合对大文件的读写操作。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990813597-68e3cb47-8000-4806-b252-236869732719.png"></p>
<p>也可能导致 OutOfMemoryError 异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">    at java.nio.Bits.reserveMemory(Bits.java:<span class="number">693</span>)</span><br><span class="line">    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">    at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>由于直接内存在 Java 堆外，因此它的大小不会直接受限于-Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
<ul>
<li>分配回收成本较高</li>
<li>不受 JVM 内存回收管理</li>
</ul>
<p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置。如果不指定，默认与堆的最大值-Xmx 参数值一致</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990813725-b30a93a1-f33a-4375-b060-d387d388e4f9.png"></p>
<p>java的进程空间约等于&#x3D;java的堆空间+本地内存（虚拟机栈等空间太小，此处忽略）</p>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>09 执行引擎</title>
    <url>/2023/08/23/09%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="1-机器码、指令、汇编语言"><a href="#1-机器码、指令、汇编语言" class="headerlink" title="1. 机器码、指令、汇编语言"></a>1. 机器码、指令、汇编语言</h1><h2 id="1-1-机器码"><a href="#1-1-机器码" class="headerlink" title="1.1 机器码"></a>1.1 机器码</h2><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p>
<p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p>
<p>用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p>
<p>机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同。</p>
<span id="more"></span>
<h2 id="1-2-指令"><a href="#1-2-指令" class="headerlink" title="1.2 指令"></a>1.2 指令</h2><p>由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令。</p>
<p>指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令（一般为英文简写，如 mov，inc 等），可读性稍好</p>
<p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同。</p>
<h2 id="1-3-指令集"><a href="#1-3-指令集" class="headerlink" title="1.3 指令集"></a>1.3 指令集</h2><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p>
<ul>
<li>x86 指令集，对应的是 x86 架构的平台</li>
<li>ARM 指令集，对应的是 ARM 架构的平台</li>
</ul>
<h2 id="1-4-汇编语言"><a href="#1-4-汇编语言" class="headerlink" title="1.4 汇编语言"></a>1.4 汇编语言</h2><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p>
<p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用&lt;mark 地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p>
<p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p>
<h2 id="1-5-高级语言"><a href="#1-5-高级语言" class="headerlink" title="1.5. 高级语言"></a>1.5. 高级语言</h2><p><strong><font style="background-color:#FADB14;">高级语言必须得先翻译成汇编语言(编译过程)</font></strong></p>
<hr>
<p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p>
<p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/c812403e1ebae81455d5276b884e5ca8.png&sign=8ad6cbcb536941ccdab4011d002970957999e70b3a99eddffc8d1259e5140f40"></p>
<p>高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码，如下面说的 C 和 C++</p>
<h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>
<p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/71d4298a250e724d64d78a2d8ec67cdc.png&sign=5cab970a612b7eca4466a0b10e388402a18a50590e2817f719195630d3d4599c"></p>
<h2 id="1-6-字节码"><a href="#1-6-字节码" class="headerlink" title="1.6 字节码"></a>1.6 字节码</h2><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p>
<p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p>
<p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码典型的应用为：Java bytecode</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/cba8c417f20ae9f6671e64574d2e229a.png&sign=e48f563e26a45b29dd8ab51379e55d7bbf371fa0ad3ad699d03aa955ec7f885b"></p>
<h1 id="2-执行引擎概述"><a href="#2-执行引擎概述" class="headerlink" title="2 执行引擎概述"></a>2 执行引擎概述</h1><h2 id="2-1-通用概述"><a href="#2-1-通用概述" class="headerlink" title="2.1 通用概述"></a>2.1 通用概述</h2><p>执行引擎属于 JVM 的下层，里面包括解释器、及时编译器、垃圾回收器</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990857646-76859fa0-7214-422a-a6cf-ef57856a0660.png"></p>
<p>执行引擎是 Java 虚拟机核心的组成部分之一。</p>
<p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>JVM 的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990857705-20a66e89-2f54-4733-932c-50483ec8447f.png"></p>
<p>那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令.才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>
<h2 id="2-2-执行引擎的工作流程"><a href="#2-2-执行引擎的工作流程" class="headerlink" title="2.2 执行引擎的工作流程"></a>2.2 执行引擎的工作流程</h2><ol>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。</li>
<li>每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ol>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990857672-fa493747-e0b4-4bf2-b0c7-7aa5eec09514.png"></p>
<p>从外观上来看，所有的 Java 虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p>
<h1 id="3-Java的代码编译和执行过程"><a href="#3-Java的代码编译和执行过程" class="headerlink" title="3 Java的代码编译和执行过程"></a>3 Java的代码编译和执行过程</h1><h2 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h2><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/e2a8ec10bc97a061e4b77abf63936ba1.png&sign=a08107277a028935dd3af371880c4ff434fd1b30a959f8ba1ed4ced6808bdd20"></p>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p>
<p>Java 代码编译是由 Java 源码编译器（前端编译器）来完成，流程图如下所示：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990857708-effe6526-22c1-4ea5-94ad-f5ca6e984016.png"></p>
<p>Java 字节码的执行是由 JVM 执行引擎（后端编译器）来完成，流程图 如下所示</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990857745-1946eb88-cffc-44ca-a8b4-f29f67167f40.png"></p>
<h2 id="3-2-什么是解释器（Interpreter）？什么是-JIT-编译器？"><a href="#3-2-什么是解释器（Interpreter）？什么是-JIT-编译器？" class="headerlink" title="3.2 什么是解释器（Interpreter）？什么是 JIT 编译器？"></a>3.2 什么是解释器（Interpreter）？什么是 JIT 编译器？</h2><p>解释器：当 Java 虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<h2 id="3-3-为什么-Java-是半编译半解释型语言？"><a href="#3-3-为什么-Java-是半编译半解释型语言？" class="headerlink" title="3.3 为什么 Java 是半编译半解释型语言？"></a>3.3 为什么 Java 是半编译半解释型语言？</h2><p>JDK1.0 时代，将 Java 语言定位为“解释执行”还是比较准确的。再后来，Java 也发展出可以直接生成本地代码的编译器。现在 JVM 在执行 Java 代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
<p><strong>图示</strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990858594-1ad55ad0-a86d-4305-a817-eaa6e17c2109.png"></p>
<h1 id="4-解释器"><a href="#4-解释器" class="headerlink" title="4 解释器"></a>4 解释器</h1><p>JVM 设计者们的初衷仅仅只是单纯地为了满足 Java 程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990858552-c52b8f20-7d06-42cd-a9f6-c7753d92f659.png"></p>
<p>为什么 Java 源文件不直接翻译成 JMV，而是翻译成字节码文件？可能是因为直接翻译的代价是比较大的</p>
<h2 id="4-1-解释器工作机制"><a href="#4-1-解释器工作机制" class="headerlink" title="4.1 解释器工作机制"></a>4.1 解释器工作机制</h2><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p>当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<h2 id="4-2-解释器分类"><a href="#4-2-解释器分类" class="headerlink" title="4.2 解释器分类"></a>4.2 解释器分类</h2><p>在 Java 的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p>
<ul>
<li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li>
<li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li>
</ul>
<p>在 HotSpot VM 中，解释器主要由 Interpreter 模块和 Code 模块构成。</p>
<ul>
<li>Interpreter 模块：实现了解释器的核心功能</li>
<li>Code 模块：用于管理 HotSpot VM 在运行时生成的本地机器指令</li>
</ul>
<h2 id="4-3-现状"><a href="#4-3-现状" class="headerlink" title="4.3 现状"></a>4.3 现状</h2><p>由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些 C&#x2F;C++程序员所调侃。</p>
<p>为了解决这个问题，JVM 平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p>
<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
<h1 id="5-JIT-编译器"><a href="#5-JIT-编译器" class="headerlink" title="5 JIT 编译器"></a>5 JIT 编译器</h1><h3 id="9-5-1-Java-代码的执行分类"><a href="#9-5-1-Java-代码的执行分类" class="headerlink" title="9.5.1. Java 代码的执行分类"></a>9.5.1. Java 代码的执行分类</h3><ul>
<li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</li>
<li>第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</li>
</ul>
<p>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
<p>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C&#x2F;C++ 程序一较高下的地步。</p>
<p><strong>问题来了</strong></p>
<p>有些开发人员会感觉到诧异，既然 HotSpot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以： 尽管 JRockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="9-5-2-HotSpot-JVM-执行方式"><a href="#9-5-2-HotSpot-JVM-执行方式" class="headerlink" title="9.5.2. HotSpot JVM 执行方式"></a>9.5.2. HotSpot JVM 执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p>
<p><strong>案例来了</strong></p>
<p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的 JVM 均是解释执行，还没有进行热点代码统计和 JIT 动态编译，导致机器启动之后，当前 1&#x2F;2 发布成功的服务器马上全部宕机，此故障说明了 JIT 的存在。—阿里团队</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990858498-4327040d-2a16-4c61-9170-f2e3f208c001.png"></p>
<h3 id="9-5-3-概念解释"><a href="#9-5-3-概念解释" class="headerlink" title="9.5.3. 概念解释"></a>9.5.3. 概念解释</h3><p>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java 文件转变成.class 文件的过程；</p>
<p>也可能是指虚拟机的后端运行期编译器（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</p>
<p>还可能是指使用静态提前编译器（AOT 编译器，Ahead of Time Compiler）直接把.java 文件编译成本地机器代码的过程。</p>
<ul>
<li>前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。</li>
<li>JIT 编译器：HotSpot VM 的 C1、C2 编译器。</li>
<li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li>
</ul>
<h3 id="9-5-4-热点代码及探测技术"><a href="#9-5-4-热点代码及探测技术" class="headerlink" title="9.5.4. 热点代码及探测技术"></a>9.5.4. 热点代码及探测技术</h3><p>当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。</p>
<p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过 JIT 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT 编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p>
<p>目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测。</p>
<p>采用基于计数器的热点探测，HotSpot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发 JIT 编译。</p>
<p>这个阀值可以通过虚拟机参数 <code>-XX:CompileThreshold</code>来人为设定。</p>
<p>当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990858475-53485b49-f968-416d-8809-b5f3c27b76f2.png"></p>
<h4 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h4><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
<p>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990858803-bdc969dd-91a7-47e0-a0a5-2682d44a4bd8.png"></p>
<h3 id="9-5-5-HotSpotVM-可以设置程序执行方法"><a href="#9-5-5-HotSpotVM-可以设置程序执行方法" class="headerlink" title="9.5.5. HotSpotVM 可以设置程序执行方法"></a>9.5.5. HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下 HotSpot VM 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为 Java 虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<ul>
<li><code>-Xint</code>：完全采用解释器模式执行程序；</li>
<li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<h3 id="9-5-6-HotSpotVM-中-JIT-分类"><a href="#9-5-6-HotSpotVM-中-JIT-分类" class="headerlink" title="9.5.6. HotSpotVM 中 JIT 分类"></a>9.5.6. HotSpotVM 中 JIT 分类</h3><p>JIT 的编译器还分为了两种，分别是 C1 和 C2，在 HotSpot VM 中内嵌有两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，但大多数情况下我们简称为 C1 编译器 和 C2 编译器。开发人员可以通过如下命令显式指定 Java 虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><code>-client</code>：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器；C1 编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li>
<li><code>-server</code>：指定 Java 虚拟机运行在 server 模式下，并使用 C2 编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。</li>
</ul>
<p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。</p>
<p>不过在 Java7 版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由 C1 编译器和 C2 编译器相互协作共同来执行编译任务。</p>
<h4 id="C1-和-C2-编译器不同的优化策略"><a href="#C1-和-C2-编译器不同的优化策略" class="headerlink" title="C1 和 C2 编译器不同的优化策略"></a>C1 和 C2 编译器不同的优化策略</h4><p>在不同的编译器上有不同的优化策略，C1 编译器上主要有方法内联、去虚拟化、冗余消除。</p>
<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
<p>C2 的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在 C2 上有如下几种优化：</p>
<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指 synchronized</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般来讲，JIT 编译出来的机器码性能比解释器高。C2 编译器启动时长比 C1 慢，系统稳定执行以后，C2 编译器执行速度远快于 C1 编译器</p>
<h3 id="写到最后-1"><a href="#写到最后-1" class="headerlink" title="写到最后 1"></a>写到最后 1</h3><ul>
<li>自 JDK10 起，HotSpot 又加入了一个全新的及时编译器：Graal 编译器</li>
<li>编译效果短短几年时间就追评了 C2 编译器，未来可期</li>
<li>目前，带着实验状态标签，需要使用开关参数<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code>去激活才能使用</li>
</ul>
<h3 id="写到最后-2：AOT-编译器"><a href="#写到最后-2：AOT-编译器" class="headerlink" title="写到最后 2：AOT 编译器"></a>写到最后 2：AOT 编译器</h3><p>jdk9 引入了 AOT 编译器（静态提前编译器，Ahead of Time Compiler）</p>
<p>Java 9 引入了实验性 AOT 编译工具 jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。</p>
<p>所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p>
<p>最大的好处：Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验</p>
<p>缺点：</p>
<ul>
<li>破坏了 java “ 一次编译，到处运行”的理念，必须为每个不同的硬件，OS 编译对应的发行包</li>
<li>降低了 Java 链接过程的动态性，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持 Linux X64 java base</li>
</ul>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>10 StringTable</title>
    <url>/2023/08/24/10%20StringTable/</url>
    <content><![CDATA[<h1 id="1-String的基本概念"><a href="#1-String的基本概念" class="headerlink" title="1 String的基本概念"></a>1 String的基本概念</h1><h2 id="使用概览"><a href="#使用概览" class="headerlink" title="使用概览"></a>使用概览</h2><ul>
<li>String属于引用数据类型，不像C#有string关键字，Java没有对应的string关键字。</li>
<li>String 声明为 final 的，不可被继承。</li>
<li>String 实现了 Serializable 接口：表示字符串是支持序列化的。</li>
<li>String 实现了 Comparable 接口：表示 String 可以比较大小</li>
<li>【重要变更】String的内部定义：String在JDK8及以前内部定义了<code>&lt;font style=&quot;color:#F5222D;&quot;&gt;final char[] value&lt;/font&gt;</code>用来存储字符串数据。JDK9版本开始后更改为了<code>&lt;font style=&quot;color:#F5222D;&quot;&gt;byte[]+编码标记&lt;/font&gt;</code>。同时,StringBuffer和StringBuilder也相应的更改了。更改原因：大部分数据都在1个字节内（byte为1个字节，char为2个字节），节省空间考虑。官网地址：<a href="http://openjdk.java.net/jeps/254">JEP 254: Compact Strings (java.net)</a></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1629875853679-324611ab-8429-41ef-a1ce-af728b4e1a51.png"><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1629875854237-7364bb58-dc11-4460-b482-751d7dacc1c9.png"></p>
<span id="more"></span>
<p>参考文档：</p>
<p><a href="https://www.yuque.com/zhuyufei-x9kmd/feay0m/25132231">Java常用类.pdf · 资料文件 · 语雀</a></p>
<!-- more -->
<h2 id="String的不可变更性"><a href="#String的不可变更性" class="headerlink" title="String的不可变更性"></a>String的不可变更性</h2><p>String不可变性的几个体现：</p>
<ol>
<li>当对字符串重新赋值时，会更改该变量栈空间上存储的地址值，原栈空间指向的实际值未做更改。</li>
<li>当对字符串进行连接操作时，会更改该变量栈空间上存储的地址值，原栈空间指向的实际值未做更改。</li>
<li>当调用String的replace()方法修改字符或字符串, 也会更改该变量栈空间上存储的地址值，原栈</li>
</ol>
<p>间指向的实际值未做更改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">System.out.println(str);<span class="comment">//abc//str本身未做改变</span></span><br><span class="line">System.out.println(str2);<span class="comment">//1bc</span></span><br></pre></td></tr></table></figure>

<h1 id="2-String的常用操作"><a href="#2-String的常用操作" class="headerlink" title="2 String的常用操作"></a>2 String的常用操作</h1><h2 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String方法都不能更改原来的String值。因为其内部是<span class="keyword">final</span> <span class="type">char</span>[]或<span class="keyword">final</span> <span class="type">byte</span>[]，必须以新的变量去接收更改后的值。</span><br><span class="line">如：toLowerCase()/toUpperCase()/trim()/replace()。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 截取的方法(substring)为左闭右开</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span>。返回一个新字符串，它是此字符串从beginIndex（包含）开始截取到endIndex（不包含）的一个子字符串。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 除非指定了ignoreCase，否则String方法内部都是大小写敏感的。</span><br><span class="line">equasl()/endsWith()/startWith()/contains()内部都是大写敏感的。手动指定了忽略了大小写的方法的除外，如：equalsIgnoreCase()。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 拼接方法：String <span class="title function_">concat</span><span class="params">(String str)</span>等价于“+”拼接。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> String与<span class="type">char</span>[]之间的转换</span><br><span class="line">String-&gt;<span class="type">char</span>[]：调用String.toCharArray()方法，如<span class="type">char</span>[] arrs = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[]-&gt;String：调用String的构造器，如<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arrs);</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> isEmpty()是否<span class="number">0</span>长度的字符串</span><br><span class="line">字符串通过 length() 方法计算字符串长度，如果返回 <span class="number">0</span>，isEmpty()即为<span class="literal">true</span>。</span><br></pre></td></tr></table></figure>

<p><strong>String.format方法的使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=String.format(<span class="string">&quot;Hi,%s:%s.%s&quot;</span>, <span class="string">&quot;王南&quot;</span>,<span class="string">&quot;王力&quot;</span>,<span class="string">&quot;王张&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印输出的值为：Hi,王南:王力.王张</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/Dhouse/p/7776780.html">参考文档</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1629875862334-0e5cf9fc-fa37-4d6c-914d-8a2ccd0885a8.png"></p>
<h2 id="String的编码问题"><a href="#String的编码问题" class="headerlink" title="String的编码问题"></a>String的编码问题</h2><p>String和byte[]之间的转换</p>
<ol>
<li>**String-&gt;byte[]**：调用String.getBytes()，如<code>_byte[] bytes = s1.getBytes();_</code></li>
<li><strong>byte[]-&gt;String</strong>：调用String的构造器，如<code>_String str = byte bytes[]_</code></li>
</ol>
<p>注意点：编码(-&gt;byte[])和解码(-&gt;String)的格式必须一致。只有to byte和byte from才需要特别注意。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1629875861988-4f2d53bc-b93b-4a8e-86f0-32538cd79f45.png"></p>
<h1 id="3-String创建对象和其内存分布"><a href="#3-String创建对象和其内存分布" class="headerlink" title="3 String创建对象和其内存分布"></a>3 String创建对象和其内存分布</h1><h2 id="3-1-String的内存原理"><a href="#3-1-String的内存原理" class="headerlink" title="3.1 String的内存原理"></a>3.1 String的内存原理</h2><p><strong>浅堆</strong></p>
<p>浅堆是指一个对象所消耗的内存。在 64 位系统中，一个对象引用会占据 4 个字节，一个 int 类型会占据 4 个字节，long 型变量会占据 8 个字节，每个对象头需要占用 8 个字节。根据堆快照格式不同，对象的大小可能会同 8 字节进行对齐。具体可详见：</p>
<p><a href="https://www.yuque.com/zhuyufei-x9kmd/npm5bq/f46ced8c42d4947c7f6e5c01822ed87b">补充：浅堆深堆与内存泄露</a></p>
<hr>
<p><strong>计算String对象的大小</strong></p>
<ul>
<li>如果String作为对象：通过<code>String str=new String(&quot;你好&quot;);</code>或<code>String str=&quot;你好&quot;</code>的方式创建String对象：<font style="background-color:#FADB14;">共计24bytes（24个字节）。</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645359825731-62472aa5-08b4-4d7d-8853-cd72bc352f14.png"></p>
<ul>
<li>如果String变为变量：<font style="background-color:#FADB14;">4bytes（4个字节）</font></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645360342558-30256582-c403-4834-af61-d09d48f30c98.png"></p>
<p><strong>StringPool字符串常量池</strong></p>
<p>在Java语言中有 8 种基本数据类型和一种比较特殊的类型 String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就类似一个 Java 系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String的常量池比较特殊，它会根据String类的使用而调用。</p>
<p>String 的 String Pool 是一个固定大小的 Hashtable，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 String.intern 时性能会大幅下降。<font style="color:#F5222D;">字符串常量池不会存储相同内容的字符串。</font></p>
<p>使用<code>-XX:StringTablesize</code>可设置 StringTable 的长度</p>
<ul>
<li>在 jdk6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求</li>
<li>在 jdk7 中，StringTable 的长度默认值是 60013，StringTablesize 设置没有要求</li>
<li>在 JDK8 中，设置 StringTable 长度的话，1009 是可以设置的最小值</li>
</ul>
<hr>
<p><strong>StringPool常量池的使用</strong></p>
<p>它的主要使用方法有两种：</p>
<ul>
<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern()方法。这个后面重点谈。</li>
</ul>
<hr>
<p><strong>StringPool常量池存储在哪？</strong></p>
<ul>
<li>Java 6 及以前，字符串常量池存放在永久代。</li>
<li>Java 7，字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到 Java 堆内。<ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用<code>String.intern()</code>。</li>
</ul>
</li>
<li>Java8，字符串常量池在方法区的元空间上。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645242098089-3f598628-17b9-44bd-829e-5f4f695679dd.png"></p>
<blockquote>
<p>Java7为什么要调整StringTable的存储位置？</p>
<p>原因：1、永久代的perSize默认比较小；2、永久代垃圾回收频率低</p>
<p>附官网地址：<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">Java SE 7 Features and Enhancements (oracle.com)</a></p>
<p>Synopsis: In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the <code>String.intern()</code> method will see more significant differences.</p>
<p>简介：在 JDK 7 中，内部字符串不再分配在 Java 堆的永久代中，而是分配在 Java 堆的主要部分（称为年轻代和老年代），与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主 Java 堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但加载许多类或大量使用 String.intern()方法的大型应用程序将看到更明显的差异。</p>
</blockquote>
<h2 id="3-2-通过字面量的方式"><a href="#3-2-通过字面量的方式" class="headerlink" title="3.2   通过字面量的方式"></a>3.2   通过字面量的方式</h2><p>格式：String str &#x3D; “FlyShow”;</p>
<p>生成的对象：栈空间str、str指向的字符串常量区</p>
<p>原理分析：如图</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632387655454-e3063100-0bb2-4f84-96d1-f477ed2a3b33.png"></p>
<h2 id="3-3-通过String-intern-方法"><a href="#3-3-通过String-intern-方法" class="headerlink" title="3.3 通过String.intern()方法"></a>3.3 通过String.intern()方法</h2><p><strong>通览</strong></p>
<p>格式：<code>String str = new String(&quot;FlyShow&quot;).intern();</code></p>
<p>生成的对象：栈空间str、new的时候在堆空间生成的String对象Flyshow、调用intern()方法后去常量池查找如果没有就开辟的常量池字符串对象Flyshow。</p>
<p>方法说明：通过new String()在堆空间开辟了对象，然后调用intern()方法后会判断字符串常量池中是否存在”FlyShow”值，如果存在则返回常量池中该对象的地址。如果不存在JDK6的情况是在常量池中先复制堆上的”FlyShow”到常量池并再返回该对象在常量池的地址给变量str，在JDK7及以后，字符串常量池复制的是堆空间的一个引用，而不再复制完整内容，返回的也是这个堆空间的地址。</p>
<p>intern方法可以确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池(String Intern Pool)。</p>
<p><strong>调用intern()方法在不同JDK版本下的区分</strong></p>
<p>JDK1.6 中，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果字符串常量池中有，则并不会放入。返回已有的字符串常量池中的对象的地址。</li>
<li>如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址。</li>
</ul>
<p>JDK1.7起，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址（此时返回的就是对象的引用）</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632390575350-59285ad0-9f85-4039-9f32-9f00de6c9599.png"></p>
<p><strong>进一步了解</strong></p>
<blockquote>
<p>官方 API 文档中的解释</p>
<p>public String intern()</p>
<p>Returns a canonical representation for the string object.</p>
<p>A pool of strings, initially empty, is maintained privately by the class <code>String</code>.</p>
<p>When the intern method is invoked, if the pool already contains a string equal to this <code>String</code> object as determined by the <code>[equals(Object)](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-)</code> method, then the string from the pool is returned. Otherwise, this <code>String</code> object is added to the pool and a reference to this <code>String</code> object is returned.</p>
<p>It follows that for any two strings <code>s</code> and <code>t</code>, <code>s.intern() == t.intern()</code> is <code>true</code> if and only if <code>s.equals(t)</code> is <code>true</code>.</p>
<p>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.</p>
<hr>
<p><strong>Returns:</strong><br>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.</p>
<p>当调用 intern 方法时，如果池子里已经包含了一个与这个 String 对象相等的字符串，正如 equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个 String 对象被添加到池中，并返回这个 String 对象的引用。</p>
<p>由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t)为真时，s.intern() &#x3D;&#x3D; t.intern()为真。</p>
<p>所有字面字符串和以字符串为值的常量表达式都是 interned。</p>
<p>返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池。</p>
</blockquote>
<p>intern 是一个 native 方法，调用的是底层 C 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，它会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">myInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">&quot;I LOVE YOU&quot;</span>).intern();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也就是说，如果在任意字符串上调用 String.intern 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。</span></span><br><span class="line"><span class="comment">//因此，下列表达式的值必定是 true</span></span><br><span class="line">(<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>).intern() == <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>通俗点讲，Interned string 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645243221790-2cdd36bf-046e-42a6-94d0-342f2403f5a3.png"></p>
<hr>
<p><strong>intern 的使用：JDK6 vs JDK7&#x2F;8</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//创建了两个对象:堆空间中一个new对象;字符串常量池中一个字符串常量&quot;1&quot;（注意：此时字符串常量池中已有&quot;1&quot;）</span></span><br><span class="line">s.intern();<span class="comment">//由于字符串常量池中已存在&quot;1&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;<span class="comment">//由于字符串常量池中已存在&quot;1&quot;</span></span><br><span class="line">System.out.println(s==s2); <span class="comment">//s指向的是堆空间中的对象地址;s2指向的是堆空间中常量池中&quot;1&quot;的地址。所以不相等</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">jdk1<span class="number">.6</span>  <span class="literal">false</span> </span><br><span class="line">jdk7/<span class="number">8</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//等价于new String（&quot;11&quot;），但是，常量池中并不生成字符串&quot;11&quot;</span></span><br><span class="line">s3.intern();<span class="comment">//由于此时常量池中并无&quot;11&quot;,jdk7/8是把s3中记录的对象的地址存入常量池;jdk6是直接复制的内容到常量池。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>; 	</span><br><span class="line">System.out.println(s3==s4); </span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">jdk1<span class="number">.6</span> <span class="literal">false</span> </span><br><span class="line">jdk7/<span class="number">8</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645243222025-70e766c8-e250-4e5e-a487-8e7cc0fe39c6.png"><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645243222044-2bb505ff-590b-4ee4-bbc1-d8040555f120.png"></p>
<p><strong>intern的效率测试</strong></p>
<p>我们通过测试一下，使用了 intern 和不使用的时候，其实相差还挺多的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassTest</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String a=<span class="string">&quot;xcxx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer [] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">            <span class="comment">//arr[i] = new String(String.valueOf(data[i%data.length])).intern();//花费的时间为：925</span></span><br><span class="line">            <span class="comment">//arr[i] = new String(String.valueOf(data[i%data.length]));//花费的时间为：2423</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//new String(String.valueOf(data[i%data.length]));//花费的时间为：236</span></span><br><span class="line">            <span class="comment">//new String(String.valueOf(data[i%data.length])).intern();//花费的时间为：844</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q：为什么在量大且很多重复字符串的时候使用<code>arr[i] = new String(String.valueOf(data[i%data.length]))</code>性能比<code>new String(String.valueOf(data[i%data.length])).intern()</code>差？</p>
<p>A：主要是在空间消耗上，不加intern，内存里的对象都在Heap上，占据了大量的内存空间。使用了intern，堆里面的空间会被GC（new String这一步还是会在堆上面创建对象的），重复的变量都在StringPool上了，空间会大幅降低，对应的时间消耗就变小了。</p>
<p>图示内存实例数：上一个是不加intern，下一个是加了intern。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645262751650-dee2a421-62ec-4b26-9b54-a9f935d54089.png"><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645262731938-9730d877-de52-4c02-830c-c8abc37b3aeb.png"></p>
<p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用 intern()方法能够节省内存空间。</p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern()方法，就会很明显降低内存的大小。</p>
<h2 id="3-4-通过拼接：全常量拼接"><a href="#3-4-通过拼接：全常量拼接" class="headerlink" title="3.4 通过拼接：全常量拼接"></a>3.4 通过拼接：全常量拼接</h2><ul>
<li>常量与常量的拼接结果在常量池（如果变量使用final修饰也认为是常量），原理是编译期优化</li>
<li>使用 final 修饰，即为常量。会在编译器进行代码优化。<font style="color:#F5222D;">在实际开发中，能够使用 final 的，尽量使用。</font></li>
<li>常量池中不会存在相同内容的变量。</li>
<li>如果拼接的结果调用 intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例1</span></span><br><span class="line">使用格式</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">final</span> String s1=<span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line"></span><br><span class="line">生成的对象：栈空间str、str指向的字符串常量区。</span><br><span class="line">原理分析：常量与常量的拼接结果在常量池,原理是编译期优化,其内存布局和通过字面量方式生成的是一致。</span><br><span class="line">note：常量池中不会存在相同内容的常量。</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//s1指向的对象存在字符串常量区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//s1指向的对象存在字符串常量区</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//值为true</span></span><br><span class="line">原因分析：编译器将.java文件编译成.class文件时,语句<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;自动编译成了<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632389693217-c0f3a2cd-6f67-4c8b-b46b-a6274790ed59.png"></h3><h2 id="3-4-通过拼接：变量拼接"><a href="#3-4-通过拼接：变量拼接" class="headerlink" title="3.4+ 通过拼接：变量拼接"></a>3.4+ 通过拼接：变量拼接</h2><ul>
<li>拼接多方只要其中有一个是变量，结果就在堆中。变量拼接的原理是 StringBuilder。</li>
<li>不使用 final 修饰，即为变量。如下面例子s3 行的 s1 和 s2，会通过 new StringBuilder 进行拼接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;<span class="comment">//编译后约等于String s3 = new StringBuiler().append(&quot;a&quot;).append(&quot;b&quot;).toString();</span></span><br><span class="line">其中oString()=&gt;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span><br><span class="line"></span><br><span class="line">内存分析：栈空间str/s1/s2、StringBuilder堆对象、s1/s2的字符串常量区、str指向的最终的堆结果之,注意：str的值未在字符串常量区里。</span><br><span class="line"></span><br><span class="line">原理分析：拼接运算中只要其中有一个是变量值(非<span class="keyword">final</span>修饰的变量)，则结果就相当于在堆中(非字符串常量池里) <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)开辟了新对象。</span><br><span class="line">如上语句在JDK5<span class="number">.0</span>之后反编译后看到的内部逻辑为(JDK&lt;<span class="number">5.0</span>则将StringBuiler替换成StringBuffer)：</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuiler</span>().append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).toString();其中StringBuilder.toString()=&gt;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count);</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632389887238-3b3bf902-02d6-4512-8c8a-8b57b0dc97d7.png"></h3><p><strong>字符串拼接性能对比</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        testString(times);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;String: &quot;</span> + (end-start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// StringBuilder</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        testStringBuilder(times);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuilder: &quot;</span> + (end-start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// StringBuffer</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        testStringBuffer(times);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer: &quot;</span> + (end-start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            str += <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStringBuilder</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStringBuffer</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">String: 7963ms</span><br><span class="line">StringBuilder: 1ms</span><br><span class="line">StringBuffer: 4ms</span><br></pre></td></tr></table></figure>

<p>本实验进行 5 万次循环，String 拼接方式的时间是 StringBuilder.append 方式的约 8000 倍，StringBuffer.append()方式的时间是 StringBuilder.append()方式的约 4 倍</p>
<p>可以看到，通过 StringBuilder 的 append 方式的速度，要比直接对 String 使用“+”拼接的方式快的不是一点半点</p>
<p>那么，在实际开发中，对于需要多次或大量拼接的操作，在不考虑线程安全问题时，我们就应该尽可能使用 StringBuilder 进行 append 操作</p>
<p>除此之外，还有那些操作能够帮助我们提高字符串方面的运行效率呢？</p>
<p>StringBuilder 空参构造器的初始化大小为 16。那么，如果提前知道需要拼接 String 的个数，就应该直接使用带参构造器指定 capacity，以减少扩容的次数（扩容的逻辑可以自行查看源代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a string builder with no characters in it and an</span></span><br><span class="line"><span class="comment"> * initial capacity of 16 characters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a string builder with no characters in it and an</span></span><br><span class="line"><span class="comment"> * initial capacity specified by the &#123;<span class="doctag">@code</span> capacity&#125; argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      capacity  the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     NegativeArraySizeException  if the &#123;<span class="doctag">@code</span> capacity&#125;</span></span><br><span class="line"><span class="comment"> *               argument is less than &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拼接操作总结：</strong>String可以和8种基本数据类型变量做运算，<font style="color:#F5222D;">且运算只能是拼接运算，即只要一端有String类型，即为连接，运算的结果也为String</font>。字符串参与运算时boolean类型的直接转换为字符串false&#x2F;true，char类型的则是其字符展现形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Fly&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isOK</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例一：值为97+10+&quot;Fly&quot;=107Fly,此时+先为加运算，再为拼接</span></span><br><span class="line">System.out.println(c + i + str);</span><br><span class="line"><span class="comment">//案例二：值为Flya10，此时+先做为拼接，做完拼接后结果类型为String,再做拼接</span></span><br><span class="line">System.out.println(str + c + i);</span><br><span class="line"><span class="comment">//案例三：值为107Fly+false=107Flyfalse</span></span><br><span class="line">System.out.println(c + i + str + isOK);</span><br><span class="line"><span class="comment">//案例四：编译失败(boolean类型不参与和基础类型的运算)</span></span><br><span class="line">System.out.println(c + i + isOK + str);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例一：char类型在做运算的时候，是会转换为数值型的，值为：97+9+97=203</span></span><br><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">//案例二：先基本类型char做数值运算，再和String做拼接运算，值为：106a</span></span><br><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//案例三：先做拼接运算，然后后面均为拼接运算，值为：a a，其中中间的空格为转义字符\t</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">//案例四：做拼接运算，值为：a	a</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1629875858001-e77451b9-62fb-4c61-ae81-996c56f31ba0.png?x-oss-process=image/resize,w_163,limit_0"></h2><h2 id="3-5-通过new-String的方式"><a href="#3-5-通过new-String的方式" class="headerlink" title="3.5 通过new String的方式"></a>3.5 通过new String的方式</h2><p>格式：<code>String str=new String(&quot;FlyShow&quot;);</code></p>
<p>生成的对象：栈空间str、str指向的堆对象、String堆对象里面存储在字符串常量池的value值对象（根据情况决定是否会在字符串常量池里面开辟）</p>
<p>原理分析：new String(String value)调用的构造器源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];		<span class="comment">//The value is used for character storage.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; 				<span class="comment">//Default to 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = original.value;</span><br><span class="line">        <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的代码以及内存图概览：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632388923089-bca8764d-0165-48c2-bc85-98dc459cdbc5.png"></p>
<h2 id="总结：几种创建字符串的方式"><a href="#总结：几种创建字符串的方式" class="headerlink" title="总结：几种创建字符串的方式"></a>总结：几种创建字符串的方式</h2><p><font style="color:#E8323C;">速记：Pool&#x3D;&gt;Police:literal、intern、constanadd  &#x3D;&#x3D;&gt;nb(new stringbuilder)</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串在常量池StringPool====》速记：Pool=&gt;Police:literal、intern、constanadd</span></span><br><span class="line"><span class="number">1</span>、通过字面量literal赋值的方式String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="number">2</span>、调用intern()方法</span><br><span class="line"><span class="number">3</span>、部分拼接(即常量拼接Constant Add)：所有连接方均为常量</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串在堆里面：实际在String类里面的final byte[](jdk9及之后)或final char[](jdk8及之前)</span></span><br><span class="line"><span class="number">1</span>、通过<span class="keyword">new</span> <span class="title class_">String</span>()构造器传入</span><br><span class="line"><span class="number">2</span>、部分拼接：多个拼接方有一个非常量<span class="comment">//其内部源码使用StringBuilder()。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1629875859401-60399750-c44b-4100-863b-a9a11e764f29.png?x-oss-process=image/resize,w_1153,limit_0"><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1629875859905-b31d78ed-d6e3-45b9-bf39-ebbfc59a5f7f.png"></p>
<h2 id="一些截图案例"><a href="#一些截图案例" class="headerlink" title="一些截图案例"></a>一些截图案例</h2><p><strong>案例1</strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990872986-22c3ed21-aebb-4b6d-b79e-7375fd6d150c.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990872929-5a8d010e-9e70-4619-b0c4-fbc635199dfe.png"></p>
<p><strong>案例2</strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990872975-ba57311e-55ab-4a31-8edb-7f801b6f3c70.png"></p>
<p><strong>案例3</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//都是常量，前端编译期会进行代码优化</span></span><br><span class="line">      <span class="comment">//通过idea直接看对应的反编译的class文件，会显示 String s1 = &quot;abc&quot;; 说明做了代码优化</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">      <span class="comment">// true，有上述可知，s1和s2实际上指向字符串常量池中的同一个值</span></span><br><span class="line">      System.out.println(s1 == s2);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例4</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// true 编译期优化</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// false s1是变量，不能编译期优化</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// false s2是变量，不能编译期优化</span></span><br><span class="line">    System.out.println(s3 == s7); <span class="comment">// false s1、s2都是变量</span></span><br><span class="line">    System.out.println(s5 == s6); <span class="comment">// false s5、s6 不同的对象实例</span></span><br><span class="line">    System.out.println(s5 == s7); <span class="comment">// false s5、s7 不同的对象实例</span></span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">// false s6、s7 不同的对象实例</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8); <span class="comment">// true intern之后，s8和s3一样，指向字符串常量池中的&quot;javaEEhadoop&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2022/png/696107/1645280150064-3c6301fa-9254-445b-a620-1cfc8789f1bd.png">**<br>**<strong>举例6</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3==s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：我们上面案例例的字节码进行查看，可以发现<code>s1 + s2</code>实际上是 new 了一个 StringBuilder 对象，并使用了 append 方法将 s1 和 s2 添加进来，最后调用了 toString 方法赋给 s4，而StringBuilder的toString方法就是new String()。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 ldc #2 &lt;a&gt;</span><br><span class="line"> 2 astore_1</span><br><span class="line"> 3 ldc #3 &lt;b&gt;</span><br><span class="line"> 5 astore_2</span><br><span class="line"> 6 ldc #4 &lt;ab&gt;</span><br><span class="line"> 8 astore_3</span><br><span class="line"> 9 new #5 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">12 dup</span><br><span class="line">13 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">16 aload_1</span><br><span class="line">17 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">20 aload_2</span><br><span class="line">21 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">24 invokevirtual #8 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">27 astore 4</span><br><span class="line">29 getstatic #9 &lt;java/lang/System.out&gt;</span><br><span class="line">32 aload_3</span><br><span class="line">33 aload 4</span><br><span class="line">35 if_acmpne 42 (+7)</span><br><span class="line">38 iconst_1</span><br><span class="line">39 goto 43 (+4)</span><br><span class="line">42 iconst_0</span><br><span class="line">43 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">46 return</span><br><span class="line"></span><br><span class="line">//而StringBuilder.toString()的源码</span><br><span class="line">public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123;</span><br><span class="line"></span><br><span class="line">		char[] value;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        //Create a copy, don&#x27;t share the array</span><br><span class="line">        return new String(value, 0, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String(char value[], int offset, int count) &#123;</span><br><span class="line">        if (offset &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &lt;= 0) &#123;</span><br><span class="line">            if (count &lt; 0) &#123;</span><br><span class="line">                throw new StringIndexOutOfBoundsException(count);</span><br><span class="line">            &#125;</span><br><span class="line">            if (offset &lt;= value.length) &#123;</span><br><span class="line">                this.value = &quot;&quot;.value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br><span class="line">        if (offset &gt; value.length - count) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        this.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-StringTable-的垃圾回收"><a href="#5-StringTable-的垃圾回收" class="headerlink" title="5 StringTable 的垃圾回收"></a>5 StringTable 的垃圾回收</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -Xms15m -Xmx15m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            String.valueOf(i).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;504K(4608K)] 4096K-&gt;1689K(15872K), <span class="number">0.0581583</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4600K-&gt;504K(4608K)] 5785K-&gt;2310K(15872K), <span class="number">0.0015621</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4600K-&gt;504K(4608K)] 6406K-&gt;2350K(15872K), <span class="number">0.0034849</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 4608K, used 1919K [<span class="number">0x00000000ffb00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 4096K, <span class="number">34</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffc61d30</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">98</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff7e010</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 11264K, used 1846K [<span class="number">0x00000000ff000000</span>, <span class="number">0x00000000ffb00000</span>, <span class="number">0x00000000ffb00000</span>)</span><br><span class="line">  object space 11264K, <span class="number">16</span>% used [<span class="number">0x00000000ff000000</span>,<span class="number">0x00000000ff1cd9b0</span>,<span class="number">0x00000000ffb00000</span>)</span><br><span class="line"> Metaspace       used 3378K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h1 id="6-G1-中的-String-去重操作"><a href="#6-G1-中的-String-去重操作" class="headerlink" title="6 G1 中的 String 去重操作"></a>6 G1 中的 String 去重操作</h1><blockquote>
<p>官网地址：<a href="http://openjdk.java.net/jeps/192">JEP 192: String Deduplication in G1 (java.net)</a></p>
<hr>
<p><strong>Motivation</strong></p>
<p>Many large-scale Java applications are currently bottlenecked on memory. Measurements have shown that roughly 25% of the Java heap live data set in these types of applications is consumed by <code>String</code> objects. Further, roughly half of those <code>String</code> objects are duplicates, where duplicates means <code>string1.equals(string2)</code> is true. Having duplicate <code>String</code> objects on the heap is, essentially, just a waste of memory. This project will implement automatic and continuous <code>String</code> deduplication in the G1 garbage collector to avoid wasting memory and reduce the memory footprint.</p>
<hr>
<p><strong>动机</strong></p>
<p>目前，许多大规模的 Java 应用程序在内存上遇到了瓶颈。测量表明，在这些类型的应用程序中，大约 25%的 Java 堆实时数据集被<code>String&#39;对象所消耗。此外，这些 &quot;String &quot;对象中大约有一半是重复的，其中重复意味着 &quot;string1.equals(string2) &quot;是真的。在堆上有重复的</code>String’对象，从本质上讲，只是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动和持续的&#96;String’重复数据删除，以避免浪费内存，减少内存占用。</p>
</blockquote>
<p><font style="color:#F5222D;">注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</font></p>
<p>背景：对许多 Java 应用（有大的也有小的）做的测试得出以下结果：</p>
<ul>
<li>堆存活数据集合里面 string 对象占了 25%</li>
<li>堆存活数据集合里面重复的 string 对象有 13.5%</li>
<li>string 对象的平均长度是 45</li>
</ul>
<p>许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java 堆中存活的数据集合差不多 25%是 String 对象。更进一步，这里面差不多一半 string 对象是重复的，重复的意思是说： <code>stringl.equals(string2)= true</code>。堆上存在重复的 String 对象必然是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 string 对象进行去重，这样就能避免浪费内存。</p>
<hr>
<p><strong>实现</strong></p>
<ol>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的 String 对象</li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 string 对象。</li>
<li>使用一个 hashtable 来记录所有的被 String 对象使用的不重复的 char 数组。当去重的时候，会查这个 hashtable，来看堆上是否已经存在一个一模一样的 char 数组。</li>
<li>如果存在，String 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char 数组会被插入到 hashtable，这样以后的时候就可以共享这个数组了。</li>
</ol>
<hr>
<p><strong>命令行选项</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启String去重，默认是不开启的，需要手动开启。</span> </span><br><span class="line">UseStringDeduplication(bool)  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印详细的去重统计信息</span> </span><br><span class="line">PrintStringDeduplicationStatistics(bool)  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">达到这个年龄的String对象被认为是去重的候选对象</span></span><br><span class="line">StringpeDuplicationAgeThreshold(uintx)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>12 垃圾回收相关概念</title>
    <url>/2023/08/26/12%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1 System.gc()的理解"></a>1 System.gc()的理解</h1><p>在默认情况下，通过 system.gc()或者 Runtime.getRuntime().gc() 的调用，会显式触发 Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p>
<p>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();<span class="comment">// 提醒JVM的垃圾回收器执行gc，但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">// 与Runtime.getRuntime().gc();的作用一样</span></span><br><span class="line">        System.runFinalization();<span class="comment">//强制执行使用引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="2-内存溢出与内存泄露"><a href="#2-内存溢出与内存泄露" class="headerlink" title="2 内存溢出与内存泄露"></a>2 内存溢出与内存泄露</h1><h2 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h2><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
<p>由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 ooM 的情况。</p>
<p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p>
<p>javadoc 中对 OutOfMemoryError 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p>首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p>
<ol>
<li>Java 虚拟机的堆内存设置不够。<br>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code> 、<code>-Xmx</code>来调整。</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）<br>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“<code>java.lang.OutOfMemoryError: PermGen space</code>“。<br>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 ooM 有所改观，出现 OOM，异常信息则变成了：“<code>java.lang.OutofMemoryError:Metaspace</code>“。直接内存不足，也会导致 OOM。</li>
</ol>
<p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li>
<li>在<code>java.nio.BIts.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</li>
</ul>
<p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</li>
</ul>
<h2 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h2><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 00M，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。</p>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1719990947387-1bd31216-7803-43a6-b4f8-90d008ae5d0c.png"></p>
<p><strong>举例</strong></p>
<ol>
<li>单例模式<br>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li>
<li>一些提供 close 的资源未关闭导致内存泄漏<br>数据库连接（dataSourse.getConnection() ），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</li>
</ol>
<h1 id="3-Stop-The-World"><a href="#3-Stop-The-World" class="headerlink" title="3 Stop The World"></a>3 Stop The World</h1><p>Stop-the-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。</p>
<p>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li>
</ul>
<p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p>
<p>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</p>
<p>哪怕是 G1 也不能完全避免 Stop-the-World 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW 是 JVM 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>开发中不要用 System.gc() 会导致 Stop-the-World 的发生。</p>
<h1 id="4-垃圾回收的并行与并发"><a href="#4-垃圾回收的并行与并发" class="headerlink" title="4 垃圾回收的并行与并发"></a>4 垃圾回收的并行与并发</h1><h2 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h2><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
<p>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1719990947441-ac858b5c-dfa0-45f4-9c26-a38f80fea052.png"></p>
<h2 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h2><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占 CPU 资源，可以同时进行，我们称之为并行（Parallel）。</p>
<p>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p>
<p>适合科学计算，后台处理等弱交互场景</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1719990947339-736a5a34-a967-4e25-b372-271b93d21eca.png"></p>
<h2 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h2><ul>
<li>并发，指的是多个事情，在同一时间段内同时发生了。</li>
<li>并行，指的是多个事情，在同一时间点上同时发生了。</li>
<li>并发的多个任务之间是互相抢占资源的。</li>
<li>并行的多个任务之间是不互相抢占资源的。</li>
<li>只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。</li>
<li>否则，看似同时发生的事情，其实都是并发执行的。</li>
</ul>
<h2 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h2><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<h3 id="并行（Parallel）-1"><a href="#并行（Parallel）-1" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h3><p>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如 ParNew、Parallel Scavenge、Parallel Old；</p>
<h3 id="串行（Serial）"><a href="#串行（Serial）" class="headerlink" title="串行（Serial）"></a>串行（Serial）</h3><p>相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动 JM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1719990947442-ceb0dc48-8c7b-4bfb-a7f7-3186194bc9d4.png"></p>
<h3 id="并发（Concurrent）-1"><a href="#并发（Concurrent）-1" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h3><p>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个 CPU 上；如：CMS、G1</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1719990947487-920621ce-c59e-4261-b8b1-365176d9a3d6.png"></p>
<h1 id="5-安全点与安全区域"><a href="#5-安全点与安全区域" class="headerlink" title="5 安全点与安全区域"></a>5 安全点与安全区域</h1><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe Point 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为 Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<h3 id="抢先式中断：（目前没有虚拟机采用了）"><a href="#抢先式中断：（目前没有虚拟机采用了）" class="headerlink" title="抢先式中断：（目前没有虚拟机采用了）"></a>抢先式中断：（目前没有虚拟机采用了）</h3><ul>
<li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。\</li>
</ul>
<h3 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h3><p>设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</p>
<h2 id="安全区域（Safe-Resion）"><a href="#安全区域（Safe-Resion）" class="headerlink" title="安全区域（Safe Resion）"></a>安全区域（Safe Resion）</h2><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 Gc 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p>
<h2 id="实际执行时"><a href="#实际执行时" class="headerlink" title="实际执行时"></a>实际执行时</h2><ol>
<li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Relgion，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</li>
<li>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止；</li>
</ol>
<h1 id="6-再谈引用"><a href="#6-再谈引用" class="headerlink" title="6 再谈引用"></a>6 再谈引用</h1><h2 id="6-1-强引用"><a href="#6-1-强引用" class="headerlink" title="6.1 强引用"></a>6.1 强引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p>
<p>在 JDK1.2 版之后，Java 对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这 4 种引用强度依次逐渐减弱。</p>
<p>除强引用外，其他 3 种引用均可以在 java.lang.ref 包中找到它们的身影。如下图，显示了这 3 种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p>.<img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1719990947803-7cbaf865-b5f0-4f28-85dd-48b96663bfce.png"></p>
<p>Reference 子类中只有终结器引用是包内可见的，其他 3 种引用类型均为 public，可以在应用程序中直接使用</p>
<ul>
<li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>Object obj = new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li>
<li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h3 id="强引用（Strong-Reference）——不回收"><a href="#强引用（Strong-Reference）——不回收" class="headerlink" title="强引用（Strong Reference）——不回收"></a>强引用（Strong Reference）——不回收</h3><p>在 Java 程序中，最常见的引用类型是强引用（普通系统 99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成 Java 内存泄漏的主要原因之一。</p>
<p><strong>强引用例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello mogublog&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>局部变量 str 指向 StringBuffer 实例所在堆空间，通过 str 可以操作该实例，那么 str 就是 StringBuffer 实例的强引用</p>
<p><strong>对应内存结构</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1719990947840-9c154b4c-23be-421b-aa0f-5c56dbb4e110.png"></p>
<p>此时，如果再运行一个赋值语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;</span><br></pre></td></tr></table></figure>

<p><strong>对应的内存结构</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/25873401/1719990947996-5bcce6b1-cdcd-4843-9120-50f24b022f00.png"></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ul>
<h2 id="6-2-软引用"><a href="#6-2-软引用" class="headerlink" title="6.2 软引用"></a>6.2 软引用</h2><h3 id="软引用（Soft-Reference）——内存不足即回收"><a href="#软引用（Soft-Reference）——内存不足即回收" class="headerlink" title="软引用（Soft Reference）——内存不足即回收"></a>软引用（Soft Reference）——内存不足即回收</h3><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
<p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p>在 JDK1.2 版之后提供了 java.lang.ref.SoftReference 类来实现软引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-弱引用"><a href="#6-3-弱引用" class="headerlink" title="6.3 弱引用"></a>6.3 弱引用</h2><h3 id="弱引用（Weak-Reference）——发现即回收"><a href="#弱引用（Weak-Reference）——发现即回收" class="headerlink" title="弱引用（Weak Reference）——发现即回收"></a>弱引用（Weak Reference）——发现即回收</h3><p>弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>在 JDK1.2 版之后提供了 WeakReference 类来实现弱引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<p>弱引用对象与软引用对象的最大不同就在于，当 GC 在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC 总是进行回收。弱引用对象更容易、更快被 GC 回收。</p>
<p><strong>面试题：你开发中使用过 WeakHashMap 吗？</strong></p>
<p>WeakHashMap 用来存储图片信息，可以在内存不足的时候，及时回收，避免了 OOM</p>
<h2 id="6-4-虚引用"><a href="#6-4-虚引用" class="headerlink" title="6.4 虚引用"></a>6.4 虚引用</h2><h3 id="虚引用（Phantom-Reference）——对象回收跟踪"><a href="#虚引用（Phantom-Reference）——对象回收跟踪" class="headerlink" title="虚引用（Phantom Reference）——对象回收跟踪"></a>虚引用（Phantom Reference）——对象回收跟踪</h3><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get()方法取得对象时，总是 null</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
<p>在 JDK1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-终结器引用"><a href="#6-5-终结器引用" class="headerlink" title="6.5 终结器引用"></a>6.5 终结器引用</h2><p>它用于实现对象的 finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p>
<p>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象调用它的 finalize()方法，第二次 GC 时才回收被引用的对象</p>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>11 垃圾回收概述及算法</title>
    <url>/2023/08/25/11%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-什么是垃圾？"><a href="#1-什么是垃圾？" class="headerlink" title="1 什么是垃圾？"></a>1 什么是垃圾？</h1><h2 id="前览"><a href="#前览" class="headerlink" title="前览"></a>前览</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990932591-186bd997-41d9-4cf1-9fe5-3d6712a7c6ec.png"></p>
<p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p>
<p>关于垃圾收集有三个经典问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
<span id="more"></span>
<p><strong>大厂面试题</strong></p>
<blockquote>
<p>蚂蚁金服</p>
<ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms 和 G1？</li>
<li>JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法？</li>
<li>G1 回收器讲下回收过程 GC 是什么？为什么要有 GC？</li>
<li>GC 的两种判定方法？CMS 收集器与 G1 收集器的特点</li>
</ul>
<p>百度</p>
<ul>
<li>说一下 GC 算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ul>
<p>天猫</p>
<ul>
<li>JVM GC 原理，JVM 怎么回收内存</li>
<li>CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ul>
<p>滴滴</p>
<ul>
<li>Java 的垃圾回收器都有哪些，说下 g1 的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ul>
<p>京东</p>
<ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li>
</ul>
<p>阿里</p>
<ul>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM 有哪三种垃圾回收器？</li>
</ul>
<p>字节跳动</p>
<ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc（）和 Runtime.gc（）会做什么事情？</li>
<li>Java GC 机制？GC Roots 有哪些？</li>
<li>Java 对象的回收方式，回收算法。</li>
<li>CMS 和 G1 了解么，CMS 解决什么问题，说一下回收的过程。</li>
<li>CMS 回收停顿了几次，为什么要停顿两次?</li>
</ul>
</blockquote>
<h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><blockquote>
<p>An object is considered garbage when it can no longer be reached from any pointer in the running program</p>
</blockquote>
<p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p>
<p><strong>磁盘碎片整理的日子</strong></p>
<p>机械硬盘需要进行磁盘整理，同时还有坏道</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990932645-45ce8550-f515-4ddd-ac73-e8bfed5cee37.png"></p>
<h1 id="2-为什么需要-GC"><a href="#2-为什么需要-GC" class="headerlink" title="2 为什么需要 GC"></a>2 为什么需要 GC</h1><p><strong>想要学习 GC，首先需要理解为什么需要 GC？</strong></p>
<p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM 将整理出的内存分配给新的对象。</p>
<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序的正常进行。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p>
<blockquote>
<p><strong>早期垃圾回收</strong></p>
</blockquote>
<p>在早期的 C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>();</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridge-&gt;<span class="built_in">Register</span>(kDestroy) != NO ERROR）</span><br><span class="line">	<span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></table></figure>

<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p>
<p>在有了垃圾回收机制后，上述代码极有可能变成这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>();</span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure>

<p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p>
<h1 id="3-Java的垃圾回收机制"><a href="#3-Java的垃圾回收机制" class="headerlink" title="3 Java的垃圾回收机制"></a>3 Java的垃圾回收机制</h1><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p>
<ul>
<li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
<p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p>
<p>oracle 官网关于垃圾回收的介绍 <a href="f71194a4ab42d145dcc36f7dcb93dbd7">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
<h2 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h2><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p>
<p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 outofMemoryError 时，快速地根据错误异常日志定位问题和解决问题。</p>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="GC-主要关注的区域"><a href="#GC-主要关注的区域" class="headerlink" title="GC 主要关注的区域"></a>GC 主要关注的区域</h2><p>GC 主要关注于 方法区 和堆中的垃圾收集</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990932694-e9eecbc9-54a5-497f-8e66-7dd1a3856f43.png"></p>
<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。其中，Java 堆是垃圾收集器的工作重点</p>
<p>从次数上讲：</p>
<ul>
<li>频繁收集 Young 区</li>
<li>较少收集 Old 区</li>
<li>基本不收集 Perm 区（元空间）</li>
</ul>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>任何GC行为都会触发STW(Stop The World全局停顿)</p>
<p>• Minor GC(YGC) 针对年轻代进行回收,执行效率高</p>
<p>• Full GC,全堆回收,针对年轻代&#x2F;老年代&#x2F;方法区进行全面收集,执行效率低下,会导致系统长时间停滞,减少Full GC是JVM优化的重点.</p>
<p>• Major GC,针对老年代回收,目前只有CMS收集器才存在Major GC.</p>
<h1 id="4-垃圾回收相关算法"><a href="#4-垃圾回收相关算法" class="headerlink" title="4 垃圾回收相关算法"></a>4 垃圾回收相关算法</h1><h2 id="4-1-对象存活判断"><a href="#4-1-对象存活判断" class="headerlink" title="4.1 对象存活判断"></a>4.1 对象存活判断</h2><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p>
<p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>
<p>判断对象存活一般有两种方式：引用计数算法和可达性分析算法。</p>
<h2 id="4-2-标记阶段"><a href="#4-2-标记阶段" class="headerlink" title="4.2 标记阶段"></a>4.2 标记阶段</h2><h3 id="4-2-1-标记阶段：引用计数算法"><a href="#4-2-1-标记阶段：引用计数算法" class="headerlink" title="4.2.1 标记阶段：引用计数算法"></a>4.2.1 标记阶段：引用计数算法</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</p>
<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p>缺点：</p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li>
<li>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li>
</ul>
<h4 id="问题：循环引用"><a href="#问题：循环引用" class="headerlink" title="问题：循环引用"></a>问题：循环引用</h4><p>当 p 的指针断开的时候，内部的引用形成一个循环，这就是循环引用</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990932594-f3cdcf58-64ed-47a4-9b31-0681b17561e3.png"></p>
<p><strong>举例</strong></p>
<p>测试 Java 中是否采用的是引用计数算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为</span></span><br><span class="line">        <span class="comment">// 这里发生GC，obj1和obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</span><br></pre></td></tr></table></figure>

<p>上述进行了 GC 收集的行为，所以可以证明 JVM 中采用的不是引用计数器的算法</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990932537-383a3afb-d88b-4021-aeff-50102d05f12c.png"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p>
<p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>
<p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p>
<p>Python 如何解决循环引用？</p>
<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li>
</ul>
<h3 id="4-2-2-标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#4-2-2-标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="4.2.2 标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>4.2.2 标记阶段：可达性分析算法（根搜索算法、追踪性垃圾收集）</h3><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>
<p>相较于引用计数算法，这里的可达性分析就是 Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p>
<p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990932890-3106e7b1-a8a6-49d1-b645-3032e8589a20.png"></p>
<h4 id="在-Java-语言中，GC-Roots-包括以下几类元素："><a href="#在-Java-语言中，GC-Roots-包括以下几类元素：" class="headerlink" title="在 Java 语言中，GC Roots 包括以下几类元素："></a>在 Java 语言中，GC Roots 包括以下几类元素：</h4><ul>
<li>虚拟机栈中引用的对象<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象<ul>
<li>比如：Java 类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁 synchronized 持有的对象</li>
<li>Java 虚拟机内部的引用。<ul>
<li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>
</ul>
</li>
<li>反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990932968-64a0ce78-de13-4e9c-ba53-cdada7eb4902.png"></p>
<p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（PartialGC）。</p>
<p>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GCRoots 集合中去考虑，才能保证可达性分析的准确性。</p>
<p><font style="background-color:#FADB14;">小技巧：由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</font></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p>
<p>这点也是导致 GC 进行时必须“stop The World”的一个重要原因。</p>
<ul>
<li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。</li>
</ul>
<h3 id="4-2-3-对象的-finalization-机制"><a href="#4-2-3-对象的-finalization-机制" class="headerlink" title="4.2.3 对象的 finalization 机制"></a>4.2.3 对象的 finalization 机制</h3><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize()方法。</p>
<p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<p>永远不要主动调用某个对象的 finalize()方法 I 应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>在 finalize()时可能会导致对象复活。</li>
<li>finalize()方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize()方法将没有执行机会。</li>
<li>一个糟糕的 finalize()会严重影响 Gc 的性能。</li>
</ul>
<p>从功能上来说，finalize()方法与 C中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize()方法在本质上不同于 C中的析构函数。</p>
<p>由于 finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li>可触及的：从根节点开始，可以到达这个对象。</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在 finalize()中复活。</li>
<li>不可触及的：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</li>
</ul>
<p>以上 3 种状态中，是由于 inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p>
<ol>
<li>如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记。</li>
<li>进行筛选，判断此对象是否有必要执行 finalize()方法</li>
<li>如果对象 objA 没有重写 finalize()方法，或者 finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li>
<li>如果对象 objA 重写了 finalize()方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize()方法执行。</li>
<li>finalize()方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize 方法只会被调用一次。</li>
</ol>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;</span><br><span class="line">    <span class="comment">// 类变量，属于GC Roots的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj canReliveObj;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        canReliveObj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        canReliveObj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">        canReliveObj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------第一次gc操作------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------第二次gc操作------------&quot;</span>);</span><br><span class="line">        canReliveObj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------第一次gc操作------------</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">-----------------第二次gc操作------------</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>

<p>在第一次 GC 时，执行了 finalize 方法，但 finalize()方法只会被调用一次，所以第二次该对象被 GC 标记并清除了。</p>
<h2 id="4-3-扩展：MAT-与-JProfiler-的-GC-Roots-溯源"><a href="#4-3-扩展：MAT-与-JProfiler-的-GC-Roots-溯源" class="headerlink" title="4.3 扩展：MAT 与 JProfiler 的 GC Roots 溯源"></a>4.3 扩展：MAT 与 JProfiler 的 GC Roots 溯源</h2><h4 id="MAT-是什么？"><a href="#MAT-是什么？" class="headerlink" title="MAT 是什么？"></a>MAT 是什么？</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p>
<p>大家可以在 <a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a> 下载并使用 MAT</p>
<h4 id="获取-dump-文件"><a href="#获取-dump-文件" class="headerlink" title="获取 dump 文件"></a>获取 dump 文件</h4><h5 id="方式一：命令行使用-jmap"><a href="#方式一：命令行使用-jmap" class="headerlink" title="方式一：命令行使用 jmap"></a>方式一：命令行使用 jmap</h5><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990933029-4adb4df7-cc19-4072-a804-d96eecf7d948.png"></p>
<h5 id="方式二：使用-JVisualVM-导出"><a href="#方式二：使用-JVisualVM-导出" class="headerlink" title="方式二：使用 JVisualVM 导出"></a>方式二：使用 JVisualVM 导出</h5><p>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</p>
<p>可通过以下方法捕获 heap dump：</p>
<ul>
<li>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump（堆 Dump）。</li>
<li>在 Monitor（监视）子标签页中点击 Heap Dump（堆 Dump）按钮。</li>
</ul>
<p>本地应用程序的 Heap dumps 作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。</p>
<p>右击这个节点选择 save as（另存为）即可将 heap dump 保存到本地。</p>
<h5 id="方式三：使用-MAT-打开-Dump-文件"><a href="#方式三：使用-MAT-打开-Dump-文件" class="headerlink" title="方式三：使用 MAT 打开 Dump 文件"></a>方式三：使用 MAT 打开 Dump 文件</h5><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990933440-12975264-66da-41a2-bd8a-b244f30d6ec9.png"></p>
<h4 id="JProfiler-的-GC-Roots-溯源"><a href="#JProfiler-的-GC-Roots-溯源" class="headerlink" title="JProfiler 的 GC Roots 溯源"></a>JProfiler 的 GC Roots 溯源</h4><p>我们在实际的开发中，一般不会查找全部的 GC Roots，可能只是查找某个对象的整个链路，或者称为 GC Roots 溯源，这个时候，我们就可以使用 JProfiler</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990933295-c6575c37-35f4-4d7e-b3e2-dc83663914d2.png"></p>
<h2 id="4-4-清除阶段"><a href="#4-4-清除阶段" class="headerlink" title="4.4 清除阶段"></a>4.4 清除阶段</h2><h3 id="4-4-1-清除阶段：标记-清除算法"><a href="#4-4-1-清除阶段：标记-清除算法" class="headerlink" title="4.4.1 清除阶段：标记-清除算法"></a>4.4.1 清除阶段：标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<p>目前在 JVM 中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</p>
<h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并并应用于 Lisp 语言。</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
<ul>
<li>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象。</li>
<li>清除：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990933363-e36925cf-2f02-4ee0-b2d8-cf8648baa2a2.png"></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>标记清除算法的效率不算高</li>
<li>在进行 GC 的时候，需要停止整个应用程序，用户体验较差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>
</ul>
<h4 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
<h3 id="4-4-2-清除阶段：复制算法"><a href="#4-4-2-清除阶段：复制算法" class="headerlink" title="4.4.2 清除阶段：复制算法"></a>4.4.2 清除阶段：复制算法</h3><h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于 1963 年发表了著名的论文，“使用双存储区的 Lisp 语言垃圾收集器 CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990933500-531d493b-3c7e-4b30-b2f1-0683c18d689f.png"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</li>
</ul>
<h4 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h4><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在新生代，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990933654-0180061c-29d6-4835-9381-346831c97bcd.png"></p>
<h3 id="4-4-3-清除阶段：标记-压缩（整理）算法"><a href="#4-4-3-清除阶段：标记-压缩（整理）算法" class="headerlink" title="4.4.3 清除阶段：标记-压缩（整理）算法"></a>4.4.3 清除阶段：标记-压缩（整理）算法</h3><h4 id="标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="标记-压缩（或标记-整理、Mark-Compact）算法"></a>标记-压缩（或标记-整理、Mark-Compact）算法</h4><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
<p>1970 年前后，G.L.Steele、C.J.Chene 和 D.s.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><ol>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li>
<li>之后，清理边界外所有的空间。</li>
</ol>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990934105-8b6e4666-c2eb-4fd2-a7a0-34c41a897f61.png"></p>
<p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<h4 id="指针碰撞（Bump-the-Pointer）"><a href="#指针碰撞（Bump-the-Pointer）" class="headerlink" title="指针碰撞（Bump the Pointer）"></a>指针碰撞（Bump the Pointer）</h4><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>
</ul>
<h3 id="4-4-4-小结"><a href="#4-4-4-小结" class="headerlink" title="4.4.4 小结"></a>4.4.4 小结</h3><table>
<thead>
<tr>
<th></th>
<th align="left">Mark-Sweep</th>
<th align="left">Mark-Compact</th>
<th align="left">Copying</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td align="left">中等</td>
<td align="left">最慢</td>
<td align="left">最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td align="left">少（但会堆积碎片）</td>
<td align="left">少（不堆积碎片）</td>
<td align="left">通常需要活对象的 2 倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p>
<p>难道就没有一种最优算法吗？</p>
<p>回答：无，没有最好的算法，只有最合适的算法。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990934215-1f9bebda-b1bf-4dda-8d1a-42de6450589d.png"></p>
<h3 id="4-4-5-分代收集算法"><a href="#4-4-5-分代收集算法" class="headerlink" title="4.4.5 分代收集算法"></a>4.4.5 分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String 对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p>目前几乎所有的 GC 都采用分代手机算法执行垃圾回收的。</p>
<p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<h4 id="年轻代（Young-Gen）"><a href="#年轻代（Young-Gen）" class="headerlink" title="年轻代（Young Gen）"></a>年轻代（Young Gen）</h4><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解。</p>
<h4 id="老年代（Tenured-Gen）"><a href="#老年代（Tenured-Gen）" class="headerlink" title="老年代（Tenured Gen）"></a>老年代（Tenured Gen）</h4><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark 阶段的开销与存活对象的数量成正比。</li>
<li>Sweep 阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact 阶段的开销与存活对象的数据成正比。</li>
</ul>
<p>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>
<h3 id="4-4-5-增量收集算法、分区算法"><a href="#4-4-5-增量收集算法、分区算法" class="headerlink" title="4.4.5 增量收集算法、分区算法"></a>4.4.5 增量收集算法、分区算法</h3><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990934549-e3442b37-0c73-403d-9cf0-69a132d46672.png"></p>
<h4 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h4><p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>14 垃圾日志分析</title>
    <url>/2023/08/27/14%20%E5%9E%83%E5%9C%BE%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="日志概述"><a href="#日志概述" class="headerlink" title="日志概述"></a>日志概述</h1><p>通过阅读 Gc 日志，我们可以了解 Java 虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p>
<ul>
<li><code>-XX:+PrintGC</code> 输出 GC 日志。类似：<code>-verbose:gc</code></li>
<li><code>&lt;font style=&quot;background-color:#FADB14;&quot;&gt;-XX:+PrintGCDetails&lt;/font&gt;</code><font style="background-color:#FADB14;"> 输出 GC 的详细日志</font></li>
<li><code>-XX:+PrintGCTimestamps</code> 输出 GC 的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDatestamps</code> 输出 GcC 的时间戳（以日期的形式，如 2013-05-04T21：53：59.234+0800）</li>
<li><code>-XX:+PrintHeapAtGC</code> 在进行 GC 的前后打印出堆的信息</li>
<li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li>
</ul>
<span id="more"></span>
<h2 id="XX-PrintGC（输出简易GC日志信息）"><a href="#XX-PrintGC（输出简易GC日志信息）" class="headerlink" title="-XX:+PrintGC（输出简易GC日志信息）"></a>-XX:+PrintGC（输出简易GC日志信息）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-verbose:gc-XX:+PrintGC</span><br><span class="line"></span><br><span class="line">这个只会显示总的 GC 堆的变化，如下：</span><br><span class="line">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),0.0084018 secs]</span><br><span class="line">[GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),0.0184066 secs]</span><br><span class="line">[Full GC (Metadata GC Threshold) 21465K-&gt;16716K(201728K),0.0619261 secs]</span><br><span class="line"></span><br><span class="line">参数详解</span><br><span class="line">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。</span><br><span class="line">Allocation Failure：GC发生的原因。</span><br><span class="line"><span class="meta prompt_">80832K-&gt;</span><span class="language-bash">19298K：堆在GC前的大小和GC后的大小。</span></span><br><span class="line">228840k：现在的堆大小。</span><br><span class="line">0.0084018 secs：GC持续的时间。</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632819429581-52a88e22-da7e-4ec1-9db1-d992f3c5041d.png"></h2><h2 id="XX-PrintGCDetails（输出详细GC信息）"><a href="#XX-PrintGCDetails（输出详细GC信息）" class="headerlink" title="-XX:+PrintGCDetails（输出详细GC信息）"></a>-XX:+PrintGCDetails（输出详细GC信息）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line">输入信息如下</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),0.0172573 secs] [Times:user=0.03 sys=0.00,real=0.02 secs]</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),0.0151573 secs] [Times:user=0.00 sys=0.01,real=0.02 secs]</span><br><span class="line">[Full GC (Metadata GC Threshold)[PSYoungGen:8154K-&gt;0K(142336K)]</span><br><span class="line">[ParOldGen:13107K-&gt;16809K(62464K)] 21261K-&gt;16809K(204800K),[Metaspace:20599K-&gt;20599K(1067008K)],0.0639732 secs]</span><br><span class="line">[Times:user=0.14 sys=0.00,real=0.06 secs]</span><br><span class="line"></span><br><span class="line">参数解析</span><br><span class="line">GC，Full FC：同样是GC的类型</span><br><span class="line">Allocation Failure：GC原因</span><br><span class="line">PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化</span><br><span class="line">ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化</span><br><span class="line">Metaspace： 元数据区GC前后大小的变化，JDK1.8中引入了元数据区以替代永久代</span><br><span class="line">xxx secs：指GC花费的时间</span><br><span class="line">Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632819896906-7337d0e1-f203-42c4-a261-8c2d0cb128b7.png"></p>
<h2 id="XX-PrintGCTimestamps-XX-PrintGCDatestamps（格式化）"><a href="#XX-PrintGCTimestamps-XX-PrintGCDatestamps（格式化）" class="headerlink" title="-XX:+PrintGCTimestamps -XX:+PrintGCDatestamps（格式化）"></a>-XX:+PrintGCTimestamps -XX:+PrintGCDatestamps（格式化）</h2><p>打开 GC 日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps</span><br><span class="line"></span><br><span class="line">输入信息如下</span><br><span class="line">2019-09-24T22:15:24.518+0800: 3.287: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),0.0248249 secs] [Times:user=0.05 sys=0.00,real=0.03 secs]</span><br><span class="line">2019-09-24T22:15:25.559+0800: 4.329: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),0.0094071 secs] [Times: user=0.00 sys=0.00,real=0.01 secs]</span><br><span class="line">2019-09-24T22:15:25.569+0800: 4.338: [Full GC (Metadata GC Threshold) [PSYoungGen:10068K-&gt;0K(274944K)][ParoldGen:12590K-&gt;13564K(56320K)] 22658K-&gt;13564K(331264K),[Metaspace:20590K-&gt;20590K(1067008K)],0.0494875 secs] [Times: user=0.17 sys=0.02,real=0.05 secs]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632820318644-f3062ecf-3585-40fd-bc61-7c2e9faf6fea.png"></p>
<h2 id="XX-PrintHeapAtGC（在进行GC前后打印日志信息）"><a href="#XX-PrintHeapAtGC（在进行GC前后打印日志信息）" class="headerlink" title="-XX:+PrintHeapAtGC（在进行GC前后打印日志信息）"></a>-XX:+PrintHeapAtGC（在进行GC前后打印日志信息）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintHeapAtGC</span><br></pre></td></tr></table></figure>

<h2 id="Xloggc-path（打印输出日志）"><a href="#Xloggc-path（打印输出日志）" class="headerlink" title="-Xloggc:path（打印输出日志）"></a>-Xloggc:path（打印输出日志）</h2><p>说明：带上了日期和实践</p>
<p>如果想把 GC 日志存到文件的话，是下面的参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xloggc:/path/to/gc.log</span><br></pre></td></tr></table></figure>

<h2 id="日志补充说明"><a href="#日志补充说明" class="headerlink" title="日志补充说明"></a>日志补充说明</h2><ul>
<li>“<code>[GC</code>“和”<code>[Full GC</code>“说明了这次垃圾收集的停顿类型，如果有”Full”则说明 GC 发生了”Stop The World”</li>
<li>各个不同垃圾回收器显示的名称<ul>
<li>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是”<code>[DefNew</code>“</li>
<li>使用 ParNew 收集器在新生代的名字会变成”<code>[ParNew</code>“，意思是”Parallel New Generation”</li>
<li>使用 Parallel scavenge 收集器在新生代的名字是”<code>[PSYoungGen</code>“，老年代为ParOldGen</li>
<li>使用 G1 收集器的话，会显示为”garbage-first heap”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
</ul>
</li>
<li>Allocation Failure<br>表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li>
<li>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)<br>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）<br>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
<li>user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时。由于多核的原因，时间总和可能会超过 real 时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap（堆）</span><br><span class="line">PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="number">0x00000000ff600000</span>,<span class="number">0x0000000100000000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">eden space（堆中的Eden区默认占比是<span class="number">8</span>）8192K，<span class="number">768</span> used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc16b08</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="number">1</span>）1024K， <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line">object space（显示个使用百分比）10240K，<span class="number">688</span> used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff2d6630</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line">PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000faf00000</span>,<span class="number">0x00000000fec00000</span>)</span><br><span class="line">object space（显示个使用百分比，自己能算出来）21504K， <span class="number">238</span> used [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000f9ed55e0</span>,<span class="number">0x00000000faf00000</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Minor-GC-日志"><a href="#Minor-GC-日志" class="headerlink" title="Minor GC 日志"></a>Minor GC 日志</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990983376-fdab7655-dc7d-4176-8122-7bb0d611c161.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632825435480-7c2bb68e-5fa4-472b-9adf-af73675cb187.png"></p>
<h1 id="Full-GC-日志"><a href="#Full-GC-日志" class="headerlink" title="Full GC 日志"></a>Full GC 日志</h1><p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632825206774-ba7e1396-0baa-4485-b550-84d4416e43f1.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632825446168-bbb7c2d3-57f8-48cc-8476-6fd1b7582014.png"></p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>视频：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=198&spm_id_from=pageDriver">https://www.bilibili.com/video/BV1PJ411n7xZ?p=198&spm_id_from&#x3D;pageDriver</a></p>
<blockquote>
<p><strong>设置 JVM 参数</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  参数说明：</span><br><span class="line">  -Xms：初始堆总大小20M，Xmx最大20M</span><br><span class="line">  -Xmn：新生代大小10M</span><br><span class="line">  -XX:SurvivorRatio=8：Eden占新生代的8/10，From幸存区和To幸存区各占新生代的1/10</span><br><span class="line">  -XX:+PrintGCDetails打印GC细节</span><br><span class="line">  -XX:+UseSerialGC：使用最简单的串行垃圾收集器</span><br><span class="line">*/</span><br><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--测试OOM</span><br><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>JDK7下</strong></p>
</blockquote>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632828040232-277149ea-3a90-48c9-aca1-e9979a1baaae.png"></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/8dada6b73786eb693975593db10ce825.png&sign=d3ad6b703025e9a3326785829f8ff90fa41f02e810f3c8023e3948566c9eedb6"></p>
<blockquote>
<p><strong>JDK8</strong></p>
</blockquote>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2021/png/696107/1632828206136-1ebc8000-811e-4620-87a7-517c80ab8fa7.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990983376-f96eb4b8-6827-4892-b699-62a0c6aa965b.png"></p>
<p>可以用一些工具去分析这些 GC 日志</p>
<p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p>
<h1 id="-1"><a href="#-1" class="headerlink" title="["></a>[</h1><p>](<a href="https://www.infoq.com/articles/azul_gc_in_detail">https://www.infoq.com/articles/azul_gc_in_detail</a>)</p>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>13 垃圾回收器</title>
    <url>/2023/08/26/13%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-GC-分类与性能指标"><a href="#1-GC-分类与性能指标" class="headerlink" title="1 GC 分类与性能指标"></a>1 GC 分类与性能指标</h1><h2 id="1-1-垃圾回收器概述"><a href="#1-1-垃圾回收器概述" class="headerlink" title="1.1 垃圾回收器概述"></a>1.1 垃圾回收器概述</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p>
<p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p>
<p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p>
<span id="more"></span>
<h2 id="1-2-垃圾收集器分类"><a href="#1-2-垃圾收集器分类" class="headerlink" title="1.2 垃圾收集器分类"></a>1.2 垃圾收集器分类</h2><p>按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961605-15b5d1e4-bdd2-4073-8a88-75d3560efe92.png"></p>
<p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的 Client 模式下的 JVM 中</li>
<li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
<p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p>
<p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961351-8dc80392-f4ad-4c5b-857b-666535277caf.png"></p>
<p>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>非压缩式的垃圾回收器不进行这步操作。</li>
</ul>
<p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>
<h2 id="1-3-评估-GC-的性能指标"><a href="#1-3-评估-GC-的性能指标" class="headerlink" title="1.3 评估 GC 的性能指标"></a>1.3 评估 GC 的性能指标</h2><ul>
<li>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>内存占用：Java 堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p>
<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p>
<p>简单来说，主要抓住两点：吞吐量、暂停时间</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 &#x3D; 0.4</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961427-5cfeabec-d6da-4c7b-86f3-2ad9741cceeb.png"></p>
<h3 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。</p>
<p>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</p>
<p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 &#x3D; 0.5</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961506-1a4386a1-4cf8-4d3f-bcb5-2a573269bf9f.png"></p>
<h3 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
<p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
<p>现在标准：在最大吞吐量优先的情况下，降低停顿时间</p>
<h1 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2 不同的垃圾回收器概述"></a>2 不同的垃圾回收器概述</h1><h2 id="2-1-不同的垃圾收集器概述"><a href="#2-1-不同的垃圾收集器概述" class="headerlink" title="2.1 不同的垃圾收集器概述"></a>2.1 不同的垃圾收集器概述</h2><p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p>
<h2 id="2-2-如何查看默认垃圾收集器"><a href="#2-2-如何查看默认垃圾收集器" class="headerlink" title="2.2 如何查看默认垃圾收集器"></a>2.2 如何查看默认垃圾收集器</h2><p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p>
<p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p>
<h2 id="2-3-垃圾回收器发展史"><a href="#2-3-垃圾回收器发展史" class="headerlink" title="2.3 垃圾回收器发展史"></a>2.3 垃圾回收器发展史</h2><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p>
<ul>
<li>1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本</li>
<li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·</li>
<li>Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。</li>
<li>2012 年，在 JDK1.7u4 版本中，G1 可用。</li>
<li>2017 年，JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li>
<li>2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。·</li>
<li>2019 年 9 月，JDK13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020 年 3 月，JDK14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macos 和 Windows 上的应用</li>
</ul>
<h2 id="2-4-7-种经典的垃圾收集器"><a href="#2-4-7-种经典的垃圾收集器" class="headerlink" title="2.4 7 种经典的垃圾收集器"></a>2.4 7 种经典的垃圾收集器</h2><ul>
<li>串行回收器：Serial、Serial Old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>
<li>并发回收器：CMS、G1</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961459-90114bb1-e3c9-4430-950f-7587ea3deb89.png"></p>
<p>官方手册：<a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>截止 JDK1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<table>
<thead>
<tr>
<th>组合</th>
<th align="left"><strong>垃圾收集器</strong></th>
<th align="left"><strong>分类</strong></th>
<th align="left"><strong>作用位置</strong></th>
<th align="left"><strong>使用算法</strong></th>
<th align="left"><strong>特点</strong></th>
<th align="left"><strong>适用场景</strong></th>
<th><strong>历史</strong></th>
</tr>
</thead>
<tbody><tr>
<td>可组合<br/></td>
<td align="left">Serial</td>
<td align="left">串行运行</td>
<td align="left">作用于新生代</td>
<td align="left">复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">适用于单 CPU 环境下的 client 模式</td>
<td><font style="background-color:#FFFB8F;">JDK1.3 之前回收新生代唯一的选择。</font><br/><font style="background-color:#FFFB8F;">Serial 收集器作为 HotSpot 中 client 模式下的默认新生代垃圾收集器</font></td>
</tr>
<tr>
<td></td>
<td align="left">Serial Old</td>
<td align="left">串行运行</td>
<td align="left">作用于老年代</td>
<td align="left">标记-压缩算法</td>
<td align="left">响应速度优先</td>
<td align="left">适用于单 CPU 环境下的 Client 模式</td>
<td><font style="background-color:#FFFB8F;"></font></td>
</tr>
<tr>
<td></td>
<td align="left">ParNew</td>
<td align="left">并行运行</td>
<td align="left">作用于新生代</td>
<td align="left">复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">多 CPU 环境 Server 模式下与 CMS 配合使用</td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left">CMS</td>
<td align="left">并发运行</td>
<td align="left">作用于老年代</td>
<td align="left">标记-清除算法</td>
<td align="left">响应速度优先</td>
<td align="left">适用于互联网或 B／S 业务</td>
<td>JDK14 发布。删除 CMS 垃圾回收器</td>
</tr>
<tr>
<td>可组合</td>
<td align="left">Parallel</td>
<td align="left">并行运行</td>
<td align="left">作用于新生代</td>
<td align="left">复制算法</td>
<td align="left">吞吐量优先</td>
<td align="left">适用于后台运算而不需要太多交互的场景</td>
<td><font style="background-color:#FFFB8F;">Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC</font><br/><font style="background-color:#FFFB8F;">JDK8默认组合就是使用Parallel GC+Parallel Old GC</font></td>
</tr>
<tr>
<td></td>
<td align="left">Parallel Old</td>
<td align="left">并行运行</td>
<td align="left">作用于老年代</td>
<td align="left">标记-压缩算法</td>
<td align="left">吞吐量优先</td>
<td align="left">适用于后台运算而不需要太多交互的场景</td>
<td></td>
</tr>
<tr>
<td>全功能独立</td>
<td align="left">G1</td>
<td align="left">并发、并行运行</td>
<td align="left">作用于新生代、老年代</td>
<td align="left">标记-压缩算法、复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">面向服务端应用</td>
<td>JDK7开始引入<br/>JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS</td>
</tr>
</tbody></table>
<p>GC 发展阶段：Serial &#x3D;&gt; Parallel（并行）&#x3D;&gt; CMS（并发）&#x3D;&gt; G1 &#x3D;&gt; ZGC</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 Gc 有什么不同呢？</p>
<p>请记住以下口令：</p>
<ul>
<li>如果你想要最小化地使用内存和并行开销，请选 Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC；</li>
<li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li>
</ul>
<h2 id="2-5-7-款经典收集器与垃圾分代之间的关系"><a href="#2-5-7-款经典收集器与垃圾分代之间的关系" class="headerlink" title="2.5 7 款经典收集器与垃圾分代之间的关系"></a>2.5 7 款经典收集器与垃圾分代之间的关系</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961809-4b696c28-1dc3-4727-85b0-806f28f45ef2.png"></p>
<ul>
<li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS；</li>
<li>整堆收集器：G1；</li>
</ul>
<h2 id="2-6-垃圾收集器的组合关系"><a href="#2-6-垃圾收集器的组合关系" class="headerlink" title="2.6 垃圾收集器的组合关系"></a>2.6 垃圾收集器的组合关系</h2><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961862-ba70d031-cb31-41a4-899b-64a70cbfdd11.png"></p>
<ol>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial&#x2F;Serial Old、Serial&#x2F;CMS、ParNew&#x2F;Serial Old、ParNew&#x2F;CMS、Parallel Scavenge&#x2F;Serial Old、Parallel Scavenge&#x2F;Parallel Old、G1；</li>
<li>其中 Serial Old 作为 CMS 出现”<code>Concurrent Mode Failure</code>“失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）</li>
<li>（绿色虚框）JDK14 中：删除 CMS 垃圾回收器（JEP363）</li>
</ol>
<h2 id="2-7-怎么选择垃圾回收器"><a href="#2-7-怎么选择垃圾回收器" class="headerlink" title="2.7 怎么选择垃圾回收器"></a>2.7 怎么选择垃圾回收器</h2><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p>
<p>怎么选择垃圾收集器？</p>
<ol>
<li>优先调整堆的大小让 JVM 自适应完成。</li>
<li>如果内存小于 100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</li>
<li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器<br>官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1。</li>
</ol>
<p>最后需要明确一个观点：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
<p><strong>面试</strong></p>
<p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p>
<ul>
<li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
<p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="3-经典垃圾回收器详解"><a href="#3-经典垃圾回收器详解" class="headerlink" title="3 经典垃圾回收器详解"></a>3 经典垃圾回收器详解</h1><h2 id="3-1-Serial-回收器：串行回收"><a href="#3-1-Serial-回收器：串行回收" class="headerlink" title="3.1 Serial 回收器：串行回收"></a>3.1 Serial 回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p>
<p>Serial 收集器作为 HotSpot 中 client 模式下的默认新生代垃圾收集器。</p>
<p>Serial 收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p>
<p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。Serial Old 收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<ul>
<li>Serial old 是运行在 Client 模式下默认的老年代的垃圾回收器</li>
<li>Serial 0ld 在 Server 模式下主要有两个用途：① 与新生代的 Parallel scavenge 配合使用 ② 作为老年代 CMS 收集器的后备垃圾收集方案</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961923-707d3ec5-4e59-4b56-861f-78db75906d00.png"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p>
<p>优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在 Client 模式下的虚拟机是个不错的选择。</p>
<p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC</p>
<p><strong>总结</strong></p>
<p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu 才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</p>
<h2 id="3-2-ParNew-回收器：并行回收"><a href="#3-2-ParNew-回收器：并行回收" class="headerlink" title="3.2 ParNew 回收器：并行回收"></a>3.2 ParNew 回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，New：只能处理的是新生代</p>
<p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。</p>
<p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990961972-42612e3a-4fd9-4cb0-9d25-49ca59b72e18.png"></p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效。</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 serial 收集器更高效？</p>
<ul>
<li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
<p>因为除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p>
<p>在程序中，开发人员可以通过选项”<code>-XX:+UseParNewGC</code>“手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和 CPU 数据相同的线程数。</p>
<h2 id="3-3-CMS-回收器：低延迟（并发）"><a href="#3-3-CMS-回收器：低延迟（并发）" class="headerlink" title="3.3 CMS 回收器：低延迟（并发）"></a>3.3 CMS 回收器：低延迟（并发）</h2><p>在 JDK1.5 时期，Hotspot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li>目前很大一部分的 Java 应用集中在互联网站或者 B&#x2F;S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li>
</ul>
<p>CMS 的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-World”</p>
<p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p>
<p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962108-2f106f21-6fa7-4c41-84f2-685dc98609ed.png"></p>
<p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p>
<ul>
<li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出 GCRoots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li>
<li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
<p>尽管 CMS 收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p>
<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962335-63fd4ecf-3923-4f85-af90-2d03c8b56296.png"></p>
<p><strong>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact？</strong></p>
<p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact 更适合“Stop the World” 这种场景下使用</p>
<h3 id="CMS-的优点"><a href="#CMS-的优点" class="headerlink" title="CMS 的优点"></a>CMS 的优点</h3><ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<h3 id="CMS-的弊端"><a href="#CMS-的弊端" class="headerlink" title="CMS 的弊端"></a>CMS 的弊端</h3><ul>
<li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC。</li>
<li>CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li>CMS 收集器无法处理浮动垃圾。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li>
</ul>
<h3 id="设置的参数"><a href="#设置的参数" class="headerlink" title="设置的参数"></a>设置的参数</h3><ul>
<li><code>-XX:+UseConcMarkSweepGC</code>手动指定使用 CMS 收集器执行内存回收任务。<br>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young 区用）+CMS（Old 区用）+ Serial Old 的组合。</li>
<li><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul>
<li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。JDK6 及以上版本默认值为 92%</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Ful1Gc 的执行次数。</li>
</ul>
</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。</li>
<li><code>-XX:ParallelcMSThreads</code> 设置 CMS 的线程数量。<ul>
<li>CMS 默认启动的线程数是（ParallelGCThreads+3）&#x2F;4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<h3 id="JDK-后续版本中-CMS-的变化"><a href="#JDK-后续版本中-CMS-的变化" class="headerlink" title="JDK 后续版本中 CMS 的变化"></a>JDK 后续版本中 CMS 的变化</h3><p>JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p>
<ul>
<li>如果对 JDK9 及以上版本的 HotSpot 虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li>
</ul>
<p>JDK14 新特性：删除 CMS 垃圾回收器（JEP363）</p>
<ul>
<li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM 不会报错，只是给出一个 warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM</li>
</ul>
<h1 id="4-Parallel-回收器：吞吐量优先-JDK8中默认的即是Parallel-x2F-ParlallelOld"><a href="#4-Parallel-回收器：吞吐量优先-JDK8中默认的即是Parallel-x2F-ParlallelOld" class="headerlink" title="4 Parallel 回收器：吞吐量优先(JDK8中默认的即是Parallel&#x2F;ParlallelOld)"></a>4 Parallel 回收器：吞吐量优先(JDK8中默认的即是Parallel&#x2F;ParlallelOld)</h1><p><strong><font style="background-color:#FADB14;">核心特点：主打服务器端、JDK8中默认的、Parallel+ParlallelOld新生代和老年代搭配使用</font></strong></p>
<p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p>
<p>那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和 ParNew 收集器不同，ParallelScavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>
<li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li>
</ul>
<p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
<p>Parallel Old 收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/8a4b655ee277aaf0f9a46754248ce05a.png&sign=4abc526a299d375dbbfcb0bb78a08b41ae0bb53b31e376ef932001bb22848622"></p>
<p>在程序吞吐量优先的应用场景中，<font style="background-color:#FADB14;">Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java8 中，默认是此垃圾收集器</font>。</p>
<p><strong>参数配置</strong></p>
<ul>
<li><code>-XX:+UseParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</li>
<li><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。<ul>
<li>分别适用于新生代和老年代。默认 jdk8 是开启的。</li>
<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。<br>$ ParallelGCThreads &#x3D; \begin{cases} CPU_Count &amp; \text (CPU_Count &lt;&#x3D; 8) \ 3 + (5 * CPUï¼¿Count &#x2F; 8) &amp; \text (CPU_Count &gt; 8) \end{cases}<br> $</li>
<li><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STw 的时间）。单位是毫秒。<ul>
<li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li>
<li>该参数使用需谨慎。</li>
</ul>
</li>
<li><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（&#x3D;1&#x2F;（N+1））。用于衡量吞吐量的大小。<ul>
<li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li>
<li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li>
</ul>
</li>
<li><code>-XX:+UseAdaptivesizePolicy</code> 设置 Parallel Scavenge 收集器具有自适应调节策略<ul>
<li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
<h1 id="5-分代垃圾回收器：G1-JDK9之后默认的"><a href="#5-分代垃圾回收器：G1-JDK9之后默认的" class="headerlink" title="5 分代垃圾回收器：G1(JDK9之后默认的)"></a>5 分代垃圾回收器：G1(JDK9之后默认的)</h1><p><strong>既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？</strong></p>
<p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序正常进行，而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。G1（Garbage-First）垃圾回收器是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
<p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<p>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</p>
<p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p>
<p>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</p>
<p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在 JDK1.7 版本正式启用，移除了 Experimenta1 的标识，是JDK9 以后的默认垃圾回收器，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“全功能的垃圾收集器”。</p>
<p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p>
<h2 id="1-G1-回收器的特点-优势"><a href="#1-G1-回收器的特点-优势" class="headerlink" title="1 G1 回收器的特点(优势)"></a>1 G1 回收器的特点(优势)</h2><p>与其他 GC 收集器相比，G1 使用了全新的分区算法，其特点如下所示：</p>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul>
<li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li>
<li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><ul>
<li>从分代上看，G1 依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962376-5480ae15-bba1-4080-b9ba-4ae56e132291.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962530-f9cc3751-9ccf-477b-aef3-cccf21eecbc7.png"></p>
<h3 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h3><ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理</li>
<li>G1 将内存划分为一个个的 region。内存的回收是以 region 作为基本单位的。Region 之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li>
</ul>
<h3 id="可预测的停顿时间模型（即：软实时-soft-real-time）"><a href="#可预测的停顿时间模型（即：软实时-soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即：软实时 soft real-time）"></a>可预测的停顿时间模型（即：软实时 soft real-time）</h3><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
<ul>
<li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于 CMSGC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<h2 id="2-G1-收集器的适用场景"><a href="#2-G1-收集器的适用场景" class="headerlink" title="2 G1 收集器的适用场景"></a>2 G1 收集器的适用场景</h2><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
<p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p>
<p>用来替换掉 JDK1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p>
<ul>
<li>超过 50%的 Java 堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC 停顿时间过长（长于 0.5 至 1 秒）</li>
</ul>
<p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<h2 id="3-G1-垃圾收集器的缺点"><a href="#3-G1-垃圾收集器的缺点" class="headerlink" title="3 G1 垃圾收集器的缺点"></a>3 G1 垃圾收集器的缺点</h2><p>占用额外的内容空间。</p>
<p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p>
<p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。</p>
<h2 id="4-G1-常见操作步骤和参数设置"><a href="#4-G1-常见操作步骤和参数设置" class="headerlink" title="4 G1 常见操作步骤和参数设置"></a>4 G1 常见操作步骤和参数设置</h2><blockquote>
<p><strong>操作步骤</strong></p>
</blockquote>
<p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启 G1 垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
<p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p>
<blockquote>
<p><strong>参数设置</strong></p>
</blockquote>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1&#x2F;2000。</li>
<li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）</li>
<li><code>-XX:+ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8（上面说过 Parallel 回收器的线程计算公式，当 CPU_Count &gt; 8 时，ParallelGCThreads 也会大于 8）</li>
<li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1&#x2F;4 左右。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li>
</ul>
<h2 id="5-核心概念一：分区-Region：化整为零"><a href="#5-核心概念一：分区-Region：化整为零" class="headerlink" title="5 核心概念一：分区 Region：化整为零"></a>5 核心概念一：分区 Region：化整为零</h2><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962444-05aa7093-f41d-452f-ac78-77d724d291d3.png"></p>
<p>一个 region 有可能属于 Eden，Survivor 或者 Old&#x2F;Tenured 内存区域。但是一个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p>
<p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 region，就放到 H。</p>
<p>设置 H 的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p>
<p>每个 Region 都是通过指针碰撞来分配空间</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962700-d5f6c78e-3fbe-499e-9493-c97434fb100c.png"></p>
<h2 id="6-核心概念二：Remembered-Set"><a href="#6-核心概念二：Remembered-Set" class="headerlink" title="6 核心概念二：Remembered Set"></a>6 核心概念二：Remembered Set</h2><ul>
<li>一个对象被不同区域引用的问题</li>
<li>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</li>
<li>在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？</li>
<li>这样的话会降低 MinorGC 的效率；</li>
</ul>
<p><strong>解决方法：</strong></p>
<p>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：</p>
<p>每个 Region 都有一个对应的 Remembered Set；</p>
<p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；</p>
<p>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
<p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；</p>
<p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/img_convert/c97de4bdada1da5a9fdd344692ed0957.png&sign=e57aa46582d6e20d0b29bf359c4d68440be1b2c66799c5f0499cee3e39d4b555"></p>
<h2 id="7-G1-垃圾回收器的回收过程"><a href="#7-G1-垃圾回收器的回收过程" class="headerlink" title="7 G1 垃圾回收器的回收过程"></a>7 G1 垃圾回收器的回收过程</h2><p>G1GC 的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代 GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）<br>（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962828-465533bc-141b-4d4a-9b68-c0e5761090e3.png"></p>
<p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC 顺序，进行垃圾回收。</p>
<p>应用程序分配内存，当年轻代的 Eden 区用尽时开始年轻代回收过程；G1 的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的 Region 就可以了。同时，这个老年代 Region 是和年轻代一起被回收的。</p>
<p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<h3 id="G1-回收过程一：年轻代-GC"><a href="#G1-回收过程一：年轻代-GC" class="headerlink" title="G1 回收过程一：年轻代 GC"></a>G1 回收过程一：年轻代 GC</h3><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p>
<p>首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962892-5a63a12f-d0af-4fa4-a7aa-4f8d33e4d459.png"></p>
<p>然后开始如下回收过程：</p>
<ol>
<li>第一阶段，扫描根。根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</li>
<li>第二阶段，更新 RSet。处理 dirty card queue（见备注）中的 card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代对所在的内存分段中对象的引用。</li>
<li>第三阶段，处理 RSet。识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li>
<li>第四阶段，复制对象。此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</li>
<li>第五阶段，处理引用。处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
</ol>
<h3 id="G1-回收过程二：并发标记过程"><a href="#G1-回收过程二：并发标记过程" class="headerlink" title="G1 回收过程二：并发标记过程"></a>G1 回收过程二：并发标记过程</h3><ol>
<li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li>
<li>根区域扫描（Root Region Scanning）：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 YoungGC 之前完成。</li>
<li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 YoungGC 中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>
<li>独占清理（cleanup，STW）：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集</li>
<li>并发清理阶段：识别并清理完全空闲的区域。</li>
</ol>
<h3 id="G1-回收过程三：混合回收"><a href="#G1-回收过程三：混合回收" class="headerlink" title="G1 回收过程三：混合回收"></a>G1 回收过程三：混合回收</h3><p>当越来越多的对象晋升到老年代 o1d region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990962943-093f50e1-bc1c-422c-be77-b8ccc7e76890.png"></p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p>
<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行 8 次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p>
<h3 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h3><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p>
<p>导致 G1 Full GC 的原因可能有两个：</p>
<ul>
<li>Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<h2 id="8-补充"><a href="#8-补充" class="headerlink" title="8 补充"></a>8 补充</h2><p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h2 id="9-G1-回收器优化建议"><a href="#9-G1-回收器优化建议" class="headerlink" title="9 G1 回收器优化建议"></a>9 G1 回收器优化建议</h2><p>年轻代大小</p>
<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
<p>暂停时间目标不要太过严苛</p>
<ul>
<li>G1 GC 的吞吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li>
<li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
<h1 id="10-垃圾回收器的新发展"><a href="#10-垃圾回收器的新发展" class="headerlink" title="10 垃圾回收器的新发展"></a>10 垃圾回收器的新发展</h1><p>GC 仍然处于飞速发展之中，目前的默认选项G1 GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Fu11GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Fu11GC 已经是并行运行，在很多场景下，其表现还略优于 ParallelGC 的并行 Ful1GC 实现。</p>
<p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。</p>
<p>比较不幸的是 CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK9 中已经被标记为废弃，并在 JDK14 版本中移除</p>
<h2 id="JDK11-新特性"><a href="#JDK11-新特性" class="headerlink" title="JDK11 新特性"></a>JDK11 新特性</h2><p>Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/318</a></p>
<p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）<a href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/333</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990963233-11a6f137-e199-4b12-bbbb-24ebf66c7e29.png"></p>
<p>现在 G1 回收器已成为默认回收器好几年了。</p>
<p>我们还看到了引入了两个新的收集器：ZGC（JDK11 出现）和 Shenandoah（Open JDK12）。主打特点：低停顿时间</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990963244-7b8eeea8-27a8-405d-87d3-091316239271.png"></p>
<h2 id="Open-JDK12-的-Shenandoash-GC"><a href="#Open-JDK12-的-Shenandoash-GC" class="headerlink" title="Open JDK12 的 Shenandoash GC"></a>Open JDK12 的 Shenandoash GC</h2><p>Open JDK12 的 Shenandoash GC：低停顿时间的 GC（实验性）</p>
<p>Shenandoah，无疑是众多 GC 中最孤独的一个。是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的受到官方的排挤。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 OracleJDK12 中支持 Shenandoah。</p>
<p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM 上的内存回收实现低停顿的需求.。在 2014 年贡献给 OpenJDK。</p>
<p>Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990963303-d56e2cea-1782-4b65-b4af-f41f777b0760.png"></p>
<p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 Es 对 200GB 的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
<p>总结</p>
<ul>
<li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li>
<li>Shenandoah GC 的强项：低延迟时间。</li>
<li>Shenandoah GC 的工作过程大致分为九个阶段，这里就不再赘述。在之前 Java12 新特性视频里有过介绍。</li>
</ul>
<p>【Java12 新特性地址】</p>
<p><a href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v&#x3D;222</a></p>
<p>或</p>
<p><a href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&seid=12339069673726242866</a></p>
<h2 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h2><p>官方地址：<a href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990963400-59d87164-c8af-442f-aa84-bcc4b28a0417.png"></p>
<p>ZGC 与 Shenandoah 目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p>
<p>《深入理解 Java 虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC 的工作过程可以分为 4 个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射 等。</p>
<p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STw 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
<p>测试数据：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990963408-60791f93-626e-4ee9-9c8f-36440487ea39.png"></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990963930-ef45d136-1b2a-404e-8f7e-3b7cbebc082e.png"></p>
<p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p>
<p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990963821-88c657ab-7372-4940-9fd5-542b98d7f0c9.png"></p>
<p>JEP 364：ZGC 应用在 macos 上</p>
<p>JEP 365：ZGC 应用在 Windows 上</p>
<p>JDK14 之前，ZGC 仅 Linux 才支持。</p>
<p>尽管许多使用 zGc 的用户都使用类 Linux 的环境，但在 Windows 和 macos 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macos 上。</p>
<p>现在 mac 或 Windows 上也能使用 zGC 了，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></table></figure>

<h2 id="其他垃圾回收器：AliGC"><a href="#其他垃圾回收器：AliGC" class="headerlink" title="其他垃圾回收器：AliGC"></a>其他垃圾回收器：AliGC</h2><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1719990964049-702deb07-5903-4612-840b-2e21b9e9308a.png"></p>
<p>当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC：Zing，有兴趣可以参考提供的链接 <a href="https://www.infoq.com/articles/azul_gc_in_detail">https://www.infoq.com/articles/azul_gc_in_detail</a></p>
]]></content>
      <categories>
        <category>JVM上篇：内存与垃圾回收篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
