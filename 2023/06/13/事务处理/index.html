<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="事务的四大特性 原子性(Atomicity) 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性(Consistency) 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。">
<meta property="og:type" content="article">
<meta property="og:title" content="事务处理">
<meta property="og:url" content="http://example.com/2023/06/13/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="进学阁">
<meta property="og:description" content="事务的四大特性 原子性(Atomicity) 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性(Consistency) 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716974826311-3b0e8907-86d6-44db-a7cb-7d738e3f4780.png">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039295214-f6b578a9-f5b8-42ad-a084-574eadda6268.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039890546-106f9f7f-79d2-40c7-b110-1bec3c7d5758.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039898106-00a40ce6-3800-47f8-a8cc-ce1156f47093.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039960367-31d88ae9-d08e-4582-aa7d-5f4b07627fec.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717040314866-11d5dd8b-e6dd-440b-92d2-0a384c1d896b.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717040599275-ea807cb7-1694-4ca0-8396-60c6dc9c385c.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048524181-8e1e70d4-c0b1-49f5-8cb1-32e3dbbb4ed5.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048524123-cd2cf78d-57d4-433c-a3d0-c4860e769979.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559781-c6ab3c4f-fc28-41fc-b4cf-25bf985a0d6b.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559736-8999a648-def3-46d1-8be3-ab48d174d901.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559623-6cee2ece-15a0-4afc-b749-8562c3693d60.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559795-7654eac6-debc-4019-867e-87fd9bd6fe0d.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559686-29a20060-b95e-483a-8701-ba33a77ea3b2.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048833158-398a5518-357e-412b-914d-4790a49e8c93.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048832921-a527647d-5789-49a2-bd67-24a5434a9466.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717049082035-9b10eb14-bac6-4727-b729-554586cc0f3b.webp">
<meta property="og:image" content="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717049340079-d389ca08-a8b4-47fb-a95e-1b69427149a0.webp">
<meta property="article:published_time" content="2023-06-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-06T09:30:49.401Z">
<meta property="article:author" content="139">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="事务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716974826311-3b0e8907-86d6-44db-a7cb-7d738e3f4780.png">

<link rel="canonical" href="http://example.com/2023/06/13/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>事务处理 | 进学阁</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">进学阁</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">业精于勤荒于嬉，行成于思毁于随</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">54</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/13/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom/avatar.jpg">
      <meta itemprop="name" content="139">
      <meta itemprop="description" content="一个普通的JAVA开发的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进学阁">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          事务处理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-13 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-13T00:00:00+08:00">2023-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-06 17:30:49" itemprop="dateModified" datetime="2025-03-06T17:30:49+08:00">2025-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="		事务的四大特性"></a><font style="color:rgb(79, 79, 79);">		事务的四大特性</font></h4><ol>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">原子性(Atomicity) </font></strong><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">事务是最小的执行单位，不允许分割</font><font style="color:rgba(0, 0, 0, 0.75);">。事务的原子性确保动作要么全部完成，要么完全不起作用；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">一致性(Consistency) </font></strong><font style="color:rgba(0, 0, 0, 0.75);">一致性是指</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">事务必须使数据库从一个一致性状态变换到另一个一致性状态</font><font style="color:rgba(0, 0, 0, 0.75);">，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</font><span id="more"></span>
:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</font></li>
</ol>
<p>:::</p>
<ol start="3">
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">隔离性(Isolation) </font></strong><font style="color:rgba(0, 0, 0, 0.75);">并发访问数据库时，即一个事务内部的操作及使用的数据对并发的其他事务是隔离</font><strong><font style="color:rgba(0, 0, 0, 0.75);"><br></font></strong><font style="color:rgba(0, 0, 0, 0.75);">的，并发执行的各个事务之间不能互相干扰。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">持久性(Durability) </font></strong><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">一个事务被提交之后。它对数据库中数据的改变是持久的</font><font style="color:rgba(0, 0, 0, 0.75);">，即使数据库发生故障也不应该对其有任何影响</font></li>
</ol>
<h4 id="事务产生的问题"><a href="#事务产生的问题" class="headerlink" title="事务产生的问题"></a><font style="color:rgb(79, 79, 79);">事务产生的问题</font></h4><h5 id="脏读-Drity-Read"><a href="#脏读-Drity-Read" class="headerlink" title="脏读(Drity Read)"></a>脏读<font style="color:rgb(79, 79, 79);">(Drity Read)</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">已知有两个事务A和B, A读取了已经被B更新但还没有被提交的数据。之后，B回滚事务，A读取的数据就是脏数据</font><font style="color:rgb(77, 77, 77);">。即：一个事务在执行的过程中读取到了其他事务还没有提交的数据。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">此处的”脏”主要指由于回滚，导致了数据的无效性，也就是读到了脏数据。</font></p>
<p>:::</p>
<p><font style="color:rgb(77, 77, 77);"> 脏读，可以简单理解为读到了无效数据。</font></p>
<h5 id="不可重复读-Non-repeatable-read"><a href="#不可重复读-Non-repeatable-read" class="headerlink" title="不可重复读(Non-repeatable read)"></a>不可重复读<font style="color:rgb(79, 79, 79);">(Non-repeatable read)</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">已知有两个事务A和B，A多次读取同一数据，B在A多次读取的过程中对数据作了修改并提交，导致A多次读取同一数据时，结果不一致</font><font style="color:rgb(77, 77, 77);">。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">此处的”重复”指的是由于修改，某个事务重复读取的某个值发生了变化。</font></p>
<p><font style="color:rgb(77, 77, 77);">不可重复读，可简单理解为多次重复读取，读取到了不一样的数据。</font></p>
<h5 id="幻读-Phantom-Read"><a href="#幻读-Phantom-Read" class="headerlink" title="幻读(Phantom Read)"></a>幻读<font style="color:rgb(79, 79, 79);">(Phantom Read)</font></h5><p> 幻读在可重复读的模式下才会出现，其他隔离级别中不会出现。</p>
<p>  有两个事务A和B，A从一个表中读取了数据，然后B在该表中插入了一些新数据，导致A再次读取同一个表, 就会多出几行。简单地说，一个事务中先后读取一个范围的记录，但每次读取的纪录数不同，多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<h5 id="不可重复读和幻读区别"><a href="#不可重复读和幻读区别" class="headerlink" title="不可重复读和幻读区别"></a><font style="color:rgba(0, 0, 0, 0.75);">不可重复读和幻读区别</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);"> 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</font></p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a><font style="color:rgb(79, 79, 79);">事务的隔离级别</font></h4><p><font style="color:rgb(77, 77, 77);">了解决多个事务之间数据可见性及数据正确性的问题，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted(读未提交)、Read committed(读已提交)、Repeatable read(可重复读)、Serializable(串行)。</font></p>
<p><font style="color:rgb(77, 77, 77);">事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。<br></font><font style="color:rgb(77, 77, 77);"> InnoDB存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</font></p>
<h5 id="查看隔离级别命令"><a href="#查看隔离级别命令" class="headerlink" title="查看隔离级别命令"></a><font style="color:rgb(77, 77, 77);">查看隔离级别命令</font></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看隔离级别命令</span><br><span class="line">   show variables like &#x27;transaction_isolation&#x27;;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">要修改隔离级别的话，可以进行全局修改，也就是修改配置文件（my.ini），示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transaction-isolation=READ-UNCOMMITTED</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);"> 也可以通过命令修改当前session的隔离级别：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level 事务级别;</span><br></pre></td></tr></table></figure>

<h5 id="各种隔离级别中会出现的问题"><a href="#各种隔离级别中会出现的问题" class="headerlink" title="各种隔离级别中会出现的问题"></a><font style="color:rgb(79, 79, 79);">各种隔离级别中会出现的问题</font></h5><ul>
<li>读未提交  存在脏读，不可重复读，幻读的问题 </li>
<li>读已提交  处理了脏读的问题但是存在不可重复读和幻读的问题</li>
<li>可重复读  处理了不可重复读的问题，幻读依然存在 ，但是mysql中的这一级别因为mvcc的存在已经将幻读的问题也处理了</li>
<li>串型化   都一个一个处理了肯定不存在脏读 重复读 幻读的问题</li>
</ul>
<h5 id="READ-UNCOMMITTED-读未提交"><a href="#READ-UNCOMMITTED-读未提交" class="headerlink" title="READ-UNCOMMITTED(读未提交)"></a><font style="color:rgb(79, 79, 79);">READ-UNCOMMITTED(读未提交)</font></h5><p><font style="color:rgb(77, 77, 77);">最低的隔离级别，</font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">允许一个事务可以读取另外一个事务未提交的事务</font><font style="color:rgb(77, 77, 77);">。多次读取结果不一样，会出现了脏读、不可重复读问题。</font><br><font style="color:rgb(77, 77, 77);"> 这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用。</font></p>
<h5 id="READ-COMMITTED-读已提交"><a href="#READ-COMMITTED-读已提交" class="headerlink" title="READ-COMMITTED(读已提交)*"></a><font style="color:rgb(79, 79, 79);">READ-COMMITTED(读已提交)*</font></h5><p><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">允许一个事务读取另一个并发事务已经提交的数据</font><font style="color:rgb(77, 77, 77);">。读已提交情况下，无法读取到其他事务还未提交的数据，可以读取到其他事务已经提交的数据，多次读取结果不一样，未出现脏读，出现了读已提交、不可重复读。</font></p>
<h5 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE-READ(可重复读)*"></a><font style="color:rgb(79, 79, 79);">REPEATABLE-READ(可重复读)*</font></h5><p>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。即使数据被其他事务修改， 当前事务也不会读取到新的数据。重复读事务中的查询看到的是事务开始时的快照， 而不是该事务当前查询开始时的快照。</p>
<p>  可重复读情况下，未出现脏读，未读取到其他事务已提交的数据，多次读取结果一致，即可重复读。</p>
<h5 id="SERIALIZABLE-串行"><a href="#SERIALIZABLE-串行" class="headerlink" title="SERIALIZABLE(串行)*"></a><font style="color:rgb(79, 79, 79);">SERIALIZABLE(串行)*</font></h5><p><font style="color:rgb(77, 77, 77);">最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰（多个事务之间读写、写读、写写会产生互斥，效果就是串行执行，多个事务之间的读读不会产生互斥）。</font></p>
<p>:::tips<br><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">该级别可以防止脏读、不可重复读以及幻读。</font></p>
<p>:::</p>
<h4 id="Mysql中的事务操作"><a href="#Mysql中的事务操作" class="headerlink" title="Mysql中的事务操作"></a><font style="color:rgb(79, 79, 79);">Mysql中的事务操作</font></h4><p> Mysql中事务默认是隐式事务，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。</p>
<p>:::tips<br>  事务分为隐式事务和显式事务。是否开启隐式事务是由变量 autocommit 控制的。可以通过set session autoCommit &#x3D; on&#x2F;off来设置mysql事务是否自动开启。如果我们设置autoCommit为off的时候，需要手动开启mysql事务。</p>
<p>:::</p>
<h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a><font style="color:rgb(79, 79, 79);">隐式事务</font></h5><h5 id="事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。"><a href="#事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。" class="headerlink" title="事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。"></a><font style="color:rgb(77, 77, 77);">事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。</font></h5><p><font style="color:rgb(77, 77, 77);"> 实际项目开发时，用隐式事务即可。</font></p>
<h5 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a><font style="color:rgb(79, 79, 79);">显式事务</font></h5><p><font style="color:rgb(77, 77, 77);">需要手动开启、提交或回滚，由开发者自己控制。有两种方式：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 方式1</span><br><span class="line">//设置不自动提交事务</span><br><span class="line">set autocommit=0;</span><br><span class="line">//执行事务操作</span><br><span class="line">commit|rollback;</span><br><span class="line"></span><br><span class="line">-- 方式2</span><br><span class="line">start transaction;//开启事务</span><br><span class="line">//执行事务操作</span><br><span class="line">commit|rollback;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a><font style="color:rgb(79, 79, 79);">savepoint</font></h5><p><font style="color:rgb(77, 77, 77);">如果在事务中我们执行了一大批操作，可只想回滚部分数据。此时可以将一大批操作分为几个部分，然后指定回滚某个部分，通过savepoint(保存点)来实现。示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into test1 values (1);</span><br><span class="line">-- 设置一个保存点</span><br><span class="line">savepoint part1;</span><br><span class="line">insert into test1 values (2);</span><br><span class="line">-- 将savepint = part1的语句到当前语句之间所有的操作回滚</span><br><span class="line">rollback to part1;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a><font style="color:rgb(79, 79, 79);">只读事务</font></h5><p><font style="color:rgb(77, 77, 77);">表示在事务中执行的是一些只读操作，如查询，但是不会做insert、update、delete操作。开启只读事务后，执行修改操作会报错。</font></p>
<h5 id="查看变量-autocommit-是否开启了自动提交命令："><a href="#查看变量-autocommit-是否开启了自动提交命令：" class="headerlink" title="查看变量 autocommit 是否开启了自动提交命令："></a><font style="color:rgb(77, 77, 77);">查看变量 autocommit 是否开启了自动提交命令：</font></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;autocommit&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ACID的保证"><a href="#ACID的保证" class="headerlink" title="ACID的保证"></a><font style="color:rgb(79, 79, 79);">ACID的保证</font></h4><p><font style="color:rgb(77, 77, 77);"> 事务的原子性是通过 undo log 来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的持久性是通过 redo log 来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的隔离性是通过 (读写锁+MVCC)来实现的。</font><br><font style="color:rgb(77, 77, 77);"> 事务的一致性是通过原子性、持久性、隔离性来实现的。</font></p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><font style="color:rgba(0, 0, 0, 0.75);">原子性</font></h5><p>1、每条数据变更(insert&#x2F;update&#x2F;delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上。</p>
<p>2、所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</p>
<h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><font style="color:rgba(0, 0, 0, 0.75);">持久性</font></h5><p><img src="https://cdn.fbbizyy.com/yuque/0/2024/png/25873401/1716974826311-3b0e8907-86d6-44db-a7cb-7d738e3f4780.png"></p>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><font style="color:rgba(0, 0, 0, 0.75);">隔离性</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);">MySQL定义了4种隔离级别。隔离性是要做到什么呢？ 隔离性是要管理多个并发读写请求的访问顺序。MVCC和读写锁都能达到一定的隔离效果。</font></p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><font style="color:rgba(0, 0, 0, 0.75);">一致性</font></h5><p><font style="color:rgba(0, 0, 0, 0.75);">数据库总是从一个一致性的状态转移到另一个一致性的状态。通过回滚，以及恢复，和在并发环境下的隔离可以达到一致性的效果。</font></p>
<h4 id="InnoDB的幻读问题"><a href="#InnoDB的幻读问题" class="headerlink" title="InnoDB的幻读问题"></a><font style="color:rgb(79, 79, 79);">InnoDB的幻读问题</font></h4><p><font style="color:rgb(79, 79, 79);">隔离级别REPEATABLE-READ（可重复读）的时候，并没有解决幻读的问题，串行的话性能无法保证，所以在InnoDB引擎中引入了mvcc和间隙锁以及行锁来处理</font></p>
<h6 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a><font style="color:rgb(79, 79, 79);">快照读</font></h6><p><font style="color:rgb(79, 79, 79);">InnoDB引擎通过mvcc来解决快照读的幻读问题，生成一个ReadView然后结合undo日志来解决幻读的问题</font></p>
<h6 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a><font style="color:rgb(79, 79, 79);">当前读</font></h6><p><font style="color:rgb(79, 79, 79);">InnoDB引擎通过间隙锁来解决幻读问题，事务A和事务B产生并发，事务A未提交时阻塞事务B，这样就不会产生幻读问题</font></p>
<h4 id="MVCC基础概念"><a href="#MVCC基础概念" class="headerlink" title="MVCC基础概念"></a><font style="color:rgb(79, 79, 79);">MVCC基础概念</font></h4><p>:::tips<br><font style="color:black;">数据库通过</font><strong><font style="color:rgb(37, 132, 181);">加锁</font></strong><font style="color:black;">，可以实现事务的隔离性，</font><strong><font style="color:rgb(37, 132, 181);">串行化隔离级别就是加锁实现的</font></strong><font style="color:black;">，但是加锁会</font><strong><font style="color:rgb(37, 132, 181);">降低数据库性能</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">因此，数据库引入了</font><strong><font style="color:rgb(37, 132, 181);">MVCC多版本并发控制</font></strong><font style="color:black;">，在读取数据不用加锁的情况下，实现读取数据的同时可以修改数据，修改数据时同时可以读取数据。</font></p>
<p>:::</p>
<h5 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h5><p><font style="color:rgb(79, 79, 79);">MVCC(Mutil-Version Concurrency Control)，多版本并发控制。是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。用于支持读已提交(RC）和可重复读(RR）隔离级别的实现。</font></p>
<p>:::tips<br><font style="color:rgb(79, 79, 79);">MVCC</font><font style="color:rgb(79, 79, 79);">在</font><font style="color:rgb(79, 79, 79);">MySQL InnoDB</font><font style="color:rgb(79, 79, 79);">引擎中的实现主要是为了在处理读-写冲突时提高数据库并发性能，记录读已提交和可重复读这两种隔离级别下事务操作版本连的过程。</font></p>
<p>:::</p>
<ul>
<li><font style="color:rgb(79, 79, 79);">数据库并发场景一般有三种：</font><ul>
<li><font style="color:rgb(79, 79, 79);">读-读</font><font style="color:rgb(79, 79, 79);">：不存在任何问题，不需要并发控制</font></li>
<li><font style="color:rgb(79, 79, 79);">读-写</font><font style="color:rgb(79, 79, 79);">：有线程安全问题，可能会造成事务隔离性问题，可能会有脏读，幻读，不可重复读</font></li>
<li><font style="color:rgb(79, 79, 79);">写-写</font><font style="color:rgb(79, 79, 79);">：有线程安全问题，可能会存在更新丢失问题。</font></li>
</ul>
</li>
<li><font style="color:rgb(79, 79, 79);">MVCC主要是用来解决【</font><font style="color:rgb(79, 79, 79);">读-写</font><font style="color:rgb(79, 79, 79);">】冲突的</font><font style="color:rgb(79, 79, 79);">无锁并发控制</font><font style="color:rgb(79, 79, 79);">，可以解决以下问题：</font><ul>
<li><font style="color:rgb(79, 79, 79);">在并发读写数据时，可以做到在读操作时不用阻塞写操作，写操作不用阻塞读操作，提高数据库并发读写的性能</font><font style="color:rgb(79, 79, 79);">。</font></li>
<li><font style="color:rgb(79, 79, 79);">可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决【写-写】引起的更新丢失问题</font><font style="color:rgb(79, 79, 79);">。</font></li>
</ul>
</li>
<li><font style="color:rgb(79, 79, 79);">MVCC与锁的组合</font><font style="color:rgb(79, 79, 79);">：</font></li>
</ul>
<p><font style="color:rgb(79, 79, 79);">一般数据库中都会采用以上MVCC与锁的两种组合来解决并发场景的问题，以此最大限度的提高数据库性能</font><font style="color:rgb(79, 79, 79);">。</font></p>
<pre><code>- &lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC + 悲观锁&lt;/font&gt;&lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC解决读-写冲突，悲观锁解决写-写冲突。&lt;/font&gt;
- &lt;font style=&quot;color:rgb(79, 79, 79);&quot;&gt;MVCC + 乐观锁MVCC解决读-写冲突，乐观锁解决写-写冲突。&lt;/font&gt;
</code></pre>
<p>:::tips<br><font style="color:rgb(0, 0, 0);">通过上述描述，MVCC的作用可以概括为就是为了解决【读写冲突】，提高数据库性能的，而MVCC的实现又依赖于六个概念：【隐式字段】【undo日志】【版本链】【快照读和当前读】【读视图】。</font></p>
<p>:::</p>
<h5 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h5><p><strong><font style="color:rgb(37, 132, 181);">在InnoDB存储引擎，针对每行记录都有固定的两个隐藏列【DB_TRX_ID】【DB_ROLL_PTR】以及一个可能存在的隐藏列【DB_ROW_ID】</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039295214-f6b578a9-f5b8-42ad-a084-574eadda6268.webp"></p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(248, 248, 248);">隐式字段</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);">描述</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);">是否必须存在</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">DB_TRX_ID</font></td>
<td><font style="color:rgb(0, 0, 0);">事物Id，也叫事物版本号，占用6byte的标识，</font><strong><font style="color:rgb(37, 132, 181);">事务开启之前，从数据库获得一个自增长的事务ID，用其判断事务的执行顺序</font></strong></td>
<td><font style="color:rgb(0, 0, 0);">是</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">DB_ROLL_PTR</font></td>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">占用7byte，</font><strong><font style="color:rgb(37, 132, 181);background-color:rgb(248, 222, 203);">回滚指针，指向这条记录的上一个版本的undo log记录，存储于回滚段（rollback segment）中</font></strong></td>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">是</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">DB_ROW_ID</font></td>
<td><font style="color:rgb(0, 0, 0);">隐含的自增ID（隐藏主键），如果表中没有主键和非NULL唯一键时，则会生成一个</font><strong><font style="color:rgb(37, 132, 181);">单调递增的行ID作为聚簇索引</font></strong></td>
<td><font style="color:rgb(0, 0, 0);">否</font></td>
</tr>
</tbody></table>
<p><font style="color:black;">表中的数据会因此分为两种形式：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">有主键或唯一非空字段</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039890546-106f9f7f-79d2-40c7-b110-1bec3c7d5758.webp"></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">没有主键且没有唯一非空字段</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039898106-00a40ce6-3800-47f8-a8cc-ce1156f47093.webp"><font style="color:black;"><br></font></p>
<h5 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h5><p><strong><font style="color:rgb(37, 132, 181);">一种用于撤销回退的日志，在事务开始之前，会先记录存放到 Undo 日志文件里，备份起来，当事务回滚时或者数据库崩溃时用于回滚事务。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">undo日志的主要作用是事务回滚和实现MVCC快照读</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">undo log日志分为两种</font></strong><font style="color:black;">：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">insert undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">代表事务在</font></strong></strong><font style="color:rgb(30, 107, 184);">insert</font><strong><strong><font style="color:rgb(37, 132, 181);">新记录时产生的</font></strong></strong><font style="color:rgb(30, 107, 184);">undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">, 仅用于事务回滚，并且在事务提交后可以被立即丢弃</font></strong></strong><font style="color:rgb(1, 1, 1);">。</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">update undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">事务在进行</font></strong></strong><font style="color:rgb(30, 107, 184);">update</font><strong><strong><font style="color:rgb(37, 132, 181);">或</font></strong></strong><font style="color:rgb(30, 107, 184);">delete</font><strong><strong><font style="color:rgb(37, 132, 181);">时产生的</font></strong></strong><font style="color:rgb(30, 107, 184);">undo log</font><strong><strong><font style="color:rgb(37, 132, 181);">; 不仅在事务回滚时需要，在实现MVCC快照读时也需要</font></strong></strong><font style="color:rgb(1, 1, 1);">；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被清理线程统一清除。</font></strong></li>
</ul>
<p><font style="color:black;">MVCC实际上是使用的</font><font style="color:rgb(30, 107, 184);">update undo log</font><font style="color:black;"> 实现的快照读。</font></p>
<p>:::tips<br><strong><font style="color:rgb(37, 132, 181);">InnoDB 并不会真正地去开辟空间存储多个版本的行记录，只是借助 undo log 记录每次写操作的反向操作。所以B+ 索引树上对应的记录只会有一个最新版本，InnoDB 可以根据 undo log 得到数据的历史版本，从而实现多版本控制。</font></strong></p>
<p>:::</p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717039960367-31d88ae9-d08e-4582-aa7d-5f4b07627fec.webp"></p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>:::tips<br><font style="color:rgb(0, 0, 0);">一致性非锁定读是通过 </font><strong><font style="color:rgb(37, 132, 181);">MVCC</font></strong><font style="color:rgb(0, 0, 0);"> 来实现的。但是MVCC 没有一个统一的实现标准，所以各个存储引擎的实现机制不尽相同。InnoDB 存储引擎中 MVCC 的实现是通过 </font><strong><font style="color:rgb(37, 132, 181);">undo log</font></strong><font style="color:rgb(0, 0, 0);"> 来完成的</font></p>
<p>:::</p>
<p><strong><font style="color:rgb(37, 132, 181);">当事务对某一行数据进行改动时，会产生一条Undo日志，多个事务同时操作一条记录时，就会产生多个版本的Undo日志，这些日志通过回滚指针（DB_ROLL_PTR）连成一个链表，称为版本链</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717040314866-11d5dd8b-e6dd-440b-92d2-0a384c1d896b.webp"></p>
<p><font style="color:black;">只要有事务写入数据时，就会产生一条对应的 undo log，一条 undo log 对应这行数据的一个版本，当这行数据有多个版本时，就会有多条 undo log 日志，undo log 之间通过回滚指针（DB_ROLL_PTR）连接，这样就形成了一个 undo log 版本链。</font></p>
<h5 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a><font style="color:rgb(0, 0, 0);">快照读和当前读</font></h5><h6 id="快照读："><a href="#快照读：" class="headerlink" title="快照读："></a><font style="color:rgb(79, 79, 79);">快照读：</font></h6><p><strong><font style="color:rgb(51, 51, 51);">也叫普通读，读取的是记录数据的可见版本，不加锁，不加锁的普通select语句都是快照读，即不加锁的非阻塞读</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">快照读的执行方式是生成 ReadView，直接利用 MVCC 机制来进行读取，并不会对记录进行加锁</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<h6 id="当前读："><a href="#当前读：" class="headerlink" title="当前读："></a><font style="color:rgb(79, 79, 79);">当前读：</font></h6><p><strong><font style="color:rgb(51, 51, 51);">也称锁定读【Locking Read】，读取的是记录数据的最新版本，并且需要先获取对应记录的锁</font></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE;  # 共享锁</span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ...  # 排他锁</span><br><span class="line">DELETE FROM student WHERE ...  # 排他锁</span><br><span class="line">UPDATE student SET ...  # 排他锁</span><br></pre></td></tr></table></figure>

<h5 id="读视图"><a href="#读视图" class="headerlink" title="读视图"></a><font style="color:rgb(0, 0, 0);">读视图</font></h5><p><strong><font style="color:rgb(37, 132, 181);">Read View提供了某一时刻事务系统的快照，主要是用来做</font><strong><strong><font style="color:rgb(30, 107, 184);">可见性</font></strong></strong><font style="color:rgb(37, 132, 181);">判断, 里面保存了【对本事务不可见的其他活跃事务】</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">当事务在开始执行的时候，会产生一个读视图（Read View），用来判断当前事务可见哪个版本的数据，即可见性判断</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">实际上在innodb中，每个SQL语句执行前都会生成一个Read View</font></strong><font style="color:black;">。</font></p>
<h6 id="读视图的四个属性"><a href="#读视图的四个属性" class="headerlink" title="读视图的四个属性"></a><font style="color:black;">读视图的四个属性</font></h6><p><font style="color:rgb(0, 0, 0);">MySQL</font><font style="color:rgb(30, 107, 184);">5.7</font><font style="color:rgb(0, 0, 0);">源码中对</font><font style="color:rgb(30, 107, 184);">Read View</font><font style="color:rgb(0, 0, 0);">定义了四个属性，如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class ReadView &#123;</span><br><span class="line">	private:</span><br><span class="line">		/** The read should not see any transaction with trx id &gt;= this</span><br><span class="line">		value. In other words, this is the &quot;high water mark&quot;. */</span><br><span class="line">		trx_id_t	m_low_limit_id;</span><br><span class="line"></span><br><span class="line">		/** The read should see all trx ids which are strictly</span><br><span class="line">		smaller (&lt;) than this value.  In other words, this is the</span><br><span class="line">		low water mark&quot;. */</span><br><span class="line">		trx_id_t	m_up_limit_id;</span><br><span class="line"></span><br><span class="line">		/** trx id of creating transaction, set to TRX_ID_MAX for free</span><br><span class="line">		views. */</span><br><span class="line">		trx_id_t	m_creator_trx_id;</span><br><span class="line"></span><br><span class="line">		/** Set of RW transactions that was active when this snapshot</span><br><span class="line">		was taken */</span><br><span class="line">		ids_t		m_ids;</span><br><span class="line"></span><br><span class="line">		/** The view does not need to see the undo logs for transactions</span><br><span class="line">		whose transaction number is strictly smaller (&lt;) than this value:</span><br><span class="line">		they can be removed in purge if not needed by other views */</span><br><span class="line">		trx_id_t	m_low_limit_no;</span><br><span class="line"></span><br><span class="line">		/** AC-NL-RO transaction view that has been &quot;closed&quot;. */</span><br><span class="line">		bool		m_closed;</span><br><span class="line"></span><br><span class="line">		typedef UT_LIST_NODE_T(ReadView) node_t;</span><br><span class="line"></span><br><span class="line">		/** List of read views in trx_sys */</span><br><span class="line">		byte		pad1[64 - sizeof(node_t)];</span><br><span class="line">		node_t		m_view_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font style="color:rgb(37, 132, 181);">creator_trx_id </font>****<font style="color:rgb(0, 0, 0);">创建当前read view的事务ID</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_ids </font>****<font style="color:rgb(0, 0, 0);">当前系统中所有的活跃事务的 id，活跃事务指的是当前系统中开启了事务，但还没有提交的事务;</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_low_limit_id  </font>****<font style="color:rgb(0, 0, 0);">表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。</font></strong></li>
<li><strong><font style="color:rgb(37, 132, 181);">m_up_limit_id  </font>****<font style="color:rgb(0, 0, 0);">当前系统中事务的 id 值最大的那个事务 id 值再加 1，也就是系统中下一个要生成的事务 id。</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">ReadView 会根据这 4 个属性，结合 undo log 版本链，来实现 MVCC 机制，决定一个事务能读取到数据那个版本</font></strong><font style="color:rgb(0, 0, 0);">。</font></p>
<p>:::tips<br><font style="color:black;">假设现在有事务 A 和事务 B 并发执行，事务 A 的事务 id 为 10，事务 B 的事务 id 为 20。</font></p>
<p><font style="color:black;">事务A的ReadView ：m_ids&#x3D;[10,20]，m_low_limit_id&#x3D;10，m_up_limit_id&#x3D;21，creator_trx_id&#x3D;10。</font></p>
<p><font style="color:black;">事务B的ReadView ：m_ids&#x3D;[10,20]，m_low_limit_id&#x3D;10，m_up_limit_id&#x3D;21，creator_trx_id&#x3D;20。</font></p>
<p>:::</p>
<h6 id="读视图可见性判断规则"><a href="#读视图可见性判断规则" class="headerlink" title="读视图可见性判断规则"></a><font style="color:black;">读视图可见性判断规则</font></h6><p><font style="color:black;">将Read View中的活跃事务Id按照大小放在坐标轴上表示的话，如下图：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717040599275-ea807cb7-1694-4ca0-8396-60c6dc9c385c.webp"></p>
<p><font style="color:black;">当一个事务读取某条数据时，会</font><strong><font style="color:rgb(37, 132, 181);">通过DB_TRX_ID【Uodo日志的事务Id】在坐标轴上的位置</font></strong><font style="color:black;">来进行可见性规则判断，如下：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID &lt; m_low_limit_id</font></strong></li>
</ul>
<p><strong><font style="color:black;">表示DB_TRX_ID对应这条数据【Undo日志】是在当前事务开启之前，其他的事务就已经将该条数据修改了并提交了事务(事务的 id 值是递增的)，所以当前事务【开启Read View的事务】能读取到。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID &gt;&#x3D; m_up_limit_id</font></strong></li>
</ul>
<p><strong><font style="color:black;">表示在当前事务【creator_trx_id】开启以后，有新的事务开启，并且新的事务修改了这行数据的值并提交了事务，因为这是【creator_trx_id】后面的事务修改提交的数据，所以当前事务【creator_trx_id】是不能读取到的。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">m_low_limit_id &#x3D;&lt; DB_TRX_ID &lt; m_up_limit_id</font></strong><ul>
<li><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID  在 m_ids 数组中</font></strong></li>
</ul>
</li>
</ul>
<p><font style="color:rgb(0, 0, 0);"></font><font style="color:rgb(0, 0, 0);">表</font><font style="color:rgb(0, 0, 0);">示DB_TRX_ID【</font><font style="color:rgb(0, 0, 0);">写Undo日志的事务】 和当前事务【creator_trx_id】是在同一</font><font style="color:rgb(0, 0, 0);">时</font><font style="color:rgb(0, 0, 0);">刻开启</font><font style="color:rgb(0, 0, 0);">的</font><font style="color:rgb(0, 0, 0);">事</font><font style="color:rgb(0, 0, 0);">务</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID  不等于creator_trx_id</font></strong></p>
<p><strong><font style="color:rgb(0, 0, 0);">DB_TRX_ID事务修改了数据的值，并提交了事务，所以当前事务【creator_trx_id】不能读取到。</font></strong><font style="color:black;"></font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;DB_TRX_ID  等于creator_trx_id&lt;/font&gt;**&lt;font style=&quot;color:black;&quot;&gt;&lt;/font&gt;
</code></pre>
<p><font style="color:black;"></font><font style="color:rgb(0, 0, 0);">表明数据【Undo日志】 是自己生成的，因此是</font><strong><font style="color:rgb(37, 132, 181);">可见</font></strong><font style="color:rgb(0, 0, 0);">的</font></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;DB_TRX_ID  不在 m_ids 数组中&lt;/font&gt;**
</code></pre>
<p><strong><font style="color:black;">表示的是在当前事务【creator_trx_id】开启之前，其他事务【DB_TRX_ID】将数据修改后就已经提交了事务，所以当前事务能读取到。</font></strong></p>
<h6 id="读视图可见性判断规则案例说明"><a href="#读视图可见性判断规则案例说明" class="headerlink" title="读视图可见性判断规则案例说明"></a><font style="color:black;">读视图可见性判断规则案例说明</font></h6><p><font style="color:black;">了解了读视图可见性判断规则，下面通过一个场景案例图解的方式来详细逐条验证上述规则。一般来说，我们的行数据结构都为一下模式：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048524181-8e1e70d4-c0b1-49f5-8cb1-32e3dbbb4ed5.webp"></p>
<p><font style="color:black;">假设有一个事物【DB_TRX_ID &#x3D; 10】在表中插入了一条数据，则它的数据结构为为：</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048524123-cd2cf78d-57d4-433c-a3d0-c4860e769979.webp"></p>
<ul>
<li><strong><font style="color:black;">【第一步】：假设现在有事务 A【DB_TRX_ID &#x3D; 20】 和事务 B 【DB_TRX_ID &#x3D; 30】并发执行</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">select name from user where id = 1;</span><br><span class="line">#事物B：</span><br><span class="line">update user set name = &#x27;edwin&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">事物开始后分别生成ReadView</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:black;&quot;&gt;事务A的ReadView ：m_ids=[20,30]，m_low_limit_id=20，m_up_limit_id=31，creator_trx_id=20。&lt;/font&gt;**
- **&lt;font style=&quot;color:black;&quot;&gt;事务B的ReadView ：m_ids=[20,30]，m_low_limit_id=20，m_up_limit_id=31，creator_trx_id=30。&lt;/font&gt;**
</code></pre>
<ul>
<li><strong><font style="color:black;">【第二步】：事物A开启事物之后通过版本链</font><strong><strong><font style="color:rgb(37, 132, 181);">第一次</font></strong></strong><font style="color:black;">读取数据，版本链中的DB_TRX_ID &#x3D; 10，小于事物A的【DB_TRX_ID &#x3D; 20】，说明DB_TRX_ID &#x3D; 10这条数据是事物A开启之前就已经写入，并提交了事物，所以事物A可以读取到。</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559781-c6ab3c4f-fc28-41fc-b4cf-25bf985a0d6b.webp"></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">【第三步】：事务 B 【DB_TRX_ID &#x3D; 30】修改数据，将name修改为Edwin，修改后写入Undo Log日志，</font><strong><strong><font style="color:rgb(37, 132, 181);">此时还没有提交事务B</font></strong></strong><font style="color:rgb(1, 1, 1);">。示意图如下：</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559736-8999a648-def3-46d1-8be3-ab48d174d901.webp"></p>
<ul>
<li><strong><font style="color:black;">【第四步】：事务A【DB_TRX_ID &#x3D; 20】</font><strong><strong><font style="color:rgb(37, 132, 181);">第二次</font></strong></strong><font style="color:black;">去读取数据</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">在 undo log版本链中，数据最新版本的事务id为30，这个值处于事务A的 ReadView 里 m_low_limit_id 和 m_up_limit_id 并且存在于m_ids 数组中，表示这个版本的数据是和自己同一时刻启动的事务修改的，因此这个版本的数据，数据 A 读取不到</font>****<font style="color:black;">。</font></strong></p>
<p><font style="color:black;">此时需要沿着 undo log 的版本链向前找，接着会找到该行数据的上一个版本db_trx_id&#x3D;10，由于db_trx_id&#x3D;10小于 m_low_limit_id的值，因此事务 A 能读取到该版本的值，即事务 A 读取到的值是星之码。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559623-6cee2ece-15a0-4afc-b749-8562c3693d60.webp"></p>
<ul>
<li><strong><font style="color:black;">【第五步】：现在事务 B 提交，此时系统中活跃的事务只有事物A，事物A</font><strong><strong><font style="color:rgb(37, 132, 181);">第三次</font></strong></strong><font style="color:black;">读取，读取到内容就有两种可能性：</font></strong></li>
</ul>
<p><strong><font style="color:black;">这里留一个问题一：造成这两种情况的原因是什么？</font></strong></p>
<p><strong><font style="color:black;">我们留到本文第三节【不同隔离级别MVCC实现原理】中说明，继续案例</font></strong></p>
<pre><code>- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;读已提交（RC）隔离级别：读取到是事物B提交的Edwin&lt;/font&gt;****&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;**
- **&lt;font style=&quot;color:rgb(37, 132, 181);&quot;&gt;可重复读（RR）隔离级别：读取到是原始数据提交的星河之码&lt;/font&gt;****&lt;font style=&quot;color:rgb(1, 1, 1);&quot;&gt;。&lt;/font&gt;**
</code></pre>
<ul>
<li><strong><font style="color:black;">【第六步】：新的事物C【DB_TRX_ID &#x3D; 40】修改数据，将name修改为彬</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#事物C：</span><br><span class="line">update user set name = &#x27;彬&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><font style="color:black;">执行脚本前生成的ReadView如下，执行脚本后，提交事物C。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">事务C的ReadView ：m_ids&#x3D;[20,40]，m_low_limit_id&#x3D;20，m_up_limit_id&#x3D;41，creator_trx_id&#x3D;40</font></strong><font style="color:black;">。</font></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559795-7654eac6-debc-4019-867e-87fd9bd6fe0d.webp"></p>
<ul>
<li><strong><font style="color:black;">【第七步】：事务 A【DB_TRX_ID &#x3D; 20】</font><strong><strong><font style="color:rgb(37, 132, 181);">第四次</font></strong></strong><font style="color:black;">读取数据，</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时由于事物A，由于事物A的m_up_limit_id&#x3D;31，而日志中的DB_TRX_ID&#x3D;40，根据可见性判断规则可以知到，事物A不能读取到DB_TRX_ID&#x3D;40的记录，按照版本链的DB_POLL_PTR继续往上找，找到DB_TRX_ID&#x3D;30的记录，虽然30在事物A的的m_ids&#x3D;[20,30]，但是</font><strong><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID&#x3D;30不等于事物A的creator_trx_id&#x3D;20</font></strong></strong><font style="color:black;">，所以还是不能读取，继续往上找，最终读取到了DB_TRX_ID&#x3D;10的记录，name&#x3D;星河之码</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048559686-29a20060-b95e-483a-8701-ba33a77ea3b2.webp"></p>
<p>:::tips<br><font style="color:black;">实际上，这里事务A在不同场景下也是可以读取到DB_TRX_ID&#x3D;40得数据的。</font></p>
<p><font style="color:black;">这里也留一个问题二：在什么场景下能够读取到DB_TRX_ID&#x3D;40得数据name&#x3D;彬呢？</font></p>
<p><font style="color:black;">我们留到本文第三节【不同隔离级别MVCC实现原理】中说明，继续案例</font></p>
<p>:::</p>
<ul>
<li><strong><font style="color:black;">【第八步】：事务 A【DB_TRX_ID &#x3D; 20】开始修改数据，将name 修改为 ‘法外狂徒张三’</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">update user set name = &#x27;法外狂徒张三&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">此时事务A还没有提交，但是已经写入了Undo 日志，新的版本链如下</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048833158-398a5518-357e-412b-914d-4790a49e8c93.webp"></p>
<ul>
<li><strong><font style="color:black;">【第九步】：事务 A</font><strong><strong><font style="color:rgb(37, 132, 181);">第五次</font></strong></strong><font style="color:black;">读取数据</font></strong></li>
</ul>
<p><strong><font style="color:black;">由于Undo日志中的最新数据DB_TRX_ID&#x3D;20等于事物A的creator_trx_id&#x3D;20，说明是自己修改的数据，可以查到，name&#x3D;法外狂徒张三</font></strong></p>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717048832921-a527647d-5789-49a2-bd67-24a5434a9466.webp"></p>
<p><font style="color:black;">通过以上九个步骤图解的方式，对读视图可见性判断规则做了分析，通过ReadView 和 undo log分析了MVCC 的实现原理，接下来结合事务的隔离级别，看看MVCC是怎么读取数据的。</font></p>
<h5 id="不同隔离级别MVCC实现原理"><a href="#不同隔离级别MVCC实现原理" class="headerlink" title="不同隔离级别MVCC实现原理"></a>不同隔离级别MVCC实现原理</h5><h6 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h6><p><font style="color:black;">通过上述对【Read View】的分析可以总结出：</font><strong><font style="color:rgb(37, 132, 181);">InnoDB 实现MVCC是通过</font><strong><strong><font style="color:rgb(30, 107, 184);"> </font></strong></strong><font style="color:rgb(30, 107, 184);">Read View与Undo Log</font><strong><strong><font style="color:rgb(37, 132, 181);"> </font></strong></strong><font style="color:rgb(37, 132, 181);">实现的，Undo Log 保存了历史快照，形成版版本链，Read View可见性规则判断当前版本的数据是否可见</font></strong><font style="color:black;">。</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">InnnoDB执行查询语句的具体步骤为</font></strong><font style="color:black;">：</font></p>
<ul>
<li><strong><font style="color:black;">执行语句之前获取查询事务自己的事务Id，即事务版本号。</font></strong></li>
<li><strong><font style="color:black;">通过事务id获取Read View</font></strong></li>
<li><strong><font style="color:black;">查询存储的数据，将其事务Id与Read View中的事务版本号进行比较</font></strong></li>
<li><strong><font style="color:black;">不符合Read View的可见性规则，则读取Undo log中历史快照数据</font></strong></li>
<li><strong><font style="color:black;">找到当前事务能够读取的数据返回</font></strong></li>
</ul>
<p><strong><font style="color:rgb(37, 132, 181);">而在实际的使用过程中，Read View在不同的隔离级别下是得工作方式是不一样</font></strong><font style="color:black;">。</font></p>
<h6 id="读已提交（RC）MVCC实现原理"><a href="#读已提交（RC）MVCC实现原理" class="headerlink" title="读已提交（RC）MVCC实现原理"></a>读已提交（RC）MVCC实现原理</h6><p><strong><font style="color:rgb(37, 132, 181);">在读已提交(Read committed)的隔离级别下实现MVCC，同一个事务里面，【每一次查询都会产生一个新的Read View副本】，这样可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">还是按照上述案例来说明一下：</font></p>
<ul>
<li><strong><font style="color:rgb(1, 1, 1);">【第一步】：准备一条原始数据</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717049082035-9b10eb14-bac6-4727-b729-554586cc0f3b.webp"></p>
<ul>
<li><strong><font style="color:black;">【第二步】：假设现在有事务 A【DB_TRX_ID &#x3D; 20】 和事务 B 【DB_TRX_ID &#x3D; 30】并发执行</font></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#事物A：</span><br><span class="line">select name from user where id = 1;</span><br><span class="line">#事物B：</span><br><span class="line">update user set name = &#x27;edwin&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:black;">执行过程为</font></strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong><font style="color:rgb(1, 1, 1);">开始事务</font></strong></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 222, 203);">第一次查询：select name from user where id &#x3D; 1;</font></strong></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);">开始事务</font></strong></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 248, 248);">执行修改：update user set name &#x3D; ‘edwin’ where id &#x3D; 1;</font></strong></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td><strong><font style="color:rgb(1, 1, 1);">   </font>****<font style="color:rgb(1, 1, 1);">提交事务</font></strong></td>
</tr>
<tr>
<td>6</td>
<td><strong><font style="color:rgb(1, 1, 1);background-color:rgb(248, 248, 248);">第二次查询：select name from user where id &#x3D; 1;</font></strong></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td><strong><font style="color:rgb(1, 1, 1);">提交事务</font></strong></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong><font style="color:black;">版本链为：</font></strong></li>
</ul>
<p><img src="https://cdn.fbbizyy.com/yuque/0/2024/webp/25873401/1717049340079-d389ca08-a8b4-47fb-a95e-1b69427149a0.webp"></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例结果分析</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">上述案例在</font><strong><font style="color:rgb(37, 132, 181);">在读已提交(Read committed)的隔离级别下实现，同一个事务里面，【每一次查询都会产生一个新的Read View副本】</font></strong><font style="color:black;">。所以第二步实际上产生了三个Read View</font></p>
<table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_ids</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_low_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_up_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">creator_trx_id</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">事务A：第一次查询Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>20</td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);background-color:rgb(248, 222, 203);">事务B：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>30</td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">事务A：第二次查询Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td>31</td>
<td>20</td>
</tr>
</tbody></table>
<p><font style="color:black;">通过可见性判断：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第一次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">日志事务Id【DB_TRX_ID &#x3D; 10】 &lt; 最小活跃事务ID【m_low_limit_id&#x3D;20】，因此可以读取到DB_TRX_ID &#x3D; 10这条版本链中的数据。即name &#x3D; 星河之码。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第二次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时事务B已经提交，版本链中最新版本为DB_TRX_ID &#x3D; 30，而可见性规则中虽然满足</font></strong></p>
<p><strong><font style="color:black;">【m_low_limit_id&#x3D;20】&#x3D;&lt;【DB_TRX_ID&#x3D;30】&lt;【m_up_limit_id&#x3D;31】但是【DB_TRX_ID&#x3D;30】不在m_ids集合[20]中，因此事务A的第二次查询可以读取【DB_TRX_ID&#x3D;30】的数据，即name &#x3D; edwin。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例总结</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">通过上述案例说明，</font><strong><font style="color:rgb(37, 132, 181);">同一个事务A的两个相同查询，第一次结果为星河之码，第二次结果为edwin，因此在读已提交（RC）隔离级别下，存在不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<h6 id="可重复读（RR）MVCC实现原理"><a href="#可重复读（RR）MVCC实现原理" class="headerlink" title="可重复读（RR）MVCC实现原理"></a>可重复读（RR）MVCC实现原理</h6><p><strong><font style="color:rgb(37, 132, 181);">在可重复读(Repeatable read)的隔离级别下实现MVCC，【同一个事务里面，多次查询，都只会产生一个共用Read View】，以此不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<p><font style="color:black;">案例与读已提交一样，这里就不重复赘述，可以再看一遍读已提交的【第一步】【第二步】，直接进行案例分析</font></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例结果分析</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">由于同一个事物只会产生一个共用Read View，所以可重复读的隔离级别下第二步只产生了两个Read View</font></p>
<p><font style="color:black;">上述案例在</font><strong><font style="color:rgb(37, 132, 181);">可重复读(Repeatable read)，【每一次查询都会产生一个新的Read View副本】</font></strong><font style="color:black;">。所以第二步实际上产生了三个Read View</font></p>
<table>
<thead>
<tr>
<th></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_ids</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_low_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">m_up_limit_id</font></strong></th>
<th><strong><font style="color:rgb(248, 248, 248);background-color:rgb(235, 114, 80);">creator_trx_id</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(0, 0, 0);">事务A：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td><font style="color:rgb(0, 0, 0);">31</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
</tr>
<tr>
<td><font style="color:rgb(0, 0, 0);">事务B：Read View</font></td>
<td><font style="color:rgb(0, 0, 0);">[20,30]</font></td>
<td><font style="color:rgb(0, 0, 0);">20</font></td>
<td><font style="color:rgb(0, 0, 0);">31</font></td>
<td><font style="color:rgb(0, 0, 0);">30</font></td>
</tr>
</tbody></table>
<p><font style="color:black;">通过可见性判断：</font></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第一次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">日志事务Id【DB_TRX_ID &#x3D; 10】 &lt; 最小活跃事务ID【m_low_limit_id&#x3D;20】，因此可以读取到DB_TRX_ID &#x3D; 10这条版本链中的数据。即name &#x3D; 星河之码。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(37, 132, 181);">事务A第二次查询时</font></strong></li>
</ul>
<p><strong><font style="color:black;">此时事务B已经提交，版本链中最新版本为DB_TRX_ID &#x3D; 30，而可见性规则中虽然满足</font></strong></p>
<p><strong><font style="color:black;">【m_low_limit_id&#x3D;20】&#x3D;&lt;【DB_TRX_ID&#x3D;30】&lt;【m_up_limit_id&#x3D;20】并且【DB_TRX_ID&#x3D;30】也在m_ids集合[20，30]中，但是【DB_TRX_ID&#x3D;30】不等于事物A的【creator_trx_id&#x3D;20】，说明</font><strong><strong><font style="color:rgb(37, 132, 181);">DB_TRX_ID&#x3D;30是同一时刻其他事物提交的，事物A不能读取到</font></strong></strong><font style="color:black;">，因此事物A只能按照版本链继续往上找，最终读取到【DB_TRX_ID&#x3D;10】的数据，即name &#x3D; 星河之码。</font></strong></p>
<p><strong><font style="color:rgb(37, 132, 181);">案例总结</font></strong><font style="color:black;">：</font></p>
<p><font style="color:black;">通过上述案例说明，</font><strong><font style="color:rgb(37, 132, 181);">同一个事务A的两个相同查询，结果都为星河之码，因此在可重复读（RR）隔离级别下，解决了不可重复读并发问题</font></strong><font style="color:black;">。</font></p>
<p>:::tips<br><font style="color:black;">其实读已经提交与可重复读的可见性判断的区别就在于事务A第二次查询时使用的Read View不同。</font></p>
<p>:::</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"><i class="fa fa-tag"></i> mysql</a>
              <a href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag"><i class="fa fa-tag"></i> 事务</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/11/sql%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/" rel="prev" title="MySQL语法整理">
      <i class="fa fa-chevron-left"></i> MySQL语法整理
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/14/%E7%B4%A2%E5%BC%95/" rel="next" title="索引">
      索引 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">		事务的四大特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">事务产生的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB-Drity-Read"><span class="nav-number">2.1.</span> <span class="nav-text">脏读(Drity Read)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Non-repeatable-read"><span class="nav-number">2.2.</span> <span class="nav-text">不可重复读(Non-repeatable read)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%BB%E8%AF%BB-Phantom-Read"><span class="nav-number">2.3.</span> <span class="nav-text">幻读(Phantom Read)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">不可重复读和幻读区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%91%BD%E4%BB%A4"><span class="nav-number">3.1.</span> <span class="nav-text">查看隔离级别命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%AD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">各种隔离级别中会出现的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#READ-UNCOMMITTED-%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="nav-number">3.3.</span> <span class="nav-text">READ-UNCOMMITTED(读未提交)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#READ-COMMITTED-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">3.4.</span> <span class="nav-text">READ-COMMITTED(读已提交)*</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#REPEATABLE-READ-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">3.5.</span> <span class="nav-text">REPEATABLE-READ(可重复读)*</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SERIALIZABLE-%E4%B8%B2%E8%A1%8C"><span class="nav-number">3.6.</span> <span class="nav-text">SERIALIZABLE(串行)*</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">Mysql中的事务操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.1.</span> <span class="nav-text">隐式事务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AF%E3%80%81%E6%8F%90%E4%BA%A4%E6%88%96%E5%9B%9E%E6%BB%9A%EF%BC%8C%E6%AF%94%E5%A6%82insert%E3%80%81update%E3%80%81delete%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BC%80%E5%90%AF%E3%80%81%E6%8F%90%E4%BA%A4%E6%88%96%E5%9B%9E%E6%BB%9A%E7%94%B1Mysql%E5%86%85%E9%83%A8%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E3%80%82"><span class="nav-number">4.2.</span> <span class="nav-text">事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由Mysql内部自动控制的。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.3.</span> <span class="nav-text">显式事务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#savepoint"><span class="nav-number">4.4.</span> <span class="nav-text">savepoint</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.5.</span> <span class="nav-text">只读事务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F-autocommit-%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BA%86%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="nav-number">4.6.</span> <span class="nav-text">查看变量 autocommit 是否开启了自动提交命令：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ACID%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">5.</span> <span class="nav-text">ACID的保证</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">持久性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">5.4.</span> <span class="nav-text">一致性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E7%9A%84%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">InnoDB的幻读问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">6.0.1.</span> <span class="nav-text">快照读</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="nav-number">6.0.2.</span> <span class="nav-text">当前读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">7.</span> <span class="nav-text">MVCC基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVCC"><span class="nav-number">7.1.</span> <span class="nav-text">什么是MVCC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="nav-number">7.2.</span> <span class="nav-text">隐式字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#undo%E6%97%A5%E5%BF%97"><span class="nav-number">7.3.</span> <span class="nav-text">undo日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E9%93%BE"><span class="nav-number">7.4.</span> <span class="nav-text">版本链</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="nav-number">7.5.</span> <span class="nav-text">快照读和当前读</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9A"><span class="nav-number">7.5.1.</span> <span class="nav-text">快照读：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%9A"><span class="nav-number">7.5.2.</span> <span class="nav-text">当前读：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E8%A7%86%E5%9B%BE"><span class="nav-number">7.6.</span> <span class="nav-text">读视图</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%BB%E8%A7%86%E5%9B%BE%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="nav-number">7.6.1.</span> <span class="nav-text">读视图的四个属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%BB%E8%A7%86%E5%9B%BE%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%A4%E6%96%AD%E8%A7%84%E5%88%99"><span class="nav-number">7.6.2.</span> <span class="nav-text">读视图可见性判断规则</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%BB%E8%A7%86%E5%9B%BE%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%A4%E6%96%AD%E8%A7%84%E5%88%99%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">7.6.3.</span> <span class="nav-text">读视图可见性判断规则案例说明</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABMVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.7.</span> <span class="nav-text">不同隔离级别MVCC实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.7.1.</span> <span class="nav-text">MVCC实现原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%88RC%EF%BC%89MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.7.2.</span> <span class="nav-text">读已提交（RC）MVCC实现原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88RR%EF%BC%89MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.7.3.</span> <span class="nav-text">可重复读（RR）MVCC实现原理</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="139"
      src="/images/custom/avatar.jpg">
  <p class="site-author-name" itemprop="name">139</p>
  <div class="site-description" itemprop="description">一个普通的JAVA开发的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备2023004484号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">139</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
